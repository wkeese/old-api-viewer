<?xml version="1.0" encoding="UTF-8"?>
<javascript>
  <object location="dijit">
    <properties>
      <property name="_dialogStack" scope="normal" type="Array"/>
      <property name="_masterTT" scope="normal" type="Object"/>
      <property name="_Calendar" scope="normal" type=""/>
      <property name="_lastKeyDownNode" scope="normal" type="Object"/>
      <property name="_curFocus" scope="normal" type="DomNode">
        <summary>Currently focused item on screen</summary>
      </property>
      <property name="_prevFocus" scope="normal" type="DomNode">
        <summary>Previously focused item on screen</summary>
      </property>
      <property name="_activeStack" scope="normal" type="dijit._Widget[]">
        <summary>List of currently active widgets (focused widget and it's ancestors)</summary>
      </property>
      <property name="placementRegistry" scope="normal" type="Object"/>
      <property name="_frames" scope="normal" type="Object"/>
      <property name="_XhtmlRoles" scope="normal" type="RegExp"/>
      <property name="dijit-all" scope="normal" type="Object">
        <summary>A rollup that includes every dijit. You probably don't need this.</summary>
      </property>
      <property name="dijit" scope="normal" type="Object">
        <summary>A roll-up for common dijit methods</summary>
      </property>
      <property name="demos" scope="normal" type="Object">
        <summary>Home of the official dijit demo code</summary>
      </property>
      <property name="robotx" scope="normal" type="Object"/>
      <property name="_scopeName" scope="normal" type="String"/>
    </properties>
    <methods>
      <method name="_underlay" scope="normal">
        <summary>A shared instance of a &lt;code&gt;dijit.DialogUnderlay&lt;/code&gt;</summary>
        <description>A shared instance of a `dijit.DialogUnderlay` created and
	used by `dijit.Dialog`, though never created until some Dialog
	or subclass thereof is shown.</description>
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="showTooltip" scope="normal">
        <summary>Display tooltip w/specified contents in specified position.
	See description of dijit.Tooltip.defaultPosition for details on position parameter.
	If position is not specified then dijit.Tooltip.defaultPosition is used.</summary>
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="position" type="String[]" usage="optional"/>
        </parameters>
      </method>
      <method name="hideTooltip" scope="normal">
        <summary>Hide the tooltip</summary>
        <parameters>
          <parameter name="aroundNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_connectOnUseEventHandler" scope="normal">
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="isCollapsed" scope="normal">
        <summary>Returns true if there is no text selected</summary>
      </method>
      <method name="getBookmark" scope="normal">
        <summary>Retrieves a bookmark that can be used with moveToBookmark to return to the same range</summary>
        <return-types>
          <return-type type="Object."/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="moveToBookmark" scope="normal">
        <summary>Moves current selection to a bookmark</summary>
        <parameters>
          <parameter name="bookmark" type="Object" usage="required">
            <summary>This should be a returned object from dijit.getBookmark()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFocus" scope="normal">
        <summary>Called as getFocus(), this returns an Object showing the current focus
	and selected text.
	Called as getFocus(widget), where widget is a (widget representing) a button
	that was just pressed, it returns where focus was before that button
	was pressed.   (Pressing the button may have either shifted focus to the button,
	or removed focus altogether.)   In this case the selected text is not returned,
	since it can't be accurately determined.</summary>
        <return-description>A handle to restore focus/selection, to be passed to `dijit.focus`</return-description>
        <parameters>
          <parameter name="menu" type="Widget" usage="optional">
            <summary>dijit._Widget or {domNode: DomNode} structure
	The button that was just pressed.  If focus has disappeared or moved
	to this button, returns the previous focus.  In this case the bookmark
	information is already lost, and null is returned.</summary>
          </parameter>
          <parameter name="openedForWindow" type="Window" usage="optional">
            <summary>iframe in which menu was opened</summary>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="normal">
        <summary>Sets the focused node and the selection according to argument.
	To set focus to an iframe's content, pass in the iframe itself.</summary>
        <parameters>
          <parameter name="handle" type="Object" usage="required">
            <summary>object returned by get(), or a DomNode</summary>
          </parameter>
        </parameters>
      </method>
      <method name="registerIframe" scope="normal">
        <summary>Registers listeners on the specified iframe so that any click
	or focus event on that iframe (or anything in it) is reported
	as a focus/click event on the &amp;lt;iframe&amp;gt; itself.</summary>
        <description>Currently only used by editor.</description>
        <return-description>Handle to pass to unregisterIframe()</return-description>
        <parameters>
          <parameter name="iframe" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="unregisterIframe" scope="normal">
        <summary>Unregisters listeners on the specified iframe created by registerIframe.
	After calling be sure to delete or null out the handle itself.</summary>
        <parameters>
          <parameter name="handle" type="Object" usage="required">
            <summary>Handle returned by registerIframe()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="registerWin" scope="normal">
        <summary>Registers listeners on the specified window (either the main
	window or an iframe's window) to detect when the user has clicked somewhere
	or focused somewhere.</summary>
        <description>Users should call registerIframe() instead of this method.</description>
        <return-description>Handle to pass to unregisterWin()</return-description>
        <parameters>
          <parameter name="targetWindow" type="Window" usage="optional">
            <summary>If specified this is the window associated with the iframe,
	i.e. iframe.contentWindow.</summary>
          </parameter>
          <parameter name="effectiveNode" type="DomNode" usage="optional">
            <summary>If specified, report any focus events inside targetWindow as
	an event on effectiveNode, rather than on evt.target.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="unregisterWin" scope="normal">
        <summary>Unregisters listeners on the specified window (either the main
	window or an iframe's window) according to handle returned from registerWin().
	After calling be sure to delete or null out the handle itself.</summary>
        <parameters>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlurNode" scope="normal">
        <summary>Called when focus leaves a node.
	Usually ignored, _unless_ it *isn't* follwed by touching another node,
	which indicates that we tabbed off the last field on the page,
	in which case every widget is marked inactive</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_onTouchNode" scope="normal">
        <summary>Callback when node is focused or mouse-downed</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>The node that was touched.</summary>
          </parameter>
          <parameter name="by" type="String" usage="required">
            <summary>&amp;quot;mouse&amp;quot; if the focus/touch was caused by a mouse down event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onFocusNode" scope="normal">
        <summary>Callback when node is focused</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setStack" scope="normal">
        <summary>The stack of active widgets has changed.  Send out appropriate events and records new stack.</summary>
        <parameters>
          <parameter name="newStack" type="String[]" usage="required">
            <summary>array of widget id's, starting from the top (outermost) widget</summary>
          </parameter>
          <parameter name="by" type="String" usage="required">
            <summary>&amp;quot;mouse&amp;quot; if the focus/touch was caused by a mouse down event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getViewport" scope="normal">
        <summary>Returns the dimensions and scroll position of the viewable area of a browser window</summary>
      </method>
      <method name="placeOnScreen" scope="normal">
        <summary>Positions one of the node's corners at specified position
	such that node is fully visible in viewport.</summary>
        <description>NOTE: node is assumed to be absolutely or relatively positioned.</description>
        <examples>
          <example>Try to place node's top right corner at (10,20).
	If that makes node go (partially) off screen, then try placing
	bottom left corner at (10,20).
		placeOnScreen(node, {x: 10, y: 20}, ["TR", "BL"])</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="dijit.__Position" usage="required">
            <summary>Object like {x: 10, y: 20}</summary>
          </parameter>
          <parameter name="corners" type="String[]" usage="required">
            <summary>Array of Strings representing order to try corners in, like [&amp;quot;TR&amp;quot;, &amp;quot;BL&amp;quot;].
	Possible values are:
	* &amp;quot;BL&amp;quot; - bottom left
	* &amp;quot;BR&amp;quot; - bottom right
	* &amp;quot;TL&amp;quot; - top left
	* &amp;quot;TR&amp;quot; - top right</summary>
          </parameter>
          <parameter name="padding" type="dijit.__Position" usage="optional">
            <summary>set padding to put some buffer around the element you want to position.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_place" scope="normal">
        <summary>Given a list of spots to put node, put it at the first spot where it fits,
	of if it doesn't fit anywhere then the place with the least overflow</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="choices" type="Array" usage="required">
            <summary>Array of elements like: {corner: 'TL', pos: {x: 10, y: 20} }
	Above example says to put the top-left corner of the node at (10,20)</summary>
          </parameter>
          <parameter name="layoutNode" type="Function" usage="required">
            <summary>Function(node, aroundNodeCorner, nodeCorner)
	for things like tooltip, they are displayed differently (and have different dimensions)
	based on their orientation relative to the parent.   This adjusts the popup based on orientation.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="placeOnScreenAroundNode" scope="normal">
        <summary>Position node adjacent or kitty-corner to aroundNode
	such that it's fully visible in viewport.</summary>
        <description>Place node such that corner of node touches a corner of
	aroundNode, and that node is fully visible.</description>
        <examples>
          <example>	dijit.placeOnScreenAroundNode(node, aroundNode, {'BL':'TL', 'TR':'BR'});
	This will try to position node such that node's top-left corner is at the same position
	as the bottom left corner of the aroundNode (ie, put node below
	aroundNode, with left edges aligned).  If that fails it will try to put
	the bottom-right corner of node where the top right corner of aroundNode is
	(ie, put node above aroundNode, with right edges aligned)</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required">
            <summary>Ordered list of pairs of corners to try matching up.
	Each pair of corners is represented as a key/value in the hash,
	where the key corresponds to the aroundNode's corner, and
	the value corresponds to the node's corner:
		{ aroundNodeCorner1: nodeCorner1, aroundNodeCorner2: nodeCorner2, ...}
	The following strings are used to represent the four corners:
	* &amp;quot;BL&amp;quot; - bottom left
	* &amp;quot;BR&amp;quot; - bottom right
	* &amp;quot;TL&amp;quot; - top left
	* &amp;quot;TR&amp;quot; - top right</summary>
          </parameter>
          <parameter name="layoutNode" type="Function" usage="optional">
            <summary>Function(node, aroundNodeCorner, nodeCorner)
	For things like tooltip, they are displayed differently (and have different dimensions)
	based on their orientation relative to the parent.   This adjusts the popup based on orientation.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="placeOnScreenAroundRectangle" scope="normal">
        <summary>Like dijit.placeOnScreenAroundNode(), except that the &amp;quot;around&amp;quot;
	parameter is an arbitrary rectangle on the screen (x, y, width, height)
	instead of a dom node.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundRect" type="dijit.__Rectangle" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_placeOnScreenAroundRect" scope="normal">
        <summary>Like dijit.placeOnScreenAroundNode(), except it accepts coordinates
	of a rectangle to place node adjacent to.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="y" type="Number" usage="required"/>
          <parameter name="width" type="Number" usage="required"/>
          <parameter name="height" type="Number" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="placeOnScreenAroundElement" scope="normal">
        <summary>Like dijit.placeOnScreenAroundNode(), except it accepts an arbitrary object
	for the &amp;quot;around&amp;quot; argument and finds a proper processor to place a node.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundElement" type="Object" usage="required"/>
          <parameter name="aroundCorners" type="Object" usage="required"/>
          <parameter name="layoutNode" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="getPopupAlignment" scope="normal">
        <summary>Transforms the passed array of preferred positions into a format suitable for passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.</summary>
        <parameters>
          <parameter name="position" type="Array" usage="required">
            <summary>String[] This variable controls the position of the drop down.
	It's an array of strings with the following values:
	* before: places drop down to the left of the target node/widget, or to the right in
	the case of RTL scripts like Hebrew and Arabic
	* after: places drop down to the right of the target node/widget, or to the left in
	the case of RTL scripts like Hebrew and Arabic
	* above: drop down goes above target node
	* below: drop down goes below target node
	The list is positions is tried, in order, until a position is found where the drop down fits
	within the viewport.</summary>
          </parameter>
          <parameter name="leftToRight" type="Boolean" usage="required">
            <summary>Whether the popup will be displaying in leftToRight mode.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getPopupAroundAlignment" scope="normal">
        <summary>Transforms the passed array of preferred positions into a format suitable for passing as the aroundCorners argument to dijit.placeOnScreenAroundElement.</summary>
        <parameters>
          <parameter name="position" type="Array" usage="required">
            <summary>String[] This variable controls the position of the drop down.
	It's an array of strings with the following values:
	* before: places drop down to the left of the target node/widget, or to the right in
	the case of RTL scripts like Hebrew and Arabic
	* after: places drop down to the right of the target node/widget, or to the left in
	the case of RTL scripts like Hebrew and Arabic
	* above: drop down goes above target node
	* below: drop down goes below target node
	The list is positions is tried, in order, until a position is found where the drop down fits
	within the viewport.</summary>
          </parameter>
          <parameter name="leftToRight" type="Boolean" usage="required">
            <summary>Whether the popup will be displaying in leftToRight mode.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="normal">
        <summary>Scroll the passed node into view, if it is not already.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="pos" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="nothing to do"/>
        </return-types>
      </method>
      <method name="hasWaiRole" scope="normal">
        <summary>Determines if an element has a particular non-XHTML role.</summary>
        <return-description>True if elem has the specific non-XHTML role attribute and false if not.
	For backwards compatibility if role parameter not provided,
	returns true if has non XHTML role</return-description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getWaiRole" scope="normal">
        <summary>Gets the non-XHTML role for an element (which should be a wai role).</summary>
        <return-description>The non-XHTML role of elem or an empty string if elem
	does not have a role.</return-description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
        </parameters>
      </method>
      <method name="setWaiRole" scope="normal">
        <summary>Sets the role on an element.</summary>
        <description>Replace existing role attribute with new role.
	If elem already has an XHTML role, append this role to XHTML role
	and remove other ARIA roles.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeWaiRole" scope="normal">
        <summary>Removes the specified non-XHTML role from an element.
	Removes role attribute if no specific role provided (for backwards compat.)</summary>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="role" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="hasWaiState" scope="normal">
        <summary>Determines if an element has a given state.</summary>
        <description>Checks for an attribute called "aria-"+state.</description>
        <return-description>true if elem has a value for the given state and
	false if it does not.</return-description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getWaiState" scope="normal">
        <summary>Gets the value of a state on an element.</summary>
        <description>Checks for an attribute called "aria-"+state.</description>
        <return-description>The value of the requested state on elem
	or an empty string if elem has no value for state.</return-description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setWaiState" scope="normal">
        <summary>Sets a state on an element.</summary>
        <description>Sets an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeWaiState" scope="normal">
        <summary>Removes a state from an element.</summary>
        <description>Sets an attribute called "aria-"+state.</description>
        <parameters>
          <parameter name="elem" type="Element" usage="required"/>
          <parameter name="state" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getDocumentWindow" scope="normal">
        <summary>Get window object associated with document doc</summary>
        <parameters>
          <parameter name="doc" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Window"/>
        </return-types>
      </method>
      <method name="selectInputText" scope="normal">
        <summary>Select text in the input element argument, from start (default 0), to stop (default end).</summary>
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="start" type="Number" usage="optional"/>
          <parameter name="stop" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.Calendar" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A simple GUI for choosing a date in the context of a monthly calendar.</summary>
    <description>A simple GUI for choosing a date in the context of a monthly calendar.
	This widget can't be used in a form because it doesn't serialize the date to an
	`&lt;input&gt;` field.  For a form element, use dijit.form.DateTextBox instead.
	Note that the parser takes all dates attributes passed in the
	[RFC 3339 format](http://www.faqs.org/rfcs/rfc3339.html), e.g. `2005-06-30T08:05:00-07:00`
	so that they are serializable and locale-independent.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example>	var calendar = new dijit.Calendar({}, dojo.byId("calendarNode"));</example>
      <example>	&lt;div dojoType="dijit.Calendar"&gt;&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="value" scope="prototype" type="Date">
        <summary>The currently selected Date</summary>
      </property>
      <property name="datePackage" scope="instance-prototype" type="String">
        <summary>JavaScript namespace to find Calendar routines.  Uses Gregorian Calendar routines
	at dojo.date by default.</summary>
      </property>
      <property name="dayWidth" scope="prototype" type="String">
        <summary>How to represent the days of the week in the calendar header. See dojo.date.locale</summary>
      </property>
      <property name="tabIndex" scope="prototype" type="Integer">
        <summary>Order fields are traversed when user hits the tab key</summary>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="displayMonth" scope="prototype" type="Object"/>
      <property name="_popupHandler" scope="prototype" type="Object"/>
      <property name="_currentNode" scope="prototype" type="Object"/>
      <property name="dateClassObj" scope="instance" type="Object"/>
      <property name="dateFuncObj" scope="instance" type="Object"/>
      <property name="dateLocaleModule" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>Deprecated.   Used attr('value', ...) instead.</summary>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>Support getter attr('value')</summary>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Support setter attr(&amp;quot;value&amp;quot;, ...)</summary>
        <description>Set the current date and update the UI.  If the date is disabled, the value will
	not change, but the display will change to the corresponding month.</description>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="prototype">
        <summary>This just sets the content of node to the specified text.
	Can't do &amp;quot;node.innerHTML=text&amp;quot; because of an IE bug w/tables, see #3434.</summary>
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="text" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_populateGrid" scope="prototype">
        <summary>Fills in the calendar grid with each day (1-31)</summary>
      </method>
      <method name="goToToday" scope="prototype">
        <summary>Sets calendar's value to today's date</summary>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_onMenuHover" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustDisplay" scope="prototype">
        <summary>Moves calendar forwards or backwards by months or years</summary>
        <parameters>
          <parameter name="part" type="String" usage="required">
            <summary>&amp;quot;month&amp;quot; or &amp;quot;year&amp;quot;</summary>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <summary>Number of months or years</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onMonthToggle" scope="prototype">
        <summary>Handler for when user triggers or dismisses the month list</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMonthSelect" scope="prototype">
        <summary>Handler for when user selects a month from a list</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayClick" scope="prototype">
        <summary>Handler for day clicks, selects the date if appropriate</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOver" scope="prototype">
        <summary>Handler for mouse over events on days, sets up hovered style</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDayMouseOut" scope="prototype">
        <summary>Handler for mouse out events on days, clears hovered style</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <summary>Provides keyboard navigation of calendar</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="prototype">
        <summary>Notification that a date cell was selected.  It may be the same as the previous value.</summary>
        <description>Used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.DateTextBox`)
	to get notification when the user has clicked a date.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Called only when the selected date has changed</summary>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_isSelectedDate" scope="prototype">
        <summary>Extension point so developers can subclass Calendar to
	support multiple (concurrently) selected dates</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="prototype">
        <summary>May be overridden to disable certain dates in the calendar e.g. &lt;code&gt;isDisabledDate=dojo.date.locale.isWeekend&lt;/code&gt;</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getClassForDate" scope="prototype">
        <summary>May be overridden to return CSS classes to associate with the date entry for the given dateObject,
	for example to indicate a holiday in specified locale.</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit.CheckedMenuItem" type="Function" classlike="true" superclass="dijit.MenuItem">
    <summary>A checkbox-like menu item for toggling on and off</summary>
    <mixins>
      <mixin scope="instance" location="dijit.MenuItem"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="checked" scope="prototype" type="Boolean">
        <summary>Our checked state</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setCheckedAttr" scope="prototype">
        <summary>Hook so attr('checked', bool) works.
	Sets the class and state for the check box.</summary>
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <summary>User defined function to handle check/uncheck events</summary>
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="prototype">
        <summary>Clicking this item just toggles its state</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.ColorPalette" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A keyboard accessible color-picking widget</summary>
    <description>Grid showing various colors, so the user can pick a certain color.
	Can be used standalone, or as a popup.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dijit.ColorPalette"&gt;&lt;/div&gt;</example>
      <example>    var picker = new dijit.ColorPalette({ },srcNode);
		picker.startup();</example>
    </examples>
    <properties>
      <property name="defaultTimeout" scope="prototype" type="Number">
        <summary>Number of milliseconds before a held key or button becomes typematic</summary>
      </property>
      <property name="timeoutChangeRate" scope="prototype" type="Number">
        <summary>Fraction of time used to change the typematic timer between events
	1.0 means that each typematic event fires at defaultTimeout intervals
	&amp;lt; 1.0 means that each typematic event fires at an increasing faster rate</summary>
      </property>
      <property name="palette" scope="prototype" type="String">
        <summary>Size of grid, either &amp;quot;7x10&amp;quot; or &amp;quot;3x4&amp;quot;.</summary>
      </property>
      <property name="value" scope="prototype" type="String">
        <summary>The value of the selected color.</summary>
      </property>
      <property name="_currentFocus" scope="prototype" type="DomNode">
        <summary>The currently focused or hovered color.
	Different from value, which represents the selected (i.e. clicked) color.</summary>
      </property>
      <property name="_xDim" scope="prototype" type="Integer">
        <summary>This is the number of colors horizontally across.</summary>
      </property>
      <property name="_yDim" scope="prototype" type="Integer">
        <summary>/		This is the number of colors vertically down.</summary>
      </property>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template of this widget.</summary>
      </property>
      <property name="tabIndex" scope="prototype" type="String">
        <summary>Widget tab index.</summary>
      </property>
      <property name="_cellNodes" scope="prototype" type="Array"/>
      <property name="colorNames" scope="prototype" type="Object"/>
      <property name="_blankGif" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="focus" scope="prototype">
        <summary>Focus this ColorPalette.  Puts focus on the most recently focused cell.</summary>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Callback when a color is selected.</summary>
        <parameters>
          <parameter name="color" type="String" usage="required">
            <summary>Hex value corresponding to color.
	console.debug(&amp;quot;Color selected is: &amp;quot;+color);</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype">
        <summary>Handler for when the ColorPalette gets focus (because a cell inside
	the ColorPalette got focus)</summary>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>Handler for when the ColorPalette loses focus</summary>
      </method>
      <method name="_onCellDijitclick" scope="prototype">
        <summary>Handler for click, enter key &amp;amp; space key. Selects the color.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellMouseEnter" scope="prototype">
        <summary>Handler for onMouseEnter event on a cell. Put highlight on the color under the mouse.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The mouse event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellMouseLeave" scope="prototype">
        <summary>Handler for onMouseLeave event on a cell. Remove highlight on the color under the mouse.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The mouse event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellFocus" scope="prototype">
        <summary>Handler for onFocus of a cell.</summary>
        <description>Removes highlight of the color that just lost focus, and highlights
	the new color.  Also moves the tabIndex setting to the new cell.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The focus event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setCurrent" scope="prototype">
        <summary>Called when a color is hovered or focused.</summary>
        <description>Removes highlight of the old color, and highlights
	the new color.  Also moves the tabIndex setting to the new cell.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_selectColor" scope="prototype">
        <summary>This selects a color. It triggers the onChange event
	area:
	The area node that covers the color being selected.</summary>
        <parameters>
          <parameter name="selectNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_navigateByKey" scope="prototype">
        <summary>This is the callback for typematic.
	It changes the focus and the highlighed color.</summary>
        <parameters>
          <parameter name="increment" type="How" usage="required">
            <summary>much the key is navigated.</summary>
          </parameter>
          <parameter name="typeCount" type="How" usage="required">
            <summary>many times typematic has fired.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.ColorPalette._palettes" type="Map">
    <summary>This represents the value of the colors.
	The first level is a hashmap of the different arrays available
	The next two dimensions represent the columns and rows of colors.</summary>
    <properties>
      <property name="7x10" scope="normal" type="Array"/>
      <property name="3x4" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dijit.ColorPalette._imagePaths" type="Map">
    <summary>This is stores the path to the palette images</summary>
    <properties>
      <property name="7x10" scope="normal" type="Object"/>
      <property name="3x4" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dijit.ColorPalette._paletteCoords" type="Map">
    <summary>This is a map that is used to calculate the coordinates of the
	images that make up the palette.</summary>
    <properties>
      <property name="leftOffset" scope="normal" type="Number"/>
      <property name="topOffset" scope="normal" type="Number"/>
      <property name="cWidth" scope="normal" type="Number"/>
      <property name="cHeight" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dijit.ColorPalette._paletteDims">
    <summary>Size of the supported palettes for alignment purposes.</summary>
  </object>
  <object location="dijit.ColorPalette._paletteDims.7x10">
    <properties>
      <property name="width" scope="normal" type="String"/>
      <property name="height" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dijit.ColorPalette._paletteDims.3x4">
    <properties>
      <property name="width" scope="normal" type="String"/>
      <property name="height" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dijit.ColorPalette.domNode.style" type="">
    <properties>
      <property name="position" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.Declaration" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>The Declaration widget allows a developer to declare new widget
	classes directly from a snippet of markup.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="_noScript" scope="prototype" type="Boolean">
        <summary>Flag to parser to leave alone the script tags contained inside of me</summary>
      </property>
      <property name="widgetClass" scope="prototype" type="String">
        <summary>Name of class being declared, ex: &amp;quot;acme.myWidget&amp;quot;</summary>
      </property>
      <property name="mixins" scope="prototype" type="String[]">
        <summary>List containing the prototype for this widget, and also any mixins,
	ex: [&amp;quot;dijit._Widget&amp;quot;, &amp;quot;dijit._Container&amp;quot;]</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.Declaration.defaults">
    <properties>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="_skipNodeCache" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit._DialogBase" type="Function" classlike="true" superclass="dijit._Templated">
    <summary>A modal dialog Widget</summary>
    <description>Pops up a modal dialog window, blocking access to the screen
	and also graying out the screen Dialog is extended from
	ContentPane so it supports all the same parameters (href, etc.)</description>
    <mixins>
      <mixin scope="prototype" location="dijit.form._FormMixin.prototype"/>
      <mixin scope="prototype" location="dijit._DialogMixin.prototype"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit.form._FormMixin"/>
      <mixin scope="instance" location="dijit._DialogMixin"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dijit.Dialog" href="test.html"&gt;&lt;/div&gt;</example>
      <example>	var foo = new dijit.Dialog({ title: "test dialog", content: "test content" };
		dojo.body().appendChild(foo.domNode);
		foo.startup();</example>
    </examples>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="open" scope="prototype" type="Boolean">
        <summary>True if Dialog is currently displayed on screen.</summary>
      </property>
      <property name="duration" scope="normal" type="Integer">
        <summary>The time in milliseconds it takes the dialog to fade in and out</summary>
      </property>
      <property name="refocus" scope="prototype" type="Boolean">
        <summary>A Toggle to modify the default focus behavior of a Dialog, which
	is to re-focus the element which had focus before being opened.
	False will disable refocusing. Default: true</summary>
      </property>
      <property name="autofocus" scope="prototype" type="Boolean">
        <summary>A Toggle to modify the default focus behavior of a Dialog, which
	is to focus on the first dialog element after opening the dialog.
	False will disable autofocusing. Default: true</summary>
      </property>
      <property name="_firstFocusItem" scope="prototype" type="[readonly]">
        <summary>DomNode
	The pointer to the first focusable node in the dialog.
	Set by &lt;code&gt;dijit._DialogMixin._getFocusItems&lt;/code&gt;.</summary>
      </property>
      <property name="_lastFocusItem" scope="prototype" type="[readonly]">
        <summary>DomNode
	The pointer to which node has focus prior to our dialog.
	Set by &lt;code&gt;dijit._DialogMixin._getFocusItems&lt;/code&gt;.</summary>
      </property>
      <property name="doLayout" scope="prototype" type="Boolean">
        <summary>Don't change this parameter from the default value.
	This ContentPane parameter doesn't make sense for Dialog, since Dialog
	is never a child of a layout container, nor can you specify the size of
	Dialog in order to control the size of an inner widget.</summary>
      </property>
      <property name="draggable" scope="prototype" type="Boolean">
        <summary>Toggles the moveable aspect of the Dialog. If true, Dialog
	can be dragged by it's title. If false it will remain centered
	in the viewport.</summary>
      </property>
      <property name="aria-describedby" scope="prototype" type="String">
        <summary>Allows the user to add an aria-describedby attribute onto the dialog.   The value should
	be the id of the container element of text that describes the dialog purpose (usually
	the first text in the dialog).
	&amp;lt;div dojoType=&amp;quot;dijit.Dialog&amp;quot; aria-describedby=&amp;quot;intro&amp;quot; .....&amp;gt;
	&amp;lt;div id=&amp;quot;intro&amp;quot;&amp;gt;Introductory text&amp;lt;/div&amp;gt;
	&amp;lt;div&amp;gt;rest of dialog contents&amp;lt;/div&amp;gt;
	&amp;lt;/div&amp;gt;</summary>
      </property>
      <property name="_modalconnects" scope="prototype" type="Array"/>
      <property name="_relativePosition" scope="prototype" type="Object"/>
      <property name="domNode" scope="prototype" type=""/>
      <property name="_moveable" scope="prototype" type=""/>
      <property name="underlayAttrs" scope="prototype" type="Object"/>
      <property name="_fadeIn" scope="prototype" type="Object"/>
      <property name="_fadeOut" scope="prototype" type="Object"/>
      <property name="_singleChildOriginalStyle" scope="prototype" type=""/>
      <property name="_alreadyInitialized" scope="prototype" type="Object"/>
      <property name="_savedFocus" scope="prototype" type="Object"/>
      <property name="_scrollConnected" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="onLoad" scope="prototype">
        <summary>Called when data has been loaded from an href.
	Unlike most other callbacks, this function can be connected to (via &lt;code&gt;dojo.connect&lt;/code&gt;)
	but should *not* be overriden.</summary>
      </method>
      <method name="_endDrag" scope="prototype">
        <summary>Called after dragging the Dialog. Saves the position of the dialog in the viewport.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setup" scope="prototype">
        <summary>Stuff we need to do before showing the Dialog for the first
	time (but we defer it until right beforehand, for
	performance reasons).</summary>
      </method>
      <method name="uninitialize" scope="prototype"/>
      <method name="_size" scope="prototype">
        <summary>If necessary, shrink dialog contents so dialog fits in viewport</summary>
      </method>
      <method name="_position" scope="prototype">
        <summary>Position modal dialog in the viewport. If no relative offset
	in the viewport has been determined (by dragging, for instance),
	center the node. Otherwise, use the Dialog's stored relative offset,
	and position the node to top: left: values based on the viewport.</summary>
      </method>
      <method name="_onKey" scope="prototype">
        <summary>Handles the keyboard events for accessibility reasons</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="just let it go"/>
        </return-types>
      </method>
      <method name="show" scope="prototype">
        <summary>Display the dialog</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Hide the dialog</summary>
      </method>
      <method name="layout" scope="prototype">
        <summary>Position the Dialog and the underlay</summary>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="_onCloseEnter" scope="prototype">
        <summary>Called when user hovers over close icon</summary>
      </method>
      <method name="_onCloseLeave" scope="prototype">
        <summary>Called when user stops hovering over close icon</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._DialogBase._singleChild.domNode.style" type="">
    <properties>
      <property name="cssText" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.Dialog" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <mixins>
      <mixin scope="prototype" location="dijit._DialogBase.prototype"/>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
      <mixin scope="instance" location="dijit._DialogBase"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.DialogUnderlay" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>The component that blocks the screen behind a &lt;code&gt;dijit.Dialog&lt;/code&gt;</summary>
    <description>A component used to block input behind a `dijit.Dialog`. Only a single
	instance of this widget is created by `dijit.Dialog`, and saved as
	a reference to be shared between all Dialogs as `dijit._underlay`
	The underlay itself can be styled based on and id:
		#myDialog_underlay { background-color:red; }
	In the case of `dijit.Dialog`, this id is based on the id of the Dialog,
	suffixed with _underlay.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="dialogId" scope="prototype" type="String">
        <summary>Id of the dialog.... DialogUnderlay's id is based on this id</summary>
      </property>
      <property name="class" scope="prototype" type="String">
        <summary>This class name is used on the DialogUnderlay node, in addition to dijitDialogUnderlay</summary>
      </property>
      <property name="bgIframe" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setDialogIdAttr" scope="prototype">
        <parameters>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setClassAttr" scope="prototype">
        <parameters>
          <parameter name="clazz" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype">
        <summary>Append the underlay to the body</summary>
      </method>
      <method name="layout" scope="prototype">
        <summary>Sets the background to the size of the viewport</summary>
        <description>Sets the background to the size of the viewport (rather than the size
	of the document) since we need to cover the whole browser window, even
	if the document is only a few lines long.</description>
      </method>
      <method name="show" scope="prototype">
        <summary>Show the dialog underlay</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Hides the dialog underlay</summary>
      </method>
      <method name="uninitialize" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.DialogUnderlay.attributeMap">
    <properties>
      <property name="id" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dijit.DialogUnderlay.node" type="">
    <properties>
      <property name="className" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.DialogUnderlay.domNode" type=""/>
  <object location="dijit.DialogUnderlay.domNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
      <property name="top" scope="prototype" type="String"/>
      <property name="left" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.DialogUnderlay.node.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.Editor" type="Function" classlike="true" superclass="dijit._editor.RichText">
    <summary>A rich text Editing widget</summary>
    <description>This widget provides basic WYSIWYG editing features, based on the browser's
	underlying rich text editing capability, accompanied by a toolbar (`dijit.Toolbar`).
	A plugin model is available to extend the editor's capabilities as well as the
	the options available in the toolbar.  Content generation may vary across
	browsers, and clipboard operations may have different results, to name
	a few limitations.  Note: this widget should not be used with the HTML
	&amp;lt;TEXTAREA&amp;gt; tag -- see dijit._editor.RichText for details.</description>
    <mixins>
      <mixin scope="instance" location="dijit._editor.RichText"/>
    </mixins>
    <properties>
      <property name="plugins" scope="instance-prototype" type="Object[]">
        <summary>A list of plugin names (as strings) or instances (as objects)
	for this widget.
	When declared in markup, it might look like:
		plugins=&amp;quot;['bold',{name:'dijit._editor.plugins.FontChoice', command:'fontName', generic:true}]&amp;quot;</summary>
      </property>
      <property name="extraPlugins" scope="prototype" type="Object[]">
        <summary>A list of extra plugin names which will be appended to plugins array
	the following 3 functions are required to make the editor play nice under a layout widget, see #4070</summary>
      </property>
      <property name="_steps" scope="prototype" type="Array"/>
      <property name="_undoedSteps" scope="prototype" type="Array"/>
      <property name="commands" scope="prototype" type="Object"/>
      <property name="toolbar" scope="prototype" type="Object"/>
      <property name="_plugins" scope="instance-prototype" type="Array"/>
      <property name="_layoutMode" scope="prototype" type="Object"/>
      <property name="customUndo" scope="normal" type="Boolean">
        <summary>Whether we shall use custom undo/redo support instead of the native
	browser support. By default, we only enable customUndo for IE, as it
	has broken native undo/redo support. Note: the implementation does
	support other browsers which have W3C DOM2 Range API implemented.</summary>
      </property>
      <property name="editActionInterval" scope="prototype" type="Integer">
        <summary>When using customUndo, not every keystroke will be saved as a step.
	Instead typing (including delete) will be grouped together: after
	a user stops typing for editActionInterval seconds, a step will be
	saved; if a user resume typing within editActionInterval seconds,
	the timeout will be restarted. By default, editActionInterval is 3
	seconds.
	end of custom undo/redo support</summary>
      </property>
      <property name="_inEditing" scope="prototype" type="bool"/>
      <property name="_editTimer" scope="prototype" type="Object"/>
      <property name="_savedSelection" scope="prototype" type="Object"/>
      <property name="_editInterval" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>Runs on widget initialization to setup arrays etc.</summary>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="addPlugin" scope="prototype">
        <summary>takes a plugin name as a string or a plugin instance and
	adds it to the toolbar and associates it with this editor
	instance. The resulting plugin is added to the Editor's
	plugins array. If index is passed, it's placed in the plugins
	array at that index. No big magic, but a nice helper for
	passing in plugin names via markup.</summary>
        <parameters>
          <parameter name="plugin" type="String||Object" usage="required">
            <summary>String, args object or plugin instance
	args:
	This object will be passed to the plugin constructor</summary>
          </parameter>
          <parameter name="index" type="Integer" usage="optional">
            <summary>Used when creating an instance from
	something already in this.plugins. Ensures that the new
	instance is assigned to this.plugins at that index.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="startup" scope="prototype">
        <summary>Exists to make Editor work as a child of a layout widget.
	Developers don't need to call this method.</summary>
      </method>
      <method name="resize" scope="prototype">
        <summary>Resize the editor to the specified size, see &lt;code&gt;dijit.layout._LayoutWidget.resize&lt;/code&gt;</summary>
        <parameters>
          <parameter name="size" type="" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="prototype">
        <summary>Called from &lt;code&gt;dijit.layout._LayoutWidget.resize&lt;/code&gt;.  This shouldn't be called directly</summary>
      </method>
      <method name="_onIEMouseDown" scope="prototype">
        <summary>IE only to prevent 2 clicks to focus</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeActivate" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeDeactivate" scope="prototype">
        <summary>Called on IE right before focus is lost.   Saves the selected range.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="beginEditing" scope="prototype">
        <summary>Called to note that the user has started typing alphanumeric characters, if it's not already noted.
	Deals with saving undo; see editActionInterval parameter.</summary>
        <parameters>
          <parameter name="cmd" type="" usage="required"/>
        </parameters>
      </method>
      <method name="execCommand" scope="prototype">
        <summary>Main handler for executing any commands to the editor, like paste, bold, etc.
	Called by plugins, but not meant to be called by end users.</summary>
        <parameters>
          <parameter name="cmd" type="" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandEnabled" scope="prototype">
        <summary>Returns true if specified editor command is enabled.
	Used by the plugins to know when to highlight/not highlight buttons.</summary>
        <parameters>
          <parameter name="cmd" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToBookmark" scope="prototype">
        <summary>Selects the text specified in bookmark b</summary>
        <parameters>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_changeToStep" scope="prototype">
        <summary>Reverts editor to &amp;quot;to&amp;quot; setting, from the undo stack.</summary>
        <parameters>
          <parameter name="from" type="" usage="required"/>
          <parameter name="to" type="" usage="required"/>
        </parameters>
      </method>
      <method name="undo" scope="prototype">
        <summary>Handler for editor undo (ex: ctrl-z) operation</summary>
      </method>
      <method name="redo" scope="prototype">
        <summary>Handler for editor redo (ex: ctrl-y) operation</summary>
      </method>
      <method name="endEditing" scope="prototype">
        <summary>Called to note that the user has stopped typing alphanumeric characters, if it's not already noted.
	Deals with saving undo; see editActionInterval parameter.</summary>
        <parameters>
          <parameter name="ignore_caret" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getBookmark" scope="prototype">
        <summary>Get the currently selected text</summary>
      </method>
      <method name="_beginEditing" scope="prototype">
        <summary>Called when the user starts typing alphanumeric characters.
	Deals with saving undo; see editActionInterval parameter.</summary>
        <parameters>
          <parameter name="cmd" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_endEditing" scope="prototype">
        <summary>Called when the user stops typing alphanumeric characters.
	Deals with saving undo; see editActionInterval parameter.</summary>
        <parameters>
          <parameter name="ignore_caret" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <summary>Handler for onkeydown event.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>Called from focus manager when focus has moved away from this editor</summary>
      </method>
      <method name="_saveSelection" scope="prototype">
        <summary>Save the currently selected text in _savedSelection attribute</summary>
      </method>
      <method name="_restoreSelection" scope="prototype">
        <summary>Re-select the text specified in _savedSelection attribute;
	see _saveSelection().</summary>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Handler for when editor is clicked</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.Editor.editingArea.style" type="">
    <properties>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.Editor.iframe.style" type="">
    <properties>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit._editor" private="true">
    <properties>
      <property name="html" scope="normal" type="Object"/>
      <property name="range" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="escapeXml" scope="normal">
        <summary>Adds escape sequences for special characters in XML: &amp;amp;&amp;lt;&amp;gt;&amp;quot;'
	Optionally skips escapes for single quotes</summary>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getNodeHtml" scope="normal">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getChildrenHtml" scope="normal">
        <summary>Returns the html content of a DomNode and children</summary>
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit._editor._Plugin" type="Function" classlike="true" private="true">
    <properties>
      <property name="editor" scope="prototype" type="dijit.Editor">
        <summary>Points to the parent editor</summary>
      </property>
      <property name="iconClassPrefix" scope="prototype" type="String">
        <summary>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</summary>
      </property>
      <property name="button" scope="prototype" type="dijit._Widget">
        <summary>Pointer to &lt;code&gt;dijit.form.Button&lt;/code&gt; or other widget (ex: &lt;code&gt;dijit.form.FilteringSelect&lt;/code&gt;)
	that is added to the toolbar to control this plugin.
	If not specified, will be created on initialization according to &lt;code&gt;buttonClass&lt;/code&gt;</summary>
      </property>
      <property name="command" scope="prototype" type="String">
        <summary>String like &amp;quot;insertUnorderedList&amp;quot;, &amp;quot;outdent&amp;quot;, &amp;quot;justifyCenter&amp;quot;, etc. that represents an editor command.
	Passed to editor.execCommand() if &lt;code&gt;useDefaultCommand&lt;/code&gt; is true.</summary>
      </property>
      <property name="useDefaultCommand" scope="prototype" type="Boolean">
        <summary>If true, this plugin executes by calling Editor.execCommand() with the argument specified in &lt;code&gt;command&lt;/code&gt;.</summary>
      </property>
      <property name="buttonClass" scope="normal" type="Widget">
        <summary>Class
	Class of widget (ex: dijit.form.Button or dijit.form.FilteringSelect)
	that is added to the toolbar to control this plugin.
	This is used to instantiate the button, unless &lt;code&gt;button&lt;/code&gt; itself is specified directly.</summary>
      </property>
      <property name="enabled" scope="prototype" type=""/>
      <property name="checked" scope="prototype" type=""/>
      <property name="params" scope="instance" type="Object"/>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
          <parameter name="node" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
          <parameter name="node" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>Returns the label to use for the button</summary>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_initButton" scope="prototype">
        <summary>Initialize the button or other widget that will control this plugin.
	This code only works for plugins controlling built-in commands in the editor.</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroy this plugin</summary>
      </method>
      <method name="connect" scope="prototype">
        <summary>Make a dojo.connect() that is automatically disconnected when this plugin is destroyed.
	Similar to &lt;code&gt;dijit._Widget.connect&lt;/code&gt;.</summary>
        <parameters>
          <parameter name="o" type="" usage="required"/>
          <parameter name="f" type="" usage="required"/>
          <parameter name="tf" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateState" scope="prototype">
        <summary>Change state of the plugin to respond to events in the editor.</summary>
        <description>This is called on meaningful events in the editor, such as change of selection
	or caret position (but not simple typing of alphanumeric keys).   It gives the
	plugin a chance to update the CSS of its button.
	For example, the "bold" plugin will highlight/unhighlight the bold button depending on whether the
	characters next to the caret are bold or not.
	Only makes sense when `useDefaultCommand` is true, as it calls Editor.queryCommandEnabled(`command`).</description>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Tell the plugin which Editor it is associated with.</summary>
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="prototype">
        <summary>Tell the plugin to add it's controller widget (often a button)
	to the toolbar.  Does nothing if there is no controller widget.</summary>
        <parameters>
          <parameter name="toolbar" type="dijit.Toolbar" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.InlineEditBox" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>An element with in-line edit capabilitites</summary>
    <description>Behavior for an existing node (`&lt;p&gt;`, `&lt;div&gt;`, `&lt;span&gt;`, etc.) so that
	when you click it, an editor shows up in place of the original
	text.  Optionally, Save and Cancel button are displayed below the edit widget.
	When Save is clicked, the text is pulled from the edit
	widget and redisplayed and the edit widget is again hidden.
	By default a plain Textarea widget is used as the editor (or for
	inline values a TextBox), but you can specify an editor such as
	dijit.Editor (for editing HTML) or a Slider (for adjusting a number).
	An edit widget must support the following API to be used:
	- displayedValue or value as initialization parameter,
	and available through attr('displayedValue') / attr('value')
	- void focus()
	- DOM-node focusNode = node containing editable text</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="editing" scope="prototype" type="Boolean">
        <summary>Is the node currently in edit mode?</summary>
      </property>
      <property name="autoSave" scope="prototype" type="Boolean">
        <summary>Changing the value automatically saves it; don't have to push save button
	(and save button isn't even displayed)</summary>
      </property>
      <property name="buttonSave" scope="prototype" type="String">
        <summary>Save button label</summary>
      </property>
      <property name="buttonCancel" scope="prototype" type="String">
        <summary>Cancel button label</summary>
      </property>
      <property name="renderAsHtml" scope="prototype" type="Boolean">
        <summary>Set this to true if the specified Editor's value should be interpreted as HTML
	rather than plain text (ex: &lt;code&gt;dijit.Editor&lt;/code&gt;)</summary>
      </property>
      <property name="editor" scope="prototype" type="String">
        <summary>Class name for Editor widget</summary>
      </property>
      <property name="editorWrapper" scope="prototype" type="String">
        <summary>Class name for widget that wraps the editor widget, displaying save/cancel
	buttons.</summary>
      </property>
      <property name="editorParams" scope="instance-prototype" type="Object">
        <summary>Set of parameters for editor, like {required: true}</summary>
      </property>
      <property name="width" scope="prototype" type="String">
        <summary>Width of editor.  By default it's width=100% (ie, block mode).</summary>
      </property>
      <property name="value" scope="prototype" type="String">
        <summary>The display value of the widget in read-only mode</summary>
      </property>
      <property name="noValueIndicator" scope="prototype" type="String">
        <summary>The text that gets displayed when there is no value (so that the user has a place to click to edit)</summary>
      </property>
      <property name="disabled" scope="prototype" type=""/>
      <property name="_savedPosition" scope="prototype" type="Object"/>
      <property name="_savedOpacity" scope="prototype" type="Object"/>
      <property name="_savedTabIndex" scope="prototype" type="Object"/>
      <property name="wrapperWidget" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onChange" scope="prototype">
        <summary>Set this handler to be notified of changes to value.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="prototype">
        <summary>Set this handler to be notified when editing is cancelled.</summary>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Sets up private arrays etc.</summary>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="setDisabled" scope="prototype">
        <summary>Deprecated.   Use attr('disable', ...) instead.</summary>
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>Hook to make attr(&amp;quot;disabled&amp;quot;, ...) work.
	Set disabled state of widget.</summary>
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="prototype">
        <summary>Handler for onmouseover event.</summary>
      </method>
      <method name="_onMouseOut" scope="prototype">
        <summary>Handler for onmouseout event.</summary>
      </method>
      <method name="_onClick" scope="prototype">
        <summary>Handler for onclick event.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="edit" scope="prototype">
        <summary>Display the editor widget in place of the original (read only) markup.</summary>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>Called when focus moves outside the InlineEditBox.
	Performs garbage collection.</summary>
      </method>
      <method name="_showText" scope="prototype">
        <summary>Revert to display mode, and optionally focus on display node</summary>
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="prototype">
        <summary>Save the contents of the editor and revert to display mode.</summary>
        <parameters>
          <parameter name="focus" type="Boolean" usage="required">
            <summary>Focus on the display mode text</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>Deprecated.   Use attr('value', ...) instead.</summary>
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook to make attr(&amp;quot;value&amp;quot;, ...) work.
	Inserts specified HTML value into this node, or an &amp;quot;input needed&amp;quot; character if node is blank.</summary>
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>Deprecated.   Use attr('value') instead.</summary>
      </method>
      <method name="cancel" scope="prototype">
        <summary>Revert to display mode, discarding any changes made in the editor</summary>
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.InlineEditBox.displayNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit._InlineEditor" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Internal widget used by InlineEditBox, displayed when in editing mode
	to display the editor and maybe save/cancel buttons.  Calling code should
	connect to save/cancel methods to detect when editing is finished
	Has mainly the same parameters as InlineEditBox, plus these values:
	style: Object
	Set of CSS attributes of display node, to replicate in editor
	value: String
	Value as an HTML string or plain text string, depending on renderAsHTML flag</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="messages" scope="prototype" type="Object"/>
      <property name="sourceStyle" scope="prototype" type=""/>
      <property name="editWidget" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_onIntermediateChange" scope="prototype">
        <summary>Called for editor widgets that support the intermediateChanges=true flag as a way
	to detect when to enable/disabled the save button</summary>
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="getValue" scope="prototype">
        <summary>Return the [display] value of the edit widget</summary>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <summary>Handler for keypress in the edit box in autoSave mode.</summary>
        <description>For autoSave widgets, if Esc/Enter, call cancel/save.</description>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>Called when focus moves outside the editor</summary>
      </method>
      <method name="_onChange" scope="prototype">
        <summary>Called when the underlying widget fires an onChange event,
	such as when the user selects a value from the drop down list of a ComboBox,
	which means that the user has finished entering the value and we should save.</summary>
      </method>
      <method name="enableSave" scope="prototype">
        <summary>User overridable function returning a Boolean to indicate
	if the Save button should be enabled or not - usually due to invalid conditions</summary>
      </method>
      <method name="focus" scope="prototype">
        <summary>Focus the edit widget.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._InlineEditor.inlineEditBox" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._InlineEditor.domNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit._InlineEditor.inlineEditBox.editorParams" type="">
    <properties>
      <property name="style" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._InlineEditor.buttonContainer.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit._MenuBase" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Base class for Menu and MenuBar</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._KeyNavContainer.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._KeyNavContainer"/>
    </mixins>
    <properties>
      <property name="parentMenu" scope="prototype" type="Widget">
        <summary>pointer to menu that displayed me</summary>
      </property>
      <property name="popupDelay" scope="prototype" type="Integer">
        <summary>number of milliseconds before hovering (without clicking) causes the popup to automatically open.</summary>
      </property>
      <property name="hover_timer" scope="prototype" type="Object"/>
      <property name="_hoveredChild" scope="prototype" type="Object"/>
      <property name="_focus_timer" scope="prototype" type="Object"/>
      <property name="isActive" scope="prototype" type="bool"/>
      <property name="isShowingNow" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="onExecute" scope="prototype">
        <summary>Attach point for notification about when a menu item has been executed.
	This is an internal mechanism used for Menus to signal to their parent to
	close them, because they are about to execute the onClick handler.   In
	general developers should not attach to or override this method.</summary>
      </method>
      <method name="onCancel" scope="prototype">
        <summary>Attach point for notification about when the user cancels the current menu
	This is an internal mechanism used for Menus to signal to their parent to
	close them.  In general developers should not attach to or override this method.</summary>
        <parameters>
          <parameter name="closeAll" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToPopup" scope="prototype">
        <summary>This handles the right arrow key (left arrow key on RTL systems),
	which will either open a submenu, or move to the next item in the
	ancestor MenuBar</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onPopupHover" scope="prototype">
        <summary>This handler is called when the mouse moves over the popup.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onItemHover" scope="prototype">
        <summary>Called when cursor is over a MenuItem.</summary>
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="prototype">
        <summary>Called when a child MenuItem becomes inactive because focus
	has been removed from the MenuItem *and* it's descendant menus.</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onItemUnhover" scope="prototype">
        <summary>Callback fires when mouse exits a MenuItem</summary>
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_stopPopupTimer" scope="prototype">
        <summary>Cancels the popup timer because the user has stop hovering
	on the MenuItem, etc.</summary>
      </method>
      <method name="_stopPendingCloseTimer" scope="prototype">
        <summary>Cancels the pending-close timer because the close has been preempted</summary>
        <parameters>
          <parameter name="popup" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_stopFocusTimer" scope="prototype">
        <summary>Cancels the pending-focus timer because the menu was closed before focus occured</summary>
      </method>
      <method name="_getTopMenu" scope="prototype">
        <summary>Returns the top menu in this chain of Menus</summary>
      </method>
      <method name="onItemClick" scope="prototype">
        <summary>Handle clicks on an item.</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_openPopup" scope="prototype">
        <summary>Open the popup to the side of/underneath the current menu item</summary>
        <return-types>
          <return-type type="the focused child lost focus since the timer was started"/>
        </return-types>
      </method>
      <method name="_markActive" scope="prototype">
        <summary>Mark this menu's state as active.
	Called when this Menu gets focus from:
	1) clicking it (mouse or via space/arrow key)
	2) being opened by a parent menu.
	This is not called just from mouse hover.
	Focusing a menu via TAB does NOT automatically set isActive
	since TAB is a navigation operation and not a selection one.
	For Windows apps, pressing the ALT key focuses the menubar
	menus (similar to TAB navigation) but the menu is not active
	(ie no dropdown) until an item is clicked.</summary>
      </method>
      <method name="onOpen" scope="prototype">
        <summary>Callback when this menu is opened.
	This is called by the popup manager as notification that the menu
	was opened.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_markInactive" scope="prototype">
        <summary>Mark this menu's state as inactive.</summary>
      </method>
      <method name="onClose" scope="prototype">
        <summary>Callback when this menu is closed.
	This is called by the popup manager as notification that the menu
	was closed.</summary>
      </method>
      <method name="_closeChild" scope="prototype">
        <summary>Called when submenu is clicked or focus is lost.  Close hierarchy of menus.</summary>
      </method>
      <method name="_onItemFocus" scope="prototype">
        <summary>Called when child of this Menu gets focus from:
	1) clicking it
	2) tabbing into it
	3) being opened by a parent menu.
	This is not called just from mouse hover.</summary>
        <parameters>
          <parameter name="item" type="MenuItem" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>Called when focus is moved away from this Menu and it's submenus.</summary>
      </method>
      <method name="_cleanUp" scope="prototype">
        <summary>Called when the user is done with this menu.  Closes hierarchy of menus.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._MenuBase.currentPopup"/>
  <object location="dijit._MenuBase.currentPopup.parentMenu" type="">
    <properties>
      <property name="focusedChild" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._MenuBase.focusedChild"/>
  <object location="dijit._MenuBase.focusedChild.popup" type="">
    <properties>
      <property name="parentMenu" scope="prototype" type="Object"/>
      <property name="from_item" scope="prototype" type=""/>
      <property name="_focus_timer" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.Menu" type="Function" classlike="true" superclass="dijit._MenuBase">
    <mixins>
      <mixin scope="instance" location="dijit._MenuBase"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="targetNodeIds" scope="prototype" type="String[]">
        <summary>Array of dom node ids of nodes to attach to.
	Fill this with nodeIds upon widget creation and it becomes context menu for those nodes.</summary>
      </property>
      <property name="contextMenuForWindow" scope="prototype" type="Boolean">
        <summary>If true, right clicking anywhere on the window will cause this context menu to open.
	If false, must specify targetNodeIds.</summary>
      </property>
      <property name="leftClickToOpen" scope="prototype" type="Boolean">
        <summary>If true, menu will open on left click instead of right click, similiar to a file menu.</summary>
      </property>
      <property name="refocus" scope="prototype" type="Boolean">
        <summary>When this menu closes, re-focus the element which had focus before it was opened.</summary>
      </property>
      <property name="_contextMenuWithMouse" scope="prototype" type="Boolean">
        <summary>Used to record mouse and keyboard events to determine if a context
	menu is being opened with the keyboard or the mouse.</summary>
      </property>
      <property name="_openSubMenuKey" scope="prototype" type=""/>
      <property name="_closeSubMenuKey" scope="prototype" type=""/>
      <property name="_bindings" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <summary>Handle keyboard based menu navigation.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeContentWindow" scope="prototype">
        <summary>Returns the window reference of the passed iframe</summary>
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Window"/>
        </return-types>
      </method>
      <method name="_iframeContentDocument" scope="prototype">
        <summary>Returns a reference to the document object inside iframe_el</summary>
        <parameters>
          <parameter name="iframe_el" type="HTMLIFrameElement" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="HTMLDocument"/>
        </return-types>
      </method>
      <method name="bindDomNode" scope="prototype">
        <summary>Attach menu to given node</summary>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="unBindDomNode" scope="prototype">
        <summary>Detach menu from given node</summary>
        <parameters>
          <parameter name="nodeName" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_contextKey" scope="prototype">
        <summary>Code to handle popping up editor using F10 key rather than mouse</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_contextMouse" scope="prototype">
        <summary>Helper to remember when we opened the context menu with the mouse instead
	of with the keyboard</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_openMyself" scope="prototype">
        <summary>Internal function for opening myself when the user
	does a right-click or something similar.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="node" type="DomNode" usage="optional">
            <summary>The node that is being clicked</summary>
          </parameter>
          <parameter name="iframe" type="DomNode" usage="optional">
            <summary>If an &amp;lt;iframe&amp;gt; is being clicked, iframe points to that iframe and node
	points to the iframe's body.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype"/>
      <method name="uninitialize" scope="prototype"/>
      <method name="getPlaceholders" scope="prototype">
        <summary>returns an array of placeholders with the given label.  There
	can be multiples.</summary>
        <return-description>An array of placeholders that match the given label</return-description>
        <parameters>
          <parameter name="label" type="String" usage="optional">
            <summary>Label to search for - if not specified, then all placeholders
	are returned</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.widget.PlaceholderMenuItem[]"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit.MenuBar" type="Function" classlike="true" superclass="dijit._MenuBase">
    <summary>A menu bar, listing menu choices horizontally, like the &amp;quot;File&amp;quot; menu in most desktop applications</summary>
    <mixins>
      <mixin scope="instance" location="dijit._MenuBase"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_isMenuBar" scope="prototype" type="Boolean">
        <summary>This is a MenuBar widget, not a (vertical) Menu widget.</summary>
      </property>
      <property name="focusedChild" scope="prototype" type=""/>
      <property name="_orient" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>Sets up local variables etc.</summary>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="focusChild" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <summary>Handle keyboard based menu navigation.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onItemClick" scope="prototype">
        <summary>Handle clicks on an item. Cancels a dropdown if already open.</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._MenuBarItemMixin" type="Function" classlike="true">
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.MenuBarItem" type="Function" classlike="true" superclass="dijit.MenuItem">
    <summary>Item in a MenuBar that's clickable, and doesn't spawn a submenu when pressed (or hovered)</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._MenuBarItemMixin.prototype"/>
      <mixin scope="instance" location="dijit.MenuItem"/>
      <mixin scope="instance" location="dijit._MenuBarItemMixin"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.MenuItem" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A line item in a Menu Widget</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="label" scope="prototype" type="String">
        <summary>Menu text</summary>
      </property>
      <property name="iconClass" scope="prototype" type="String">
        <summary>Class to apply to DOMNode to make it display an icon.</summary>
      </property>
      <property name="accelKey" scope="prototype" type="String">
        <summary>Text for the accelerator (shortcut) key combination.
	Note that although Menu can display accelerator keys there
	is no infrastructure to actually catch and execute these
	accelerators.</summary>
      </property>
      <property name="disabled" scope="prototype" type="Boolean">
        <summary>If true, the menu item is disabled.
	If false, the menu item is enabled.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_fillContent" scope="prototype">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_onHover" scope="prototype">
        <summary>Handler when mouse is moved onto menu item</summary>
      </method>
      <method name="_onUnhover" scope="prototype">
        <summary>Handler when mouse is moved off of menu item,
	possibly to a child menu, or maybe to a sibling
	menuitem or somewhere else entirely.</summary>
      </method>
      <method name="_onClick" scope="prototype">
        <summary>Internal handler for click events on MenuItem.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>User defined function to handle clicks</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <summary>Focus on this MenuItem</summary>
      </method>
      <method name="_onFocus" scope="prototype">
        <summary>This is called by the focus manager when focus
	goes to this MenuItem or a child menu.</summary>
      </method>
      <method name="_setSelected" scope="prototype">
        <summary>Indicate that this node is the currently selected one</summary>
        <parameters>
          <parameter name="selected" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="prototype">
        <summary>Deprecated.   Use attr('label', ...) instead.</summary>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="prototype">
        <summary>Deprecated.   Use attr('disabled', bool) instead.</summary>
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>Hook for attr('disabled', ...) to work.
	Enable or disable this menu item.</summary>
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setAccelKeyAttr" scope="prototype">
        <summary>Hook for attr('accelKey', ...) to work.
	Set accelKey on this menu item.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.MenuItem.accelKeyNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.MenuItem.accelKeyNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.MenuSeparator" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A line between two menu items</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="isFocusable" scope="prototype">
        <summary>Override to always return false</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit.PopupMenuBarItem" type="Function" classlike="true" superclass="dijit.PopupMenuItem">
    <summary>Item in a MenuBar like &amp;quot;File&amp;quot; or &amp;quot;Edit&amp;quot;, that spawns a submenu when pressed (or hovered)</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._MenuBarItemMixin.prototype"/>
      <mixin scope="instance" location="dijit.PopupMenuItem"/>
      <mixin scope="instance" location="dijit._MenuBarItemMixin"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.PopupMenuItem" type="Function" classlike="true" superclass="dijit.MenuItem">
    <mixins>
      <mixin scope="instance" location="dijit.MenuItem"/>
    </mixins>
    <properties>
      <property name="dropDownContainer" scope="prototype" type=""/>
      <property name="popup" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_fillContent" scope="prototype">
        <summary>When Menu is declared in markup, this code gets the menu label and
	the popup widget from the srcNodeRef.</summary>
        <description>srcNodeRefinnerHTML contains both the menu item text and a popup widget
	The first part holds the menu item text and the second part is the popup</description>
        <examples>
          <example>	&lt;div dojoType="dijit.PopupMenuItem"&gt;
			&lt;span&gt;pick me&lt;/span&gt;
			&lt;popup&gt; ... &lt;/popup&gt;
		&lt;/div&gt;</example>
        </examples>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="destroyDescendants" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.PopupMenuItem.popup.domNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.ProgressBar" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A progress indication widget, showing the amount completed
	(often the percentage completed) of a task.</summary>
    <description>Note that the progress bar is updated via (a non-standard)
	update() method, rather than via attr() like other widgets.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="ProgressBar"
			 places="0"
			 progress="..." maximum="..."&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="progress" scope="prototype" type="String">
        <summary>(Percentage or Number)
	Number or percentage indicating amount of task completed.
	With &amp;quot;%&amp;quot;: percentage value, 0% &amp;lt;= progress &amp;lt;= 100%, or
	without &amp;quot;%&amp;quot;: absolute value, 0 &amp;lt;= progress &amp;lt;= maximum
	TODO: rename to value for 2.0</summary>
      </property>
      <property name="maximum" scope="prototype" type="Float">
        <summary>Max sample number</summary>
      </property>
      <property name="places" scope="prototype" type="Number">
        <summary>Number of places to show in values; 0 by default</summary>
      </property>
      <property name="indeterminate" scope="prototype" type="Boolean">
        <summary>If false: show progress value (number or percentage).
	If true: show that a process is underway but that the amount completed is unknown.</summary>
      </property>
      <property name="name" scope="prototype" type="String">
        <summary>this is the field name (for a form) if set. This needs to be set if you want to use
	this widget in a dijit.form.Form widget (such as dijit.Dialog)</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_indeterminateHighContrastImagePath" scope="prototype" type="dojo._URL">
        <summary>URL to image to use for indeterminate progress bar when display is in high contrast mode</summary>
      </property>
      <property name="internalProgress" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="update" scope="prototype">
        <summary>Change attributes of ProgressBar, similar to attr(hash).</summary>
        <examples>
          <example>	myProgressBar.update({'indeterminate': true});
		myProgressBar.update({'progress': 80});</example>
        </examples>
        <parameters>
          <parameter name="attributes" type="Object" usage="optional">
            <summary>May provide progress and/or maximum properties on this parameter;
	see attribute specs for details.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype"/>
      <method name="report" scope="prototype">
        <summary>Generates message to show inside progress bar (normally indicating amount of task completed).
	May be overridden.</summary>
        <parameters>
          <parameter name="percent" type="float" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Callback fired when progress updates.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.ProgressBar.label.firstChild" type="">
    <properties>
      <property name="nodeValue" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.ProgressBar.internalProgress.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.TitlePane" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <summary>A pane with a title on top, that can be expanded or collapsed.</summary>
    <description>An accessible container with a title Heading, and a content
	section that slides open and closed. TitlePane is an extension to
	`dijit.layout.ContentPane`, providing all the useful content-control aspects from it.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example> 	// load a TitlePane from remote file:
		var foo = new dijit.TitlePane({ href: "foobar.html", title:"Title" });
		foo.startup();</example>
      <example>	&lt;!-- markup href example: --&gt;
		&lt;div dojoType="dijit.TitlePane" href="foobar.html" title="Title"&gt;&lt;/div&gt;</example>
      <example>	&lt;!-- markup with inline data --&gt;
	 	&lt;div dojoType="dijit.TitlePane" title="Title"&gt;
			&lt;p&gt;I am content&lt;/p&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="title" scope="prototype" type="String">
        <summary>Title of the pane</summary>
      </property>
      <property name="open" scope="prototype" type="Boolean">
        <summary>Whether pane is opened or closed.</summary>
      </property>
      <property name="toggleable" scope="prototype" type="Boolean">
        <summary>Whether pane can be opened or closed by clicking the title bar.</summary>
      </property>
      <property name="tabIndex" scope="prototype" type="String">
        <summary>Tabindex setting for the title (so users can tab to the title then
	use space/enter to open/close the title pane)</summary>
      </property>
      <property name="duration" scope="normal" type="Integer">
        <summary>Time in milliseconds to fade in/fade out</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String">
        <summary>The root className to be placed on this widget's domNode.</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="hideNode" scope="prototype" type=""/>
      <property name="wipeNode" scope="prototype" type=""/>
      <property name="_wipeIn" scope="prototype" type="Object"/>
      <property name="_wipeOut" scope="prototype" type="Object"/>
      <property name="titleBarNode" scope="prototype" type="Object"/>
      <property name="_titleBarClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setOpenAttr" scope="prototype">
        <summary>Hook to make attr(&amp;quot;open&amp;quot;, boolean) control the open/closed state of the pane.</summary>
        <parameters>
          <parameter name="open" type="Boolean" usage="required">
            <summary>True if you want to open the pane, false if you want to close it.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setToggleableAttr" scope="prototype">
        <summary>Hook to make attr(&amp;quot;canToggle&amp;quot;, boolean) work.</summary>
        <parameters>
          <parameter name="canToggle" type="Boolean" usage="required">
            <summary>True to allow user to open/close pane by clicking title bar.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="prototype">
        <summary>Hook to make attr(&amp;quot;content&amp;quot;, ...) work.
	Typically called when an href is loaded.  Our job is to make the animation smooth.</summary>
        <parameters>
          <parameter name="content" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="prototype">
        <summary>Switches between opened and closed state</summary>
      </method>
      <method name="_setCss" scope="prototype">
        <summary>Set the open/close css state for the TitlePane</summary>
      </method>
      <method name="_onTitleKey" scope="prototype">
        <summary>Handler for when user hits a key</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTitleEnter" scope="prototype">
        <summary>Handler for when someone hovers over my title</summary>
      </method>
      <method name="_onTitleLeave" scope="prototype">
        <summary>Handler when someone stops hovering over my title</summary>
      </method>
      <method name="_onTitleClick" scope="prototype">
        <summary>Handler when user clicks the title bar</summary>
      </method>
      <method name="_handleFocus" scope="prototype">
        <summary>Handle blur and focus events on title bar</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setTitle" scope="prototype">
        <summary>Deprecated.  Use attr('title', ...) instead.</summary>
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.TitlePane.hideNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.TitlePane.wipeNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.TitlePane.arrowNodeInner" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.Toolbar" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A Toolbar widget, used to hold things like &lt;code&gt;dijit.Editor&lt;/code&gt; buttons</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._KeyNavContainer.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._KeyNavContainer"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.ToolbarSeparator" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A spacer between two &lt;code&gt;dijit.Toolbar&lt;/code&gt; items</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="isFocusable" scope="prototype">
        <summary>This widget isn't focusable, so pass along that fact.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._MasterTooltip" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Internal widget that holds the actual tooltip markup,
	which occurs once per page.
	Called by Tooltip widgets which are just containers to hold
	the markup</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="duration" scope="normal" type="Integer">
        <summary>Milliseconds to fade in/fade out</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="bgIframe" scope="prototype" type="Object"/>
      <property name="fadeIn" scope="prototype" type="Object"/>
      <property name="fadeOut" scope="prototype" type="Object"/>
      <property name="_onDeck" scope="prototype" type="Object"/>
      <property name="isShowingNow" scope="prototype" type="bool"/>
      <property name="aroundNode" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="show" scope="prototype">
        <summary>Display tooltip w/specified contents to right of specified node
	(To left if there's no space on the right, or if LTR==right)</summary>
        <parameters>
          <parameter name="innerHTML" type="String" usage="required"/>
          <parameter name="aroundNode" type="DomNode" usage="required"/>
          <parameter name="position" type="String[]" usage="optional"/>
        </parameters>
      </method>
      <method name="orient" scope="prototype">
        <summary>Private function to set CSS for tooltip node based on which position it's in.
	This is called by the dijit popup code.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="tooltipCorner" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="prototype">
        <summary>Called at end of fade-in operation</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Hide the tooltip</summary>
        <parameters>
          <parameter name="aroundNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onHide" scope="prototype">
        <summary>Called at end of fade-out operation</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._MasterTooltip.containerNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._MasterTooltip.domNode.style" type="">
    <properties>
      <property name="top" scope="prototype" type="String"/>
      <property name="filter" scope="prototype" type="String"/>
      <property name="cssText" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.Tooltip" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Pops up a tooltip (a help message) when you hover over a node.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="label" scope="prototype" type="String">
        <summary>Text to display in the tooltip.
	Specified as innerHTML when creating the widget from markup.</summary>
      </property>
      <property name="showDelay" scope="prototype" type="Integer">
        <summary>Number of milliseconds to wait after hovering over/focusing on the object, before
	the tooltip is displayed.</summary>
      </property>
      <property name="connectId" scope="prototype" type="String[]">
        <summary>Id's of domNodes to attach the tooltip to.
	When user hovers over any of the specified dom nodes, the tooltip will appear.
	Note: Currently connectId can only be specified on initialization, it cannot
	be changed via attr('connectId', ...)
	Note: in 2.0 this will be renamed to connectIds for less confusion.</summary>
      </property>
      <property name="position" scope="prototype" type="String[]">
        <summary>See description of &lt;code&gt;dijit.Tooltip.defaultPosition&lt;/code&gt; for details on position parameter.</summary>
      </property>
      <property name="_focus" scope="prototype" type="bool"/>
      <property name="_showTimer" scope="prototype" type="Object"/>
      <property name="_connectNode" scope="prototype" type=""/>
      <property name="_nodeConnectionsById" scope="instance" type="Object"/>
      <property name="defaultPosition" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="_setConnectIdAttr" scope="prototype">
        <parameters>
          <parameter name="newIds" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getConnectIdAttr" scope="prototype"/>
      <method name="addTarget" scope="prototype">
        <summary>Attach tooltip to specified node, if it's not already connected</summary>
        <parameters>
          <parameter name="id" type="DOMNODE" usage="required">
            <summary>|| String</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Already connected"/>
        </return-types>
      </method>
      <method name="removeTarget" scope="prototype">
        <summary>Detach tooltip from specified node</summary>
        <parameters>
          <parameter name="node" type="DOMNODE" usage="required">
            <summary>|| String</summary>
          </parameter>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_onTargetMouseEnter" scope="prototype">
        <summary>Handler for mouseenter event on the target node</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTargetMouseLeave" scope="prototype">
        <summary>Handler for mouseleave event on the target node</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTargetFocus" scope="prototype">
        <summary>Handler for focus event on the target node</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onTargetBlur" scope="prototype">
        <summary>Handler for blur event on the target node</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHover" scope="prototype">
        <summary>Despite the name of this method, it actually handles both hover and focus
	events on the target node, setting a timer to show the tooltip.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnHover" scope="prototype">
        <summary>Despite the name of this method, it actually handles both mouseleave and blur
	events on the target node, hiding the tooltip.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="prototype">
        <summary>Display the tooltip; usually not called directly.</summary>
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>Hide the tooltip or cancel timer for show of tooltip</summary>
      </method>
      <method name="onShow" scope="prototype">
        <summary>Called when the tooltip is shown</summary>
        <parameters>
          <parameter name="target" type="" usage="required"/>
          <parameter name="position" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onHide" scope="prototype">
        <summary>Called when the tooltip is hidden</summary>
      </method>
      <method name="uninitialize" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.TooltipDialog" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <summary>Pops up a dialog that appears like a Tooltip</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit.form._FormMixin.prototype"/>
      <mixin scope="prototype" location="dijit._DialogMixin.prototype"/>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit.form._FormMixin"/>
      <mixin scope="instance" location="dijit._DialogMixin"/>
    </mixins>
    <properties>
      <property name="title" scope="prototype" type="String">
        <summary>Description of tooltip dialog (required for a11y)</summary>
      </property>
      <property name="doLayout" scope="prototype" type="Boolean">
        <summary>Don't change this parameter from the default value.
	This ContentPane parameter doesn't make sense for TooltipDialog, since TooltipDialog
	is never a child of a layout container, nor can you specify the size of
	TooltipDialog in order to control the size of an inner widget.</summary>
      </property>
      <property name="autofocus" scope="prototype" type="Boolean">
        <summary>A Toggle to modify the default focus behavior of a Dialog, which
	is to focus on the first dialog element after opening the dialog.
	False will disable autofocusing. Default: true</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String">
        <summary>The root className to use for the various states of this widget</summary>
      </property>
      <property name="_firstFocusItem" scope="prototype" type="[readonly]">
        <summary>DomNode
	The pointer to the first focusable node in the dialog.
	Set by &lt;code&gt;dijit._DialogMixin._getFocusItems&lt;/code&gt;.</summary>
      </property>
      <property name="_lastFocusItem" scope="prototype" type="[readonly]">
        <summary>DomNode
	The pointer to which node has focus prior to our dialog.
	Set by &lt;code&gt;dijit._DialogMixin._getFocusItems&lt;/code&gt;.</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_currentOrientClass" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="orient" scope="prototype">
        <summary>Configure widget to be displayed in given position relative to the button.
	This is called from the dijit.popup code, and should not be called
	directly.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="aroundCorner" type="String" usage="required"/>
          <parameter name="corner" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="prototype">
        <summary>Called when dialog is displayed.
	This is called from the dijit.popup code, and should not be called directly.</summary>
        <parameters>
          <parameter name="pos" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="prototype">
        <summary>Called when dialog is hidden.
	This is called from the dijit.popup code, and should not be called directly.</summary>
      </method>
      <method name="_onKey" scope="prototype">
        <summary>Handler for keyboard events</summary>
        <description>Keep keyboard focus in dialog; close dialog on escape key</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.TooltipDialog.containerNode" type="">
    <properties>
      <property name="title" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._TreeNode" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Single node within a tree.   This class is used internally
	by Tree and should not be accessed directly.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="item" scope="prototype" type="dojo.data.Item">
        <summary>the dojo.data entry this tree represents</summary>
      </property>
      <property name="isTreeNode" scope="prototype" type="Boolean">
        <summary>Indicates that this is a TreeNode.   Used by &lt;code&gt;dijit.Tree&lt;/code&gt; only,
	should not be accessed directly.</summary>
      </property>
      <property name="label" scope="prototype" type="String">
        <summary>Text of this tree node</summary>
      </property>
      <property name="isExpandable" scope="prototype" type="Boolean">
        <summary>This node has children, so show the expando node (+ sign)</summary>
      </property>
      <property name="isExpanded" scope="prototype" type="Boolean">
        <summary>This node is currently expanded (ie, opened)</summary>
      </property>
      <property name="state" scope="prototype" type="String">
        <summary>Dynamic loading-related stuff.
	When an empty folder node appears, it is &amp;quot;UNCHECKED&amp;quot; first,
	then after dojo.data query it becomes &amp;quot;LOADING&amp;quot; and, finally &amp;quot;LOADED&amp;quot;</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="indent" scope="prototype" type="Integer">
        <summary>Levels from this node to the root node</summary>
      </property>
      <property name="_expandDeferred" scope="prototype" type="Object"/>
      <property name="_wipeOut" scope="prototype" type="Object"/>
      <property name="labelNode" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setIndentAttr" scope="prototype">
        <summary>Tell this node how many levels it should be indented</summary>
        <description>0 for top level nodes, 1 for their children, 2 for their
	grandchildren, etc.</description>
        <parameters>
          <parameter name="indent" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markProcessing" scope="prototype">
        <summary>Visually denote that tree is loading data, etc.</summary>
      </method>
      <method name="unmarkProcessing" scope="prototype">
        <summary>Clear markup from markProcessing() call</summary>
      </method>
      <method name="_updateItemClasses" scope="prototype">
        <summary>Set appropriate CSS classes for icon and label dom node
	(used to allow for item updates to change respective CSS)</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_applyClassAndStyle" scope="prototype">
        <summary>Set the appropriate CSS classes and styles for labels, icons and rows.</summary>
        <parameters>
          <parameter name="item" type="The" usage="required">
            <summary>data item.</summary>
          </parameter>
          <parameter name="lower" type="The" usage="required">
            <summary>lower case attribute to use, e.g. 'icon', 'label' or 'row'.</summary>
          </parameter>
          <parameter name="upper" type="The" usage="required">
            <summary>upper case attribute to use, e.g. 'Icon', 'Label' or 'Row'.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_updateLayout" scope="prototype">
        <summary>Set appropriate CSS classes for this.domNode</summary>
      </method>
      <method name="_setExpando" scope="prototype">
        <summary>Set the right image for the expando node</summary>
        <parameters>
          <parameter name="processing" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="expand" scope="prototype">
        <summary>Show my children</summary>
        <return-description>Deferred that fires when expansion is complete</return-description>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="collapse" scope="prototype">
        <summary>Collapse this node (if it's expanded)</summary>
      </method>
      <method name="setChildItems" scope="prototype">
        <summary>Sets the child items of this node, removing/adding nodes
	from current children to match specified items[] array.
	Also, if this.persist == true, expands any children that were previously
	opened.</summary>
        <return-description>Deferred object that fires after all previously opened children
	have been expanded again (or fires instantly if there are no such children).</return-description>
        <parameters>
          <parameter name="items" type="Object[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="node" type="treeNode" usage="required"/>
        </parameters>
      </method>
      <method name="makeExpandable" scope="prototype">
        <summary>if this node wasn't already showing the expando node,
	turn it into one and call _setExpando()</summary>
      </method>
      <method name="_onLabelFocus" scope="prototype">
        <summary>Called when this node is focused (possibly programatically)</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onLabelBlur" scope="prototype">
        <summary>Called when focus was moved away from this node, either to
	another TreeNode or away from the Tree entirely.
	Note that we aren't using _onFocus/_onBlur builtin to dijit
	because _onBlur() isn't called when focus is moved to my child TreeNode.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="prototype">
        <summary>A Tree has a (single) currently selected node.
	Mark that this node is/isn't that currently selected node.</summary>
        <description>In particular, setting a node as selected involves setting tabIndex
	so that when user tabs to the tree, focus will go to that node (only).</description>
        <parameters>
          <parameter name="selected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="prototype">
        <summary>Handler for onclick event on a node</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onDblClick" scope="prototype">
        <summary>Handler for ondblclick event on a node</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseEnter" scope="prototype">
        <summary>Handler for onmouseenter event on a node</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseLeave" scope="prototype">
        <summary>Handler for onmouseenter event on a node</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._TreeNode.tree" type="">
    <properties>
      <property name="model" scope="prototype" type=""/>
      <property name="lastFocused" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._TreeNode.expandoNodeText" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.Tree" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>This widget displays hierarchical data from a store.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="store" scope="prototype" type="String||dojo.data.Store">
        <summary>Deprecated.  Use &amp;quot;model&amp;quot; parameter instead.
	The store to get data to display in the tree.</summary>
      </property>
      <property name="model" scope="prototype" type="dijit.Tree.model">
        <summary>Interface to read tree data, get notifications of changes to tree data,
	and for handling drop operations (i.e drag and drop onto the tree)</summary>
      </property>
      <property name="query" scope="prototype" type="anything">
        <summary>Deprecated.  User should specify query to the model directly instead.
	Specifies datastore query to return the root item or top items for the tree.</summary>
      </property>
      <property name="label" scope="prototype" type="String">
        <summary>Deprecated.  Use dijit.tree.ForestStoreModel directly instead.
	Used in conjunction with query parameter.
	If a query is specified (rather than a root node id), and a label is also specified,
	then a fake root node is created and displayed, with this label.</summary>
      </property>
      <property name="showRoot" scope="prototype" type="Boolean">
        <summary>Should the root node be displayed, or hidden?</summary>
      </property>
      <property name="childrenAttr" scope="prototype" type="String[]">
        <summary>Deprecated.   This information should be specified in the model.
	One ore more attributes that holds children of a tree node</summary>
      </property>
      <property name="path" scope="prototype" type="String[]">
        <summary>or Item[]
	Full path from rootNode to selected node expressed as array of items or array of ids.</summary>
      </property>
      <property name="selectedItem" scope="prototype" type="Item">
        <summary>The currently selected item in this tree.
	This property can only be set (via attr('selectedItem', ...)) when that item is already
	visible in the tree.   (I.e. the tree has already been expanded to show that node.)
	Should generally use &lt;code&gt;path&lt;/code&gt; attribute to set the selected item instead.</summary>
      </property>
      <property name="openOnClick" scope="prototype" type="Boolean">
        <summary>If true, clicking a folder node's label will open it, rather than calling onClick()</summary>
      </property>
      <property name="openOnDblClick" scope="prototype" type="Boolean">
        <summary>If true, double-clicking a folder node's label will open it, rather than calling onDblClick()</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="persist" scope="prototype" type="Boolean">
        <summary>Enables/disables use of cookies for state saving.</summary>
      </property>
      <property name="autoExpand" scope="prototype" type="Boolean">
        <summary>Fully expand the tree on load.   Overrides &lt;code&gt;persist&lt;/code&gt;</summary>
      </property>
      <property name="dndController" scope="prototype" type="String">
        <summary>Class name to use as as the dnd controller.  Specifying this class enables DnD.
	Generally you should specify this as &amp;quot;dijit.tree.dndSource&amp;quot;.</summary>
      </property>
      <property name="dndParams" scope="prototype" type="Array"/>
      <property name="dragThreshold" scope="prototype" type="Integer">
        <summary>Number of pixels mouse moves before it's considered the start of a drag operation</summary>
      </property>
      <property name="betweenThreshold" scope="prototype" type="Integer">
        <summary>Set to a positive value to allow drag and drop &amp;quot;between&amp;quot; nodes.
	If during DnD mouse is over a (target) node but less than betweenThreshold
	pixels from the bottom edge, dropping the the dragged node will make it
	the next sibling of the target node, rather than the child.
	Similarly, if mouse is over a target node but less that betweenThreshold
	pixels from the top edge, dropping the dragged node will make it
	the target node's previous sibling rather than the target node's child.</summary>
      </property>
      <property name="_nodePixelIndent" scope="prototype" type="Integer">
        <summary>Number of pixels to indent tree nodes (relative to parent node).
	Default is 19 but can be overridden by setting CSS class dijitTreeIndent
	and calling resize() or startup() on tree after it's in the DOM.</summary>
      </property>
      <property name="tree" scope="prototype" type="Object"/>
      <property name="_itemNodesMap" scope="prototype" type="Object"/>
      <property name="cookieName" scope="prototype" type="String"/>
      <property name="_loadDeferred" scope="prototype" type="Object"/>
      <property name="_v10Compat" scope="prototype" type="Object"/>
      <property name="lastFocused" scope="prototype" type="Object"/>
      <property name="_keyHandlerMap" scope="prototype" type=""/>
      <property name="multiCharSearchDuration" scope="prototype" type="Number">
        <summary>If multiple characters are typed where each keystroke happens within
	multiCharSearchDuration of the previous keystroke,
	search for nodes matching all the keystrokes.
	For example, typing &amp;quot;ab&amp;quot; will search for entries starting with
	&amp;quot;ab&amp;quot; unless the delay between &amp;quot;a&amp;quot; and &amp;quot;b&amp;quot; is greater than multiCharSearchDuration.</summary>
      </property>
      <property name="_curSearch" scope="prototype" type="Object"/>
      <property name="_openedItemIds" scope="prototype" type="Object"/>
      <property name="rootNode" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onDndDrop" scope="prototype">
        <summary>Parameter to dndController, see &lt;code&gt;dijit.tree.dndSource.onDndDrop&lt;/code&gt;.
	Generally this doesn't need to be set.</summary>
      </method>
      <method name="itemCreator" scope="prototype">
        <summary>Returns objects passed to &lt;code&gt;Tree.model.newItem()&lt;/code&gt; based on DnD nodes
	dropped onto the tree.   Developer must override this method to enable
	dropping from external sources onto this Tree, unless the Tree.model's items
	happen to look like {id: 123, name: &amp;quot;Apple&amp;quot; } with no other attributes.</summary>
        <description>For each node in nodes[], which came from source, create a hash of name/value
	pairs to be passed to Tree.model.newItem().  Returns array of those hashes.</description>
        <return-description>Object[]
	Array of name/value hashes for each new item to be added to the Tree, like:
		[
			{ id: 123, label: "apple", foo: "bar" },
			{ id: 456, label: "pear", zaz: "bam" }
		]</return-description>
        <parameters>
          <parameter name="nodes" type="DomNode[]" usage="required">
            <summary>The DOMNodes dragged from the source container</summary>
          </parameter>
          <parameter name="target" type="DomNode" usage="required">
            <summary>The target TreeNode.rowNode</summary>
          </parameter>
          <parameter name="source" type="dojo.dnd.Source" usage="required">
            <summary>The source container the nodes were dragged from, perhaps another Tree or a plain dojo.dnd.Source</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="prototype">
        <summary>Parameter to dndController, see &lt;code&gt;dijit.tree.dndSource.onDndCancel&lt;/code&gt;.
	Generally this doesn't need to be set.</summary>
      </method>
      <method name="checkAcceptance" scope="prototype">
        <summary>Checks if the Tree itself can accept nodes from this source</summary>
        <parameters>
          <parameter name="source" type="dijit.tree._dndSource" usage="required">
            <summary>The source which provides items</summary>
          </parameter>
          <parameter name="nodes" type="DOMNode[]" usage="required">
            <summary>Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
	source is a dijit.Tree.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="checkItemAcceptance" scope="prototype">
        <summary>Stub function to be overridden if one wants to check for the ability to drop at the node/item level</summary>
        <description>In the base case, this is called to check if target can become a child of source.
	When betweenThreshold is set, position="before" or "after" means that we
	are asking if the source node can be dropped before/after the target node.</description>
        <parameters>
          <parameter name="target" type="DOMNode" usage="required">
            <summary>The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
	Use dijit.getEnclosingWidget(target) to get the TreeNode.</summary>
          </parameter>
          <parameter name="source" type="dijit.tree.dndSource" usage="required">
            <summary>The (set of) nodes we are dropping</summary>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <summary>&amp;quot;over&amp;quot;, &amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_publish" scope="prototype">
        <summary>Publish a message for this widget/topic</summary>
        <parameters>
          <parameter name="topicName" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_store2model" scope="prototype">
        <summary>User specified a store&amp;amp;query rather than model, so create model from store/query</summary>
      </method>
      <method name="onLoad" scope="prototype">
        <summary>Called when tree finishes loading and expanding.</summary>
        <description>If persist == true the loading may encompass many levels of fetches
	from the data store, each asynchronous.   Waits for all to finish.</description>
      </method>
      <method name="_load" scope="prototype">
        <summary>Initial load of the tree.
	Load root node (possibly hidden) and it's children.</summary>
      </method>
      <method name="getNodesByItem" scope="prototype">
        <summary>Returns all tree nodes that refer to an item</summary>
        <return-description>Array of tree nodes that refer to passed item</return-description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required">
            <summary>or id</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setSelectedItemAttr" scope="prototype">
        <summary>Select a tree node related to passed item.
	WARNING: if model use multi-parented items or desired tree node isn't already loaded
	behavior is not granted. Use 'path' attr instead for full support.</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required">
            <summary>or id</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getSelectedItemAttr" scope="prototype">
        <summary>Return item related to selected tree node.</summary>
      </method>
      <method name="_setPathAttr" scope="prototype">
        <summary>Select the tree node identified by passed path.</summary>
        <parameters>
          <parameter name="path" type="Item[]" usage="required">
            <summary>Array of items or item id's</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getPathAttr" scope="prototype">
        <summary>Return an array of items that is the path to selected tree node.</summary>
      </method>
      <method name="mayHaveChildren" scope="prototype">
        <summary>Deprecated.   This should be specified on the model itself.
	Overridable function to tell if an item has or may have children.
	Controls whether or not +/- expando icon is shown.
	(For efficiency reasons we may not want to check if an element actually
	has children until user clicks the expando node)</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getItemChildren" scope="prototype">
        <summary>Deprecated.   This should be specified on the model itself.
	Overridable function that return array of child items of given parent item,
	or if parentItem==null then return top items in tree</summary>
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items)" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>Overridable function to get the label for a tree node (given the item)</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getIconClass" scope="prototype">
        <summary>Overridable function to return CSS class name to display icon</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelClass" scope="prototype">
        <summary>Overridable function to return CSS class name to display label</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getRowClass" scope="prototype">
        <summary>Overridable function to return CSS class name to display row</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getIconStyle" scope="prototype">
        <summary>Overridable function to return CSS styles to display icon</summary>
        <return-description>Object suitable for input to dojo.style() like {backgroundImage: "url(...)"}</return-description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelStyle" scope="prototype">
        <summary>Overridable function to return CSS styles to display label</summary>
        <return-description>Object suitable for input to dojo.style() like {color: "red", background: "green"}</return-description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getRowStyle" scope="prototype">
        <summary>Overridable function to return CSS styles to display row</summary>
        <return-description>Object suitable for input to dojo.style() like {background-color: "#bbb"}</return-description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="opened" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getTooltip" scope="prototype">
        <summary>Overridable function to get the tooltip for a tree node (given the item)</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <summary>Translates keypress events into commands for the controller</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onEnterKey" scope="prototype">
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDownArrow" scope="prototype">
        <summary>down arrow pressed; get next visible node, set focus there</summary>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpArrow" scope="prototype">
        <summary>Up arrow pressed; move to previous visible node</summary>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onRightArrow" scope="prototype">
        <summary>Right arrow pressed; go to child node</summary>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLeftArrow" scope="prototype">
        <summary>Left arrow pressed.
	If not collapsed, collapse, else move to parent.</summary>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onHomeKey" scope="prototype">
        <summary>Home key pressed; get first visible node, and set focus there</summary>
      </method>
      <method name="_onEndKey" scope="prototype">
        <summary>End key pressed; go to last visible node.</summary>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_onLetterKeyNav" scope="prototype">
        <summary>Called when user presses a prinatable key; search for node starting with recently typed letters.</summary>
        <parameters>
          <parameter name="message" type="Object" usage="required">
            <summary>Like { node: TreeNode, key: 'a' } where key is the key the user pressed.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onClick" scope="prototype">
        <summary>Translates click events into commands for the controller to process</summary>
        <parameters>
          <parameter name="nodeWidget" type="TreeNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDblClick" scope="prototype">
        <summary>Translates double-click events into commands for the controller to process</summary>
        <parameters>
          <parameter name="nodeWidget" type="TreeNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onExpandoClick" scope="prototype">
        <summary>User clicked the +/- icon; expand or collapse my children.</summary>
        <parameters>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Callback when a tree node is clicked</summary>
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onDblClick" scope="prototype">
        <summary>Callback when a tree node is double-clicked</summary>
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="prototype">
        <summary>Callback when a node is opened</summary>
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="prototype">
        <summary>Callback when a node is closed</summary>
        <parameters>
          <parameter name="item" type="dojo.data" usage="required"/>
          <parameter name="node" type="TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextNode" scope="prototype">
        <summary>Get next visible node</summary>
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_TreeNode"/>
        </return-types>
      </method>
      <method name="_getRootOrFirstNode" scope="prototype">
        <summary>Get first visible node</summary>
      </method>
      <method name="_collapseNode" scope="prototype">
        <summary>Called when the user has requested to collapse the node</summary>
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
        </parameters>
      </method>
      <method name="_expandNode" scope="prototype">
        <summary>Called when the user has requested to expand the node</summary>
        <return-description>Deferred that fires when the node is loaded and opened and (if persist=true) all it's descendants
	that were previously opened too</return-description>
        <parameters>
          <parameter name="node" type="_TreeNode" usage="required"/>
          <parameter name="recursive" type="Boolean" usage="optional">
            <summary>Internal flag used when _expandNode() calls itself, don't set.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="focusNode" scope="prototype">
        <summary>Focus on the specified node (which must be visible)</summary>
        <parameters>
          <parameter name="node" type="_tree.Node" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeFocus" scope="prototype">
        <summary>Called when a TreeNode gets focus, either by user clicking
	it, or programatically by arrow key handling code.</summary>
        <description>It marks that the current node is the selected one, and the previously
	selected node no longer is.</description>
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeMouseEnter" scope="prototype">
        <summary>Called when mouse is over a node (onmouseenter event)</summary>
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeMouseLeave" scope="prototype">
        <summary>Called when mouse is over a node (onmouseenter event)</summary>
        <parameters>
          <parameter name="node" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChange" scope="prototype">
        <summary>Processes notification of a change to an item's scalar values like label</summary>
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChildrenChange" scope="prototype">
        <summary>Processes notification of a change to an item's children</summary>
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemDelete" scope="prototype">
        <summary>Processes notification of a deletion of an item</summary>
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="_initState" scope="prototype">
        <summary>Load in which nodes should be opened automatically</summary>
      </method>
      <method name="_state" scope="prototype">
        <summary>Query or set expanded state for an item,</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="expanded" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_saveState" scope="prototype">
        <summary>Create and save a cookie with the currently expanded nodes identifiers</summary>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="destroyRecursive" scope="prototype"/>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="changeSize" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_createTreeNode" scope="prototype">
        <summary>creates a TreeNode</summary>
        <description>Developers can override this method to define their own TreeNode class;
	However it will probably be removed in a future release in favor of a way
	of just specifying a widget for the label, rather than one that contains
	the children too.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._Contained" type="Function" classlike="true">
    <summary>Mixin for widgets that are children of a container widget</summary>
    <examples>
      <example> 	// make a basic custom widget that knows about it's parents
		dojo.declare("my.customClass",[dijit._Widget,dijit._Contained],{});</example>
    </examples>
    <methods>
      <method constructor="constructor"/>
      <method name="getParent" scope="prototype">
        <summary>Returns the parent widget of this widget, assuming the parent
	specifies isContainer</summary>
      </method>
      <method name="_getSibling" scope="prototype">
        <summary>Returns next or previous sibling</summary>
        <parameters>
          <parameter name="which" type="String" usage="required">
            <summary>Either &amp;quot;next&amp;quot; or &amp;quot;previous&amp;quot;</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getPreviousSibling" scope="prototype">
        <summary>Returns null if this is the first child of the parent,
	otherwise returns the next element sibling to the &amp;quot;left&amp;quot;.</summary>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getNextSibling" scope="prototype">
        <summary>Returns null if this is the last child of the parent,
	otherwise returns the next element sibling to the &amp;quot;right&amp;quot;.</summary>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getIndexInParent" scope="prototype">
        <summary>Returns the index of this widget within its container parent.
	It returns -1 if the parent does not exist, or if the parent
	is not a dijit._Container</summary>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit._Container" type="Function" classlike="true">
    <summary>Mixin for widgets that contain a set of widget children.</summary>
    <description>Use this mixin for widgets that needs to know about and
	keep track of their widget children. Suitable for widgets like BorderContainer
	and TabContainer which contain (only) a set of child widgets.
	It's not suitable for widgets like ContentPane
	which contains mixed HTML (plain DOM nodes in addition to widgets),
	and where contained widgets are not necessarily directly below
	this.containerNode.   In that case calls like addChild(node, position)
	wouldn't make sense.</description>
    <properties>
      <property name="isContainer" scope="prototype" type="Boolean">
        <summary>Indicates that this widget acts as a &amp;quot;parent&amp;quot; to the descendant widgets.
	When the parent is started it will call startup() on the child widgets.
	See also &lt;code&gt;isLayoutContainer&lt;/code&gt;.</summary>
      </property>
      <property name="containerNode" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="addChild" scope="prototype">
        <summary>Makes the given widget a child of this widget.</summary>
        <description>Inserts specified child widget's dom node as a child of this widget's
	container node, and possibly does other processing (such as layout).</description>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <summary>Removes the passed widget instance from this widget but does
	not destroy it.  You can also pass in an integer indicating
	the index within the container to remove</summary>
        <parameters>
          <parameter name="widget" type="Widget" usage="required">
            <summary>or int</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype">
        <summary>Returns array of children widgets.</summary>
        <description>Returns the widgets that are directly under this.containerNode.</description>
        <return-types>
          <return-type type="Widget[]"/>
        </return-types>
      </method>
      <method name="hasChildren" scope="prototype">
        <summary>Returns true if widget has children, i.e. if this.containerNode contains something.</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroyDescendants" scope="prototype">
        <summary>Destroys all the widgets inside this.containerNode,
	but not this widget itself</summary>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getSiblingOfChild" scope="prototype">
        <summary>Get the next or previous widget sibling of child</summary>
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="dir" type="int" usage="required">
            <summary>if 1, get the next sibling
	if -1, get the previous sibling</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="getIndexOfChild" scope="prototype">
        <summary>Gets the index of the child in this container or -1 if not found</summary>
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="startup" scope="prototype">
        <summary>Called after all the widgets have been instantiated and their
	dom nodes have been inserted somewhere under dojo.doc.body.
	Widgets should override this method to do any initialization
	dependent on other widgets existing, and then call
	this superclass method to finish things off.
	startup() in subclasses shouldn't do anything
	size related because the size of the widget hasn't been set yet.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._DialogMixin" type="Function" classlike="true">
    <summary>This provides functions useful to Dialog and TooltipDialog</summary>
    <properties>
      <property name="attributeMap" scope="normal" type=""/>
      <property name="_firstFocusItem" scope="prototype" type="Object"/>
      <property name="_lastFocusItem" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="execute" scope="prototype">
        <summary>Callback when the user hits the submit button.
	Override this method to handle Dialog execution.</summary>
        <description>After the user has pressed the submit button, the Dialog
	first calls onExecute() to notify the container to hide the
	dialog and restore focus to wherever it used to be.
	*Then* this method is called.
	type:
	callback</description>
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="prototype">
        <summary>Called when user has pressed the Dialog's cancel button, to notify container.</summary>
        <description>Developer shouldn't override or connect to this method;
	it's a private communication device between the TooltipDialog
	and the thing that opened it (ex: `dijit.form.DropDownButton`)
	type:
	protected</description>
      </method>
      <method name="onExecute" scope="prototype">
        <summary>Called when user has pressed the dialog's OK button, to notify container.</summary>
        <description>Developer shouldn't override or connect to this method;
	it's a private communication device between the TooltipDialog
	and the thing that opened it (ex: `dijit.form.DropDownButton`)
	type:
	protected</description>
      </method>
      <method name="_onSubmit" scope="prototype">
        <summary>Callback when user hits submit button
	type:
	protected</summary>
      </method>
      <method name="_getFocusItems" scope="prototype">
        <summary>Find focusable Items each time a dialog is opened,
	setting _firstFocusItem and _lastFocusItem</summary>
        <parameters>
          <parameter name="dialogNode" type="Node" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._HasDropDown" type="Function" classlike="true">
    <summary>Mixin for widgets that need drop down ability.</summary>
    <properties>
      <property name="_buttonNode" scope="prototype" type="DomNode">
        <summary>The button/icon/node to click to display the drop down.
	Can be set via a dojoAttachPoint assignment.
	If missing, then either focusNode or domNode (if focusNode is also missing) will be used.</summary>
      </property>
      <property name="_arrowWrapperNode" scope="prototype" type="DomNode">
        <summary>Will set CSS class dijitUpArrow, dijitDownArrow, dijitRightArrow etc. on this node depending
	on where the drop down is set to be positioned.
	Can be set via a dojoAttachPoint assignment.
	If missing, then _buttonNode will be used.</summary>
      </property>
      <property name="_popupStateNode" scope="prototype" type="DomNode">
        <summary>The node to set the popupActive class on.
	Can be set via a dojoAttachPoint assignment.
	If missing, then focusNode or _buttonNode (if focusNode is missing) will be used.</summary>
      </property>
      <property name="_aroundNode" scope="prototype" type="DomNode">
        <summary>The node to display the popup around.
	Can be set via a dojoAttachPoint assignment.
	If missing, then domNode will be used.</summary>
      </property>
      <property name="autoWidth" scope="prototype" type="Boolean">
        <summary>Set to true to make the drop down at least as wide as this
	widget.  Set to false if the drop down should just be its
	default width</summary>
      </property>
      <property name="forceWidth" scope="prototype" type="Boolean">
        <summary>Set to true to make the drop down exactly as wide as this
	widget.  Overrides autoWidth.</summary>
      </property>
      <property name="maxHeight" scope="prototype" type="Integer">
        <summary>The max height for our dropdown.  Set to 0 for no max height.
	any dropdown taller than this will have scrollbars</summary>
      </property>
      <property name="_stopClickEvents" scope="prototype" type="Boolean">
        <summary>When set to false, the click events will not be stopped, in
	case you want to use them in your subwidget</summary>
      </property>
      <property name="_seenKeydown" scope="prototype" type="bool"/>
      <property name="_docHandler" scope="prototype" type="Object"/>
      <property name="_preparedNode" scope="prototype" type="Object"/>
      <property name="_explicitDDWidth" scope="prototype" type="Object"/>
      <property name="_explicitDDHeight" scope="prototype" type="Object"/>
      <property name="_opened" scope="prototype" type="bool"/>
      <property name="state" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_onDropDownMouse" scope="prototype">
        <summary>Callback when the user mouse clicks on the arrow icon, or presses the down
	arrow key, to open the drop down.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownMouseup" scope="prototype">
        <summary>Callback when the user lifts their mouse after mouse down on the arrow icon.
	If the drop is a simple menu and the mouse is over the menu, we execute it, otherwise, we focus our
	dropDown node.  If the event is missing, then we are not
	a mouseup event.
	This is useful for the common mouse movement pattern
	with native browser &amp;lt;select&amp;gt; nodes:
	1. mouse down on the select node (probably on the arrow)
	2. move mouse to a menu item while holding down the mouse button
	3. mouse up.  this selects the menu item as though the user had clicked it.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
      <method name="_setupDropdown" scope="prototype">
        <summary>set up nodes and connect our mouse and keypress events</summary>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="destroyDescendants" scope="prototype"/>
      <method name="_onDropDownKeydown" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onDropDownBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="prototype">
        <summary>Callback when the user presses a key on menu popup node</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>Called magically when focus has shifted away from this widget and it's dropdown</summary>
      </method>
      <method name="isLoaded" scope="prototype">
        <summary>Returns whether or not the dropdown is loaded.  This can
	be overridden in order to force a call to loadDropDown().</summary>
      </method>
      <method name="loadDropDown" scope="prototype">
        <summary>Loads the data for the dropdown, and at some point, calls
	the given callback</summary>
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="toggleDropDown" scope="prototype">
        <summary>Toggle the drop-down widget; if it is up, close it, if not, open it</summary>
      </method>
      <method name="openDropDown" scope="prototype">
        <summary>Opens the dropdown for this widget - it returns the
	return value of dijit.popup.open</summary>
      </method>
      <method name="closeDropDown" scope="prototype">
        <summary>Closes the drop down on this widget</summary>
        <parameters>
          <parameter name="focus" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._HasDropDown.dropDownPosition" type="String[]">
    <summary>This variable controls the position of the drop down.
	It's an array of strings with the following values:
	* before: places drop down to the left of the target node/widget, or to the right in
	the case of RTL scripts like Hebrew and Arabic
	* after: places drop down to the right of the target node/widget, or to the left in
	the case of RTL scripts like Hebrew and Arabic
	* above: drop down goes above target node
	* below: drop down goes below target node
	The list is positions is tried, in order, until a position is found where the drop down fits
	within the viewport.</summary>
    <properties>
      <property name="0" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit._HasDropDown.dropDown" type="Widget">
    <summary>The widget to display as a popup.  This widget *must* be
	defined before the startup function is called.</summary>
    <properties>
      <property name="domNode" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._KeyNavContainer" type="Function" classlike="true" superclass="dijit._Container">
    <summary>A _Container with keyboard navigation of its children.</summary>
    <description>To use this mixin, call connectKeyNavHandlers() in
	postCreate() and call startupKeyNavChildren() in startup().
	It provides normalized keyboard and focusing code for Container
	widgets.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="focusedChild" scope="prototype" type="Widget">
        <summary>The currently focused child widget, or null if there isn't one</summary>
      </property>
      <property name="tabIndex" scope="prototype" type="Integer">
        <summary>Tab index of the container; same as HTML tabIndex attribute.
	Note then when user tabs into the container, focus is immediately
	moved to the first item in the container.</summary>
      </property>
      <property name="_keyNavCodes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="connectKeyNavHandlers" scope="prototype">
        <summary>Call in postCreate() to attach the keyboard handlers
	to the container.
	preKeyCodes: dojo.keys[]
	Key codes for navigating to the previous child.</summary>
        <parameters>
          <parameter name="prevKeyCodes" type="dojo.keys[]" usage="required"/>
          <parameter name="nextKeyCodes" type="dojo.keys[]" usage="required">
            <summary>Key codes for navigating to the next child.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="startupKeyNavChildren" scope="prototype">
        <summary>Call in startup() to set child tabindexes to -1</summary>
      </method>
      <method name="addChild" scope="prototype">
        <summary>Add a child to our _Container</summary>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <summary>Default focus() implementation: focus the first child.</summary>
      </method>
      <method name="focusFirstChild" scope="prototype">
        <summary>Focus the first focusable child in the container.</summary>
      </method>
      <method name="focusNext" scope="prototype">
        <summary>Focus the next widget</summary>
      </method>
      <method name="focusPrev" scope="prototype">
        <summary>Focus the last focusable node in the previous widget
	(ex: go to the ComboButton icon section rather than button section)</summary>
      </method>
      <method name="focusChild" scope="prototype">
        <summary>Focus widget.</summary>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required">
            <summary>Reference to container's child widget</summary>
          </parameter>
          <parameter name="last" type="Boolean" usage="required">
            <summary>If true and if widget has multiple focusable nodes, focus the
	last one instead of the first one</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_startupChild" scope="prototype">
        <summary>Setup for each child widget</summary>
        <description>Sets tabIndex=-1 on each child, so that the tab key will
	leave the container rather than visiting each child.</description>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerFocus" scope="prototype">
        <summary>Handler for when the container gets focus</summary>
        <description>Initially the container itself has a tabIndex, but when it gets
	focus, switch focus to first child...</description>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onContainerKeypress" scope="prototype">
        <summary>When a key is pressed, if it's an arrow key etc. then
	it's handled here.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onChildBlur" scope="prototype">
        <summary>Called when focus leaves a child widget to go
	to a sibling widget.</summary>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getFirstFocusableChild" scope="prototype">
        <summary>Returns first child that can be focused</summary>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="_getNextFocusableChild" scope="prototype">
        <summary>Returns the next or previous focusable child, compared
	to &amp;quot;child&amp;quot;</summary>
        <parameters>
          <parameter name="child" type="Widget" usage="required">
            <summary>The current widget</summary>
          </parameter>
          <parameter name="dir" type="Integer" usage="required">
            <summary>* 1 = after
	* -1 = before</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit._Widget" type="Function" classlike="true">
    <summary>Base class for all Dijit widgets.</summary>
    <properties>
      <property name="dojoAttachEvent" scope="prototype" type="String"/>
      <property name="dojoAttachPoint" scope="prototype" type="String"/>
      <property name="waiRole" scope="prototype" type="String"/>
      <property name="waiState" scope="prototype" type="String"/>
      <property name="id" scope="prototype" type="String">
        <summary>A unique, opaque ID string that can be assigned by users or by the
	system. If the developer passes an ID which is known not to be
	unique, the specified ID is ignored and the system-generated ID is
	used instead.</summary>
      </property>
      <property name="lang" scope="prototype" type="String">
        <summary>Rarely used.  Overrides the default Dojo locale used to render this widget,
	as defined by the [HTML LANG](http://www.w3.org/TR/html401/struct/dirlang.html#adef-lang) attribute.
	Value must be among the list of locales specified during by the Dojo bootstrap,
	formatted according to [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt) (like en-us).</summary>
      </property>
      <property name="dir" scope="prototype" type="String">
        <summary>Unsupported by Dijit, but here for completeness.  Dijit only supports setting text direction on the
	entire document.
	Bi-directional support, as defined by the [HTML DIR](http://www.w3.org/TR/html401/struct/dirlang.html#adef-dir)
	attribute. Either left-to-right &amp;quot;ltr&amp;quot; or right-to-left &amp;quot;rtl&amp;quot;.</summary>
      </property>
      <property name="class" scope="prototype" type="String">
        <summary>HTML class attribute</summary>
      </property>
      <property name="style" scope="prototype" type="String||Object">
        <summary>HTML style attributes as cssText string or name/value hash</summary>
      </property>
      <property name="title" scope="prototype" type="String">
        <summary>The label to display for a given widget.  This is interchangeable
	with the 'label' parameter, as some widgets already have a use
	for the 'label', and this can be used instead to avoid conflicts.</summary>
      </property>
      <property name="tooltip" scope="prototype" type="String">
        <summary>When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
	this specifies the tooltip to appear when the mouse is hovered over that text.</summary>
      </property>
      <property name="srcNodeRef" scope="prototype" type="DomNode">
        <summary>pointer to original DOM node</summary>
      </property>
      <property name="domNode" scope="prototype" type="DomNode">
        <summary>This is our visible representation of the widget! Other DOM
	Nodes may by assigned to other properties, usually through the
	template system's dojoAttachPoint syntax, but the domNode
	property is the canonical &amp;quot;top level&amp;quot; node in widget UI.</summary>
      </property>
      <property name="containerNode" scope="prototype" type="DomNode">
        <summary>Designates where children of the source DOM node will be placed.
	&amp;quot;Children&amp;quot; in this case refers to both DOM nodes and widgets.
	For example, for myWidget:
		&amp;lt;div dojoType=myWidget&amp;gt;
			&amp;lt;b&amp;gt; here's a plain DOM node
			&amp;lt;span dojoType=subWidget&amp;gt;and a widget&amp;lt;/span&amp;gt;
			&amp;lt;i&amp;gt; and another plain DOM node &amp;lt;/i&amp;gt;
		&amp;lt;/div&amp;gt;
	containerNode would point to:
			&amp;lt;b&amp;gt; here's a plain DOM node
			&amp;lt;span dojoType=subWidget&amp;gt;and a widget&amp;lt;/span&amp;gt;
			&amp;lt;i&amp;gt; and another plain DOM node &amp;lt;/i&amp;gt;
	In templated widgets, &amp;quot;containerNode&amp;quot; is set via a
	dojoAttachPoint assignment.
	containerNode must be defined for any widget that accepts innerHTML
	(like ContentPane or BorderContainer or even Button), and conversely
	is null for widgets that don't, like TextBox.</summary>
      </property>
      <property name="_started" scope="prototype" type="Boolean">
        <summary>startup() has completed.</summary>
      </property>
      <property name="_blankGif" scope="prototype" type="String">
        <summary>Path to a blank 1x1 image.
	Used by &amp;lt;img&amp;gt; nodes in templates that really get their image via CSS background-image.</summary>
      </property>
      <property name="_connects" scope="prototype" type="Array"/>
      <property name="_subscribes" scope="prototype" type="Array"/>
      <property name="params" scope="prototype" type=""/>
      <property name="_created" scope="prototype" type="Object"/>
      <property name="_beingDestroyed" scope="prototype" type="Object"/>
      <property name="_destroyed" scope="prototype" type="Object"/>
      <property name="_attrPairNames" scope="prototype" type="Object"/>
      <property name="nodesWithKeyClick" scope="prototype" type="String[]">
        <summary>List of nodes that correctly handle click events via native browser support,
	and don't need dijit's help</summary>
      </property>
      <property name="region" scope="prototype" type="String">
        <summary>Parameter for children of &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt;.
	Values: &amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;leading&amp;quot;, &amp;quot;trailing&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;center&amp;quot;.
	See the &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt; description for details.</summary>
      </property>
      <property name="splitter" scope="prototype" type="Boolean">
        <summary>Parameter for child of &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt; where region != &amp;quot;center&amp;quot;.
	If true, enables user to resize the widget by putting a draggable splitter between
	this widget and the region=center widget.</summary>
      </property>
      <property name="minSize" scope="prototype" type="Number">
        <summary>Parameter for children of &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt;.
	Specifies a minimum size (in pixels) for this widget when resized by a splitter.</summary>
      </property>
      <property name="maxSize" scope="normal" type="Number">
        <summary>Parameter for children of &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt;.
	Specifies a maximum size (in pixels) for this widget when resized by a splitter.</summary>
      </property>
      <property name="layoutAlign" scope="prototype" type="String">
        <summary>&amp;quot;none&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;top&amp;quot;, and &amp;quot;client&amp;quot;.
	See the LayoutContainer description for details on this parameter.</summary>
      </property>
      <property name="sizeMin" scope="prototype" type="Integer">
        <summary>Deprecated.  Parameter for children of &lt;code&gt;dijit.layout.SplitContainer&lt;/code&gt;.
	Minimum size (width or height) of a child of a SplitContainer.
	The value is relative to other children's sizeShare properties.</summary>
      </property>
      <property name="sizeShare" scope="prototype" type="Integer">
        <summary>Deprecated.  Parameter for children of &lt;code&gt;dijit.layout.SplitContainer&lt;/code&gt;.
	Size (width or height) of a child of a SplitContainer.
	The value is relative to other children's sizeShare properties.
	For example, if there are two children and each has sizeShare=10, then
	each takes up 50% of the available space.</summary>
      </property>
      <property name="selected" scope="prototype" type="Boolean">
        <summary>Parameter for children of &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt; or subclasses.
	Specifies that this widget should be the initially displayed pane.
	Note: to change the selected child use &lt;code&gt;dijit.layout.StackContainer.selectChild&lt;/code&gt;</summary>
      </property>
      <property name="closable" scope="prototype" type="Boolean">
        <summary>Parameter for children of &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt; or subclasses.
	True if user can close (destroy) this child, such as (for example) clicking the X on the tab.</summary>
      </property>
      <property name="iconClass" scope="prototype" type="String">
        <summary>Parameter for children of &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt; or subclasses.
	CSS Class specifying icon to use in label associated with this pane.</summary>
      </property>
      <property name="showTitle" scope="prototype" type="Boolean">
        <summary>Parameter for children of &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt; or subclasses.
	When true, display title of this widget as tab label etc., rather than just using
	icon specified in iconClass</summary>
      </property>
      <property name="observer" scope="prototype" type="String"/>
      <property name="dragRestriction" scope="prototype" type="Boolean">
        <summary>To remove the drag capability.</summary>
      </property>
      <property name="column" scope="prototype" type="String">
        <summary>Column of the grid to place the widget.</summary>
      </property>
      <property name="group" scope="prototype" type="String">
        <summary>Defines a group belonging.</summary>
      </property>
      <property name="slideFrom" scope="prototype" type="String">
        <summary>A parameter needed by RadioGroupSlide only. An optional paramter to force
	the ContentPane to slide in from a set direction. Defaults
	to &amp;quot;random&amp;quot;, or specify one of &amp;quot;top&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;bottom&amp;quot;
	to slideFrom top, left, right, or bottom.</summary>
      </property>
      <property name="label" scope="prototype" type="String">
        <summary>The label to display for a given widget</summary>
      </property>
      <property name="spanLabel" scope="prototype" type="Boolean">
        <summary>Setting spanLabel to true makes the widget take up both the
	label and value cells. Defaults to false.</summary>
      </property>
      <property name="colspan" scope="prototype" type="Number">
        <summary>The number of columns this widget should span.</summary>
      </property>
      <property name="toggleSplitterOpen" scope="prototype" type="Boolean"/>
      <property name="toggleSplitterClosedThreshold" scope="prototype" type="String">
        <summary>a css size value (e.g. &amp;quot;100px&amp;quot;)</summary>
      </property>
      <property name="toggleSplitterOpenSize" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="params" type="Object" usage="optional"/>
          <parameter name="srcNodeRef" type="DomNode|String" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Connect to this function to receive notifications of mouse click events.</summary>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDblClick" scope="prototype">
        <summary>Connect to this function to receive notifications of mouse double click events.</summary>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <summary>Connect to this function to receive notifications of keys being pressed down.</summary>
        <parameters>
          <parameter name="event" type="key" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyPress" scope="prototype">
        <summary>Connect to this function to receive notifications of printable keys being typed.</summary>
        <parameters>
          <parameter name="event" type="key" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="prototype">
        <summary>Connect to this function to receive notifications of keys being released.</summary>
        <parameters>
          <parameter name="event" type="key" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>Connect to this function to receive notifications of when the mouse button is pressed down.</summary>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <summary>Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.</summary>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <summary>Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.</summary>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOver" scope="prototype">
        <summary>Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.</summary>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseLeave" scope="prototype">
        <summary>Connect to this function to receive notifications of when the mouse moves off of this widget.</summary>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseEnter" scope="prototype">
        <summary>Connect to this function to receive notifications of when the mouse moves onto this widget.</summary>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>Connect to this function to receive notifications of when the mouse button is released.</summary>
        <parameters>
          <parameter name="event" type="mouse" usage="required">
            <summary>Event</summary>
          </parameter>
        </parameters>
      </method>
      <method constructor="postscript" name="postscript" scope="prototype">
        <summary>Kicks off widget instantiation.  See create() for details.</summary>
        <parameters>
          <parameter name="params" type="Object" usage="optional"/>
          <parameter name="srcNodeRef" type="DomNode|String" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="prototype">
        <summary>Kick off the life-cycle of a widget</summary>
        <description>Create calls a number of widget methods (postMixInProperties, buildRendering, postCreate,
	etc.), some of which of you'll want to override. See http://docs.dojocampus.org/dijit/_Widget
	for a discussion of the widget creation lifecycle.
	Of course, adventurous developers could override create entirely, but this should
	only be done as a last resort.</description>
        <parameters>
          <parameter name="params" type="Object" usage="optional">
            <summary>Hash of initialization parameters for widget, including
	scalar values (like title, duration etc.) and functions,
	typically callbacks like onClick.</summary>
          </parameter>
          <parameter name="srcNodeRef" type="DomNode|String" usage="optional">
            <summary>If a srcNodeRef (DOM node) is specified:
	- use srcNodeRef.innerHTML as my contents
	- if this is a behavioral widget then apply behavior
	to that srcNodeRef
	- otherwise, replace srcNodeRef with my generated DOM
	tree</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_applyAttributes" scope="prototype">
        <summary>Step during widget creation to copy all widget attributes to the
	DOM as per attributeMap and _setXXXAttr functions.</summary>
        <description>Skips over blank/false attribute values, unless they were explicitly specified
	as parameters to the widget, since those are the default anyway,
	and setting tabIndex="" is different than not setting tabIndex at all.
	It processes the attributes in the attribute map first, and then
	it goes through and processes the attributes for the _setXXXAttr
	functions that have been specified</description>
      </method>
      <method name="postMixInProperties" scope="prototype">
        <summary>Called after the parameters to the widget have been read-in,
	but before the widget template is instantiated. Especially
	useful to set properties that are referenced in the widget
	template.</summary>
      </method>
      <method name="buildRendering" scope="prototype">
        <summary>Construct the UI for this widget, setting this.domNode</summary>
        <description>Most widgets will mixin `dijit._Templated`, which implements this
	method.</description>
      </method>
      <method name="postCreate" scope="prototype">
        <summary>Processing after the DOM fragment is created</summary>
        <description>Called after the DOM fragment has been created, but not necessarily
	added to the document.  Do not include any operations which rely on
	node dimensions or placement.</description>
      </method>
      <method name="startup" scope="prototype">
        <summary>Processing after the DOM fragment is added to the document</summary>
        <description>Called after a widget and its children have been created and added to the page,
	and all related widgets have finished their create() cycle, up through postCreate().
	This is useful for composite widgets that need to control or layout sub-widgets.
	Many layout widgets can use this as a wiring phase.</description>
      </method>
      <method name="destroyRecursive" scope="prototype">
        <summary>Destroy this widget and its descendants</summary>
        <description>This is the generic "destructor" function that all widget users
	should call to cleanly discard with a widget. Once a widget is
	destroyed, it is removed from the manager object.</description>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <summary>If true, this method will leave the original DOM structure
	alone of descendant Widgets. Note: This will NOT work with
	dijit._Templated widgets.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroy this widget, but not its descendants.
	This method will, however, destroy internal widgets such as those used within a template.</summary>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required">
            <summary>If true, this method will leave the original DOM structure alone.
	Note: This will not yet work with _Templated widgets</summary>
          </parameter>
        </parameters>
      </method>
      <method name="destroyRendering" scope="prototype">
        <summary>Destroys the DOM nodes associated with this widget</summary>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <summary>If true, this method will leave the original DOM structure alone
	during tear-down. Note: this will not work with _Templated
	widgets yet.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="prototype">
        <summary>Recursively destroy the children of this widget and their
	descendants.</summary>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="optional">
            <summary>If true, the preserveDom attribute is passed to all descendant
	widget's .destroy() method. Not for use with _Templated
	widgets.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="uninitialize" scope="prototype">
        <summary>Stub function. Override to implement custom widget tear-down
	behavior.</summary>
      </method>
      <method name="onFocus" scope="prototype">
        <summary>Called when the widget becomes &amp;quot;active&amp;quot; because
	it or a widget inside of it either has focus, or has recently
	been clicked.</summary>
      </method>
      <method name="onBlur" scope="prototype">
        <summary>Called when the widget stops being &amp;quot;active&amp;quot; because
	focus moved to something outside of it, or the user
	clicked somewhere outside of it, or the widget was
	hidden.</summary>
      </method>
      <method name="_onFocus" scope="prototype">
        <summary>This is where widgets do processing for when they are active,
	such as changing CSS classes.  See onFocus() for more details.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>This is where widgets do processing for when they stop being active,
	such as changing CSS classes.  See onBlur() for more details.</summary>
      </method>
      <method name="_onConnect" scope="prototype">
        <summary>Called when someone connects to one of my handlers.
	&amp;quot;Turn on&amp;quot; that handler if it isn't active yet.
	This is also called for every single initialization parameter
	so need to do nothing for parameters like &amp;quot;id&amp;quot;.</summary>
        <parameters>
          <parameter name="event" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setClassAttr" scope="prototype">
        <summary>Custom setter for the CSS &amp;quot;class&amp;quot; attribute</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setStyleAttr" scope="prototype">
        <summary>Sets the style attribut of the widget according to value,
	which is either a hash like {height: &amp;quot;5px&amp;quot;, width: &amp;quot;3px&amp;quot;}
	or a plain string</summary>
        <description>Determines which node to set the style on based on style setting
	in attributeMap.</description>
        <parameters>
          <parameter name="value" type="String||Object" usage="required"/>
        </parameters>
      </method>
      <method name="setAttribute" scope="prototype">
        <summary>Deprecated.  Use attr() instead.</summary>
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_attrToDom" scope="prototype">
        <summary>Reflect a widget attribute (title, tabIndex, duration etc.) to
	the widget DOM, as specified in attributeMap.</summary>
        <description>Also sets this["attr"] to the new value.
	Note some attributes like "type"
	cannot be processed this way as they are not mutable.</description>
        <parameters>
          <parameter name="attr" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="prototype">
        <summary>Set or get properties on a widget instance.</summary>
        <description>Get or set named properties on a widget. If no value is
	provided, the current value of the attribute is returned,
	potentially via a getter method. If a value is provided, then
	the method acts as a setter, assigning the value to the name,
	potentially calling any explicitly provided setters to handle
	the operation. For instance, if the widget has properties "foo"
	and "bar" and a method named "_setFooAttr", calling:
		myWidget.attr("foo", "Howdy!");
	would be equivalent to calling:
		widget._setFooAttr("Howdy!");
	while calling:
		myWidget.attr("bar", "Howdy!");
	would be the same as writing:
		widget.bar = "Howdy!";
	It also tries to copy the changes to the widget's DOM according
	to settings in attributeMap (see description of `dijit._Widget.attributeMap`
	for details)
	For example, calling:
		myTitlePane.attr("title", "Howdy!");
	will do
		myTitlePane.title = "Howdy!";
		myTitlePane.title.innerHTML = "Howdy!";
	It works for DOM node attributes too.  Calling
		widget.attr("disabled", true)
	will set the disabled attribute on the widget's focusNode,
	among other housekeeping for a change in disabled state.</description>
        <parameters>
          <parameter name="name" type="String|Object" usage="required">
            <summary>The property to get or set. If an object is passed here and not
	a string, its keys are used as names of attributes to be set
	and the value of the object as values to set in the widget.</summary>
          </parameter>
          <parameter name="value" type="Object" usage="optional">
            <summary>Optional. If provided, attr() operates as a setter. If omitted,
	the current value of the named property is returned.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getAttrNames" scope="prototype">
        <summary>Helper function for Widget.attr().
	Caches attribute name values so we don't do the string ops every time.</summary>
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <summary>Returns a string that represents the widget</summary>
        <description>When a widget is cast to a string, this method will be used to generate the
	output. Currently, it does not implement any sort of reversible
	serialization.</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getDescendants" scope="prototype">
        <summary>Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
	This method should generally be avoided as it returns widgets declared in templates, which are
	supposed to be internal/hidden, but it's left here for back-compat reasons.</summary>
        <return-types>
          <return-type type="dijit._Widget[]"/>
        </return-types>
      </method>
      <method name="getChildren" scope="prototype">
        <summary>Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
	Does not return nested widgets, nor widgets that are part of this widget's template.</summary>
        <return-types>
          <return-type type="dijit._Widget[]"/>
        </return-types>
      </method>
      <method name="connect" scope="prototype">
        <summary>Connects specified obj/event to specified method of this object
	and registers for disconnect() on widget destroy.</summary>
        <description>Provide widget-specific analog to dojo.connect, except with the
	implicit use of this widget as the target object.
	This version of connect also provides a special "ondijitclick"
	event which triggers on a click or space or enter keyup</description>
        <return-description>A handle that can be passed to `disconnect` in order to disconnect before
	the widget is destroyed.</return-description>
        <examples>
          <example>	var btn = new dijit.form.Button();
		// when foo.bar() is called, call the listener we're going to
		// provide in the scope of btn
		btn.connect(foo, "bar", function(){
			console.debug(this.toString());
		});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required"/>
          <parameter name="event" type="String|Function" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="_Widget.Handle"/>
        </return-types>
      </method>
      <method name="disconnect" scope="prototype">
        <summary>Disconnects handle created by &lt;code&gt;connect&lt;/code&gt;.
	Also removes handle from this widget's list of connects.</summary>
        <parameters>
          <parameter name="handles" type="_Widget.Handle" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="prototype">
        <summary>Subscribes to the specified topic and calls the specified method
	of this object and registers for unsubscribe() on widget destroy.</summary>
        <description>Provide widget-specific analog to dojo.subscribe, except with the
	implicit use of this widget as the target object.</description>
        <examples>
          <example>	var btn = new dijit.form.Button();
		// when /my/topic is published, this button changes its label to
		 // be the parameter of the topic.
		btn.subscribe("/my/topic", function(v){
			this.attr("label", v);
		});</example>
        </examples>
        <parameters>
          <parameter name="topic" type="String" usage="required"/>
          <parameter name="method" type="String|Function" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="prototype">
        <summary>Unsubscribes handle created by this.subscribe.
	Also removes handle from this widget's list of subscriptions</summary>
        <parameters>
          <parameter name="handle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="isLeftToRight" scope="prototype">
        <summary>Checks the page for text direction</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isFocusable" scope="prototype">
        <summary>Return true if this widget can currently be focused
	and false if not</summary>
      </method>
      <method name="placeAt" scope="prototype">
        <summary>Place this widget's domNode reference somewhere in the DOM based
	on standard dojo.place conventions, or passing a Widget reference that
	contains and addChild member.</summary>
        <description>A convenience function provided in all _Widgets, providing a simple
	shorthand mechanism to put an existing (or newly created) Widget
	somewhere in the dom, and allow chaining.</description>
        <return-description>dijit._Widget
	Provides a useful return of the newly created dijit._Widget instance so you
	can "chain" this function by instantiating, placing, then saving the return value
	to a variable.</return-description>
        <examples>
          <example> 	// create a Button with no srcNodeRef, and place it in the body:
	 	var button = new dijit.form.Button({ label:"click" }).placeAt(dojo.body());
	 	// now, 'button' is still the widget reference to the newly created button
	 	dojo.connect(button, "onClick", function(e){ console.log('click'); });</example>
          <example>	// create a button out of a node with id="src" and append it to id="wrapper":
	 	var button = new dijit.form.Button({},"src").placeAt("wrapper");</example>
          <example>	// place a new button as the first element of some div
		var button = new dijit.form.Button({ label:"click" }).placeAt("wrapper","first");</example>
          <example>	// create a contentpane and add it to a TabContainer
		var tc = dijit.byId("myTabs");
		new dijit.layout.ContentPane({ href:"foo.html", title:"Wow!" }).placeAt(tc)</example>
        </examples>
        <parameters>
          <parameter name="reference" type="String|DomNode|_Widget" usage="required">
            <summary>The String id of a domNode, a domNode reference, or a reference to a Widget posessing
	an addChild method.</summary>
          </parameter>
          <parameter name="position" type="String|Int" usage="optional">
            <summary>If passed a string or domNode reference, the position argument
	accepts a string just as dojo.place does, one of: &amp;quot;first&amp;quot;, &amp;quot;last&amp;quot;,
	&amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;.
	If passed a _Widget reference, and that widget reference has an &amp;quot;.addChild&amp;quot; method,
	it will be called passing this widget instance into that method, supplying the optional
	position index passed.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onShow" scope="prototype">
        <summary>Internal method called when this widget is made visible.
	See &lt;code&gt;onShow&lt;/code&gt; for details.</summary>
      </method>
      <method name="onShow" scope="prototype">
        <summary>Called when this widget becomes the selected pane in a
	&lt;code&gt;dijit.layout.TabContainer&lt;/code&gt;, &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt;,
	&lt;code&gt;dijit.layout.AccordionContainer&lt;/code&gt;, etc.
	Also called to indicate display of a &lt;code&gt;dijit.Dialog&lt;/code&gt;, &lt;code&gt;dijit.TooltipDialog&lt;/code&gt;, or &lt;code&gt;dijit.TitlePane&lt;/code&gt;.</summary>
      </method>
      <method name="onHide" scope="prototype">
        <summary>Called when another widget becomes the selected pane in a
	&lt;code&gt;dijit.layout.TabContainer&lt;/code&gt;, &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt;,
	&lt;code&gt;dijit.layout.AccordionContainer&lt;/code&gt;, etc.
	Also called to indicate hide of a &lt;code&gt;dijit.Dialog&lt;/code&gt;, &lt;code&gt;dijit.TooltipDialog&lt;/code&gt;, or &lt;code&gt;dijit.TitlePane&lt;/code&gt;.</summary>
      </method>
      <method name="onClose" scope="prototype">
        <summary>Parameter for children of &lt;code&gt;dijit.layout.StackContainer&lt;/code&gt; or subclasses.
	Callback if a user tries to close the child.   Child will be closed if this function returns true.</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit._Templated" type="Function" classlike="true">
    <summary>Mixin for widgets that are instantiated from a template</summary>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>A string that represents the widget template. Pre-empts the
	templatePath. In builds that have their strings &amp;quot;interned&amp;quot;, the
	templatePath is converted to an inline templateString, thereby
	preventing a synchronous network call.
	Use in conjunction with dojo.cache() to load from a file.</summary>
      </property>
      <property name="templatePath" scope="prototype" type="String">
        <summary>Path to template (HTML file) for this widget relative to dojo.baseUrl.
	Deprecated: use templateString with dojo.cache() instead.</summary>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Boolean">
        <summary>Should we parse the template to find widgets that might be
	declared in markup inside it?  False by default.</summary>
      </property>
      <property name="_skipNodeCache" scope="prototype" type="bool"/>
      <property name="_earlyTemplatedStartup" scope="prototype" type="Boolean">
        <summary>A fallback to preserve the 1.0 - 1.3 behavior of children in
	templates having their startup called before the parent widget
	fires postCreate. Defaults to 'false', causing child widgets to
	have their .startup() called immediately before a parent widget
	.startup(), but always after the parent .postCreate(). Set to
	'true' to re-enable to previous, arguably broken, behavior.</summary>
      </property>
      <property name="declaredClass" scope="prototype" type=""/>
      <property name="_attachPoints" scope="prototype" type="Array"/>
      <property name="domNode" scope="prototype" type=""/>
      <property name="_startupWidgets" scope="prototype" type="Object"/>
      <property name="_supportingWidgets" scope="prototype" type="Object"/>
      <property name="containerNode" scope="prototype" type=""/>
      <property name="_templateCache" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_stringRepl" scope="prototype">
        <summary>Does substitution of ${foo} type properties in template string</summary>
        <parameters>
          <parameter name="tmpl" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildRendering" scope="prototype">
        <summary>Construct the UI for this widget from a template, setting this.domNode.</summary>
      </method>
      <method name="_fillContent" scope="prototype">
        <summary>Relocate source contents to templated container node.
	this.containerNode must be able to receive children, or exceptions will be thrown.</summary>
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_attachTemplateNodes" scope="prototype">
        <summary>Iterate through the template and attach functions and nodes accordingly.</summary>
        <description>Map widget properties and functions to the handlers specified in
	the dom node and it's descendants. This function iterates over all
	nodes and looks for these properties:
	* dojoAttachPoint
	* dojoAttachEvent
	* waiRole
	* waiState</description>
        <parameters>
          <parameter name="rootNode" type="DomNode|Array[Widgets]" usage="required">
            <summary>the node to search for properties. All children will be searched.</summary>
          </parameter>
          <parameter name="getAttrFunc" type="Function" usage="optional">
            <summary>a function which will be used to obtain property for a given
	DomNode/Widget</summary>
          </parameter>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="destroyRendering" scope="prototype"/>
      <method name="getCachedTemplate" scope="normal">
        <summary>Static method to get a template based on the templatePath or
	templateString key</summary>
        <return-description>Mixed
	Either string (if there are ${} variables that need to be replaced) or just
	a DOM tree (if the node can be cloned directly)</return-description>
        <parameters>
          <parameter name="templatePath" type="String||dojo.uri.Uri" usage="required">
            <summary>The URL to get the template from.</summary>
          </parameter>
          <parameter name="templateString" type="String" usage="optional">
            <summary>a string to use in lieu of fetching the template from a URL. Takes precedence
	over templatePath</summary>
          </parameter>
          <parameter name="alwaysUseString" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="Node"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit._TimePicker" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A graphical time picker.
	This widget is used internally by other widgets and is not available
	as a standalone widget due to lack of accessibility support.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String">
        <summary>The root className to use for the various states of this widget</summary>
      </property>
      <property name="clickableIncrement" scope="prototype" type="String">
        <summary>ISO-8601 string representing the amount by which
	every clickable element in the time picker increases.
	Set in local time, without a time zone.
	Example: &lt;code&gt;T00:15:00&lt;/code&gt; creates 15 minute increments
	Must divide dijit._TimePicker.visibleIncrement evenly</summary>
      </property>
      <property name="visibleIncrement" scope="prototype" type="String">
        <summary>ISO-8601 string representing the amount by which
	every element with a visible time in the time picker increases.
	Set in local time, without a time zone.
	Example: &lt;code&gt;T01:00:00&lt;/code&gt; creates text in every 1 hour increment</summary>
      </property>
      <property name="visibleRange" scope="prototype" type="String">
        <summary>ISO-8601 string representing the range of this TimePicker.
	The TimePicker will only display times in this range.
	Example: &lt;code&gt;T05:00:00&lt;/code&gt; displays 5 hours of options</summary>
      </property>
      <property name="value" scope="prototype" type="String">
        <summary>Date to display.
	Defaults to current time and date.
	Can be a Date object or an ISO-8601 string.
	If you specify the GMT time zone (&lt;code&gt;-01:00&lt;/code&gt;),
	the time will be converted to the local time in the local time zone.
	Otherwise, the time is considered to be in the local time zone.
	If you specify the date and isDate is true, the date is used.
	Example: if your local time zone is &lt;code&gt;GMT -05:00&lt;/code&gt;,
	&lt;code&gt;T10:00:00&lt;/code&gt; becomes &lt;code&gt;T10:00:00-05:00&lt;/code&gt; (considered to be local time),
	&lt;code&gt;T10:00:00-01:00&lt;/code&gt; becomes &lt;code&gt;T06:00:00-05:00&lt;/code&gt; (4 hour difference),
	&lt;code&gt;T10:00:00Z&lt;/code&gt; becomes &lt;code&gt;T05:00:00-05:00&lt;/code&gt; (5 hour difference between Zulu and local time)
	&lt;code&gt;yyyy-mm-ddThh:mm:ss&lt;/code&gt; is the format to set the date and time
	Example: &lt;code&gt;2007-06-01T09:00:00&lt;/code&gt;</summary>
      </property>
      <property name="_visibleIncrement" scope="prototype" type="Number"/>
      <property name="_clickableIncrement" scope="prototype" type="Number"/>
      <property name="_totalIncrements" scope="prototype" type="Number"/>
      <property name="_filterString" scope="prototype" type="string">
        <summary>The string to filter by</summary>
      </property>
      <property name="_beenOpened" scope="prototype" type="Object"/>
      <property name="_clickableIncrementDate" scope="prototype" type="Object"/>
      <property name="_visibleIncrementDate" scope="prototype" type="Object"/>
      <property name="_visibleRangeDate" scope="prototype" type="Object"/>
      <property name="_refDate" scope="prototype" type="Object"/>
      <property name="_maxIncrement" scope="prototype" type="Number"/>
      <property name="_highlighted_option" scope="prototype" type="Object"/>
      <property name="_keyboardSelected" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="serialize" scope="prototype">
        <summary>User overridable function used to convert the attr('value') result to a String</summary>
        <parameters>
          <parameter name="val" type="Date" usage="required">
            <summary>The current value</summary>
          </parameter>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>Deprecated.  Used attr('value') instead.</summary>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', ...) works.</summary>
        <description>Set the value of the TimePicker.
	Redraws the TimePicker around the new date.</description>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="prototype">
        <summary>This is called by the popup manager when a TimeTextBox is displayed on the screen</summary>
        <parameters>
          <parameter name="best" type="Whether" usage="required">
            <summary>it is being displayed above or below the &lt;code&gt;dijit.form.TimeTextBox&lt;/code&gt;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="prototype">
        <summary>May be overridden to disable certain dates in the TimePicker e.g. &lt;code&gt;isDisabledDate=dojo.date.locale.isWeekend&lt;/code&gt;
	type:
	extension</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getFilteredNodes" scope="prototype">
        <summary>Returns an array of nodes with the filter applied.  At most maxNum nodes
	will be returned - but fewer may be returned as well.  If the
	before parameter is set to true, then it will return the elements
	before the given index</summary>
        <parameters>
          <parameter name="start" type="number" usage="required"/>
          <parameter name="maxNum" type="number" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_showText" scope="prototype">
        <summary>Displays the relevant choices in the drop down list</summary>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_buttonMouse" scope="prototype">
        <summary>Handler for mouse button presses</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_createOption" scope="prototype">
        <summary>Creates a clickable time option</summary>
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onOptionSelected" scope="prototype">
        <summary>Called when user clicks an option in the drop down list</summary>
        <parameters>
          <parameter name="tgt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="prototype">
        <summary>Notification that a time was selected.  It may be the same as the previous value.</summary>
        <description>Used by `dijit.form._DateTimeTextBox` (and thus `dijit.form.TimeTextBox`)
	to get notification when the user has clicked a time.</description>
        <parameters>
          <parameter name="time" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_highlightOption" scope="prototype">
        <summary>Turns on/off hover effect on a node based on mouse out/over event</summary>
        <parameters>
          <parameter name="node" type="node" usage="required"/>
          <parameter name="highlight" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onmouseover" scope="prototype">
        <summary>Handler for onmouseover event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onmouseout" scope="prototype">
        <summary>Handler for onmouseout event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="prototype">
        <summary>Handle the mouse wheel events</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onArrowUp" scope="prototype">
        <summary>Handler for up arrow key.</summary>
        <description>Removes the bottom time and add one to the top</description>
        <parameters>
          <parameter name="count" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="typematic end"/>
        </return-types>
      </method>
      <method name="_onArrowDown" scope="prototype">
        <summary>Handler for up arrow key.</summary>
        <description>Remove the top time and add one to the bottom</description>
        <parameters>
          <parameter name="count" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="typematic end"/>
        </return-types>
      </method>
      <method name="handleKey" scope="prototype">
        <summary>Called from &lt;code&gt;dijit.form._DateTimeTextBox&lt;/code&gt; to pass a keypress event
	from the &lt;code&gt;dijit.form.TimeTextBox&lt;/code&gt; to be handled in this widget</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="mouse hover followed by TAB is NO selection"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit._TimePicker.__Constraints" type="Function" classlike="true" superclass="dojo.date.locale.__FormatOptions" private="true">
    <mixins>
      <mixin scope="instance" location="dojo.date.locale.__FormatOptions"/>
    </mixins>
    <properties>
      <property name="clickableIncrement" scope="prototype" type="String">
        <summary>See &lt;code&gt;dijit._TimePicker.clickableIncrement&lt;/code&gt;</summary>
      </property>
      <property name="visibleIncrement" scope="prototype" type="String">
        <summary>See &lt;code&gt;dijit._TimePicker.visibleIncrement&lt;/code&gt;</summary>
      </property>
      <property name="visibleRange" scope="prototype" type="String">
        <summary>See &lt;code&gt;dijit._TimePicker.visibleRange&lt;/code&gt;</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit._TimePicker.timeMenu" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit._TimePicker.constraints" type="dijit._TimePicker.__Constraints">
    <summary>Specifies valid range of times (start time, end time)</summary>
    <properties>
      <property name="locale" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._TimePicker.timeMenu.childNodes.0" type="">
    <properties>
      <property name="index" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._Widget.attributeMap">
    <summary>attributeMap sets up a &amp;quot;binding&amp;quot; between attributes (aka properties)
	of the widget and the widget's DOM.
	Changes to widget attributes listed in attributeMap will be
	reflected into the DOM.
	For example, calling attr('title', 'hello')
	on a TitlePane will automatically cause the TitlePane's DOM to update
	with the new title.
	attributeMap is a hash where the key is an attribute of the widget,
	and the value reflects a binding to a:
	- DOM node attribute
			focus: {node: &amp;quot;focusNode&amp;quot;, type: &amp;quot;attribute&amp;quot;}
	Maps this.focus to this.focusNode.focus
	- DOM node innerHTML
			title: { node: &amp;quot;titleNode&amp;quot;, type: &amp;quot;innerHTML&amp;quot; }
	Maps this.title to this.titleNode.innerHTML
	- DOM node innerText
			title: { node: &amp;quot;titleNode&amp;quot;, type: &amp;quot;innerText&amp;quot; }
	Maps this.title to this.titleNode.innerText
	- DOM node CSS class
			myClass: { node: &amp;quot;domNode&amp;quot;, type: &amp;quot;class&amp;quot; }
	Maps this.myClass to this.domNode.className
	If the value is an array, then each element in the array matches one of the
	formats of the above list.
	There are also some shorthands for backwards compatibility:
	- string --&amp;gt; { node: string, type: &amp;quot;attribute&amp;quot; }, for example:
		&amp;quot;focusNode&amp;quot; ---&amp;gt; { node: &amp;quot;focusNode&amp;quot;, type: &amp;quot;attribute&amp;quot; }
	- &amp;quot;&amp;quot; --&amp;gt; { node: &amp;quot;domNode&amp;quot;, type: &amp;quot;attribute&amp;quot; }</summary>
    <properties>
      <property name="id" scope="normal" type="String"/>
      <property name="dir" scope="normal" type="String"/>
      <property name="lang" scope="normal" type="String"/>
      <property name="class" scope="normal" type="String"/>
      <property name="style" scope="normal" type="String"/>
      <property name="title" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dijit._Widget._deferredConnects">
    <summary>attributeMap addendum for event handlers that should be connected only on first use</summary>
    <properties>
      <property name="onClick" scope="normal" type="String"/>
      <property name="onDblClick" scope="normal" type="String"/>
      <property name="onKeyDown" scope="normal" type="String"/>
      <property name="onKeyPress" scope="normal" type="String"/>
      <property name="onKeyUp" scope="normal" type="String"/>
      <property name="onMouseMove" scope="normal" type="String"/>
      <property name="onMouseDown" scope="normal" type="String"/>
      <property name="onMouseOut" scope="normal" type="String"/>
      <property name="onMouseOver" scope="normal" type="String"/>
      <property name="onMouseLeave" scope="normal" type="String"/>
      <property name="onMouseEnter" scope="normal" type="String"/>
      <property name="onMouseUp" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dijit._base" private="true">
    <properties>
      <property name="focus" scope="normal" type="Object"/>
      <property name="manager" scope="normal" type="Object"/>
      <property name="place" scope="normal" type="Object"/>
      <property name="popup" scope="normal" type="Object"/>
      <property name="scroll" scope="normal" type="Object"/>
      <property name="sniff" scope="normal" type="Object"/>
      <property name="typematic" scope="normal" type="Object"/>
      <property name="wai" scope="normal" type="Object"/>
      <property name="window" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dijit.WidgetSet" type="Function" classlike="true">
    <summary>A set of widgets indexed by id. A default instance of this class is
	available as &lt;code&gt;dijit.registry&lt;/code&gt;</summary>
    <examples>
      <example>Create a small list of widgets:
		var ws = new dijit.WidgetSet();
		ws.add(dijit.byId("one"));
	 	ws.add(dijit.byId("two"));
		// destroy both:
		ws.forEach(function(w){ w.destroy(); });</example>
      <example>Using dijit.registry:
		dijit.registry.forEach(function(w){ /* do something */ });</example>
    </examples>
    <properties>
      <property name="_hash" scope="instance" type="Object"/>
      <property name="length" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="add" scope="prototype">
        <summary>Add a widget to this list. If a duplicate ID is detected, a error is thrown.</summary>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required">
            <summary>Any dijit._Widget subclass.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <summary>Remove a widget from this WidgetSet. Does not destroy the widget; simply
	removes the reference.</summary>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="prototype">
        <summary>Call specified function for each widget in this set.</summary>
        <return-description>Returns self, in order to allow for further chaining.</return-description>
        <examples>
          <example>Using the default `dijit.registry` instance:
		dijit.registry.forEach(function(widget){
			console.log(widget.declaredClass);
		});</example>
        </examples>
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <summary>A callback function to run for each item. Is passed the widget, the index
	in the iteration, and the full hash, similar to &lt;code&gt;dojo.forEach&lt;/code&gt;.</summary>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <summary>An optional scope parameter</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="filter" scope="prototype">
        <summary>Filter down this WidgetSet to a smaller new WidgetSet
	Works the same as &lt;code&gt;dojo.filter&lt;/code&gt; and &lt;code&gt;dojo.NodeList.filter&lt;/code&gt;</summary>
        <examples>
          <example>Arbitrary: select the odd widgets in this list
		dijit.registry.filter(function(w, i){
			return i % 2 == 0;
		}).forEach(function(w){ /* odd ones */ });</example>
        </examples>
        <parameters>
          <parameter name="filter" type="Function" usage="required">
            <summary>Callback function to test truthiness. Is passed the widget
	reference and the pseudo-index in the object.</summary>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <summary>Option scope to use for the filter function.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="byId" scope="prototype">
        <summary>Find a widget in this list by it's id.</summary>
        <examples>
          <example>Test if an id is in a particular WidgetSet
	 var ws = new dijit.WidgetSet();
	 ws.add(dijit.byId("bar"));
	 var t = ws.byId("bar") // returns a widget
	 var x = ws.byId("foo"); // returns undefined</example>
        </examples>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="byClass" scope="prototype">
        <summary>Reduce this widgetset to a new WidgetSet of a particular &lt;code&gt;declaredClass&lt;/code&gt;</summary>
        <examples>
          <example>Find all `dijit.TitlePane`s in a page:
		dijit.registry.byClass("dijit.TitlePane").forEach(function(tp){ tp.close(); });</example>
        </examples>
        <parameters>
          <parameter name="cls" type="String" usage="required">
            <summary>The Class to scan for. Full dot-notated string.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.WidgetSet"/>
        </return-types>
      </method>
      <method name="toArray" scope="prototype">
        <summary>Convert this WidgetSet into a true Array</summary>
        <examples>
          <example>Work with the widget .domNodes in a real Array
		dojo.map(dijit.registry.toArray(), function(w){ return w.domNode; });</example>
        </examples>
        <return-types>
          <return-type type="dijit._Widget[]"/>
        </return-types>
      </method>
      <method name="map" scope="prototype">
        <summary>Create a new Array from this WidgetSet, following the same rules as &lt;code&gt;dojo.map&lt;/code&gt;</summary>
        <return-description>A new array of the returned values.</return-description>
        <examples>
          <example>	var nodes = dijit.registry.map(function(w){ return w.domNode; });</example>
        </examples>
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="thisObj" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="every" scope="prototype">
        <summary>A synthetic clone of &lt;code&gt;dojo.every&lt;/code&gt; acting explictly on this WidgetSet</summary>
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <summary>A callback function run for every widget in this list. Exits loop
	when the first false return is encountered.</summary>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <summary>Optional scope parameter to use for the callback</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="prototype">
        <summary>A synthetic clone of &lt;code&gt;dojo.some&lt;/code&gt; acting explictly on this WidgetSet</summary>
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <summary>A callback function run for every widget in this list. Exits loop
	when the first true return is encountered.</summary>
          </parameter>
          <parameter name="thisObj" type="Object" usage="optional">
            <summary>Optional scope parameter to use for the callback</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit.__Position" type="Function" classlike="true" private="true">
    <properties>
      <property name="y" scope="instance" type="Integer">
        <summary>vertical coordinate in pixels, relative to document body</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="thix" type="">
    <properties>
      <property name="x" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dijit.__Rectangle" type="Function" classlike="true" private="true">
    <properties>
      <property name="x" scope="instance" type="Integer">
        <summary>horizontal offset in pixels, relative to document body</summary>
      </property>
      <property name="y" scope="instance" type="Integer">
        <summary>vertical offset in pixels, relative to document body</summary>
      </property>
      <property name="width" scope="instance" type="Integer">
        <summary>width in pixels</summary>
      </property>
      <property name="height" scope="instance" type="Integer">
        <summary>height in pixels</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.BackgroundIframe" type="Function" classlike="true">
    <summary>For IE/FF z-index schenanigans. id attribute is required.</summary>
    <description>new dijit.BackgroundIframe(node)
	Makes a background iframe as a child of node, that fills
	area (and position) of node</description>
    <properties>
      <property name="_conn" scope="instance" type="Object"/>
      <property name="iframe" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <summary>resize the iframe so its the same size as node</summary>
        <description>this function is a no-op in all browsers except
	IE6, which does not support 100% width/height
	of absolute positioned iframes</description>
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.BackgroundIframe.destroy" type="Function" classlike="true">
    <summary>destroy the iframe</summary>
    <properties>
      <property name="_conn" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.popup"/>
  <object location="dijit.popup.__OpenArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="popup" scope="instance" type="Widget">
        <summary>widget to display</summary>
      </property>
      <property name="parent" scope="instance" type="Widget">
        <summary>the button etc. that is displaying this popup</summary>
      </property>
      <property name="around" scope="instance" type="DomNode">
        <summary>DOM node (typically a button); place popup relative to this node.  (Specify this *or* &amp;quot;x&amp;quot; and &amp;quot;y&amp;quot; parameters.)</summary>
      </property>
      <property name="x" scope="instance" type="Integer">
        <summary>Absolute horizontal position (in pixels) to place node at.  (Specify this *or* &amp;quot;around&amp;quot; parameter.)</summary>
      </property>
      <property name="y" scope="instance" type="Integer">
        <summary>Absolute vertical position (in pixels) to place node at.  (Specity this *or* &amp;quot;around&amp;quot; parameter.)</summary>
      </property>
      <property name="orient" scope="instance" type="Object">
        <summary>|| String
	When the around parameter is specified, orient should be an
	ordered list of tuples of the form (around-node-corner, popup-node-corner).
	dijit.popup.open() tries to position the popup according to each tuple in the list, in order,
	until the popup appears fully within the viewport.
	The default value is {BL:'TL', TL:'BL'}, which represents a list of two tuples:
	1. (BL, TL)
	2. (TL, BL)
	where BL means &amp;quot;bottom left&amp;quot; and &amp;quot;TL&amp;quot; means &amp;quot;top left&amp;quot;.
	So by default, it first tries putting the popup below the around node, left-aligning them,
	and then tries to put it above the around node, still left-aligning them.   Note that the
	default is horizontally reversed when in RTL mode.
	When an (x,y) position is specified rather than an around node, orient is either
	&amp;quot;R&amp;quot; or &amp;quot;L&amp;quot;.  R (for right) means that it tries to put the popup to the right of the mouse,
	specifically positioning the popup's top-right corner at the mouse position, and if that doesn't
	fit in the viewport, then it tries, in order, the bottom-right corner, the top left corner,
	and the top-right corner.</summary>
      </property>
      <property name="padding" scope="instance" type="dijit.__Position">
        <summary>adding a buffer around the opening position. This is only useful when around is not set.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onCancel" scope="instance">
        <summary>callback when user has canceled the popup by
	1. hitting ESC or
	2. by using the popup widget's proprietary cancel mechanism (like a cancel button in a dialog);
	i.e. whenever popupWidget.onCancel() is called, args.onCancel is called</summary>
      </method>
      <method name="onClose" scope="instance">
        <summary>callback whenever this popup is closed</summary>
      </method>
      <method name="onExecute" scope="instance">
        <summary>callback when user &amp;quot;executed&amp;quot; on the popup/sub-popup by selecting a menu choice, etc. (top menu only)</summary>
      </method>
    </methods>
  </object>
  <object location="node" type=""/>
  <object location="dojo">
    <properties>
      <property name="isIE" scope="normal" type="Number">
        <summary>| undefined
	Version as a Number if client is MSIE(PC). undefined otherwise. Corresponds to
	major detected IE version (6, 7, 8, etc.)</summary>
      </property>
      <property name="isWebKit" scope="normal" type="Number">
        <summary>| undefined
	Version as a Number if client is a WebKit-derived browser (Konqueror,
	Safari, Chrome, etc.). undefined otherwise.</summary>
      </property>
      <property name="isOpera" scope="normal" type="Number">
        <summary>| undefined
	Version as a Number if client is Opera. undefined otherwise. Corresponds to
	major detected version.</summary>
      </property>
      <property name="isFF" scope="normal" type="Number">
        <summary>| undefined
	Version as a Number if client is FireFox. undefined otherwise. Corresponds to
	major detected FireFox version (1.5, 2, 3, etc.)</summary>
      </property>
      <property name="NodeList-fx" scope="normal" type="Object">
        <summary>Adds dojo.fx animation support to dojo.query()</summary>
      </property>
      <property name="NodeList-html" scope="normal" type="Object">
        <summary>Adds a chainable html method to dojo.query() / Nodelist instances for setting/replacing node content</summary>
      </property>
      <property name="NodeList-manipulate" scope="normal" type="Object">
        <summary>Adds a chainable methods to dojo.query() / Nodelist instances for manipulating HTML
	and DOM nodes and their properties.</summary>
      </property>
      <property name="NodeList-traverse" scope="normal" type="Object">
        <summary>Adds a chainable methods to dojo.query() / Nodelist instances for traversing the DOM</summary>
      </property>
      <property name="_NodeListCtor" scope="normal" type=""/>
      <property name="_scopeName" scope="normal" type="String"/>
      <property name="_scopePrefix" scope="normal" type="String"/>
      <property name="_scopePrefixArgs" scope="normal" type="String"/>
      <property name="_scopeSuffix" scope="normal" type="String"/>
      <property name="_scopeMap" scope="normal" type="Object"/>
      <property name="_scopeMapRev" scope="normal" type="Object"/>
      <property name="_scopeArgs" scope="normal" type="Array"/>
      <property name="locale" scope="normal" type="Object">
        <summary>the locale as defined by Dojo (read-only)</summary>
      </property>
      <property name="isBrowser" scope="normal" type="Boolean">
        <summary>True if the client is a web-browser</summary>
      </property>
      <property name="isSafari" scope="normal" type="Number">
        <summary>| undefined
	Version as a Number if client is Safari or iPhone. undefined otherwise.</summary>
      </property>
      <property name="isKhtml" scope="normal" type="Number">
        <summary>| undefined
	Version as a Number if client is a KHTML browser. undefined otherwise. Corresponds to major
	detected version.</summary>
      </property>
      <property name="isMozilla" scope="normal" type="Number">
        <summary>| undefined
	Version as a Number if client is a Mozilla-based browser (Firefox,
	SeaMonkey). undefined otherwise. Corresponds to major detected version.</summary>
      </property>
      <property name="isChrome" scope="normal" type="Number">
        <summary>| undefined
	Version as a Number if client is Chrome browser. undefined otherwise.
	isMac: Boolean
	True if the client runs on Mac</summary>
      </property>
      <property name="_name" scope="normal" type="String"/>
      <property name="baseUrl" scope="normal" type="String">
        <summary>The root relative path to dojo.js (as a string)</summary>
      </property>
      <property name="isAIR" scope="normal" type="Number"/>
      <property name="isMac" scope="normal" type="bool"/>
      <property name="isMoz" scope="normal" type=""/>
      <property name="isQuirks" scope="normal" type="bool"/>
      <property name="_XMLHTTP_PROGIDS" scope="normal" type="Array"/>
      <property name="_windowUnloaders" scope="normal" type="Array"/>
      <property name="_initFired" scope="normal" type="bool"/>
      <property name="_defaultContext" scope="normal" type="Array"/>
      <property name="isRhino" scope="normal" type="Object"/>
      <property name="_timeouts" scope="normal" type="Array"/>
      <property name="isSpidermonkey" scope="normal" type="Object">
        <summary>Detect spidermonkey</summary>
      </property>
      <property name="_loadedModules" scope="normal" type="Object"/>
      <property name="_inFlightCount" scope="normal" type="Number"/>
      <property name="_hasResource" scope="normal" type="Object"/>
      <property name="_loadedUrls" scope="normal" type="Array"/>
      <property name="_postLoad" scope="normal" type="bool"/>
      <property name="_loaders" scope="normal" type="Array"/>
      <property name="_unloaders" scope="normal" type="Array"/>
      <property name="_loadNotifying" scope="normal" type="bool"/>
      <property name="_global_omit_module_check" scope="normal" type="bool"/>
      <property name="requireAfterIf" scope="normal" type=""/>
      <property name="nonDebugProvide" scope="normal" type=""/>
      <property name="_xdDebugScopeChecked" scope="normal" type="Object"/>
      <property name="_isXDomain" scope="normal" type="bool"/>
      <property name="_xdInFlight" scope="normal" type="Object"/>
      <property name="_xdOrderedReqs" scope="normal" type="Array"/>
      <property name="_xdDepMap" scope="normal" type="Object"/>
      <property name="_xdContents" scope="normal" type="Array"/>
      <property name="_xdTimer" scope="normal" type="Number"/>
      <property name="_xdCharSet" scope="normal" type="String"/>
      <property name="_xdStartTime" scope="normal" type="Object"/>
      <property name="_headElement" scope="normal" type=""/>
      <property name="_xdReqLoc" scope="normal" type=""/>
      <property name="_xdBundleMap" scope="normal" type="Object"/>
      <property name="_xdRealRequireLocalization" scope="normal" type=""/>
      <property name="_topics" scope="normal" type="Object"/>
      <property name="subscribe" scope="normal" type=""/>
      <property name="unsubscribe" scope="normal" type=""/>
      <property name="publish" scope="normal" type=""/>
      <property name="_ieListenersName" scope="normal" type="String"/>
      <property name="_Animation" scope="normal" type=""/>
      <property name="boxModel" scope="normal" type="String"/>
      <property name="toJsonIndentStr" scope="normal" type="String"/>
      <property name="_delegate" scope="normal" type="Object"/>
      <property name="_bodyLtr" scope="normal" type=""/>
      <property name="_blockAsync" scope="normal" type="bool"/>
      <property name="jaxer" scope="normal" type="Object"/>
      <property name="parser" scope="normal" type="Object"/>
      <property name="robot" scope="normal" type="Object"/>
      <property name="robotx" scope="normal" type="Object"/>
      <property name="tests" scope="normal" type="Object">
        <summary>D.O.H. Test files for Dojo unit testing.</summary>
      </property>
      <property name="_defaultXhr" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="blendColors" scope="normal">
        <summary>Blend colors end and start with weight from 0 to 1, 0.5 being a 50/50 blend,
	can reuse a previously allocated dojo.Color object for the result</summary>
        <parameters>
          <parameter name="start" type="dojo.Color" usage="required"/>
          <parameter name="end" type="dojo.Color" usage="required"/>
          <parameter name="weight" type="Number" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromRgb" scope="normal">
        <summary>get rgb(a) array from css-style color declarations</summary>
        <description>this function can handle all 4 CSS3 Color Module formats: rgb,
	rgba, hsl, hsla, including rgb(a) with percentage values.</description>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromHex" scope="normal">
        <summary>Converts a hex string with a '#' prefix to a color object.
	Supports 12-bit #rgb shorthand. Optionally accepts a
	&lt;code&gt;dojo.Color&lt;/code&gt; object to update with the parsed value.</summary>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <examples>
          <example> var thing = dojo.colorFromHex("#ededed"); // grey, longhand</example>
          <example> var thing = dojo.colorFromHex("#000"); // black, shorthand</example>
        </examples>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromArray" scope="normal">
        <summary>Builds a &lt;code&gt;dojo.Color&lt;/code&gt; from a 3 or 4 element array, mapping each
	element in sequence to the rgb(a) values of the color.</summary>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <examples>
          <example> var myColor = dojo.colorFromArray([237,237,237,0.5]); // grey, 50% alpha</example>
        </examples>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="colorFromString" scope="normal">
        <summary>Parses &lt;code&gt;str&lt;/code&gt; for a color value. Accepts hex, rgb, and rgba
	style color values.</summary>
        <description>Acceptable input values for str may include arrays of any form
	accepted by dojo.colorFromArray, hex strings such as "#aaaaaa", or
	rgb or rgba strings such as "rgb(133, 200, 16)" or "rgba(10, 10,
	10, 50)"</description>
        <return-description>A dojo.Color object. If obj is passed, it will be the return value.</return-description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="obj" type="dojo.Color" usage="optional"/>
        </parameters>
      </method>
      <method name="_mixin" scope="normal">
        <summary>Adds all properties and methods of source to target. This addition
	is &amp;quot;prototype extension safe&amp;quot;, so that instances of objects
	will not pass along prototype defaults.</summary>
        <parameters>
          <parameter name="target" type="Object" usage="required"/>
          <parameter name="source" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="mixin" scope="normal">
        <summary>Adds all properties and methods of props to obj and returns the
	(now modified) obj.</summary>
        <description>`dojo.mixin` can mix multiple source objects into a
	destination object which is then returned. Unlike regular
	`for...in` iteration, `dojo.mixin` is also smart about avoiding
	extensions which other toolkits may unwisely add to the root
	object prototype</description>
        <examples>
          <example>make a shallow copy of an object
		var copy = dojo.mixin({}, source);</example>
          <example>many class constructors often take an object which specifies
	values to be configured on the object. In this case, it is
	often simplest to call `dojo.mixin` on the `this` object:
		dojo.declare("acme.Base", null, {
			constructor: function(properties){
				// property configuration:
				dojo.mixin(this, properties);
				console.log(this.quip);
				//  ...
			},
			quip: "I wasn't born yesterday, you know - I've seen movies.",
			// ...
		});
		// create an instance of the class and configure it
		var b = new acme.Base({quip: "That's what it does!" });</example>
          <example>copy in properties from multiple objects
		var flattened = dojo.mixin(
			{
				name: "Frylock",
				braces: true
			},
			{
				name: "Carl Brutanananadilewski"
			}
		);
		// will print "Carl Brutanananadilewski"
		console.log(flattened.name);
		// will print "true"
		console.log(flattened.braces);</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <summary>The object to mix properties into. Also the return value.</summary>
          </parameter>
          <parameter name="props" type="Object" usage="one-or-more">
            <summary>One or more objects whose values are successively copied into
	obj. If more than one of these objects contain the same value,
	the one specified last in the function call will &amp;quot;win&amp;quot;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getProp" scope="normal">
        <parameters>
          <parameter name="parts" type="Array" usage="required"/>
          <parameter name="create" type="Boolean" usage="required"/>
          <parameter name="context" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="setObject" scope="normal">
        <summary>Set a property from a dot-separated string, such as &amp;quot;A.B.C&amp;quot;</summary>
        <description>Useful for longer api chains where you have to test each object in
	the chain, or when you have an object reference in string format.
	Objects are created as needed along `path`. Returns the passed
	value if setting is successful or `undefined` if not.</description>
        <examples>
          <example>set the value of `foo.bar.baz`, regardless of whether
	intermediate objects already exist:
		dojo.setObject("foo.bar.baz", value);</example>
          <example>without `dojo.setObject`, we often see code like this:
		// ensure that intermediate objects are available
		if(!obj["parent"]){ obj.parent = {}; }
		if(!obj.parent["child"]){ obj.parent.child= {}; }
		// now we can safely set the property
		obj.parent.child.prop = "some value";
	wheras with `dojo.setObject`, we can shorten that to:
		dojo.setObject("parent.child.prop", "some value", obj);</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <summary>Path to a property, in the form &amp;quot;A.B.C&amp;quot;.</summary>
          </parameter>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="context" type="Object" usage="optional">
            <summary>Optional. Object to use as root of path. Defaults to
	&lt;code&gt;dojo.global&lt;/code&gt;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getObject" scope="normal">
        <summary>Get a property from a dot-separated string, such as &amp;quot;A.B.C&amp;quot;</summary>
        <description>Useful for longer api chains where you have to test each object in
	the chain, or when you have an object reference in string format.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <summary>Path to an property, in the form &amp;quot;A.B.C&amp;quot;.</summary>
          </parameter>
          <parameter name="create" type="Boolean" usage="optional">
            <summary>Optional. Defaults to &lt;code&gt;false&lt;/code&gt;. If &lt;code&gt;true&lt;/code&gt;, Objects will be
	created at any point along the 'path' that is undefined.</summary>
          </parameter>
          <parameter name="context" type="Object" usage="optional">
            <summary>Optional. Object to use as root of path. Defaults to
	'dojo.global'. Null may be passed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="exists" scope="normal">
        <summary>determine if an object supports a given method</summary>
        <description>useful for longer api chains where you have to test each object in
	the chain. Useful only for object and method detection.
	Not useful for testing generic properties on an object.
	In particular, dojo.exists("foo.bar") when foo.bar = ""
	will return false. Use ("bar" in foo) to test for those cases.</description>
        <examples>
          <example>	// define an object
		var foo = {
			bar: { }
		};
		// search the global scope
		dojo.exists("foo.bar"); // true
		dojo.exists("foo.bar.baz"); // false
		// search from a particular scope
		dojo.exists("bar", foo); // true
		dojo.exists("bar.baz", foo); // false</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <summary>Path to an object, in the form &amp;quot;A.B.C&amp;quot;.</summary>
          </parameter>
          <parameter name="obj" type="Object" usage="optional">
            <summary>to use as root of path. Defaults to
	'dojo.global'. Null may be passed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="eval" scope="normal">
        <summary>Perform an evaluation in the global scope. Use this rather than
	calling 'eval()' directly.</summary>
        <description>Placed in a separate function to minimize size of trapped
	exceptions. Calling eval() directly from some other scope may
	complicate tracebacks on some platforms.</description>
        <return-description>The result of the evaluation. Often `undefined`</return-description>
        <parameters>
          <parameter name="scriptFragment" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="deprecated" scope="normal">
        <summary>Log a debug message to indicate that a behavior has been
	deprecated.</summary>
        <examples>
          <example>	dojo.deprecated("myApp.getTemp()", "use myApp.getLocaleTemp() instead", "1.0");</example>
        </examples>
        <parameters>
          <parameter name="behaviour" type="String" usage="required">
            <summary>The API or behavior being deprecated. Usually in the form
	of &amp;quot;myApp.someFunction()&amp;quot;.</summary>
          </parameter>
          <parameter name="extra" type="String" usage="optional">
            <summary>Text to append to the message.</summary>
          </parameter>
          <parameter name="removal" type="String" usage="optional">
            <summary>Text to indicate when in the future the behavior will be removed.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="experimental" scope="normal">
        <summary>Marks code as experimental.</summary>
        <description>This can be used to mark a function, file, or module as
	experimental.  Experimental code is not ready to be used, and the
	APIs are subject to change without notice.  Experimental code may be
	completed deleted without going through the normal deprecation
	process.</description>
        <examples>
          <example>	dojo.experimental("dojo.data.Result");</example>
          <example>	dojo.experimental("dojo.weather.toKelvin()", "PENDING approval from NOAA");</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <summary>The name of a module, or the name of a module file or a specific
	function</summary>
          </parameter>
          <parameter name="extra" type="String" usage="optional">
            <summary>some additional message for the user</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_xhrObj" scope="normal">
        <summary>does the work of portably generating a new XMLHTTPRequest object.</summary>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="XMLHTTPRequest instance"/>
        </return-types>
      </method>
      <method name="_isDocumentOk" scope="normal">
        <parameters>
          <parameter name="http" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getText" scope="normal">
        <summary>Read the contents of the specified uri and return those contents.</summary>
        <return-description>The response text. null is returned when there is a
	failure and failure is okay (an exception otherwise)</return-description>
        <parameters>
          <parameter name="uri" type="URI" usage="required">
            <summary>A relative or absolute uri.</summary>
          </parameter>
          <parameter name="fail_ok" type="Boolean" usage="required">
            <summary>Default false. If fail_ok and loading fails, return null
	instead of throwing.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="windowUnloaded" scope="normal">
        <summary>signal fired by impending window destruction. You may use
	dojo.addOnWIndowUnload() or dojo.connect() to this method to perform
	page/application cleanup methods. See dojo.addOnWindowUnload for more info.</summary>
      </method>
      <method name="addOnWindowUnload" scope="normal">
        <summary>registers a function to be triggered when window.onunload fires.
	Be careful trying to modify the DOM or access JavaScript properties
	during this phase of page unloading: they may not always be available.
	Consider dojo.addOnUnload() if you need to modify the DOM or do heavy
	JavaScript work.</summary>
        <description>The first time that addOnWindowUnload is called Dojo
	will register a page listener to trigger your unload
	handler with. Note that registering these handlers may
	destory "fastback" page caching in browsers that support
	it. Be careful trying to modify the DOM or access
	JavaScript properties during this phase of page unloading:
	they may not always be available. Consider
	dojo.addOnUnload() if you need to modify the DOM or do
	heavy JavaScript work since it fires at the eqivalent of
	the page's "onbeforeunload" event.</description>
        <examples>
          <example>	dojo.addOnWindowUnload(functionPointer)
		dojo.addOnWindowUnload(object, "functionName");
		dojo.addOnWindowUnload(object, function(){ /* ... */});</example>
          <example>	dojo.addOnWindowUnload(functionPointer)
		dojo.addOnWindowUnload(object, "functionName")
		dojo.addOnWindowUnload(object, function(){ /* ... */});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|Function" usage="optional"/>
          <parameter name="functionName" type="String|Function" usage="optional"/>
        </parameters>
      </method>
      <method name="addOnUnload" scope="normal">
        <summary>registers a function to be triggered when the page unloads.</summary>
        <description>The first time that addOnUnload is called Dojo will
	register a page listener to trigger your unload handler
	with.
	In a browser enviroment, the functions will be triggered
	during the window.onbeforeunload event. Be careful of doing
	too much work in an unload handler. onbeforeunload can be
	triggered if a link to download a file is clicked, or if
	the link is a javascript: link. In these cases, the
	onbeforeunload event fires, but the document is not
	actually destroyed. So be careful about doing destructive
	operations in a dojo.addOnUnload callback.
	Further note that calling dojo.addOnUnload will prevent
	browsers from using a "fast back" cache to make page
	loading via back button instantaneous.</description>
        <examples>
          <example>	dojo.addOnUnload(functionPointer)
		dojo.addOnUnload(object, "functionName")
		dojo.addOnUnload(object, function(){ /* ... */});</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|Function" usage="optional"/>
          <parameter name="functionName" type="String|Function" usage="optional"/>
        </parameters>
      </method>
      <method name="_loadInit" scope="normal">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_loadUri" scope="normal">
        <summary>Internal xd loader function. Overrides loadUri() from loader.js.
	xd loading requires slightly different behavior from loadPath().</summary>
        <description>Wanted to override getText(), but it is used by
	the widget code in too many, synchronous ways right now.</description>
        <parameters>
          <parameter name="uri" type="String" usage="required">
            <summary>a uri which points at the script to be loaded</summary>
          </parameter>
          <parameter name="cb" type="Function" usage="required">
            <summary>a callback function to process the result of evaluating the script
	as an expression, typically used by the resource bundle loader to
	load JSON-style resources</summary>
          </parameter>
          <parameter name="currentIsXDomain" type="boolean" usage="required"/>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
          <return-type type="Boolean: contents? true : false"/>
        </return-types>
      </method>
      <method name="pushContext" scope="normal">
        <summary>causes subsequent calls to Dojo methods to assume the
	passed object and, optionally, document as the default
	scopes to use. A 2-element array of the previous global and
	document are returned.</summary>
        <description>dojo.pushContext treats contexts as a stack. The
	auto-detected contexts which are initially provided using
	dojo.setContext() require authors to keep state in order to
	"return" to a previous context, whereas the
	dojo.pushContext and dojo.popContext methods provide a more
	natural way to augment blocks of code to ensure that they
	execute in a different window or frame without issue. If
	called without any arguments, the default context (the
	context when Dojo is first loaded) is instead pushed into
	the stack. If only a single string is passed, a node in the
	intitial context's document is looked up and its
	contextWindow and contextDocument properties are used as
	the context to push. This means that iframes can be given
	an ID and code can be executed in the scope of the iframe's
	document in subsequent calls easily.</description>
        <parameters>
          <parameter name="g" type="Object|String" usage="optional">
            <summary>The global context. If a string, the id of the frame to
	search for a context and document.</summary>
          </parameter>
          <parameter name="d" type="MDocumentElement" usage="optional">
            <summary>The document element to execute subsequent code with.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="popContext" scope="normal">
        <summary>If the context stack contains elements, ensure that
	subsequent code executes in the *previous* context to the
	current context. The current context set ([global,
	document]) is returned.</summary>
      </method>
      <method name="_inContext" scope="normal">
        <parameters>
          <parameter name="g" type="" usage="required"/>
          <parameter name="d" type="" usage="required"/>
          <parameter name="f" type="" usage="required"/>
        </parameters>
      </method>
      <method name="byId" scope="normal">
        <summary>Returns DOM node with matching &lt;code&gt;id&lt;/code&gt; attribute or &lt;code&gt;null&lt;/code&gt;
	if not found. If &lt;code&gt;id&lt;/code&gt; is a DomNode, this function is a no-op.</summary>
        <examples>
          <example>Look up a node by ID:
		var n = dojo.byId("foo");</example>
          <example>Check if a node exists, and use it.
		var n = dojo.byId("bar");
		if(n){ doStuff() ... }</example>
          <example>Allow string or DomNode references to be passed to a custom function:
		var foo = function(nodeOrId){
			nodeOrId = dojo.byId(nodeOrId);
			// ... more stuff
		}</example>
        </examples>
        <parameters>
          <parameter name="id" type="String|DOMNode" usage="required">
            <summary>A string to match an HTML id attribute or a reference to a DOM Node</summary>
          </parameter>
          <parameter name="doc" type="Document" usage="required">
            <summary>Document to work in. Defaults to the current value of
	dojo.doc.  Can be used to retrieve
	node references from other documents.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="assume it's a node"/>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="_isLocalUrl" scope="normal">
        <summary>determines if URI is local or not.</summary>
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="exit" scope="normal">
        <parameters>
          <parameter name="exitcode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="body" scope="normal">
        <summary>Return the body element of the document
	return the body object associated with dojo.doc</summary>
        <examples>
          <example>	dojo.body().appendChild(dojo.doc.createElement('div'));</example>
        </examples>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_spidermonkeyCurrentFile" scope="normal">
        <parameters>
          <parameter name="depth" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_moduleHasPrefix" scope="normal">
        <summary>checks to see if module has been established</summary>
        <parameters>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getModulePrefix" scope="normal">
        <summary>gets the prefix associated with module</summary>
        <parameters>
          <parameter name="module" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_loadPath" scope="normal">
        <summary>Internal xd loader function. Overrides loadPath() from loader.js.
	xd loading requires slightly different behavior from loadPath().</summary>
        <description>Loads and interprets the script located at relpath, which is
	relative to the script root directory.  If the script is found but
	its interpretation causes a runtime exception, that exception is
	not caught by us, so the caller will see it.  We return a true
	value if and only if the script is found.</description>
        <parameters>
          <parameter name="relpath" type="String" usage="required">
            <summary>A relative path to a script (no leading '/', and typically ending
	in '.js').</summary>
          </parameter>
          <parameter name="module" type="String" usage="optional">
            <summary>A module whose existance to check for after loading a path.  Can be
	used to determine success or failure of the load.</summary>
          </parameter>
          <parameter name="cb" type="Function" usage="optional">
            <summary>a callback function to pass the result of evaluating the script</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_loadUriAndCheck" scope="normal">
        <summary>calls loadUri then findModule and returns true if both succeed</summary>
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="cb" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loaded" scope="normal">
        <summary>signal fired when initial environment and package loading is
	complete. You should use dojo.addOnLoad() instead of doing a
	direct dojo.connect() to this method in order to handle
	initialization tasks that require the environment to be
	initialized. In a browser host,	declarative widgets will
	be constructed when this function finishes runing.</summary>
      </method>
      <method name="unloaded" scope="normal">
        <summary>signal fired by impending environment destruction. You should use
	dojo.addOnUnload() instead of doing a direct dojo.connect() to this
	method to perform page/application cleanup methods. See
	dojo.addOnUnload for more info.</summary>
      </method>
      <method name="_onto" scope="normal">
        <parameters>
          <parameter name="arr" type="" usage="required"/>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="fn" type="" usage="required"/>
        </parameters>
      </method>
      <method name="ready" scope="normal"/>
      <method name="addOnLoad" scope="normal">
        <summary>Registers a function to be triggered after the DOM and dojo.require() calls
	have finished loading.</summary>
        <description>Registers a function to be triggered after the DOM has finished
	loading and `dojo.require` modules have loaded. Widgets declared in markup
	have been instantiated if `djConfig.parseOnLoad` is true when this fires.
	Images and CSS files may or may not have finished downloading when
	the specified function is called.  (Note that widgets' CSS and HTML
	code is guaranteed to be downloaded before said widgets are
	instantiated, though including css resouces BEFORE any script elements
	is highly recommended).</description>
        <examples>
          <example>Register an anonymous function to run when everything is ready
		dojo.addOnLoad(function(){ doStuff(); });</example>
          <example>Register a function to run when everything is ready by pointer:
		var init = function(){ doStuff(); }
		dojo.addOnLoad(init);</example>
          <example>Register a function to run scoped to `object`, either by name or anonymously:
		dojo.addOnLoad(object, "functionName");
		dojo.addOnLoad(object, function(){ doStuff(); });</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="functionName" type="String|Function" usage="optional"/>
        </parameters>
      </method>
      <method name="_modulesLoaded" scope="normal"/>
      <method name="_callLoaded" scope="normal"/>
      <method name="_getModuleSymbols" scope="normal">
        <summary>Converts a module name in dotted JS notation to an array
	representing the path in the source tree</summary>
        <parameters>
          <parameter name="modulename" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="loadInit" scope="normal">
        <summary>Executes a function that needs to be executed for the loader's dojo.requireIf
	resolutions to work. This is needed mostly for the xdomain loader case where
	a function needs to be executed to set up the possible values for a dojo.requireIf
	call.</summary>
        <description>This function is mainly a marker for the xdomain loader to know parts of
	code that needs be executed outside the function wrappper that is placed around modules.
	The init function could be executed more than once, and it should make no assumptions
	on what is loaded, or what modules are available. Only the functionality in Dojo Base
	is allowed to be used. Avoid using this method. For a valid use case,
	see the source for dojox.gfx.</description>
        <parameters>
          <parameter name="init" type="Function" usage="required">
            <summary>a function reference. Executed immediately.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_loadModule" scope="normal"/>
      <method name="require" scope="normal">
        <summary>loads a Javascript module from the appropriate URI</summary>
        <description>Modules are loaded via dojo.require by using one of two loaders: the normal loader
	and the xdomain loader. The xdomain loader is used when dojo was built with a
	custom build that specified loader=xdomain and the module lives on a modulePath
	that is a whole URL, with protocol and a domain. The versions of Dojo that are on
	the Google and AOL CDNs use the xdomain loader.
	If the module is loaded via the xdomain loader, it is an asynchronous load, since
	the module is added via a dynamically created script tag. This
	means that dojo.require() can return before the module has loaded. However, this
	should only happen in the case where you do dojo.require calls in the top-level
	HTML page, or if you purposely avoid the loader checking for dojo.require
	dependencies in your module by using a syntax like dojo["require"] to load the module.
	Sometimes it is useful to not have the loader detect the dojo.require calls in the
	module so that you can dynamically load the modules as a result of an action on the
	page, instead of right at module load time.
	Also, for script blocks in an HTML page, the loader does not pre-process them, so
	it does not know to download the modules before the dojo.require calls occur.
	So, in those two cases, when you want on-the-fly module loading or for script blocks
	in the HTML page, special care must be taken if the dojo.required code is loaded
	asynchronously. To make sure you can execute code that depends on the dojo.required
	modules, be sure to add the code that depends on the modules in a dojo.addOnLoad()
	callback. dojo.addOnLoad waits for all outstanding modules to finish loading before
	executing. Example:
		&lt;script type="text/javascript"&gt;
		dojo.require("foo");
		dojo.require("bar");
		dojo.addOnLoad(function(){
			//you can now safely do something with foo and bar
		});
		&lt;/script&gt;
	This type of syntax works with both xdomain and normal loaders, so it is good
	practice to always use this idiom for on-the-fly code loading and in HTML script
	blocks. If at some point you change loaders and where the code is loaded from,
	it will all still work.
	More on how dojo.require
	`dojo.require("A.B")` first checks to see if symbol A.B is
	defined. If it is, it is simply returned (nothing to do).
	If it is not defined, it will look for `A/B.js` in the script root
	directory.
	`dojo.require` throws an excpetion if it cannot find a file
	to load, or if the symbol `A.B` is not defined after loading.
	It returns the object `A.B`, but note the caveats above about on-the-fly loading and
	HTML script blocks when the xdomain loader is loading a module.
	`dojo.require()` does nothing about importing symbols into
	the current namespace.  It is presumed that the caller will
	take care of that. For example, to import all symbols into a
	local block, you might write:
		with (dojo.require("A.B")) {
			...
		}
	And to import just the leaf symbol to a local variable:
		var B = dojo.require("A.B");
		...</description>
        <return-description>the required namespace object</return-description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <summary>module name to load, using periods for separators,
	e.g. &amp;quot;dojo.date.locale&amp;quot;.  Module paths are de-referenced by dojo's
	internal mapping of locations to names and are disambiguated by
	longest prefix. See &lt;code&gt;dojo.registerModulePath()&lt;/code&gt; for details on
	registering new modules.</summary>
          </parameter>
          <parameter name="omitModuleCheck" type="Boolean" usage="optional">
            <summary>if &lt;code&gt;true&lt;/code&gt;, omitModuleCheck skips the step of ensuring that the
	loaded file actually defines the symbol it is referenced by.
	For example if it called as &lt;code&gt;dojo.require(&amp;quot;a.b.c&amp;quot;)&lt;/code&gt; and the
	file located at &lt;code&gt;a/b/c.js&lt;/code&gt; does not define an object &lt;code&gt;a.b.c&lt;/code&gt;,
	and exception will be throws whereas no exception is raised
	when called as &lt;code&gt;dojo.require(&amp;quot;a.b.c&amp;quot;, true)&lt;/code&gt;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="provide" scope="normal">
        <summary>Register a resource with the package system. Works in conjunction with &lt;code&gt;dojo.require&lt;/code&gt;</summary>
        <description>Each javascript source file is called a resource.  When a
	resource is loaded by the browser, `dojo.provide()` registers
	that it has been loaded.
	Each javascript source file must have at least one
	`dojo.provide()` call at the top of the file, corresponding to
	the file name.  For example, `js/dojo/foo.js` must have
	`dojo.provide("dojo.foo");` before any calls to
	`dojo.require()` are made.
	For backwards compatibility reasons, in addition to registering
	the resource, `dojo.provide()` also ensures that the javascript
	object for the module exists.  For example,
	`dojo.provide("dojox.data.FlickrStore")`, in addition to
	registering that `FlickrStore.js` is a resource for the
	`dojox.data` module, will ensure that the `dojox.data`
	javascript object exists, so that calls like
	`dojo.data.foo = function(){ ... }` don't fail.
	In the case of a build where multiple javascript source files
	are combined into one bigger file (similar to a .lib or .jar
	file), that file may contain multiple dojo.provide() calls, to
	note that it includes multiple resources.</description>
        <examples>
          <example>Safely create a `my` object, and make dojo.require("my.CustomModule") work
		dojo.provide("my.CustomModule");</example>
        </examples>
        <parameters>
          <parameter name="resourceName" type="String" usage="required">
            <summary>A dot-sperated string identifying a resource.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="platformRequire" scope="normal">
        <summary>require one or more modules based on which host environment
	Dojo is currently operating in</summary>
        <description>This method takes a "map" of arrays which one can use to
	optionally load dojo modules. The map is indexed by the
	possible dojo.name_ values, with two additional values:
	"default" and "common". The items in the "default" array will
	be loaded if none of the other items have been choosen based on
	dojo.name_, set by your host environment. The items in the
	"common" array will *always* be loaded, regardless of which
	list is chosen.</description>
        <examples>
          <example>	dojo.platformRequire({
			browser: [
				"foo.sample", // simple module
				"foo.test",
				["foo.bar.baz", true] // skip object check in _loadModule (dojo.require)
			],
			default: [ "foo.sample._base" ],
			common: [ "important.module.common" ]
		});</example>
        </examples>
        <parameters>
          <parameter name="modMap" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="requireIf" scope="normal">
        <summary>If the condition is true then call &lt;code&gt;dojo.require()&lt;/code&gt; for the specified
	resource</summary>
        <examples>
          <example>	dojo.requireIf(dojo.isBrowser, "my.special.Module");</example>
        </examples>
        <parameters>
          <parameter name="condition" type="Boolean" usage="required"/>
          <parameter name="resourceName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="registerModulePath" scope="normal">
        <summary>Maps a module name to a path</summary>
        <description>An unregistered module is given the default path of ../[module],
	relative to Dojo root. For example, module acme is mapped to
	../acme.  If you want to use a different module name, use
	dojo.registerModulePath.</description>
        <examples>
          <example>If your dojo.js is located at this location in the web root:
		/myapp/js/dojo/dojo/dojo.js
	and your modules are located at:
		/myapp/js/foo/bar.js
		/myapp/js/foo/baz.js
		/myapp/js/foo/thud/xyzzy.js
	Your application can tell Dojo to locate the "foo" namespace by calling:
		dojo.registerModulePath("foo", "../../foo");
	At which point you can then use dojo.require() to load the
	modules (assuming they provide() the same things which are
	required). The full code might be:
		&lt;script type="text/javascript"
			src="/myapp/js/dojo/dojo/dojo.js"&gt;&lt;/script&gt;
		&lt;script type="text/javascript"&gt;
			dojo.registerModulePath("foo", "../../foo");
			dojo.require("foo.bar");
			dojo.require("foo.baz");
			dojo.require("foo.thud.xyzzy");
		&lt;/script&gt;</example>
        </examples>
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="prefix" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="requireLocalization" scope="normal">
        <summary>loads a bundle intelligently based on whether the module is
	local or xd. Overrides the local-case implementation.</summary>
        <description>Load translated resource bundles provided underneath the "nls"
	directory within a package.  Translated resources may be located in
	different packages throughout the source tree.
	Each directory is named for a locale as specified by RFC 3066,
	(http://www.ietf.org/rfc/rfc3066.txt), normalized in lowercase.
	Note that the two bundles in the example do not define all the
	same variants.  For a given locale, bundles will be loaded for
	that locale and all more general locales above it, including a
	fallback at the root directory.  For example, a declaration for
	the "de-at" locale will first load `nls/de-at/bundleone.js`,
	then `nls/de/bundleone.js` and finally `nls/bundleone.js`.  The
	data will be flattened into a single Object so that lookups
	will follow this cascading pattern.  An optional build step can
	preload the bundles to avoid data redundancy and the multiple
	network hits normally required to load these resources.</description>
        <examples>
          <example>A particular widget may define one or more resource bundles,
	structured in a program as follows, where moduleName is
	mycode.mywidget and bundleNames available include bundleone and
	bundletwo:
			...
		mycode/
			mywidget/
				nls/
					bundleone.js (the fallback translation, English in this example)
					bundletwo.js (also a fallback translation)
					de/
						bundleone.js
						bundletwo.js
					de-at/
						bundleone.js
					en/
						(empty; use the fallback translation)
					en-us/
						bundleone.js
					en-gb/
						bundleone.js
					es/
						bundleone.js
						bundletwo.js
					  ...etc
					...</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="String" usage="required">
            <summary>name of the package containing the &amp;quot;nls&amp;quot; directory in which the
	bundle is found</summary>
          </parameter>
          <parameter name="bundleName" type="String" usage="required">
            <summary>bundle name, i.e. the filename without the '.js' suffix. Using &amp;quot;nls&amp;quot; as a
	a bundle name is not supported, since &amp;quot;nls&amp;quot; is the name of the folder
	that holds bundles. Using &amp;quot;nls&amp;quot; as the bundle name will cause problems
	with the custom build.</summary>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <summary>the locale to load (optional)  By default, the browser's user
	locale as defined by dojo.locale</summary>
          </parameter>
          <parameter name="availableFlatLocales" type="String" usage="optional">
            <summary>A comma-separated list of the available, flattened locales for this
	bundle. This argument should only be set by the build process.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="moduleUrl" scope="normal">
        <summary>Returns a &lt;code&gt;dojo._Url&lt;/code&gt; object relative to a module.</summary>
        <examples>
          <example>	var pngPath = dojo.moduleUrl("acme","images/small.png");
		console.dir(pngPath); // list the object properties
		// create an image and set it's source to pngPath's value:
		var img = document.createElement("img");
		// NOTE: we assign the string representation of the url object
		img.src = pngPath.toString();
		// add our image to the document
		dojo.body().appendChild(img);</example>
          <example>you may de-reference as far as you like down the package
	hierarchy.  This is sometimes handy to avoid lenghty relative
	urls or for building portable sub-packages. In this example,
	the `acme.widget` and `acme.util` directories may be located
	under different roots (see `dojo.registerModulePath`) but the
	the modules which reference them can be unaware of their
	relative locations on the filesystem:
		// somewhere in a configuration block
		dojo.registerModulePath("acme.widget", "../../acme/widget");
		dojo.registerModulePath("acme.util", "../../util");
		// ...
		// code in a module using acme resources
		var tmpltPath = dojo.moduleUrl("acme.widget","templates/template.html");
		var dataPath = dojo.moduleUrl("acme.util","resources/data.json");</example>
        </examples>
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="url" type="dojo._Url||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo._Url"/>
        </return-types>
      </method>
      <method name="_xdDebugFileLoaded" scope="normal">
        <parameters>
          <parameter name="resourceName" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_xdReset" scope="normal">
        <summary>Internal xd loader function. Resets the xd state.</summary>
      </method>
      <method name="_xdClearInterval" scope="normal">
        <summary>Internal xd loader function.
	Clears the interval timer used to check on the
	status of in-flight xd module resource requests.</summary>
      </method>
      <method name="_xdCreateResource" scope="normal">
        <summary>Internal xd loader function. Creates an xd module source given an
	non-xd module contents.</summary>
        <parameters>
          <parameter name="contents" type="String" usage="required"/>
          <parameter name="resourceName" type="String" usage="required"/>
          <parameter name="resourcePath" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_xdExtractLoadInits" scope="normal">
        <parameters>
          <parameter name="fileContents" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_xdIsXDomainPath" scope="normal">
        <summary>Figure out whether the path is local or x-domain
	If there is a colon before the first / then, we have a URL with a protocol.</summary>
        <parameters>
          <parameter name="relpath" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_xdResourceLoaded" scope="normal">
        <summary>Internal xd loader function. Called by an xd module resource when
	it has been loaded via a script tag.</summary>
        <parameters>
          <parameter name="res" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdLoadFlattenedBundle" scope="normal">
        <summary>Internal xd loader function. Used when loading
	a flattened localized bundle via a script tag.</summary>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="bundleData" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_xdInitExtraLocales" scope="normal"/>
      <method name="xdRequireLocalization" scope="normal">
        <summary>Internal xd loader function. The xd version of dojo.requireLocalization.</summary>
        <parameters>
          <parameter name="m" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="fLocales" type="" usage="required"/>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="availableFlatLocales" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_xdUnpackDependency" scope="normal">
        <summary>Internal xd loader function. Determines what to do with a dependency
	that was listed in an xd version of a module contents.</summary>
        <parameters>
          <parameter name="dep" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_xdWalkReqs" scope="normal">
        <summary>Internal xd loader function.
	Walks the requires and evaluates module resource contents in
	the right order.</summary>
      </method>
      <method name="_xdEvalReqs" scope="normal">
        <summary>Internal xd loader function.
	Does a depth first, breadth second search and eval of required modules.</summary>
        <parameters>
          <parameter name="reqChain" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_xdWatchInFlight" scope="normal">
        <summary>Internal xd loader function.
	Monitors in-flight requests for xd module resources.</summary>
      </method>
      <method name="_xdNotifyLoaded" scope="normal"/>
      <method name="indexOf" scope="normal">
        <summary>locates the first index of the provided value in the
	passed array. If the value is not found, -1 is returned.</summary>
        <description>This method corresponds to the JavaScript 1.6 Array.indexOf method, with one difference: when
	run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
	1.6's indexOf skips the holes in the sparse array.
	For details on this method, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/indexOf</description>
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
          <parameter name="findLast" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="lastIndexOf" scope="normal">
        <summary>locates the last index of the provided value in the passed
	array. If the value is not found, -1 is returned.</summary>
        <description>This method corresponds to the JavaScript 1.6 Array.lastIndexOf method, with one difference: when
	run over sparse arrays, the Dojo function invokes the callback for every index whereas JavaScript
	1.6's lastIndexOf skips the holes in the sparse array.
	For details on this method, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/lastIndexOf</description>
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="value" type="Object" usage="required"/>
          <parameter name="fromIndex" type="Integer" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="forEach" scope="normal">
        <summary>for every item in arr, callback is invoked. Return values are ignored.
	If you want to break out of the loop, consider using dojo.every() or dojo.some().
	forEach does not allow breaking out of the loop over the items in arr.</summary>
        <description>This function corresponds to the JavaScript 1.6 Array.forEach() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's forEach skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/forEach</description>
        <examples>
          <example>	// log out all members of the array:
		dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			function(item){
				console.log(item);
			}
		);</example>
          <example>	// log out the members and their indexes
		dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			function(item, idx, arr){
				console.log(item, "at index:", idx);
			}
		);</example>
          <example>	// use a scoped object member as the callback
		var obj = {
			prefix: "logged via obj.callback:",
			callback: function(item){
				console.log(this.prefix, item);
			}
		};
		// specifying the scope function executes the callback in that scope
		dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			obj.callback,
			obj
		);
		// alternately, we can accomplish the same thing with dojo.hitch()
		dojo.forEach(
			[ "thinger", "blah", "howdy", 10 ],
			dojo.hitch(obj, "callback")
		);</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <summary>the array to iterate over. If a string, operates on individual characters.</summary>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <summary>a function is invoked with three arguments: item, index, and array</summary>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <summary>may be used to scope the call to callback</summary>
          </parameter>
        </parameters>
      </method>
      <method name="every" scope="normal">
        <summary>Determines whether or not every item in arr satisfies the
	condition implemented by callback.</summary>
        <description>This function corresponds to the JavaScript 1.6 Array.every() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's every skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/every</description>
        <examples>
          <example>	// returns false
		dojo.every([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
          <example>	// returns true
		dojo.every([1, 2, 3, 4], function(item){ return item&gt;0; });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <summary>the array to iterate on. If a string, operates on individual characters.</summary>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <summary>a function is invoked with three arguments: item, index,
	and array and returns true if the condition is met.</summary>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <summary>may be used to scope the call to callback</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="normal">
        <summary>Determines whether or not any item in arr satisfies the
	condition implemented by callback.</summary>
        <description>This function corresponds to the JavaScript 1.6 Array.some() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's some skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/some</description>
        <examples>
          <example>	// is true
		dojo.some([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
          <example>	// is false
		dojo.some([1, 2, 3, 4], function(item){ return item&lt;1; });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <summary>the array to iterate over. If a string, operates on individual characters.</summary>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <summary>a function is invoked with three arguments: item, index,
	and array and returns true if the condition is met.</summary>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <summary>may be used to scope the call to callback</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="map" scope="normal">
        <summary>applies callback to each element of arr and returns
	an Array with the results</summary>
        <description>This function corresponds to the JavaScript 1.6 Array.map() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's map skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/map</description>
        <examples>
          <example>	// returns [2, 3, 4, 5]
		dojo.map([1, 2, 3, 4], function(item){ return item+1 });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array|String" usage="required">
            <summary>the array to iterate on. If a string, operates on
	individual characters.</summary>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <summary>a function is invoked with three arguments, (item, index,
	array),  and returns a value</summary>
          </parameter>
          <parameter name="thisObject" type="Function" usage="optional">
            <summary>may be used to scope the call to callback</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="filter" scope="normal">
        <summary>Returns a new Array with those items from arr that match the
	condition implemented by callback.</summary>
        <description>This function corresponds to the JavaScript 1.6 Array.filter() method, with one difference: when
	run over sparse arrays, this implemenation passes the "holes" in the sparse array to
	the callback function with a value of undefined. JavaScript 1.6's filter skips the holes in the sparse array.
	For more details, see:
	https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Objects/Array/filter</description>
        <examples>
          <example>	// returns [2, 3, 4]
		dojo.filter([1, 2, 3, 4], function(item){ return item&gt;1; });</example>
        </examples>
        <parameters>
          <parameter name="arr" type="Array" usage="required">
            <summary>the array to iterate over.</summary>
          </parameter>
          <parameter name="callback" type="Function|String" usage="required">
            <summary>a function that is invoked with three arguments (item,
	index, array). The return of this function is expected to
	be a boolean which determines whether the passed-in item
	will be included in the returned array.</summary>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <summary>may be used to scope the call to callback</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="connect" scope="normal">
        <summary>&lt;code&gt;dojo.connect&lt;/code&gt; is the core event handling and delegation method in
	Dojo. It allows one function to &amp;quot;listen in&amp;quot; on the execution of
	any other, triggering the second whenever the first is called. Many
	listeners may be attached to a function, and source functions may
	be either regular function calls or DOM events.</summary>
        <description>Connects listeners to actions, so that after event fires, a
	listener is called with the same arguments passed to the orginal
	function.
	Since `dojo.connect` allows the source of events to be either a
	"regular" JavaScript function or a DOM event, it provides a uniform
	interface for listening to all the types of events that an
	application is likely to deal with though a single, unified
	interface. DOM programmers may want to think of it as
	"addEventListener for everything and anything".
	When setting up a connection, the `event` parameter must be a
	string that is the name of the method/event to be listened for. If
	`obj` is null, `dojo.global` is assumed, meaning that connections
	to global methods are supported but also that you may inadvertantly
	connect to a global by passing an incorrect object name or invalid
	reference.
	`dojo.connect` generally is forgiving. If you pass the name of a
	function or method that does not yet exist on `obj`, connect will
	not fail, but will instead set up a stub method. Similarly, null
	arguments may simply be omitted such that fewer than 4 arguments
	may be required to set up a connection See the examples for deails.
	The return value is a handle that is needed to
	remove this connection with `dojo.disconnect`.</description>
        <examples>
          <example>When obj.onchange(), do ui.update():
		dojo.connect(obj, "onchange", ui, "update");
		dojo.connect(obj, "onchange", ui, ui.update); // same</example>
          <example>Using return value for disconnect:
		var link = dojo.connect(obj, "onchange", ui, "update");
		...
		dojo.disconnect(link);</example>
          <example>When onglobalevent executes, watcher.handler is invoked:
		dojo.connect(null, "onglobalevent", watcher, "handler");</example>
          <example>When ob.onCustomEvent executes, customEventHandler is invoked:
		dojo.connect(ob, "onCustomEvent", null, "customEventHandler");
		dojo.connect(ob, "onCustomEvent", "customEventHandler"); // same</example>
          <example>When ob.onCustomEvent executes, customEventHandler is invoked
	with the same scope (this):
		dojo.connect(ob, "onCustomEvent", null, customEventHandler);
		dojo.connect(ob, "onCustomEvent", customEventHandler); // same</example>
          <example>When globalEvent executes, globalHandler is invoked
	with the same scope (this):
		dojo.connect(null, "globalEvent", null, globalHandler);
		dojo.connect("globalEvent", globalHandler); // same</example>
        </examples>
        <parameters>
          <parameter name="obj" type="Object|null" usage="required">
            <summary>The source object for the event function.
	Defaults to &lt;code&gt;dojo.global&lt;/code&gt; if null.
	If obj is a DOM node, the connection is delegated
	to the DOM event manager (unless dontFix is true).</summary>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <summary>name of the event function in obj.
	I.e. identifies a property &lt;code&gt;obj[event]&lt;/code&gt;.</summary>
          </parameter>
          <parameter name="context" type="Object|null" usage="required">
            <summary>The object that method will receive as &amp;quot;this&amp;quot;.
	If context is null and method is a function, then method
	inherits the context of event.
	If method is a string then context must be the source
	object object for method (context[method]). If context is null,
	dojo.global is used.</summary>
          </parameter>
          <parameter name="method" type="String|Function" usage="required">
            <summary>A function reference, or name of a function in context.
	The function identified by method fires after event does.
	method receives the same arguments as the event.
	See context argument comments for information on method's scope.</summary>
          </parameter>
          <parameter name="dontFix" type="Boolean" usage="optional">
            <summary>If obj is a DOM node, set dontFix to true to prevent delegation
	of this connection to the DOM event manager.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_connect" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="event" type="" usage="required"/>
          <parameter name="context" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
          <parameter name="dontFix" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="disconnect" scope="normal">
        <summary>Remove a link created by dojo.connect.</summary>
        <description>Removes the connection between event and the method referenced by handle.</description>
        <parameters>
          <parameter name="handle" type="Handle" usage="required">
            <summary>the return value of the dojo.connect call that created the connection.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_disconnect" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="event" type="" usage="required"/>
          <parameter name="handle" type="" usage="required"/>
          <parameter name="listener" type="" usage="required"/>
        </parameters>
      </method>
      <method name="connectPublisher" scope="normal">
        <summary>Ensure that everytime obj.event() is called, a message is published
	on the topic. Returns a handle which can be passed to
	dojo.disconnect() to disable subsequent automatic publication on
	the topic.</summary>
        <examples>
          <example>	dojo.connectPublisher("/ajax/start", dojo, "xhrGet");</example>
        </examples>
        <parameters>
          <parameter name="topic" type="String" usage="required">
            <summary>The name of the topic to publish.</summary>
          </parameter>
          <parameter name="obj" type="Object|null" usage="required">
            <summary>The source object for the event function. Defaults to dojo.global
	if null.</summary>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <summary>The name of the event function in obj.
	I.e. identifies a property obj[event].</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Handle"/>
        </return-types>
      </method>
      <method name="declare" scope="normal">
        <summary>Create a feature-rich constructor from compact notation.</summary>
        <description>Create a constructor using a compact notation for inheritance and
	prototype extension.
	Mixin ancestors provide a type of multiple inheritance.
	Prototypes of mixin ancestors are copied to the new class:
	changes to mixin prototypes will not affect classes to which
	they have been mixed in.
	Ancestors can be compound classes created by this version of
	dojo.declare. In complex cases all base classes are going to be
	linearized according to C3 MRO algorithm
	(see http://www.python.org/download/releases/2.3/mro/ for more
	details).
	"className" is cached in "declaredClass" property of the new class,
	if it was supplied. The immediate super class will be cached in
	"superclass" property of the new class.
	Methods in "props" will be copied and modified: "nom" property
	(the declared name of the method) will be added to all copied
	functions to help identify them for the internal machinery. Be
	very careful, while reusing methods: if you use the same
	function under different names, it can produce errors in some
	cases.
	It is possible to use constructors created "manually" (without
	dojo.declare) as bases. They will be called as usual during the
	creation of an instance, their methods will be chained, and even
	called by "this.inherited()".
	Special property "-chains-" governs how to chain methods. It is
	a dictionary, which uses method names as keys, and hint strings
	as values. If a hint string is "after", this method will be
	called after methods of its base classes. If a hint string is
	"before", this method will be called before methods of its base
	classes.
	If "constructor" is not mentioned in "-chains-" property, it will
	be chained using the legacy mode: using "after" chaining,
	calling preamble() method before each constructor, if available,
	and calling postscript() after all constructors were executed.
	If the hint is "after", it is chained as a regular method, but
	postscript() will be called after the chain of constructors.
	"constructor" cannot be chained "before", but it allows
	a special hint string: "manual", which means that constructors
	are not going to be chained in any way, and programmer will call
	them manually using this.inherited(). In the latter case
	postscript() will be called after the construction.
	All chaining hints are "inherited" from base classes and
	potentially can be overridden. Be very careful when overriding
	hints! Make sure that all chained methods can work in a proposed
	manner of chaining.
	Once a method was chained, it is impossible to unchain it. The
	only exception is "constructor". You don't need to define a
	method in order to supply a chaining hint.
	If a method is chained, it cannot use this.inherited() because
	all other methods in the hierarchy will be called automatically.
	Usually constructors and initializers of any kind are chained
	using "after" and destructors of any kind are chained as
	"before". Note that chaining assumes that chained methods do not
	return any value: any returned value will be discarded.</description>
        <return-description>New constructor function.</return-description>
        <examples>
          <example>	dojo.declare("my.classes.bar", my.classes.foo, {
			// properties to be added to the class prototype
			someValue: 2,
			// initialization function
			constructor: function(){
				this.myComplicatedObject = new ReallyComplicatedObject();
			},
			// other functions
			someMethod: function(){
				doStuff();
			}
		});</example>
          <example>	var MyBase = dojo.declare(null, {
			// constructor, properties, and methods go here
			// ...
		});
		var MyClass1 = dojo.declare(MyBase, {
			// constructor, properties, and methods go here
			// ...
		});
		var MyClass2 = dojo.declare(MyBase, {
			// constructor, properties, and methods go here
			// ...
		});
		var MyDiamond = dojo.declare([MyClass1, MyClass2], {
			// constructor, properties, and methods go here
			// ...
		});</example>
          <example>	var F = function(){ console.log("raw constructor"); };
		F.prototype.method = function(){
			console.log("raw method");
		};
		var A = dojo.declare(F, {
			constructor: function(){
				console.log("A.constructor");
			},
			method: function(){
				console.log("before calling F.method...");
				this.inherited(arguments);
				console.log("...back in A");
			}
		});
		new A().method();
		// will print:
		// raw constructor
		// A.constructor
		// before calling F.method...
		// raw method
		// ...back in A</example>
          <example>	var A = dojo.declare(null, {
			"-chains-": {
				destroy: "before"
			}
		});
		var B = dojo.declare(A, {
			constructor: function(){
				console.log("B.constructor");
			},
			destroy: function(){
				console.log("B.destroy");
			}
		});
		var C = dojo.declare(B, {
			constructor: function(){
				console.log("C.constructor");
			},
			destroy: function(){
				console.log("C.destroy");
			}
		});
		new C().destroy();
		// prints:
		// B.constructor
		// C.constructor
		// C.destroy
		// B.destroy</example>
          <example>	var A = dojo.declare(null, {
			"-chains-": {
				constructor: "manual"
			}
		});
		var B = dojo.declare(A, {
			constructor: function(){
				// ...
				// call the base constructor with new parameters
				this.inherited(arguments, [1, 2, 3]);
				// ...
			}
		});</example>
          <example>	var A = dojo.declare(null, {
			"-chains-": {
				m1: "before"
			},
			m1: function(){
				console.log("A.m1");
			},
			m2: function(){
				console.log("A.m2");
			}
		});
		var B = dojo.declare(A, {
			"-chains-": {
				m2: "after"
			},
			m1: function(){
				console.log("B.m1");
			},
			m2: function(){
				console.log("B.m2");
			}
		});
		var x = new B();
		x.m1();
		// prints:
		// B.m1
		// A.m1
		x.m2();
		// prints:
		// A.m2
		// B.m2</example>
        </examples>
        <parameters>
          <parameter name="className" type="String:" usage="optional">
            <summary>The optional name of the constructor (loosely, a &amp;quot;class&amp;quot;)
	stored in the &amp;quot;declaredClass&amp;quot; property in the created prototype.
	It will be used as a global name for a created constructor.</summary>
          </parameter>
          <parameter name="superclass" type="Function|Function[]:" usage="required">
            <summary>May be null, a Function, or an Array of Functions. This argument
	specifies a list of bases (the left-most one is the most deepest
	base).</summary>
          </parameter>
          <parameter name="props" type="Object:" usage="required">
            <summary>An object whose properties are copied to the created prototype.
	Add an instance-initialization function by making it a property
	named &amp;quot;constructor&amp;quot;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="safeMixin" scope="normal">
        <summary>Mix in properties skipping a constructor and decorating functions
	like it is done by dojo.declare.</summary>
        <description>This function is used to mix in properties like dojo._mixin does,
	but it skips a constructor property and decorates functions like
	dojo.declare does.
	It is meant to be used with classes and objects produced with
	dojo.declare. Functions mixed in with dojo.safeMixin can use
	this.inherited() like normal methods.
	This function is used to implement extend() method of a constructor
	produced with dojo.declare().</description>
        <examples>
          <example>	var A = dojo.declare(null, {
			m1: function(){
				console.log("A.m1");
			},
			m2: function(){
				console.log("A.m2");
			}
		});
		var B = dojo.declare(A, {
			m1: function(){
				this.inherited(arguments);
				console.log("B.m1");
			}
		});
		B.extend({
			m2: function(){
				this.inherited(arguments);
				console.log("B.m2");
			}
		});
		var x = new B();
		dojo.safeMixin(x, {
			m1: function(){
				this.inherited(arguments);
				console.log("X.m1");
			},
			m2: function(){
				this.inherited(arguments);
				console.log("X.m2");
			}
		});
		x.m2();
		// prints:
		// A.m1
		// B.m1
		// X.m1</example>
        </examples>
        <parameters>
          <parameter name="target" type="Object" usage="required">
            <summary>Target object to accept new properties.</summary>
          </parameter>
          <parameter name="source" type="Object" usage="required">
            <summary>Source object for new properties.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="fixEvent" scope="normal">
        <summary>normalizes properties on the event object including event
	bubbling methods, keystroke normalization, and x/y positions</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>native event object</summary>
          </parameter>
          <parameter name="sender" type="DOMNode" usage="required">
            <summary>node to treat as &amp;quot;currentTarget&amp;quot;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="stopEvent" scope="normal">
        <summary>prevents propagation and clobbers the default action of the
	passed event</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The event object. If omitted, window.event is used on IE.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isCopyKey" scope="normal">
        <summary>Checks an event for the copy key (meta on Mac, and ctrl anywhere else)</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event object to examine</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_ieDispatcher" scope="normal">
        <parameters>
          <parameter name="args" type="" usage="required"/>
          <parameter name="sender" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getIeDispatcher" scope="normal">
        <return-types>
          <return-type type="function"/>
        </return-types>
      </method>
      <method name="_fade" scope="normal">
        <summary>Returns an animation that will fade the node defined by
	args.node from the start to end values passed (args.start
	args.end) (end is mandatory, start is optional)</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="normal">
        <summary>Returns an animation that will fade node defined in 'args' from
	its current opacity to fully opaque.</summary>
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeOut" scope="normal">
        <summary>Returns an animation that will fade node defined in 'args'
	from its current opacity to fully transparent.</summary>
        <parameters>
          <parameter name="args" type="dojo.__FadeArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_defaultEasing" scope="normal">
        <summary>The default easing function for dojo.Animation(s)</summary>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="animateProperty" scope="normal">
        <summary>Returns an animation that will transition the properties of
	node defined in &lt;code&gt;args&lt;/code&gt; depending how they are defined in
	&lt;code&gt;args.properties&lt;/code&gt;</summary>
        <description>`dojo.animateProperty` is the foundation of most `dojo.fx`
	animations. It takes an object of "properties" corresponding to
	style properties, and animates them in parallel over a set
	duration.</description>
        <examples>
          <example>A simple animation that changes the width of the specified node.
		dojo.animateProperty({
			node: "nodeId",
			properties: { width: 400 },
		}).play();
	Dojo figures out the start value for the width and converts the
	integer specified for the width to the more expressive but
	verbose form `{ width: { end: '400', units: 'px' } }` which you
	can also specify directly. Defaults to 'px' if ommitted.</example>
          <example>Animate width, height, and padding over 2 seconds... the
	pedantic way:
		dojo.animateProperty({ node: node, duration:2000,
			properties: {
				width: { start: '200', end: '400', units:"px" },
				height: { start:'200', end: '400', units:"px" },
				paddingTop: { start:'5', end:'50', units:"px" }
			}
		}).play();
	Note 'paddingTop' is used over 'padding-top'. Multi-name CSS properties
	are written using "mixed case", as the hyphen is illegal as an object key.</example>
          <example>Plug in a different easing function and register a callback for
	when the animation ends. Easing functions accept values between
	zero and one and return a value on that basis. In this case, an
	exponential-in curve.
		dojo.animateProperty({
			node: "nodeId",
			// dojo figures out the start value
			properties: { width: { end: 400 } },
			easing: function(n){
				return (n==0) ? 0 : Math.pow(2, 10 * (n - 1));
			},
			onEnd: function(node){
				// called when the animation finishes. The animation
				// target is passed to this function
			}
		}).play(500); // delay playing half a second</example>
          <example>Like all `dojo.Animation`s, animateProperty returns a handle to the
	Animation instance, which fires the events common to Dojo FX. Use `dojo.connect`
	to access these events outside of the Animation definiton:
		var anim = dojo.animateProperty({
			node:"someId",
			properties:{
				width:400, height:500
			}
		});
		dojo.connect(anim,"onEnd", function(){
			console.log("animation ended");
		});
		// play the animation now:
		anim.play();</example>
          <example>Each property can be a function whose return value is substituted along.
	Additionally, each measurement (eg: start, end) can be a function. The node
	reference is passed direcly to callbacks.
		dojo.animateProperty({
			node:"mine",
			properties:{
				height:function(node){
					// shrink this node by 50%
					return dojo.position(node).h / 2
				},
				width:{
					start:function(node){ return 100; },
					end:function(node){ return 200; }
				}
			}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="dojo.__AnimArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="anim" scope="normal">
        <summary>A simpler interface to &lt;code&gt;dojo.animateProperty()&lt;/code&gt;, also returns
	an instance of &lt;code&gt;dojo.Animation&lt;/code&gt; but begins the animation
	immediately, unlike nearly every other Dojo animation API.</summary>
        <description>`dojo.anim` is a simpler (but somewhat less powerful) version
	of `dojo.animateProperty`.  It uses defaults for many basic properties
	and allows for positional parameters to be used in place of the
	packed "property bag" which is used for other Dojo animation
	methods.
	The `dojo.Animation` object returned from `dojo.anim` will be
	already playing when it is returned from this function, so
	calling play() on it again is (usually) a no-op.</description>
        <examples>
          <example>Fade out a node
		dojo.anim("id", { opacity: 0 });</example>
          <example>Fade out a node over a full second
		dojo.anim("id", { opacity: 0 }, 1000);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <summary>a DOM node or the id of a node to animate CSS properties on</summary>
          </parameter>
          <parameter name="properties" type="Object" usage="required"/>
          <parameter name="duration" type="Integer" usage="optional">
            <summary>The number of milliseconds over which the animation
	should run. Defaults to the global animation default duration
	(350ms).</summary>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <summary>An easing function over which to calculate acceleration
	and deceleration of the animation through its duration.
	A default easing algorithm is provided, but you may
	plug in any you wish. A large selection of easing algorithms
	are available in &lt;code&gt;dojo.fx.easing&lt;/code&gt;.</summary>
          </parameter>
          <parameter name="onEnd" type="Function" usage="optional">
            <summary>A function to be called when the animation finishes
	running.</summary>
          </parameter>
          <parameter name="delay" type="Integer" usage="optional">
            <summary>The number of milliseconds to delay beginning the
	animation by. The default is 0.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_destroyElement" scope="normal">
        <summary>Existing alias for &lt;code&gt;dojo.destroy&lt;/code&gt;. Deprecated, will be removed
	in 2.0</summary>
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="normal">
        <summary>Removes a node from its parent, clobbering it and all of its
	children.</summary>
        <description>Removes a node from its parent, clobbering it and all of its
	children. Function only works with DomNodes, and returns nothing.</description>
        <examples>
          <example>Destroy a node byId:
		dojo.destroy("someId");</example>
          <example>Destroy all nodes in a list by reference:
		dojo.query(".someNode").forEach(dojo.destroy);</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <summary>A String ID or DomNode reference of the element to be destroyed</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isDescendant" scope="normal">
        <summary>Returns true if node is a descendant of ancestor</summary>
        <examples>
          <example>Test is node id="bar" is a descendant of node id="foo"
		if(dojo.isDescendant("bar", "foo")){ ... }</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>string id or node reference to test</summary>
          </parameter>
          <parameter name="ancestor" type="DomNode|String" usage="required">
            <summary>string id or node reference of potential parent to test against</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setSelectable" scope="normal">
        <summary>Enable or disable selection on a node</summary>
        <examples>
          <example>Make the node id="bar" unselectable
		dojo.setSelectable("bar");</example>
          <example>Make the node id="bar" selectable
		dojo.setSelectable("bar", true);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>id or reference to node</summary>
          </parameter>
          <parameter name="selectable" type="Boolean" usage="required">
            <summary>state to put the node in. false indicates unselectable, true
	allows selection.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="place" scope="normal">
        <summary>Attempt to insert node into the DOM, choosing from various positioning options.
	Returns the first argument resolved to a DOM node.</summary>
        <return-description>DomNode
	Returned values is the first argument resolved to a DOM node.
	.place() is also a method of `dojo.NodeList`, allowing `dojo.query` node lookups.</return-description>
        <examples>
          <example>Place a node by string id as the last child of another node by string id:
		dojo.place("someNode", "anotherNode");</example>
          <example>Place a node by string id before another node by string id
		dojo.place("someNode", "anotherNode", "before");</example>
          <example>Create a Node, and place it in the body element (last child):
		dojo.place("&lt;div&gt;&lt;/div&gt;", dojo.body());</example>
          <example>Put a new LI as the first child of a list by id:
		dojo.place("&lt;li&gt;&lt;/li&gt;", "someUl", "first");</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <summary>id or node reference, or HTML fragment starting with &amp;quot;&amp;lt;&amp;quot; to place relative to refNode</summary>
          </parameter>
          <parameter name="refNode" type="String|DomNode" usage="required">
            <summary>id or node reference to use as basis for placement</summary>
          </parameter>
          <parameter name="position" type="String|Number" usage="optional">
            <summary>string noting the position of node relative to refNode or a
	number indicating the location in the childNodes collection of refNode.
	Accepted string values are:
		* before
		* after
		* replace
		* only
		* first
		* last
	&amp;quot;first&amp;quot; and &amp;quot;last&amp;quot; indicate positions as children of refNode, &amp;quot;replace&amp;quot; replaces refNode,
	&amp;quot;only&amp;quot; replaces all children.  position defaults to &amp;quot;last&amp;quot; if not specified</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="getComputedStyle" scope="normal">
        <summary>Returns a &amp;quot;computed style&amp;quot; object.</summary>
        <description>Gets a "computed style" object which can be used to gather
	information about the current state of the rendered node.
	Note that this may behave differently on different browsers.
	Values may have different formats and value encodings across
	browsers.
	Note also that this method is expensive.  Wherever possible,
	reuse the returned object.
	Use the dojo.style() method for more consistent (pixelized)
	return values.</description>
        <examples>
          <example>	dojo.getComputedStyle(dojo.byId('foo')).borderWidth;</example>
          <example>Reusing the returned object, avoiding multiple lookups:
		var cs = dojo.getComputedStyle(dojo.byId("someNode"));
		var w = cs.width, h = cs.height;</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <summary>A reference to a DOM node. Does NOT support taking an
	ID string for speed reasons.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="CSS2Properties"/>
        </return-types>
      </method>
      <method name="_toPixelValue" scope="normal">
        <parameters>
          <parameter name="element" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
          <parameter name="avalue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getOpacity" scope="normal">
        <summary>Returns the current opacity of the passed node as a
	floating-point value between 0 and 1.</summary>
        <return-description>Number between 0 and 1</return-description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>a reference to a DOM node. Does NOT support taking an
	ID string for speed reasons.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_setOpacity" scope="normal">
        <summary>set the opacity of the passed node portably. Returns the
	new opacity of the node.</summary>
        <return-description>Number between 0 and 1</return-description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <summary>a reference to a DOM node. Does NOT support taking an
	ID string for performance reasons.</summary>
          </parameter>
          <parameter name="opacity" type="Number" usage="required">
            <summary>A Number between 0 and 1. 0 specifies transparent.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="style" scope="normal">
        <summary>Accesses styles on a node. If 2 arguments are
	passed, acts as a getter. If 3 arguments are passed, acts
	as a setter.</summary>
        <description>Getting the style value uses the computed style for the node, so the value
	will be a calculated value, not just the immediate node.style value.
	Also when getting values, use specific style names,
	like "borderBottomWidth" instead of "border" since compound values like
	"border" are not necessarily reflected as expected.
	If you want to get node dimensions, use `dojo.marginBox()`,
	`dojo.contentBox()` or `dojo.position()`.</description>
        <examples>
          <example>Passing only an ID or node returns the computed style object of
	the node:
		dojo.style("thinger");</example>
          <example>Passing a node and a style property returns the current
	normalized, computed value for that property:
		dojo.style("thinger", "opacity"); // 1 by default</example>
          <example>Passing a node, a style property, and a value changes the
	current display of the node and returns the new computed value
		dojo.style("thinger", "opacity", 0.5); // == 0.5</example>
          <example>Passing a node, an object-style style property sets each of the values in turn and returns the computed style object of the node:
		dojo.style("thinger", {
			"opacity": 0.5,
			"border": "3px solid black",
			"height": "300px"
		});</example>
          <example>When the CSS style property is hyphenated, the JavaScript property is camelCased.
	font-size becomes fontSize, and so on.
		dojo.style("thinger",{
			fontSize:"14pt",
			letterSpacing:"1.2em"
		});</example>
          <example>dojo.NodeList implements .style() using the same syntax, omitting the "node" parameter, calling
	dojo.style() on every element of the list. See: `dojo.query()` and `dojo.NodeList()`
		dojo.query(".someClassName").style("visibility","hidden");
		// or
		dojo.query("#baz &gt; div").style({
			opacity:0.75,
			fontSize:"13pt"
		});</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>id or reference to node to get/set style for</summary>
          </parameter>
          <parameter name="style" type="String|Object" usage="optional">
            <summary>the style property to set in DOM-accessor format
	(&amp;quot;borderWidth&amp;quot;, not &amp;quot;border-width&amp;quot;) or an object with key/value
	pairs suitable for setting each property.</summary>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <summary>If passed, sets value on the node for style, handling
	cross-browser concerns.  When setting a pixel value,
	be sure to include &amp;quot;px&amp;quot; in the value. For instance, top: &amp;quot;200px&amp;quot;.
	Otherwise, in some cases, some browsers will not apply the style.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getPadExtents" scope="normal">
        <summary>Returns object with special values specifically useful for node
	fitting.</summary>
        <description>Returns an object with `w`, `h`, `l`, `t` properties:
			l/t = left/top padding (respectively)
			w = the total of the left and right padding
			h = the total of the top and bottom padding
	If 'node' has position, l/t forms the origin for child nodes.
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderExtents" scope="normal">
        <summary>returns an object with properties useful for noting the border
	dimensions.</summary>
        <description>* l/t = the sum of left/top border (respectively)
	* w = the sum of the left and right border
	* h = the sum of the top and bottom border
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getPadBorderExtents" scope="normal">
        <summary>Returns object with properties useful for box fitting with
	regards to padding.</summary>
        <description>* l/t = the sum of left/top padding and left/top border (respectively)
	* w = the sum of the left and right padding and border
	* h = the sum of the top and bottom padding and border
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</description>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginExtents" scope="normal">
        <summary>returns object with properties useful for box fitting with
	regards to box margins (i.e., the outer-box).
	* l/t = marginLeft, marginTop, respectively
	* w = total width, margin inclusive
	* h = total height, margin inclusive
	The w/h are used for calculating boxes.
	Normally application code will not need to invoke this
	directly, and will use the ...box... functions instead.</summary>
        <parameters>
          <parameter name="n" type="" usage="required"/>
          <parameter name="computedStyle" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getMarginBox" scope="normal">
        <summary>returns an object that encodes the width, height, left and top
	positions of the node's margin box.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getContentBox" scope="normal">
        <summary>Returns an object that encodes the width, height, left and top
	positions of the node's content box, irrespective of the
	current box model.</summary>
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="computedStyle" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getBorderBox" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="computedStyle" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setBox" scope="normal">
        <summary>sets width/height/left/top in the current (native) box-model
	dimentions. Uses the unit passed in u.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>DOM Node reference. Id string not supported for performance
	reasons.</summary>
          </parameter>
          <parameter name="l" type="Number" usage="optional">
            <summary>left offset from parent.</summary>
          </parameter>
          <parameter name="t" type="Number" usage="optional">
            <summary>top offset from parent.</summary>
          </parameter>
          <parameter name="w" type="Number" usage="optional">
            <summary>width in current box model.</summary>
          </parameter>
          <parameter name="h" type="Number" usage="optional">
            <summary>width in current box model.</summary>
          </parameter>
          <parameter name="u" type="String" usage="optional">
            <summary>unit measure to use for other measures. Defaults to &amp;quot;px&amp;quot;.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_isButtonTag" scope="normal">
        <summary>True if the node is BUTTON or INPUT.type=&amp;quot;button&amp;quot;.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_usesBorderBox" scope="normal">
        <summary>True if the node uses border-box layout.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_setContentSize" scope="normal">
        <summary>Sets the size of the node's contents, irrespective of margins,
	padding, or borders.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="widthPx" type="Number" usage="required"/>
          <parameter name="heightPx" type="Number" usage="required"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_setMarginBox" scope="normal">
        <summary>sets the size of the node's margin box and placement
	(left/top), irrespective of box model. Think of it as a
	passthrough to dojo._setBox that handles box-model vagaries for
	you.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="leftPx" type="Number" usage="optional"/>
          <parameter name="topPx" type="Number" usage="optional"/>
          <parameter name="widthPx" type="Number" usage="optional"/>
          <parameter name="heightPx" type="Number" usage="optional"/>
          <parameter name="computedStyle" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="marginBox" scope="normal">
        <summary>Getter/setter for the margin-box of node.</summary>
        <description>Getter/setter for the margin-box of node.
	Returns an object in the expected format of box (regardless
	if box is passed). The object might look like:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	for a node offset from its parent 50px to the left, 200px from
	the top with a margin width of 300px and a margin-height of
	150px.</description>
        <examples>
          <example>Retrieve the marginbox of a passed node
		var box = dojo.marginBox("someNodeId");
		console.dir(box);</example>
          <example>Set a node's marginbox to the size of another node
		var box = dojo.marginBox("someNodeId");
		dojo.marginBox("someOtherNode", box);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>id or reference to DOM Node to get/set box for</summary>
          </parameter>
          <parameter name="box" type="Object" usage="optional">
            <summary>If passed, denotes that dojo.marginBox() should
	update/set the margin box for node. Box is an object in the
	above format. All properties are optional if passed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="contentBox" scope="normal">
        <summary>Getter/setter for the content-box of node.</summary>
        <description>Returns an object in the expected format of box (regardless if box is passed).
	The object might look like:
	`{ l: 50, t: 200, w: 300: h: 150 }`
	for a node offset from its parent 50px to the left, 200px from
	the top with a content width of 300px and a content-height of
	150px. Note that the content box may have a much larger border
	or margin box, depending on the box model currently in use and
	CSS values set/inherited for node.</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>id or reference to DOM Node to get/set box for</summary>
          </parameter>
          <parameter name="box" type="Object" usage="optional">
            <summary>If passed, denotes that dojo.contentBox() should
	update/set the content box for node. Box is an object in the
	above format. All properties are optional if passed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_docScroll" scope="normal"/>
      <method name="_isBodyLtr" scope="normal"/>
      <method name="_getIeDocumentElementOffset" scope="normal">
        <summary>returns the offset in x and y from the document body to the
	visual edge of the page</summary>
        <description>The following values in IE contain an offset:
			event.clientX
			event.clientY
			node.getBoundingClientRect().left
			node.getBoundingClientRect().top
	But other position related values do not contain this offset,
	such as node.offsetLeft, node.offsetTop, node.style.left and
	node.style.top. The offset is always (2, 2) in LTR direction.
	When the body is in RTL direction, the offset counts the width
	of left scroll bar's width.  This function computes the actual
	offset.</description>
      </method>
      <method name="_fixIeBiDiScrollLeft" scope="normal">
        <parameters>
          <parameter name="scrollLeft" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_abs" scope="normal"/>
      <method name="position" scope="normal">
        <summary>Gets the position and size of the passed element relative to
	the viewport (if includeScroll==false), or relative to the
	document root (if includeScroll==true).</summary>
        <description>Returns an object of the form:
	{ x: 100, y: 300, w: 20, h: 15 }
	If includeScroll==true, the x and y values will include any
	document offsets that may affect the position relative to the
	viewport.
	Uses the border-box model (inclusive of border and padding but
	not margin).  Does not act as a setter.</description>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="coords" scope="normal">
        <summary>Deprecated: Use position() for border-box x/y/w/h
	or marginBox() for margin-box w/h/l/t.
	Returns an object representing a node's size and position.</summary>
        <description>Returns an object that measures margin-box (w)idth/(h)eight
	and absolute position x/y of the border-box. Also returned
	is computed (l)eft and (t)op values in pixels from the
	node's offsetParent as returned from marginBox().
	Return value will be in the form:
				{ l: 50, t: 200, w: 300: h: 150, x: 100, y: 300 }
	Does not act as a setter. If includeScroll is passed, the x and
	y params are affected as one would expect in dojo.position().</description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="includeScroll" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="hasAttr" scope="normal">
        <summary>Returns true if the requested attribute is specified on the
	given element, and false otherwise.</summary>
        <return-description>true if the requested attribute is specified on the
	given element, and false otherwise</return-description>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>id or reference to the element to check</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>the name of the attribute</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="attr" scope="normal">
        <summary>Gets or sets an attribute on an HTML element.</summary>
        <description>Handles normalized getting and setting of attributes on DOM
	Nodes. If 2 arguments are passed, and a the second argumnt is a
	string, acts as a getter.
	If a third argument is passed, or if the second argument is a
	map of attributes, acts as a setter.
	When passing functions as values, note that they will not be
	directly assigned to slots on the node, but rather the default
	behavior will be removed and the new behavior will be added
	using `dojo.connect()`, meaning that event handler properties
	will be normalized and that some caveats with regards to
	non-standard behaviors for onsubmit apply. Namely that you
	should cancel form submission using `dojo.stopEvent()` on the
	passed event object instead of returning a boolean value from
	the handler itself.</description>
        <return-description>when used as a getter, the value of the requested attribute
	or null if that attribute does not have a specified or
	default value;
	when used as a setter, the DOM node</return-description>
        <examples>
          <example>	// get the current value of the "foo" attribute on a node
		dojo.attr(dojo.byId("nodeId"), "foo");
		// or we can just pass the id:
		dojo.attr("nodeId", "foo");</example>
          <example>	// use attr() to set the tab index
		dojo.attr("nodeId", "tabIndex", 3);</example>
          <example>Set multiple values at once, including event handlers:
		dojo.attr("formId", {
			"foo": "bar",
			"tabIndex": -1,
			"method": "POST",
			"onsubmit": function(e){
				// stop submitting the form. Note that the IE behavior
				// of returning true or false will have no effect here
				// since our handler is connect()ed to the built-in
				// onsubmit behavior and so we need to use
				// dojo.stopEvent() to ensure that the submission
				// doesn't proceed.
				dojo.stopEvent(e);
				// submit the form with Ajax
				dojo.xhrPost({ form: "formId" });
			}
		});</example>
          <example>Style is s special case: Only set with an object hash of styles
		dojo.attr("someNode",{
			id:"bar",
			style:{
				width:"200px", height:"100px", color:"#000"
			}
		});</example>
          <example>Again, only set style as an object hash of styles:
		var obj = { color:"#fff", backgroundColor:"#000" };
		dojo.attr("someNode", "style", obj);
		// though shorter to use `dojo.style()` in this case:
		dojo.style("someNode", obj);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>id or reference to the element to get or set the attribute on</summary>
          </parameter>
          <parameter name="name" type="String|Object" usage="required">
            <summary>the name of the attribute to get or set.</summary>
          </parameter>
          <parameter name="value" type="String" usage="optional">
            <summary>The value to set for the attribute</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
          <return-type type="Anything"/>
        </return-types>
      </method>
      <method name="removeAttr" scope="normal">
        <summary>Removes an attribute from an HTML element.</summary>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>id or reference to the element to remove the attribute from</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>the name of the attribute to remove</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getNodeProp" scope="normal">
        <summary>Returns an effective value of a property or an attribute.</summary>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>id or reference to the element to remove the attribute from</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>the name of the attribute</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Anything"/>
        </return-types>
      </method>
      <method name="create" scope="normal">
        <summary>Create an element, allowing for optional attribute decoration
	and placement.</summary>
        <description>A DOM Element creation function. A shorthand method for creating a node or
	a fragment, and allowing for a convenient optional attribute setting step,
	as well as an optional DOM placement reference.
	Attributes are set by passing the optional object through `dojo.attr`.
	See `dojo.attr` for noted caveats and nuances, and API if applicable.
	Placement is done via `dojo.place`, assuming the new node to be the action
	node, passing along the optional reference node and position.</description>
        <return-description>DomNode</return-description>
        <examples>
          <example>Create a DIV:
		var n = dojo.create("div");</example>
          <example>Create a DIV with content:
		var n = dojo.create("div", { innerHTML:"&lt;p&gt;hi&lt;/p&gt;" });</example>
          <example>Place a new DIV in the BODY, with no attributes set
		var n = dojo.create("div", null, dojo.body());</example>
          <example>Create an UL, and populate it with LI's. Place the list as the first-child of a
	node with id="someId":
		var ul = dojo.create("ul", null, "someId", "first");
		var items = ["one", "two", "three", "four"];
		dojo.forEach(items, function(data){
			dojo.create("li", { innerHTML: data }, ul);
		});</example>
          <example>Create an anchor, with an href. Place in BODY:
		dojo.create("a", { href:"foo.html", title:"Goto FOO!" }, dojo.body());</example>
          <example>Create a `dojo.NodeList()` from a new element (for syntatic sugar):
		dojo.query(dojo.create('div'))
			.addClass("newDiv")
			.onclick(function(e){ console.log('clicked', e.target) })
			.place("#someNode"); // redundant, but cleaner.</example>
        </examples>
        <parameters>
          <parameter name="tag" type="String|DomNode" usage="required">
            <summary>A string of the element to create (eg: &amp;quot;div&amp;quot;, &amp;quot;a&amp;quot;, &amp;quot;p&amp;quot;, &amp;quot;li&amp;quot;, &amp;quot;script&amp;quot;, &amp;quot;br&amp;quot;),
	or an existing DOM node to process.</summary>
          </parameter>
          <parameter name="attrs" type="Object" usage="required">
            <summary>An object-hash of attributes to set on the newly created node.
	Can be null, if you don't want to set any attributes/styles.
	See: &lt;code&gt;dojo.attr&lt;/code&gt; for a description of available attributes.</summary>
          </parameter>
          <parameter name="refNode" type="String|DomNode" usage="optional">
            <summary>Optional reference node. Used by &lt;code&gt;dojo.place&lt;/code&gt; to place the newly created
	node somewhere in the dom relative to refNode. Can be a DomNode reference
	or String ID of a node.</summary>
          </parameter>
          <parameter name="pos" type="String" usage="optional">
            <summary>Optional positional reference. Defaults to &amp;quot;last&amp;quot; by way of &lt;code&gt;dojo.place&lt;/code&gt;,
	though can be set to &amp;quot;first&amp;quot;,&amp;quot;after&amp;quot;,&amp;quot;before&amp;quot;,&amp;quot;last&amp;quot;, &amp;quot;replace&amp;quot; or &amp;quot;only&amp;quot;
	to further control the placement of the new node relative to the refNode.
	'refNode' is required if a 'pos' is specified.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="empty" scope="normal">
        <summary>safely removes all children of the node.</summary>
        <examples>
          <example>Destroy node's children byId:
		dojo.empty("someId");</example>
          <example>Destroy all nodes' children in a list by reference:
		dojo.query(".someNode").forEach(dojo.empty);</example>
        </examples>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <summary>a reference to a DOM node or an id.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_toDom" scope="normal">
        <summary>converts HTML string into DOM nodes.</summary>
        <return-description>DocumentFragment</return-description>
        <examples>
          <example>Create a table row:
		var tr = dojo._toDom("&lt;tr&gt;&lt;td&gt;First!&lt;/td&gt;&lt;/tr&gt;");</example>
        </examples>
        <parameters>
          <parameter name="frag" type="String" usage="required">
            <summary>the HTML fragment</summary>
          </parameter>
          <parameter name="doc" type="DocumentNode" usage="optional">
            <summary>optional document to use when creating DOM nodes, defaults to
	dojo.doc if not specified.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="hasClass" scope="normal">
        <summary>Returns whether or not the specified classes are a portion of the
	class list currently applied to the node.</summary>
        <examples>
          <example>Do something if a node with id="someNode" has class="aSillyClassName" present
		if(dojo.hasClass("someNode","aSillyClassName")){ ... }</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>String ID or DomNode reference to check the class for.</summary>
          </parameter>
          <parameter name="classStr" type="String" usage="required">
            <summary>A string class name to look for.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="addClass" scope="normal">
        <summary>Adds the specified classes to the end of the class list on the
	passed node. Will not re-apply duplicate classes.</summary>
        <examples>
          <example>Add a class to some node:
		dojo.addClass("someNode", "anewClass");</example>
          <example>Add two classes at once:
		dojo.addClass("someNode", "firstClass secondClass");</example>
          <example>Add two classes at once (using array):
		dojo.addClass("someNode", ["firstClass", "secondClass"]);</example>
          <example>Available in `dojo.NodeList` for multiple additions
		dojo.query("ul &gt; li").addClass("firstLevel");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>String ID or DomNode reference to add a class string too</summary>
          </parameter>
          <parameter name="classStr" type="String|Array" usage="required">
            <summary>A String class name to add, or several space-separated class names,
	or an array of class names.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeClass" scope="normal">
        <summary>Removes the specified classes from node. No &lt;code&gt;dojo.hasClass&lt;/code&gt;
	check is required.</summary>
        <examples>
          <example>Remove a class from some node:
		dojo.removeClass("someNode", "firstClass");</example>
          <example>Remove two classes from some node:
		dojo.removeClass("someNode", "firstClass secondClass");</example>
          <example>Remove two classes from some node (using array):
		dojo.removeClass("someNode", ["firstClass", "secondClass"]);</example>
          <example>Remove all classes from some node:
		dojo.removeClass("someNode");</example>
          <example>Available in `dojo.NodeList()` for multiple removal
		dojo.query(".foo").removeClass("foo");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required">
            <summary>String ID or DomNode reference to remove the class from.</summary>
          </parameter>
          <parameter name="classStr" type="String|Array" usage="optional">
            <summary>An optional String class name to remove, or several space-separated
	class names, or an array of class names. If omitted, all class names
	will be deleted.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toggleClass" scope="normal">
        <summary>Adds a class to node if not present, or removes if present.
	Pass a boolean condition if you want to explicitly add or remove.</summary>
        <examples>
          <example>	dojo.toggleClass("someNode", "hovered");</example>
          <example>Forcefully add a class
		dojo.toggleClass("someNode", "hovered", true);</example>
          <example>Available in `dojo.NodeList()` for multiple toggles
		dojo.query(".toggleMe").toggleClass("toggleMe");</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="classStr" type="String|Array" usage="required"/>
          <parameter name="condition" type="Boolean" usage="optional">
            <summary>If passed, true means to add the class, false means to remove.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="fromJson" scope="normal">
        <summary>Parses a [JSON](http://json.org) string to return a JavaScript object.</summary>
        <description>Throws for invalid JSON strings, but it does not use a strict JSON parser. It
	delegates to eval().</description>
        <parameters>
          <parameter name="json" type="String" usage="required">
            <summary>a string literal of a JSON item, for instance:
	&lt;code&gt;'{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }'&lt;/code&gt;</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_escapeString" scope="normal">
        <summary>Adds escape sequences for non-visual characters, double quote and
	backslash and surrounds with double quotes to form a valid string
	literal.</summary>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="toJson" scope="normal">
        <summary>Returns a [JSON](http://json.org) serialization of an object.</summary>
        <description>Returns a [JSON](http://json.org) serialization of an object.
	Note that this doesn't check for infinite recursion, so don't do that!</description>
        <examples>
          <example>simple serialization of a trivial object
		var jsonStr = dojo.toJson({ howdy: "stranger!", isStrange: true });
		doh.is('{"howdy":"stranger!","isStrange":true}', jsonStr);</example>
          <example>a custom serializer for an objects of a particular class:
		dojo.declare("Furby", null, {
			furbies: "are strange",
			furbyCount: 10,
			__json__: function(){
			},
		});</example>
        </examples>
        <parameters>
          <parameter name="it" type="Object" usage="required">
            <summary>an object to be serialized. Objects may define their own
	serialization via a special &amp;quot;__json__&amp;quot; or &amp;quot;json&amp;quot; function
	property. If a specialized serializer has been defined, it will
	be used as a fallback.</summary>
          </parameter>
          <parameter name="prettyPrint" type="Boolean" usage="optional">
            <summary>if true, we indent objects and arrays to make the output prettier.
	The variable &lt;code&gt;dojo.toJsonIndentStr&lt;/code&gt; is used as the indent string --
	to use something other than the default (tab), change that variable
	before calling dojo.toJson().</summary>
          </parameter>
          <parameter name="_indentStr" type="String" usage="optional">
            <summary>private variable for recursive calls when pretty printing, do not use.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isString" scope="normal">
        <summary>Return true if it is a String</summary>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isArray" scope="normal">
        <summary>Return true if it is an Array.
	Does not work on Arrays created in other windows.</summary>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isFunction" scope="normal">
        <summary>Return true if it is a Function</summary>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isObject" scope="normal">
        <summary>Returns true if it is a JavaScript object (or an Array, a Function
	or null)</summary>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isArrayLike" scope="normal">
        <summary>similar to dojo.isArray() but more permissive</summary>
        <description>Doesn't strongly test for "arrayness".  Instead, settles for "isn't
	a string or number and has a length property". Arguments objects
	and DOM collections will return true when passed to
	dojo.isArrayLike(), but will return false when passed to
	dojo.isArray().</description>
        <return-description>If it walks like a duck and quacks like a duck, return `true`</return-description>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isAlien" scope="normal">
        <summary>Returns true if it is a built-in function or some other kind of
	oddball that *should* report as a function but doesn't</summary>
        <parameters>
          <parameter name="it" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="extend" scope="normal">
        <summary>Adds all properties and methods of props to constructor's
	prototype, making them available to all instances created with
	constructor.</summary>
        <parameters>
          <parameter name="constructor" type="Object" usage="required"/>
          <parameter name="props" type="Object" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_hitchArgs" scope="normal">
        <parameters>
          <parameter name="scope" type="" usage="required"/>
          <parameter name="method" type="," usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="hitch" scope="normal">
        <summary>Returns a function that will only ever execute in the a given scope.
	This allows for easy use of object member functions
	in callbacks and other places in which the &amp;quot;this&amp;quot; keyword may
	otherwise not reference the expected scope.
	Any number of default positional arguments may be passed as parameters
	beyond &amp;quot;method&amp;quot;.
	Each of these values will be used to &amp;quot;placehold&amp;quot; (similar to curry)
	for the hitched function.</summary>
        <examples>
          <example>	dojo.hitch(foo, "bar")();
	runs foo.bar() in the scope of foo</example>
          <example>	dojo.hitch(foo, myFunction);
	returns a function that runs myFunction in the scope of foo</example>
          <example>Expansion on the default positional arguments passed along from
	hitch. Passed args are mixed first, additional args after.
		var foo = { bar: function(a, b, c){ console.log(a, b, c); } };
		var fn = dojo.hitch(foo, "bar", 1, 2);
		fn(3); // logs "1, 2, 3"</example>
          <example>	var foo = { bar: 2 };
		dojo.hitch(foo, function(){ this.bar = 10; })();
	execute an anonymous function in scope of foo</example>
        </examples>
        <parameters>
          <parameter name="scope" type="Object" usage="required">
            <summary>The scope to use when method executes. If method is a string,
	scope is also the object containing method.</summary>
          </parameter>
          <parameter name="method" type="Function|String" usage="required">
            <summary>A function to be hitched to scope, or the name of the method in
	scope to be hitched.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="delegate" scope="normal">
        <summary>Returns a new object which &amp;quot;looks&amp;quot; to obj for properties which it
	does not have a value for. Optionally takes a bag of properties to
	seed the returned object with initially.</summary>
        <description>This is a small implementaton of the Boodman/Crockford delegation
	pattern in JavaScript. An intermediate object constructor mediates
	the prototype chain for the returned object, using it to delegate
	down to obj for property lookup when object-local lookup fails.
	This can be thought of similarly to ES4's "wrap", save that it does
	not act on types but rather on pure objects.</description>
        <return-description>an Object of anonymous type</return-description>
        <examples>
          <example>	var foo = { bar: "baz" };
		var thinger = dojo.delegate(foo, { thud: "xyzzy"});
		thinger.bar == "baz"; // delegated to foo
		foo.thud == undefined; // by definition
		thinger.thud == "xyzzy"; // mixed in from props
		foo.bar = "thonk";
		thinger.bar == "thonk"; // still delegated to foo's bar</example>
        </examples>
        <parameters>
          <parameter name="obj" type="The" usage="required">
            <summary>object to delegate to for properties not found directly on the
	return object or in props.</summary>
          </parameter>
          <parameter name="props" type="an" usage="required">
            <summary>object containing properties to assign to the returned object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_toArray" scope="normal">
        <summary>Converts an array-like object (i.e. arguments, DOMCollection) to an
	array. Returns a new Array with the elements of obj.</summary>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <summary>the object to &amp;quot;arrayify&amp;quot;. We expect the object to have, at a
	minimum, a length property which corresponds to integer-indexed
	properties.</summary>
          </parameter>
          <parameter name="offset" type="Number" usage="optional">
            <summary>the location in obj to start iterating from. Defaults to 0.
	Optional.</summary>
          </parameter>
          <parameter name="startWith" type="Array" usage="optional">
            <summary>An array to pack with the properties of obj. If provided,
	properties in obj are appended at the end of startWith and
	startWith is the returned array.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="partial" scope="normal">
        <summary>similar to hitch() except that the scope object is left to be
	whatever the execution context eventually becomes.</summary>
        <description>Calling dojo.partial is the functional equivalent of calling:
		dojo.hitch(null, funcName, ...);</description>
        <parameters>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="clone" scope="normal">
        <summary>Clones objects (including DOM nodes) and all children.
	Warning: do not clone cyclic structures.</summary>
        <parameters>
          <parameter name="o" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="anything"/>
          <return-type type="Node"/>
          <return-type type="Date"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="trim" scope="normal">
        <summary>Trims whitespace from both sides of the string</summary>
        <description>This version of trim() was selected for inclusion into the base due
	to its compact size and relatively good performance
	(see [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript)
	Uses String.prototype.trim instead, if available.
	The fastest but longest version of this function is located at
	dojo.string.trim()</description>
        <return-description>String
	Returns the trimmed string</return-description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <summary>String to be trimmed</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="replace" scope="normal">
        <summary>Performs parameterized substitutions on a string. Throws an
	exception if any parameter is unmatched.</summary>
        <return-description>String
	Returns the substituted string.</return-description>
        <examples>
          <example>	// uses a dictionary for substitutions:
		dojo.replace("Hello, {name.first} {name.last} AKA {nick}!",
		  {
		    nick: "Bob",
		    name: {
		      first:  "Robert",
		      middle: "X",
		      last:   "Cringely"
		    }
		  });
		// returns: Hello, Robert Cringely AKA Bob!</example>
          <example>	// uses an array for substitutions:
		dojo.replace("Hello, {0} {2}!",
		  ["Robert", "X", "Cringely"]);
		// returns: Hello, Robert Cringely!</example>
          <example>	// uses a function for substitutions:
		function sum(a){
		  var t = 0;
		  dojo.forEach(a, function(x){ t += x; });
		  return t;
		}
		dojo.replace(
		  "{count} payments averaging {avg} USD per payment.",
		  dojo.hitch(
		    { payments: [11, 16, 12] },
		    function(_, key){
		      switch(key){
		        case "count": return this.payments.length;
		        case "min":   return Math.min.apply(Math, this.payments);
		        case "max":   return Math.max.apply(Math, this.payments);
		        case "sum":   return sum(this.payments);
		        case "avg":   return sum(this.payments) / this.payments.length;
		      }
		    }
		  )
		);
		// prints: 3 payments averaging 13 USD per payment.</example>
          <example>	// uses an alternative PHP-like pattern for substitutions:
		dojo.replace("Hello, ${0} ${2}!",
		  ["Robert", "X", "Cringely"], /\$\{([^\}]+)\}/g);
		// returns: Hello, Robert Cringely!</example>
        </examples>
        <parameters>
          <parameter name="tmpl" type="String" usage="required">
            <summary>String to be used as a template.</summary>
          </parameter>
          <parameter name="map" type="Object|Function" usage="required">
            <summary>If an object, it is used as a dictionary to look up substitutions.
	If a function, it is called for every substitution with following
	parameters: a whole match, a name, an offset, and the whole template
	string (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replace
	for more details).</summary>
          </parameter>
          <parameter name="pattern" type="RegEx" usage="optional">
            <summary>Optional regular expression objects that overrides the default pattern.
	Must be global and match one item. The default is: /\{([^\}]+)\}/g,
	which matches patterns like that: &amp;quot;{xxx}&amp;quot;, where &amp;quot;xxx&amp;quot; is any sequence
	of characters, which doesn't include &amp;quot;}&amp;quot;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_filterQueryResult" scope="normal">
        <parameters>
          <parameter name="nodeList" type="" usage="required"/>
          <parameter name="simpleFilter" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setContext" scope="normal">
        <summary>changes the behavior of many core Dojo functions that deal with
	namespace and DOM lookup, changing them to work in a new global
	context (e.g., an iframe). The varibles dojo.global and dojo.doc
	are modified as a result of calling this function and the result of
	&lt;code&gt;dojo.body()&lt;/code&gt; likewise differs.</summary>
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="globalDocument" type="DocumentElement" usage="required"/>
        </parameters>
      </method>
      <method name="withGlobal" scope="normal">
        <summary>Invoke callback with globalObject as dojo.global and
	globalObject.document as dojo.doc.</summary>
        <description>Invoke callback with globalObject as dojo.global and
	globalObject.document as dojo.doc. If provided, globalObject
	will be executed in the context of object thisObject
	When callback() returns or throws an error, the dojo.global
	and dojo.doc will be restored to its previous state.</description>
        <parameters>
          <parameter name="globalObject" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="withDoc" scope="normal">
        <summary>Invoke callback with documentObject as dojo.doc.</summary>
        <description>Invoke callback with documentObject as dojo.doc. If provided,
	callback will be executed in the context of object thisObject
	When callback() returns or throws an error, the dojo.doc will
	be restored to its previous state.</description>
        <parameters>
          <parameter name="documentObject" type="DocumentElement" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
          <parameter name="cbArguments" type="Array" usage="optional"/>
        </parameters>
      </method>
      <method name="fieldToObject" scope="normal">
        <summary>Serialize a form field to a JavaScript object.</summary>
        <description>Returns the value encoded in a form field as
	as a string or an array of strings. Disabled form elements
	and unchecked radio and checkboxes are skipped.	Multi-select
	elements are returned as an array of string values.</description>
        <parameters>
          <parameter name="inputNode" type="DOMNode||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formToObject" scope="normal">
        <summary>Serialize a form node to a JavaScript object.</summary>
        <description>Returns the values encoded in an HTML form as
	string properties in an object which it then returns. Disabled form
	elements, buttons, and other non-value form elements are skipped.
	Multi-select elements are returned as an array of string values.</description>
        <examples>
          <example>This form:
		&lt;form id="test_form"&gt;
			&lt;input type="text" name="blah" value="blah"&gt;
			&lt;input type="text" name="no_value" value="blah" disabled&gt;
			&lt;input type="button" name="no_value2" value="blah"&gt;
			&lt;select type="select" multiple name="multi" size="5"&gt;
				&lt;option value="blah"&gt;blah&lt;/option&gt;
				&lt;option value="thud" selected&gt;thud&lt;/option&gt;
				&lt;option value="thonk" selected&gt;thonk&lt;/option&gt;
			&lt;/select&gt;
		&lt;/form&gt;
	yields this object structure as the result of a call to
	formToObject():
		{
			blah: "blah",
			multi: [
				"thud",
				"thonk"
			]
		};</example>
        </examples>
        <parameters>
          <parameter name="formNode" type="DOMNode||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="objectToQuery" scope="normal">
        <summary>takes a name/value mapping object and returns a string representing
	a URL-encoded version of that object.</summary>
        <examples>
          <example>this object:
		{
			blah: "blah",
			multi: [
				"thud",
				"thonk"
			]
		};
	yields the following query string:
		"blah=blah&amp;multi=thud&amp;multi=thonk"</example>
        </examples>
        <parameters>
          <parameter name="map" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formToQuery" scope="normal">
        <summary>Returns a URL-encoded string representing the form passed as either a
	node or string ID identifying the form to serialize</summary>
        <parameters>
          <parameter name="formNode" type="DOMNode||String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formToJson" scope="normal">
        <summary>Create a serialized JSON string from a form node or string
	ID identifying the form to serialize</summary>
        <parameters>
          <parameter name="formNode" type="DOMNode||String" usage="required"/>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="queryToObject" scope="normal">
        <summary>Create an object representing a de-serialized query section of a
	URL. Query keys with multiple values are returned in an array.</summary>
        <examples>
          <example>This string:
			"foo=bar&amp;foo=baz&amp;thinger=%20spaces%20=blah&amp;zonk=blarg&amp;"
	results in this object structure:
			{
				foo: [ "bar", "baz" ],
				thinger: " spaces =blah",
				zonk: "blarg"
			}
	Note that spaces and other urlencoded entities are correctly
	handled.</example>
        </examples>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_ioSetArgs" scope="normal">
        <summary>sets up the Deferred and ioArgs property on the Deferred so it
	can be used in an io call.</summary>
        <parameters>
          <parameter name="args" type="dojo.__IoArgs" usage="required">
            <summary>The args object passed into the public io call. Recognized properties on
	the args object are:</summary>
          </parameter>
          <parameter name="canceller" type="Function" usage="required">
            <summary>The canceller function used for the Deferred object. The function
	will receive one argument, the Deferred object that is related to the
	canceller.</summary>
          </parameter>
          <parameter name="okHandler" type="Function" usage="required">
            <summary>The first OK callback to be registered with Deferred. It has the opportunity
	to transform the OK response. It will receive one argument -- the Deferred
	object returned from this function.</summary>
          </parameter>
          <parameter name="errHandler" type="Function" usage="required">
            <summary>The first error callback to be registered with Deferred. It has the opportunity
	to do cleanup on an error. It will receive two arguments: error (the
	Error object) and dfd, the Deferred object returned from this function.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_ioCancelAll" scope="normal">
        <summary>Cancels all pending IO requests, regardless of IO type
	(xhr, script, iframe).</summary>
      </method>
      <method name="_ioNotifyStart" scope="normal">
        <summary>If dojo.publish is available, publish topics
	about the start of a request queue and/or the
	the beginning of request.</summary>
        <description>Used by IO transports. An IO transport should
	call this method before making the network connection.</description>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioWatch" scope="normal">
        <summary>Watches the io request represented by dfd to see if it completes.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required">
            <summary>The Deferred object to watch.</summary>
          </parameter>
          <parameter name="validCheck" type="Function" usage="required">
            <summary>Function used to check if the IO request is still valid. Gets the dfd
	object as its only argument.</summary>
          </parameter>
          <parameter name="ioCheck" type="Function" usage="required">
            <summary>Function used to check if basic IO call worked. Gets the dfd
	object as its only argument.</summary>
          </parameter>
          <parameter name="resHandle" type="Function" usage="required">
            <summary>Function used to process response. Gets the dfd
	object as its only argument.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_ioAddQueryToUrl" scope="normal">
        <summary>Adds query params discovered by the io deferred construction to the URL.
	Only use this for operations which are fundamentally GET-type operations.</summary>
        <parameters>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required"/>
        </parameters>
      </method>
      <method name="xhr" scope="normal">
        <summary>Sends an HTTP request with the given method.</summary>
        <description>Sends an HTTP request with the given method.
	See also dojo.xhrGet(), xhrPost(), xhrPut() and dojo.xhrDelete() for shortcuts
	for those HTTP methods. There are also methods for "raw" PUT and POST methods
	via dojo.rawXhrPut() and dojo.rawXhrPost() respectively.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <summary>HTTP method to be used, such as GET, POST, PUT, DELETE.  Should be uppercase.</summary>
          </parameter>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
          <parameter name="hasBody" type="Boolean" usage="optional">
            <summary>If the request has an HTTP body, then pass true for hasBody.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrGet" scope="normal">
        <summary>Sends an HTTP GET request to the server.</summary>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="rawXhrPost" scope="normal"/>
      <method name="xhrPost" scope="normal">
        <summary>Sends an HTTP POST request to the server. In addtion to the properties
	listed for the dojo.__XhrArgs type, the following property is allowed:
	postData:
	String. Send raw data in the body of the POST request.</summary>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="rawXhrPut" scope="normal"/>
      <method name="xhrPut" scope="normal">
        <summary>Sends an HTTP PUT request to the server. In addtion to the properties
	listed for the dojo.__XhrArgs type, the following property is allowed:
	putData:
	String. Send raw data in the body of the PUT request.</summary>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="xhrDelete" scope="normal">
        <summary>Sends an HTTP DELETE request to the server.</summary>
        <parameters>
          <parameter name="args" type="dojo.__XhrArgs" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="__backArgs" scope="normal">
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hash" scope="normal">
        <summary>Gets or sets the hash string.</summary>
        <description>Handles getting and setting of location.hash.
	- If no arguments are passed, acts as a getter.
	- If a string is passed, acts as a setter.</description>
        <return-description>when used as a getter, returns the current hash string.
	when used as a setter, returns the new hash string.</return-description>
        <parameters>
          <parameter name="hash" type="String" usage="optional">
            <summary>String: the hash is set - #string.</summary>
          </parameter>
          <parameter name="replace" type="Boolean" usage="optional">
            <summary>Boolean: If true, updates the hash value in the current history
	state instead of creating a new history state.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="node.ownerDocument">
    <properties>
      <property name="documentElement" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojo.doc">
    <summary>Alias for the current document. 'dojo.doc' can be modified
	for temporary context shifting. Also see dojo.withDoc().</summary>
    <description>Refer to dojo.doc rather
	than referring to 'window.document' to ensure your code runs
	correctly in managed contexts.</description>
    <examples>
      <example>	n.appendChild(dojo.doc.createElement('div'));</example>
    </examples>
  </object>
  <object location="node.ownerDocument.body">
    <properties>
      <property name="parentNode" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojo.doc.body">
    <properties>
      <property name="parentNode" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="Math" type="">
    <properties>
      <property name="floor" scope="normal" type=""/>
      <property name="max" scope="normal" type=""/>
      <property name="min" scope="normal" type=""/>
      <property name="PI" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojo.doc.documentElement">
    <properties>
      <property name="className" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dijit.typematic">
    <summary>These functions are used to repetitively call a user specified callback
	method when a specific key or mouse click over a specific DOM node is
	held down for a specific amount of time.
	Only 1 such event is allowed to occur on the browser page at 1 time.</summary>
    <methods>
      <method name="addKeyListener" scope="normal">
        <summary>Start listening for a specific typematic key.
	See also the trigger method for other parameters.</summary>
        <return-description>an array of dojo.connect handles</return-description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="keyObject" type="Object" usage="required">
            <summary>an object defining the key to listen for.
	charOrCode:
	the printable character (string) or keyCode (number) to listen for.
	keyCode:
	(deprecated - use charOrCode) the keyCode (number) to listen for (implies charCode = 0).
	charCode:
	(deprecated - use charOrCode) the charCode (number) to listen for.
	ctrlKey:
	desired ctrl key state to initiate the calback sequence:
	- pressed (true)
	- released (false)
	- either (unspecified)
	altKey:
	same as ctrlKey but for the alt key
	shiftKey:
	same as ctrlKey but for the shift key</summary>
          </parameter>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="addMouseListener" scope="normal">
        <summary>Start listening for a typematic mouse click.
	See the trigger method for other parameters.</summary>
        <return-description>an array of dojo.connect handles</return-description>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="addListener" scope="normal">
        <summary>Start listening for a specific typematic key and mouseclick.
	This is a thin wrapper to addKeyListener and addMouseListener.
	See the addMouseListener and addKeyListener methods for other parameters.</summary>
        <return-description>an array of dojo.connect handles</return-description>
        <parameters>
          <parameter name="mouseNode" type="Node" usage="required">
            <summary>the DOM node object to listen on for mouse events.</summary>
          </parameter>
          <parameter name="keyNode" type="Node" usage="required">
            <summary>the DOM node object to listen on for key events.</summary>
          </parameter>
          <parameter name="keyObject" type="Object" usage="required"/>
          <parameter name="_this" type="Object" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="subsequentDelay" type="Number" usage="required"/>
          <parameter name="initialDelay" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.typematic._fireEventAndReload" type="Function" classlike="true" private="true">
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_currentTimeout" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.typematic.trigger" type="Function" classlike="true">
    <summary>Start a timed, repeating callback sequence.
	If already started, the function call is ignored.
	This method is not normally called by the user but can be
	when the normal listener code is insufficient.</summary>
    <properties>
      <property name="_initialDelay" scope="instance" type="Number"/>
      <property name="_subsequentDelay" scope="instance" type="Number"/>
      <property name="_obj" scope="instance" type=""/>
      <property name="_evt" scope="instance" type=""/>
      <property name="_node" scope="instance" type=""/>
      <property name="_currentTimeout" scope="instance" type="Number"/>
      <property name="_count" scope="instance" type="Number"/>
      <property name="_callback" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>key or mouse event object</summary>
          </parameter>
          <parameter name="_this" type="Object" usage="required">
            <summary>pointer to the user's widget space.</summary>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <summary>the DOM node object passed in</summary>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <summary>function to call until the sequence is stopped called with 3 parameters:
	count:
	integer representing number of repeated calls (0..n) with -1 indicating the iteration has stopped</summary>
          </parameter>
          <parameter name="obj" type="Object" usage="required">
            <summary>user space object used to uniquely identify each typematic sequence</summary>
          </parameter>
          <parameter name="subsequentDelay" type="Number" usage="required">
            <summary>if &amp;gt; 1, the number of milliseconds until the 3-&amp;gt;n events occur
	or else the fractional time multiplier for the next event's delay, default=0.9</summary>
          </parameter>
          <parameter name="initialDelay" type="Number" usage="required">
            <summary>the number of milliseconds until the 2nd event occurs, default=500ms</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.typematic.stop" type="Function" classlike="true">
    <summary>Stop an ongoing timed, repeating callback sequence.</summary>
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
      <property name="_obj" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.wai">
    <methods>
      <method name="onload" scope="normal">
        <summary>Detects if we are in high-contrast mode or not</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.RichText" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features.</summary>
    <description>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features. It also encapsulates the differences
	of different js engines for various browsers.  Do not use this widget
	with an HTML &amp;lt;TEXTAREA&amp;gt; tag, since the browser unescapes XML escape characters,
	like &amp;lt;.  This can have unexpected behavior and lead to security issues
	such as scripting attacks.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="inheritWidth" scope="prototype" type="Boolean">
        <summary>whether to inherit the parent's width or simply use 100%</summary>
      </property>
      <property name="focusOnLoad" scope="prototype" type="Boolean">
        <summary>Focus into this widget when the page is loaded</summary>
      </property>
      <property name="name" scope="prototype" type="String">
        <summary>Specifies the name of a (hidden) &amp;lt;textarea&amp;gt; node on the page that's used to save
	the editor content on page leave.   Used to restore editor contents after navigating
	to a new page and then hitting the back button.</summary>
      </property>
      <property name="styleSheets" scope="prototype" type="String">
        <summary>semicolon (&amp;quot;;&amp;quot;) separated list of css files for the editing area</summary>
      </property>
      <property name="_content" scope="prototype" type="String">
        <summary>temporary content storage</summary>
      </property>
      <property name="height" scope="prototype" type="String">
        <summary>Set height to fix the editor at a specific height, with scrolling.
	By default, this is 300px.  If you want to have the editor always
	resizes to accommodate the content, use AlwaysShowToolbar plugin
	and set height=&amp;quot;&amp;quot;.  If this editor is used within a layout widget,
	set height=&amp;quot;100%&amp;quot;.</summary>
      </property>
      <property name="minHeight" scope="prototype" type="String">
        <summary>The minimum height that the editor should have.</summary>
      </property>
      <property name="isClosed" scope="prototype" type="Boolean"/>
      <property name="isLoaded" scope="prototype" type="Boolean"/>
      <property name="_SEPARATOR" scope="prototype" type="String">
        <summary>Used to concat contents from multiple editors into a single string,
	so they can be saved into a single &amp;lt;textarea&amp;gt; node.  See &amp;quot;name&amp;quot; attribute.</summary>
      </property>
      <property name="onLoadDeferred" scope="instance-prototype" type="dojo.Deferred">
        <summary>Deferred which is fired when the editor finishes loading</summary>
      </property>
      <property name="isTabIndent" scope="prototype" type="Boolean">
        <summary>Make tab key and shift-tab indent and outdent rather than navigating.
	Caution: sing this makes web pages inaccessible to users unable to use a mouse.</summary>
      </property>
      <property name="disableSpellCheck" scope="prototype" type="Boolean">
        <summary>When true, disables the browser's native spell checking, if supported.
	Works only in Firefox.</summary>
      </property>
      <property name="events" scope="instance-prototype" type="String[]">
        <summary>events which should be connected to the underlying editing area</summary>
      </property>
      <property name="captureEvents" scope="prototype" type="String[]">
        <summary>Events which should be connected to the underlying editing
	area, events in this array will be addListener with
	capture=true.
	TODO: looking at the code I don't see any distinction between events and captureEvents,
	so get rid of this for 2.0 if not sooner</summary>
      </property>
      <property name="_editorCommandsLocalized" scope="prototype" type="Object"/>
      <property name="_oldHeight" scope="prototype" type=""/>
      <property name="_oldWidth" scope="prototype" type=""/>
      <property name="savedContent" scope="prototype" type=""/>
      <property name="editingArea" scope="prototype" type="Object"/>
      <property name="editorObject" scope="prototype" type="Object"/>
      <property name="_iframeSrc" scope="prototype" type="Object"/>
      <property name="_local2NativeFormatNames" scope="prototype" type="Object"/>
      <property name="_native2LocalFormatNames" scope="prototype" type="Object"/>
      <property name="_cursorToStart" scope="prototype" type="Object"/>
      <property name="editingAreaStyleSheets" scope="instance-prototype" type="Array"/>
      <property name="disabled" scope="prototype" type="Boolean">
        <summary>The editor is disabled; the text cannot be changed.</summary>
      </property>
      <property name="_disabledOK" scope="prototype" type="Object"/>
      <property name="_iframeRegHandle" scope="prototype" type="Object"/>
      <property name="tabStop" scope="prototype" type="Object"/>
      <property name="focusNode" scope="prototype" type=""/>
      <property name="_webkitListener" scope="prototype" type="Object"/>
      <property name="_onKeyHitch" scope="prototype" type="Object"/>
      <property name="updateInterval" scope="prototype" type="Number"/>
      <property name="_updateTimer" scope="prototype" type="Object"/>
      <property name="_updateHandler" scope="prototype" type="Object"/>
      <property name="_qcaCache" scope="prototype" type="Object"/>
      <property name="__overflow" scope="prototype" type="Object"/>
      <property name="contentPreFilters" scope="instance" type="Function(String)[]">
        <summary>Pre content filter function register array.
	these filters will be executed before the actual
	editing area gets the html content.</summary>
      </property>
      <property name="contentPostFilters" scope="instance" type="Array"/>
      <property name="contentDomPreFilters" scope="instance" type="Array"/>
      <property name="contentDomPostFilters" scope="instance" type="Array"/>
      <property name="_keyHandlers" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features.</summary>
        <description>dijit._editor.RichText is the core of dijit.Editor, which provides basic
	WYSIWYG editing features. It also encapsulates the differences
	of different js engines for various browsers.  Do not use this widget
	with an HTML &amp;lt;TEXTAREA&amp;gt; tag, since the browser unescapes XML escape characters,
	like &amp;lt;.  This can have unexpected behavior and lead to security issues
	such as scripting attacks.</description>
        <parameters>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="setupDefaultShortcuts" scope="prototype">
        <summary>Add some default key handlers</summary>
        <description>Overwrite this to setup your own handlers. The default
	implementation does not use Editor commands, but directly
	executes the builtin commands within the underlying browser
	support.</description>
      </method>
      <method name="_localizeEditorCommands" scope="prototype">
        <summary>When IE is running in a non-English locale, the API actually changes,
	so that we have to say (for example) danraku instead of p (for paragraph).
	Handle that here.</summary>
      </method>
      <method name="open" scope="prototype">
        <summary>Transforms the node referenced in this.domNode into a rich text editing
	node.</summary>
        <description>Sets up the editing area asynchronously. This will result in
	the creation and replacement with an &lt;iframe&gt;.
	A dojo.Deferred object is created at this.onLoadDeferred, and
	users may attach to it to be informed when the rich-text area
	initialization is finalized.</description>
        <parameters>
          <parameter name="element" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="_getIframeDocTxt" scope="prototype">
        <summary>Generates the boilerplate text of the document inside the iframe (ie, &amp;lt;html&amp;gt;&amp;lt;head&amp;gt;...&amp;lt;/head&amp;gt;&amp;lt;body/&amp;gt;&amp;lt;/html&amp;gt;).
	Editor content (if not blank) should be added afterwards.</summary>
      </method>
      <method name="_applyEditingAreaStyleSheets" scope="prototype">
        <summary>apply the specified css files in styleSheets</summary>
      </method>
      <method name="addStyleSheet" scope="prototype">
        <summary>add an external stylesheet for the editing area</summary>
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required">
            <summary>A dojo.uri.Uri pointing to the url of the external css file</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeStyleSheet" scope="prototype">
        <summary>remove an external stylesheet for the editing area</summary>
        <parameters>
          <parameter name="uri" type="dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="this method requires init to be complete"/>
          <return-type type="! _disabledOK"/>
        </return-types>
      </method>
      <method name="onLoad" scope="prototype">
        <summary>Handler after the iframe finishes loading.</summary>
        <parameters>
          <parameter name="html" type="String" usage="required">
            <summary>Editor contents should be set to this value</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <summary>Handler for onkeydown event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="prototype">
        <summary>Handler for onkeyup event</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="prototype">
        <summary>Deprecated, use attr('disabled', ...) instead.</summary>
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Registers that attr(&amp;quot;value&amp;quot;, foo) should call setValue(foo)</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisableSpellCheckAttr" scope="prototype">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPress" scope="prototype">
        <summary>Handle the various key events</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addKeyHandler" scope="prototype">
        <summary>Add a handler for a keyboard shortcut</summary>
        <description>The key argument should be in lowercase if it is a letter character</description>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="ctrl" type="Boolean" usage="required"/>
          <parameter name="shift" type="Boolean" usage="required"/>
          <parameter name="handler" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPressed" scope="prototype">
        <summary>Handler for after the user has pressed a key, and the display has been updated.
	(Runs on a timer so that it runs after the display is updated)</summary>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Handler for when the user clicks.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onIEMouseDown" scope="prototype">
        <summary>IE only to prevent 2 clicks to focus</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>Called from focus manager when focus has moved away from this editor</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype">
        <summary>Called from focus manager when focus has moved into this editor</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="blur" scope="prototype">
        <summary>Remove focus from this instance.</summary>
      </method>
      <method name="focus" scope="prototype">
        <summary>Move focus to this editor</summary>
      </method>
      <method name="onDisplayChanged" scope="prototype">
        <summary>This event will be fired everytime the display context
	changes and the result needs to be reflected in the UI.</summary>
        <description>If you don't want to have update too often,
	onNormalizedDisplayChanged should be used instead</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onNormalizedDisplayChanged" scope="prototype">
        <summary>This event is fired every updateInterval ms or more</summary>
        <description>If something needs to happen immediately after a
	user change, please use onDisplayChanged instead.</description>
      </method>
      <method name="onChange" scope="prototype">
        <summary>This is fired if and only if the editor loses focus and
	the content is changed.</summary>
        <parameters>
          <parameter name="newContent" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeCommand" scope="prototype">
        <summary>Used as the advice function by dojo.connect to map our
	normalized set of commands to those supported by the target
	browser.</summary>
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
          <parameter name="argument" type="Anything" usage="optional"/>
        </parameters>
      </method>
      <method name="queryCommandAvailable" scope="prototype">
        <summary>Tests whether a command is supported by the host. Clients
	SHOULD check whether a command is supported before attempting
	to use it, behaviour for unsupported commands is undefined.</summary>
        <parameters>
          <parameter name="command" type="String" usage="required">
            <summary>The command to test for</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_queryCommandAvailable" scope="prototype">
        <summary>See queryCommandAvailable().</summary>
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="execCommand" scope="prototype">
        <summary>Executes a command in the Rich Text area</summary>
        <parameters>
          <parameter name="command" type="String" usage="required">
            <summary>The command to execute</summary>
          </parameter>
          <parameter name="argument" type="An" usage="required">
            <summary>optional argument to the command</summary>
          </parameter>
        </parameters>
      </method>
      <method name="queryCommandEnabled" scope="prototype">
        <summary>Check whether a command is enabled or not.</summary>
        <parameters>
          <parameter name="command" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandState" scope="prototype">
        <summary>Check the state of a given command and returns true or false.</summary>
        <parameters>
          <parameter name="command" type="" usage="required"/>
        </parameters>
      </method>
      <method name="queryCommandValue" scope="prototype">
        <summary>Check the value of a given command. This matters most for
	custom selections and complex values like font value setting.</summary>
        <parameters>
          <parameter name="command" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_sCall" scope="prototype">
        <summary>Run the named method of dijit._editor.selection over the
	current editor instance's window, with the passed args.</summary>
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="placeCursorAtStart" scope="prototype">
        <summary>Place the cursor at the start of the editing area.</summary>
      </method>
      <method name="placeCursorAtEnd" scope="prototype">
        <summary>Place the cursor at the end of the editing area.</summary>
      </method>
      <method name="getValue" scope="prototype">
        <summary>Return the current content of the editing area (post filters
	are applied).  Users should call attr('value') instead.</summary>
        <parameters>
          <parameter name="nonDestructive" type="Boolean" usage="optional">
            <summary>defaults to false. Should the post-filtering be run over a copy
	of the live DOM? Most users should pass &amp;quot;true&amp;quot; here unless they
	*really* know that none of the installed filters are going to
	mess up the editing session.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>Hook to make attr(&amp;quot;value&amp;quot;) work</summary>
      </method>
      <method name="setValue" scope="prototype">
        <summary>This function sets the content. No undo history is preserved.
	Users should use attr('value', ...) instead.</summary>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="replaceValue" scope="prototype">
        <summary>This function set the content while trying to maintain the undo stack
	(now only works fine with Moz, this is identical to setValue in all
	other browsers)</summary>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFilterContent" scope="prototype">
        <summary>Filter the input before setting the content of the editing
	area. DOM pre-filtering may happen after this
	string-based filtering takes place but as of 1.2, this is not
	guaranteed for operations such as the inserthtml command.</summary>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preDomFilterContent" scope="prototype">
        <summary>filter the input's live DOM. All filter operations should be
	considered to be &amp;quot;live&amp;quot; and operating on the DOM that the user
	will be interacting with in their editing session.</summary>
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_postFilterContent" scope="prototype">
        <summary>filter the output after getting the content of the editing area</summary>
        <description>post-filtering allows plug-ins and users to specify any number
	of transforms over the editor's content, enabling many common
	use-cases such as transforming absolute to relative URLs (and
	vice-versa), ensuring conformance with a particular DTD, etc.
	The filters are registered in the contentDomPostFilters and
	contentPostFilters arrays. Each item in the
	contentDomPostFilters array is a function which takes a DOM
	Node or array of nodes as its only argument and returns the
	same. It is then passed down the chain for further filtering.
	The contentPostFilters array behaves the same way, except each
	member operates on strings. Together, the DOM and string-based
	filtering allow the full range of post-processing that should
	be necessaray to enable even the most agressive of post-editing
	conversions to take place.
	If nonDestructive is set to "true", the nodes are cloned before
	filtering proceeds to avoid potentially destructive transforms
	to the content which may still needed to be edited further.
	Once DOM filtering has taken place, the serialized version of
	the DOM which is passed is run through each of the
	contentPostFilters functions.</description>
        <parameters>
          <parameter name="dom" type="DomNode|DomNode[]|String" usage="optional">
            <summary>a node, set of nodes, which to filter using each of the current
	members of the contentDomPostFilters and contentPostFilters arrays.</summary>
          </parameter>
          <parameter name="nonDestructive" type="Boolean" usage="optional">
            <summary>defaults to &amp;quot;false&amp;quot;. If true, ensures that filtering happens on
	a clone of the passed-in content and not the actual node
	itself.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_saveContent" scope="prototype">
        <summary>Saves the content in an onunload event if the editor has not been closed</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="escapeXml" scope="prototype">
        <summary>Adds escape sequences for special characters in XML: &amp;amp;&amp;lt;&amp;gt;&amp;quot;'
	Optionally skips escapes for single quotes</summary>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="noSingleQuotes" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getNodeHtml" scope="prototype">
        <summary>Deprecated.   Use dijit._editor._getNodeHtml() instead.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getNodeChildrenHtml" scope="prototype">
        <summary>Deprecated.   Use dijit._editor.getChildrenHtml() instead.</summary>
        <parameters>
          <parameter name="dom" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>Kills the editor and optionally writes back the modified contents to the
	element from which it originated.</summary>
        <parameters>
          <parameter name="save" type="Boolean" usage="required">
            <summary>Whether or not to save the changes. If false, the changes are discarded.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean: whether the content has been modified"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="_removeMozBogus" scope="prototype">
        <summary>Post filter to remove unwanted HTML attributes generated by mozilla</summary>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_removeWebkitBogus" scope="prototype">
        <summary>Post filter to remove unwanted HTML attributes generated by webkit</summary>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_normalizeFontStyle" scope="prototype">
        <summary>Convert &amp;lt;strong&amp;gt; and &amp;lt;em&amp;gt; to &amp;lt;b&amp;gt; and &amp;lt;i&amp;gt;.</summary>
        <description>Moz can not handle strong/em tags correctly, so to help
	mozilla and also to normalize output, convert them to &lt;b&gt; and &lt;i&gt;.
	Note the IE generates &lt;strong&gt; and &lt;em&gt; rather than &lt;b&gt; and &lt;i&gt;</description>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_preFixUrlAttributes" scope="prototype">
        <summary>Pre-filter to do fixing to href attributes on &amp;lt;a&amp;gt; and &amp;lt;img&amp;gt; tags</summary>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_inserthorizontalruleImpl" scope="prototype">
        <summary>This function implements the insertion of HTML &amp;lt;HR&amp;gt; tags.
	into a point on the page.  IE doesn't to it right, so
	we have to use an alternate form</summary>
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <summary>to the exec command, if any.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_unlinkImpl" scope="prototype">
        <summary>This function implements the unlink of an &amp;lt;a&amp;gt; tag.</summary>
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <summary>to the exec command, if any.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_hilitecolorImpl" scope="prototype">
        <summary>This function implements the hilitecolor command</summary>
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <summary>to the exec command, if any.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_backcolorImpl" scope="prototype">
        <summary>This function implements the backcolor command</summary>
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <summary>to the exec command, if any.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_forecolorImpl" scope="prototype">
        <summary>This function implements the forecolor command</summary>
        <parameters>
          <parameter name="argument" type="arguments" usage="required">
            <summary>to the exec command, if any.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_inserthtmlImpl" scope="prototype">
        <summary>This function implements the insertion of HTML content into
	a point on the page.</summary>
        <parameters>
          <parameter name="argument" type="The" usage="required">
            <summary>content to insert, if any.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.RichText._mozSettingProps" private="true">
    <properties>
      <property name="styleWithCSS" scope="normal" type="bool"/>
    </properties>
  </object>
  <object location="dijit._editor.RichText.editNode">
    <properties>
      <property name="unselectable" scope="prototype" type="String"/>
      <property name="contentEditable" scope="prototype" type="bool"/>
    </properties>
  </object>
  <object location="dijit._editor.RichText.document">
    <properties>
      <property name="designMode" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._editor.RichText.window">
    <properties>
      <property name="__registeredWindow" scope="prototype" type="Object"/>
      <property name="_frameElement" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit._editor.RichText.iframe">
    <properties>
      <property name="onfocus" scope="prototype" type="Object"/>
      <property name="_loadFunc" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit._editor.RichText.editNode.style" type="">
    <properties>
      <property name="zoom" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dijit._editor.RichText.textarea" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._editor.RichText.textarea.style" type="">
    <properties>
      <property name="position" scope="prototype" type="String"/>
      <property name="left" scope="prototype" type="String"/>
      <property name="top" scope="prototype" type="String"/>
      <property name="overflow" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._editor.RichText.domNode">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._editor._Plugin.button.domNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit._editor.plugins"/>
  <object location="dijit._editor.plugins.AlwaysShowToolbar" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin is required for Editors in auto-expand mode.
	It handles the auto-expansion as the user adds/deletes text,
	and keeps the editor's toolbar visible even when the top of the editor
	has scrolled off the top of the viewport (usually when editing a long
	document).</summary>
    <description>Specify this in extraPlugins (or plugins) parameter and also set
	height to "".</description>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dijit.Editor" height=""
		extraPlugins="['dijit._editor.plugins.AlwaysShowToolbar']"&gt;</example>
    </examples>
    <properties>
      <property name="_handleScroll" scope="prototype" type="Boolean">
        <summary>Enables/disables the handler for scroll events</summary>
      </property>
      <property name="editor" scope="prototype" type=""/>
      <property name="_lastHeight" scope="prototype" type="Integer">
        <summary>Height in px of the editor at the last time we did sizing</summary>
      </property>
      <property name="_scrollSetUp" scope="prototype" type="Object"/>
      <property name="_scrollThreshold" scope="prototype" type=""/>
      <property name="_IEOriginalPos" scope="prototype" type="Object"/>
      <property name="_fixEnabled" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setEditor" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="enable" scope="prototype">
        <summary>Enable plugin.  Called when Editor has finished initializing.</summary>
        <parameters>
          <parameter name="d" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateHeight" scope="prototype">
        <summary>Updates the height of the editor area to fit the contents.</summary>
        <return-types>
          <return-type type="prevent setting height to 0"/>
        </return-types>
      </method>
      <method name="globalOnScrollHandler" scope="prototype">
        <summary>Handler for scroll events that bubbled up to &amp;lt;html&amp;gt;</summary>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit._editor.plugins.AlwaysShowToolbar.editor.toolbar" type=""/>
  <object location="dijit._editor.plugins.AlwaysShowToolbar.editor.toolbar.domNode" type=""/>
  <object location="dijit._editor.plugins.AlwaysShowToolbar.editor.iframe.style" type="">
    <properties>
      <property name="marginTop" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit._editor.plugins.AlwaysShowToolbar.editor.toolbar.domNode.style" type="">
    <properties>
      <property name="left" scope="prototype" type="String"/>
      <property name="position" scope="prototype" type="String"/>
      <property name="top" scope="prototype" type="String"/>
      <property name="zIndex" scope="prototype" type="String"/>
      <property name="display" scope="prototype" type="String"/>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit._editor.plugins.EnterKeyHandling" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin tries to make all browsers behave consistently w.r.t
	displaying paragraphs, specifically dealing with when the user presses
	the ENTER key.
	It deals mainly with how the text appears on the screen (specifically
	address the double-spaced line problem on IE), but also has some code
	to normalize what attr('value') returns.</summary>
    <description>This plugin has three modes:
	* blockModeForEnter=BR
	* blockModeForEnter=DIV
	* blockModeForEnter=P
	In blockModeForEnter=P, the ENTER key semantically means "start a new
	paragraph", whereas shift-ENTER means  "new line in the current paragraph".
	For example:
		first paragraph &lt;shift-ENTER&gt;
		second line of first paragraph &lt;ENTER&gt;
		second paragraph
	In the other two modes, the ENTER key means to go to a new line in the
	current paragraph, and users [visually] create a new paragraph by pressing ENTER twice.
	For example, if the user enters text into an editor like this:
			one &lt;ENTER&gt;
			two &lt;ENTER&gt;
			three &lt;ENTER&gt;
			&lt;ENTER&gt;
			four &lt;ENTER&gt;
			five &lt;ENTER&gt;
			six &lt;ENTER&gt;
	It will appear on the screen as two paragraphs of three lines each.
	blockNodeForEnter=BR
	--------------------
	On IE, typing the above keystrokes in the editor will internally produce DOM of:
			&lt;p&gt;one&lt;/p&gt;
			&lt;p&gt;two&lt;/p&gt;
			&lt;p&gt;three&lt;/p&gt;
			&lt;p&gt;&lt;/p&gt;
			&lt;p&gt;four&lt;/p&gt;
			&lt;p&gt;five&lt;/p&gt;
			&lt;p&gt;six&lt;/p&gt;
	However, blockNodeForEnter=BR makes the Editor on IE display like other browsers, by
	changing the CSS for the &lt;p&gt; node to not have top/bottom margins,
	thus eliminating the double-spaced appearance.
	Also, attr('value') when used w/blockNodeForEnter=br on IE will return:
		&lt;p&gt; one &lt;br&gt; two &lt;br&gt; three &lt;/p&gt;
		&lt;p&gt; four &lt;br&gt; five &lt;br&gt; six &lt;/p&gt;
	This output normalization implemented by a filter when the
	editor writes out it's data, to convert consecutive &lt;p&gt;
	nodes into a single &lt;p&gt; node with internal &lt;br&gt; separators.
	There's also a pre-filter to mirror the post-filter.
	It converts a single &lt;p&gt; with &lt;br&gt; line breaks
	into separate &lt;p&gt; nodes, and creates empty &lt;p&gt; nodes for spacing
	between paragraphs.
	On FF typing the above keystrokes will internally generate:
			one &lt;br&gt; two &lt;br&gt; three &lt;br&gt; &lt;br&gt; four &lt;br&gt; five &lt;br&gt; six &lt;br&gt;
	And on Safari it will generate:
			"one"
			&lt;div&gt;two&lt;/div&gt;
			&lt;div&gt;three&lt;/div&gt;
			&lt;div&gt;&lt;br&gt;&lt;/div&gt;
			&lt;div&gt;four&lt;/div&gt;
			&lt;div&gt;five&lt;/div&gt;
			&lt;div&gt;six&lt;/div&gt;
	Thus, Safari and FF already look correct although semantically their content is a bit strange.
	On Safari or Firefox blockNodeForEnter=BR uses the builtin editor command "insertBrOnReturn",
	but that doesn't seem to do anything.
	Thus, attr('value') on safari/FF returns the browser-specific HTML listed above,
	rather than the semantically meaningful value that IE returns: &lt;p&gt;one&lt;br&gt;two&lt;/p&gt; &lt;p&gt;three&lt;br&gt;four&lt;/p&gt;.
	(Note: originally based on http://bugs.dojotoolkit.org/ticket/2859)
	blockNodeForEnter=P
	-------------------
	Plugin will monitor keystrokes and update the editor's content on the fly,
	so that the ENTER key will create a new &lt;p&gt; on FF and Safari (it already
	works that way by default on IE).
	blockNodeForEnter=DIV
	---------------------
	Follows the same code path as blockNodeForEnter=P but inserting a &lt;div&gt;
	on ENTER key.  Although it produces strange internal DOM, like this:
		&lt;div&gt;paragraph one&lt;/div&gt;
		&lt;div&gt;paragraph one, line 2&lt;/div&gt;
		&lt;div&gt;&amp;nbsp;&lt;/div&gt;
		&lt;div&gt;paragraph two&lt;/div&gt;
	it does provide a consistent look on all browsers, and the on-the-fly DOM updating
	can be useful for collaborative editing.</description>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="blockNodeForEnter" scope="prototype" type="String">
        <summary>This property decides the behavior of Enter key. It can be either P,
	DIV, BR, or empty (which means disable this feature). Anything else
	will trigger errors.
	See class description for more details.</summary>
      </property>
      <property name="_checkListLater" scope="prototype" type="bool"/>
      <property name="bogusHtmlContent" scope="prototype" type="String">
        <summary>HTML to stick into a new empty block</summary>
      </property>
      <property name="blockNodes" scope="prototype" type="Regex">
        <summary>Regex for testing if a given tag is a block level (display:block) tag</summary>
      </property>
      <property name="_pressedEnterInBlock" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="prototype">
        <parameters>
          <parameter name="editor" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyPressed" scope="prototype">
        <summary>Handler for keypress events.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="handleEnterKey" scope="prototype">
        <summary>Handler for enter key events when blockModeForEnter is DIV or P.</summary>
        <description>Manually handle enter key event to make the behavior consistent across
	all supported browsers. See class description for details.</description>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="let browser handle"/>
        </return-types>
      </method>
      <method name="removeTrailingBr" scope="prototype">
        <summary>If last child of container is a &amp;lt;br&amp;gt;, then remove it.</summary>
        <parameters>
          <parameter name="container" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fixNewLineBehaviorForIE" scope="prototype">
        <summary>Insert CSS so &amp;lt;p&amp;gt; nodes don't have spacing around them,
	thus hiding the fact that ENTER key on IE is creating new
	paragraphs</summary>
        <parameters>
          <parameter name="d" type="" usage="required"/>
        </parameters>
      </method>
      <method name="regularPsToSingleLinePs" scope="prototype">
        <summary>Converts a &amp;lt;p&amp;gt; node containing &amp;lt;br&amp;gt;'s into multiple &amp;lt;p&amp;gt; nodes.</summary>
        <description>See singleLinePsToRegularPs().   This method does the
	opposite thing, and is used as a pre-filter when loading the
	editor, to mirror the effects of the post-filter at end of edit.</description>
        <parameters>
          <parameter name="element" type="" usage="required"/>
          <parameter name="noWhiteSpaceInEmptyP" type="" usage="required"/>
        </parameters>
      </method>
      <method name="singleLinePsToRegularPs" scope="prototype">
        <summary>Called as post-filter.
	Apparently collapses adjacent &amp;lt;p&amp;gt; nodes into a single &amp;lt;p&amp;gt;
	nodes with &amp;lt;br&amp;gt; separating each line.</summary>
        <examples>
          <example>Given this input:
		&lt;p&gt;line 1&lt;/p&gt;
		&lt;p&gt;line 2&lt;/p&gt;
		&lt;ol&gt;
			&lt;li&gt;item 1
			&lt;li&gt;item 2
		&lt;/ol&gt;
		&lt;p&gt;line 3&lt;/p&gt;
		&lt;p&gt;line 4&lt;/p&gt;
	Will convert to:
		&lt;p&gt;line 1&lt;br&gt;line 2&lt;/p&gt;
		&lt;ol&gt;
			&lt;li&gt;item 1
			&lt;li&gt;item 2
		&lt;/ol&gt;
		&lt;p&gt;line 3&lt;br&gt;line 4&lt;/p&gt;
	Not sure why this situation would even come up after the pre-filter and
	the enter-key-handling code.</example>
        </examples>
        <parameters>
          <parameter name="element" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.EnterKeyHandling.editor" type=""/>
  <object location="dijit._editor.plugins.EnterKeyHandling.editor.document" type="">
    <properties>
      <property name="__INSERTED_EDITIOR_NEWLINE_CSS" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit._editor.plugins._FontDropDown" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Base class for widgets that contains a label (like &amp;quot;Font:&amp;quot;)
	and a FilteringSelect drop down to pick a value.
	Used as Toolbar entry.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="label" scope="prototype" type="String">
        <summary>The label to apply to this particular FontDropDown.</summary>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="boolean">
        <summary>Over-ride denoting the template has widgets to parse.</summary>
      </property>
      <property name="plainText" scope="prototype" type="boolean">
        <summary>Flag to indicate that the returned label should be plain text
	instead of an example.</summary>
      </property>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template used to construct the labeled dropdown.</summary>
      </property>
      <property name="strings" scope="prototype" type="Object"/>
      <property name="id" scope="prototype" type="Object"/>
      <property name="selectId" scope="prototype" type="String"/>
      <property name="disabled" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype">
        <summary>Over-ride to misin specific properties.</summary>
      </method>
      <method name="postCreate" scope="prototype">
        <summary>Over-ride for the default postCreate action
	This establishes the filtering selects and the like.</summary>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Over-ride for the default action of setting the
	widget value, maps the input to known values</summary>
        <parameters>
          <parameter name="value" type="Object|String" usage="required">
            <summary>The value to set in the select.</summary>
          </parameter>
          <parameter name="priorityChange" type="Optional" usage="required">
            <summary>parameter used to tell the select whether or not to fire
	onChange event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>Allow retreving the value from the composite select on
	call to button.attr(&amp;quot;value&amp;quot;);</summary>
      </method>
      <method name="focus" scope="prototype">
        <summary>Over-ride for focus control of this widget.  Delegates focus down to the
	filtering select.</summary>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>Over-ride for the button's 'disabled' attribute so that it can be
	disabled programmatically.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins._FontDropDown.select" type="">
    <properties>
      <property name="store" scope="prototype" type="Object"/>
      <property name="_lastValueReported" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit._editor.plugins._FontNameDropDown" type="Function" classlike="true" superclass="dijit._editor.plugins._FontDropDown">
    <summary>Dropdown to select a font; goes in editor toolbar.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor.plugins._FontDropDown"/>
    </mixins>
    <properties>
      <property name="generic" scope="prototype" type="Boolean">
        <summary>Use generic (web standard) font names</summary>
      </property>
      <property name="command" scope="prototype" type="String">
        <summary>The editor 'command' implemented by this plugin.</summary>
      </property>
      <property name="values" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype">
        <summary>Over-ride for the default posr mixin control</summary>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>Function used to generate the labels of the format dropdown
	will return a formatted, or plain label based on the value
	of the plainText option.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>The 'insert value' associated with a name</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>The text name of the value</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Over-ride for the default action of setting the
	widget value, maps the input to known values</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="priorityChange" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins._FontSizeDropDown" type="Function" classlike="true" superclass="dijit._editor.plugins._FontDropDown">
    <summary>Dropdown to select a font size; goes in editor toolbar.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor.plugins._FontDropDown"/>
    </mixins>
    <properties>
      <property name="command" scope="prototype" type="String">
        <summary>The editor 'command' implemented by this plugin.</summary>
      </property>
      <property name="values" scope="prototype" type="Number[]">
        <summary>The HTML font size values supported by this plugin
	sizes according to the old HTML FONT SIZE</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getLabel" scope="prototype">
        <summary>Function used to generate the labels of the format dropdown
	will return a formatted, or plain label based on the value
	of the plainText option.
	We're stuck using the deprecated FONT tag to correspond
	with the size measurements used by the editor</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>The 'insert value' associated with a name</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>The text name of the value</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Over-ride for the default action of setting the
	widget value, maps the input to known values</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="priorityChange" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins._FormatBlockDropDown" type="Function" classlike="true" superclass="dijit._editor.plugins._FontDropDown">
    <summary>Dropdown to select a format (like paragraph or heading); goes in editor toolbar.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor.plugins._FontDropDown"/>
    </mixins>
    <properties>
      <property name="command" scope="prototype" type="String">
        <summary>The editor 'command' implemented by this plugin.</summary>
      </property>
      <property name="values" scope="prototype" type="Array">
        <summary>The HTML format tags supported by this plugin</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getLabel" scope="prototype">
        <summary>Function used to generate the labels of the format dropdown
	will return a formatted, or plain label based on the value
	of the plainText option.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>The 'insert value' associated with a name</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>The text name of the value</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.FontChoice" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides three drop downs for setting style in the editor
	(font, font size, and format block), as controlled by command.</summary>
    <description>The commands provided by this plugin are:
	* fontName
			Provides a drop down to select from a list of font names
	* fontSize
			Provides a drop down to select from a list of font sizes
	* formatBlock
			Provides a drop down to select from a list of block styles
	which can easily be added to an editor by including one or more of the above commands
	in the `plugins` attribute as follows:
		plugins="['fontName','fontSize',...]"
	It is possible to override the default dropdown list by providing an Array for the `custom` property when
	instantiating this plugin, e.g.
		plugins="[{name:'dijit._editor.plugins.FontChoice', command:'fontName', custom:['Verdana','Myriad','Garamond']},...]"
	Alternatively, for `fontName` only, `generic:true` may be specified to provide a dropdown with
	[CSS generic font families](http://www.w3.org/TR/REC-CSS2/fonts.html#generic-font-families)
	Note that the editor is often unable to properly handle font styling information defined outside
	the context of the current editor instance, such as pre-populated HTML.</description>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="prototype" type="booleam">
        <summary>Override _Plugin.useDefaultCommand...
	processing is handled by this plugin, not by dijit.Editor.</summary>
      </property>
      <property name="button" scope="prototype" type="Object"/>
      <property name="editor" scope="prototype" type=""/>
      <property name="command" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Overrides _Plugin._initButton(), to initialize the FilteringSelect+label in toolbar,
	rather than a simple button.</summary>
      </method>
      <method name="updateState" scope="prototype">
        <summary>Overrides _Plugin.updateState().  This controls updating the menu
	options to the right values on state changes in the document (that trigger a
	test of the actions.)
	It set value of drop down in toolbar to reflect font/font size/format block
	of text at current caret position.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.FontChoice.params" type="">
    <properties>
      <property name="values" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._editor.plugins.FullScreen" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides FullScreen cabability to the editor.  When
	toggled on, it will render the editor into the full window and
	overlay everything.  It also binds to the hotkey: CTRL-SHIFT-F11
	for toggling fullscreen mode.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="zIndex" scope="prototype" type="Number">
        <summary>zIndex value used for overlaying the full page.
	default is 500.</summary>
      </property>
      <property name="_origState" scope="prototype" type="Object">
        <summary>The original view state of the editor.</summary>
      </property>
      <property name="_origiFrameState" scope="prototype" type="Object">
        <summary>The original view state of the iframe of the editor.</summary>
      </property>
      <property name="_resizeHandle" scope="prototype" type="Object">
        <summary>Connection point used for handling resize when window resizes.</summary>
      </property>
      <property name="isFullscreen" scope="prototype" type="boolean">
        <summary>Read-Only variable used to denote of the editor is in fullscreen mode or not.</summary>
      </property>
      <property name="button" scope="prototype" type="Object"/>
      <property name="_classedParents" scope="prototype" type="Array"/>
      <property name="_editorResizeHolder" scope="prototype" type=""/>
      <property name="_oldOverflow" scope="prototype" type="String"/>
      <property name="_oldBodyParentOverflow" scope="prototype" type="String"/>
      <property name="_rst" scope="prototype" type="Object"/>
      <property name="_resizer" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="toggle" scope="prototype">
        <summary>Function to allow programmatic toggling of the view.</summary>
      </method>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the resize button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride for the setting of the editor.</summary>
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <summary>The editor to configure for this plugin to use.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_containFocus" scope="prototype">
        <summary>When in Full Screen mode, it's good to try and retain focus in the editor
	so this function is intended to try and constrain the TAB key.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The key event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_resizeEditor" scope="prototype">
        <summary>Function to handle resizing the editor as the viewport
	resizes (window scaled)</summary>
      </method>
      <method name="_getAltViewNode" scope="prototype">
        <summary>This function is intended as a hook point for setting an
	alternate view node for when in full screen mode and the
	editable iframe is hidden.</summary>
      </method>
      <method name="_setFullScreen" scope="prototype">
        <summary>Function to handle toggling between full screen and
	regular view.</summary>
        <parameters>
          <parameter name="full" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Over-ride to ensure the resize handle gets cleaned up.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.FullScreen.editor" type="">
    <properties>
      <property name="_fullscreen_oldOnKeyDown" scope="prototype" type=""/>
      <property name="onKeyDown" scope="prototype" type="Object"/>
      <property name="domNode" scope="prototype" type=""/>
      <property name="iframe" scope="prototype" type=""/>
    </properties>
    <methods>
      <method name="resize" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit._editor.plugins.FullScreen.editor.toolbar" type="">
    <properties>
      <property name="domNode" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._editor.plugins.LinkDialog" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides the basis for an 'anchor' (link) dialog and an extension of it
	provides the image link dialog.</summary>
    <description>The command provided by this plugin is:
	* createLink</description>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="normal" type=""/>
      <property name="useDefaultCommand" scope="prototype" type="bool"/>
      <property name="urlRegExp" scope="prototype" type="String">
        <summary>Used for validating input as correct URL.  While file:// urls are not terribly
	useful, they are technically valid.</summary>
      </property>
      <property name="htmlTemplate" scope="prototype" type="String">
        <summary>String used for templating the HTML to insert at the desired point.</summary>
      </property>
      <property name="tag" scope="prototype" type="String">
        <summary>Tag used for the link type.</summary>
      </property>
      <property name="_hostRxp" scope="prototype" type="Object"/>
      <property name="linkDialogTemplate" scope="prototype" type="String">
        <summary>Template for contents of TooltipDialog to pick URL</summary>
      </property>
      <property name="dropDown" scope="prototype" type="Object"/>
      <property name="_uniqueId" scope="prototype" type=""/>
      <property name="_urlInput" scope="prototype" type="Object"/>
      <property name="_textInput" scope="prototype" type="Object"/>
      <property name="_setButton" scope="prototype" type="Object"/>
      <property name="_delayedCheck" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype"/>
      <method name="_checkAndFixInput" scope="prototype">
        <summary>A function to listen for onChange events and test the input contents
	for valid information, such as valid urls with http/https/ftp and if
	not present, try and guess if the input url is relative or not, and if
	not, append http:// to it.  Also validates other fields as determined by
	the internal _isValid function.</summary>
      </method>
      <method name="_connectTagEvents" scope="prototype">
        <summary>Over-ridable function that connects tag specific events.</summary>
      </method>
      <method name="_isValid" scope="prototype">
        <summary>Internal function to allow validating of the inputs
	for a link to determine if set should be disabled or not</summary>
      </method>
      <method name="_setContent" scope="prototype">
        <summary>Helper for _initButton above.   Not sure why it's a separate method.</summary>
        <parameters>
          <parameter name="staticPanel" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_checkValues" scope="prototype">
        <summary>Function to check the values in args and 'fix' them up as needed.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Content being set.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>Callback from the dialog when user presses &amp;quot;set&amp;quot; button.</summary>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onCloseDialog" scope="prototype">
        <summary>Handler for close event on the dialog</summary>
      </method>
      <method name="_getCurrentValues" scope="prototype">
        <summary>Over-ride for getting the values to set in the dropdown.</summary>
        <parameters>
          <parameter name="a" type="The" usage="required">
            <summary>anchor/link to process for data for the dropdown.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object;"/>
        </return-types>
      </method>
      <method name="_onOpenDialog" scope="prototype">
        <summary>Handler for when the dialog is opened.
	If the caret is currently in a URL then populate the URL's info into the dialog.</summary>
      </method>
      <method name="_onDblClick" scope="prototype">
        <summary>Function to define a behavior on double clicks on the element
	type this dialog edits to select it and pop up the editor
	dialog.</summary>
        <parameters>
          <parameter name="e" type="Object" usage="required">
            <summary>The double-click event.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.ImgLinkDialog" type="Function" classlike="true" superclass="dijit._editor.plugins.LinkDialog">
    <summary>This plugin extends LinkDialog and adds in a plugin for handling image links.
	provides the image link dialog.</summary>
    <description>The command provided by this plugin is:
	* insertImage</description>
    <mixins>
      <mixin scope="instance" location="dijit._editor.plugins.LinkDialog"/>
    </mixins>
    <properties>
      <property name="linkDialogTemplate" scope="prototype" type="String">
        <summary>Over-ride for template since img dialog doesn't need target that anchor tags may.</summary>
      </property>
      <property name="htmlTemplate" scope="prototype" type="String">
        <summary>String used for templating the &amp;lt;img&amp;gt; HTML to insert at the desired point.</summary>
      </property>
      <property name="tag" scope="prototype" type="String">
        <summary>Tag used for the link type (img).</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getCurrentValues" scope="prototype">
        <summary>Over-ride for getting the values to set in the dropdown.
	a:
	The anchor/link to process for data for the dropdown.</summary>
        <parameters>
          <parameter name="img" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object;"/>
        </return-types>
      </method>
      <method name="_isValid" scope="prototype">
        <summary>Over-ride for images.  You can have alt text of blank, it is valid.</summary>
      </method>
      <method name="_connectTagEvents" scope="prototype">
        <summary>Over-ridable function that connects tag specific events.</summary>
      </method>
      <method name="_selectTag" scope="prototype">
        <summary>A simple event handler that lets me select an image if it is clicked on.
	makes it easier to select images in a standard way across browsers.  Otherwise
	selecting an image for edit becomes difficult.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The mousedown event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_checkValues" scope="prototype">
        <summary>Function to check the values in args and 'fix' them up as needed
	(special characters in the url or alt text)</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Content being set.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.NewPage" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides a simple 'new page' calability.  In other
	words, set content to some default user defined string.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="content" scope="prototype" type="String">
        <summary>The default content to insert into the editor as the new page.
	The default is the &amp;lt;br&amp;gt; tag, a single blank line.</summary>
      </property>
      <property name="button" scope="prototype" type="Object"/>
      <property name="editor" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the Print button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Tell the plugin which Editor it is associated with.</summary>
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <summary>Object The editor object to attach the newPage capability to.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_newPage" scope="prototype">
        <summary>Function to set the content to blank.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.Print" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides Print cabability to the editor.  When
	clicked, the document in the editor frame will be printed.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="button" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the Print button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Tell the plugin which Editor it is associated with.</summary>
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <summary>Object The editor object to attach the print capability to.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_print" scope="prototype">
        <summary>Function to trigger printing of the editor document</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.Print.editor" type="">
    <properties>
      <property name="iframe" scope="prototype" type=""/>
      <property name="document" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit._editor.plugins.TabIndent" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin is used to allow the use of the tab and shift-tab keys
	to indent/outdent list items.  This overrides the default behavior
	of moving focus from/to the toolbar</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="prototype" type="bool"/>
      <property name="buttonClass" scope="normal" type=""/>
      <property name="command" scope="prototype" type="String"/>
      <property name="editor" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype"/>
      <method name="updateState" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit._editor.plugins.TextColor" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides dropdown color pickers for setting text color and background color</summary>
    <description>The commands provided by this plugin are:
	* foreColor - sets the text color
	* hiliteColor - sets the background color</description>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="normal" type=""/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit._editor.plugins.ToggleDir" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin is used to toggle direction of the edited document,
	independent of what direction the whole page is.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="prototype" type="bool"/>
      <property name="command" scope="prototype" type="String"/>
      <property name="buttonClass" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype"/>
      <method name="updateState" scope="prototype"/>
      <method name="_setRtl" scope="prototype">
        <summary>Handler for button click events, to switch the text direction of the editor</summary>
        <parameters>
          <parameter name="rtl" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.ViewSource" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides a simple view source capability.  When view
	source mode is enabled, it disables all other buttons/plugins on the RTE.
	It also binds to the hotkey: CTRL-SHIFT-F11 for toggling ViewSource mode.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="stripScripts" scope="prototype" type="Boolean">
        <summary>Boolean flag used to indicate if script tags should be stripped from the document.
	Defaults to true.</summary>
      </property>
      <property name="stripComments" scope="prototype" type="Boolean">
        <summary>Boolean flag used to indicate if iframe tags should be stripped from the document.
	Defaults to true.</summary>
      </property>
      <property name="stripIFrames" scope="prototype" type="Object"/>
      <property name="readOnly" scope="prototype" type="Boolean">
        <summary>Boolean flag used to indicate if the source view should be readonly or not.
	Cannot be changed after initialization of the plugin.
	Defaults to false.</summary>
      </property>
      <property name="_vsFocused" scope="prototype" type="Object"/>
      <property name="button" scope="prototype" type="Object"/>
      <property name="_ieFixNode" scope="prototype" type="Object"/>
      <property name="_sourceShown" scope="prototype" type=""/>
      <property name="_pluginList" scope="prototype" type="Array"/>
      <property name="_disabledPlugins" scope="prototype" type="Object"/>
      <property name="_resizeHandle" scope="prototype" type="Object"/>
      <property name="_readOnly" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="toggle" scope="prototype">
        <summary>Function to allow programmatic toggling of the view.</summary>
      </method>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the resize button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Tell the plugin which Editor it is associated with.</summary>
        <parameters>
          <parameter name="editor" type="dijit.Editor" usage="required">
            <summary>Object The editor object to attach the print capability to.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_showSource" scope="prototype">
        <summary>Function to toggle between the source and RTE views.</summary>
        <parameters>
          <parameter name="source" type="boolean" usage="required">
            <summary>Boolean value indicating if it should be in source mode or not.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_resize" scope="prototype">
        <summary>Internal function to resize the source view</summary>
      </method>
      <method name="_createSourceView" scope="prototype">
        <summary>Internal function for creating the source view area.</summary>
      </method>
      <method name="_stripScripts" scope="prototype">
        <summary>Strips out script tags from the HTML used in editor.</summary>
        <parameters>
          <parameter name="html" type="String" usage="required">
            <summary>The HTML to filter</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_stripComments" scope="prototype">
        <summary>Strips out comments from the HTML used in editor.</summary>
        <parameters>
          <parameter name="html" type="String" usage="required">
            <summary>The HTML to filter</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_stripIFrames" scope="prototype">
        <summary>Strips out iframe tags from the content, to avoid iframe script
	style injection attacks.</summary>
        <parameters>
          <parameter name="html" type="String" usage="required">
            <summary>The HTML to filter</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_filter" scope="prototype">
        <summary>Internal function to perform some filtering on the HTML.</summary>
        <parameters>
          <parameter name="html" type="String" usage="required">
            <summary>The HTML to filter</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setSourceAreaCaret" scope="prototype">
        <summary>Internal function to set the caret in the sourceArea
	to 0x0</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Over-ride to remove the node used to correct for IE's
	zoom bug.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._editor.plugins.ViewSource.editor" type="">
    <properties>
      <property name="_plugins" scope="prototype" type=""/>
      <property name="_sourceQueryCommandEnabled" scope="prototype" type=""/>
      <property name="_viewsource_oldFocus" scope="prototype" type=""/>
    </properties>
    <methods>
      <method name="queryCommandEnabled" scope="prototype">
        <parameters>
          <parameter name="cmd" type="" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit._editor.plugins.ViewSource._fsPlugin" private="true">
    <summary>Reference to a registered fullscreen plugin so that viewSource knows
	how to scale.</summary>
    <properties>
      <property name="_viewsource_getAltViewNode" scope="prototype" type=""/>
    </properties>
    <methods>
      <method name="_getAltViewNode" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit._editor.plugins.ViewSource.sourceArea">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.range">
    <properties>
      <property name="BlockTagNames" scope="normal" type="RegExp"/>
      <property name="_w3c" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="getIndex" scope="normal">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getNode" scope="normal">
        <parameters>
          <parameter name="index" type="Array" usage="required"/>
          <parameter name="parent" type="DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="terminate dojo.every"/>
          <return-type type="carry on the every loop"/>
        </return-types>
      </method>
      <method name="getCommonAncestor" scope="normal">
        <parameters>
          <parameter name="n1" type="" usage="required"/>
          <parameter name="n2" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAncestor" scope="normal">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="getBlockAncestor" scope="normal">
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="regex" type="RegEx" usage="optional"/>
          <parameter name="root" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="atBeginningOfContainer" scope="normal">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="atEndOfContainer" scope="normal">
        <parameters>
          <parameter name="container" type="DomNode" usage="required"/>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="offset" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="adjacentNoneTextNode" scope="normal">
        <parameters>
          <parameter name="startnode" type="" usage="required"/>
          <parameter name="next" type="" usage="required"/>
        </parameters>
      </method>
      <method name="create" scope="normal">
        <parameters>
          <parameter name="win" type="Window" usage="optional"/>
        </parameters>
      </method>
      <method name="getSelection" scope="normal">
        <parameters>
          <parameter name="win" type="Window" usage="required"/>
          <parameter name="ignoreUpdate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.range.W3CRange" type="Function" classlike="true">
    <properties>
      <property name="commonAncestorContainer" scope="instance-prototype" type="Object"/>
      <property name="collapsed" scope="instance-prototype" type="Object"/>
      <property name="startContainer" scope="instance-prototype" type="Object"/>
      <property name="startOffset" scope="instance-prototype" type="Number"/>
      <property name="endContainer" scope="instance-prototype" type="Object"/>
      <property name="endOffset" scope="instance-prototype" type="Number"/>
      <property name="_body" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="_updateInternal" scope="prototype"/>
      <method name="setStart" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setEnd" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setStartAfter" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setStartBefore" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setEndAfter" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setEndBefore" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setPoint" scope="prototype">
        <parameters>
          <parameter name="what" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
          <parameter name="ext" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getIERange" scope="prototype"/>
      <method name="getBookmark" scope="prototype">
        <parameters>
          <parameter name="body" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_select" scope="prototype"/>
      <method name="deleteContents" scope="prototype"/>
      <method name="cloneRange" scope="prototype"/>
      <method name="detach" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.range.ie">
    <properties>
      <property name="cachedSelection" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="decomposeControlRange" scope="normal">
        <parameters>
          <parameter name="range" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getEndPoint" scope="normal">
        <parameters>
          <parameter name="range" type="" usage="required"/>
          <parameter name="end" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setEndPoint" scope="normal">
        <parameters>
          <parameter name="range" type="" usage="required"/>
          <parameter name="container" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="decomposeTextRange" scope="normal">
        <parameters>
          <parameter name="range" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setRange" scope="normal">
        <parameters>
          <parameter name="range" type="" usage="required"/>
          <parameter name="startContainer" type="" usage="required"/>
          <parameter name="startOffset" type="" usage="required"/>
          <parameter name="endContainer" type="" usage="required"/>
          <parameter name="endOffset" type="" usage="required"/>
          <parameter name="collapsed" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.range.ie.selection" type="Function" classlike="true">
    <properties>
      <property name="_ranges" scope="instance" type="Array"/>
      <property name="rangeCount" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="win" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="r" type="" usage="required"/>
          <parameter name="internal" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="removeAllRanges" scope="instance"/>
      <method name="getRangeAt" scope="instance">
        <parameters>
          <parameter name="i" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getCurrentSelection" scope="instance"/>
    </methods>
  </object>
  <object location="dijit._editor.selection">
    <methods>
      <method name="getType" scope="normal">
        <summary>Get the selection type (like dojo.doc.select.type in IE).</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedText" scope="normal">
        <summary>Return the text (no html tags) included in the current selection or null if no text is selected</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedHtml" scope="normal">
        <summary>Return the html text of the current selection or null if unavailable</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getSelectedElement" scope="normal">
        <summary>Retrieves the selected element (if any), just in the case that
	a single element (object like and image or a table) is
	selected.</summary>
      </method>
      <method name="getParentElement" scope="normal">
        <summary>Get the parent element of the current selection</summary>
      </method>
      <method name="hasAncestorElement" scope="normal">
        <summary>Check whether current selection has a  parent element which is
	of type tagName (or one of the other specified tagName)</summary>
        <parameters>
          <parameter name="tagName" type="String" usage="required">
            <summary>The tag name to determine if it has an ancestor of.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getAncestorElement" scope="normal">
        <summary>Return the parent element of the current selection which is of
	type tagName (or one of the other specified tagName)</summary>
        <parameters>
          <parameter name="tagName" type="String" usage="required">
            <summary>The tag name to determine if it has an ancestor of.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="isTag" scope="normal">
        <summary>Function to determine if a node is one of an array of tags.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>The node to inspect.</summary>
          </parameter>
          <parameter name="tags" type="String[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getParentOfType" scope="normal">
        <summary>Function to locate a parent node that matches one of a set of tags</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>The node to inspect.</summary>
          </parameter>
          <parameter name="tags" type="String[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMNode"/>
        </return-types>
      </method>
      <method name="collapse" scope="normal">
        <summary>Function to collapse (clear), the current selection</summary>
        <parameters>
          <parameter name="beginning" type="Boolean" usage="required">
            <summary>Boolean to indicate whether to collapse the cursor to the beginning of the selection or end.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="normal">
        <summary>Function to delete the currently selected content from the document.</summary>
        <return-types>
          <return-type type="Selection"/>
        </return-types>
      </method>
      <method name="selectElementChildren" scope="normal">
        <summary>clear previous selection and select the content of the node
	(excluding the node itself)</summary>
        <parameters>
          <parameter name="element" type="DomNode" usage="required">
            <summary>DOMNode The element you wish to select the children content of.</summary>
          </parameter>
          <parameter name="nochangefocus" type="Boolean" usage="optional">
            <summary>Boolean to indicate if the foxus should change or not.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="selectElement" scope="normal">
        <summary>clear previous selection and select element (including all its children)</summary>
        <parameters>
          <parameter name="element" type="DomNode" usage="required">
            <summary>DOMNode The element to select.</summary>
          </parameter>
          <parameter name="nochangefocus" type="Boolean" usage="optional">
            <summary>Boolean indicating if the focus should be changed.  IE only.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit._tree" private="true">
    <properties>
      <property name="dndSource" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dijit.form">
    <summary>Form and input related widgets</summary>
    <properties>
      <property name="Slider" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dijit.form.Button" type="Function" classlike="true" superclass="dijit.form._FormWidget">
    <summary>Basically the same thing as a normal HTML button, but with special styling.</summary>
    <description>Buttons can display a label, an icon, or both.
	A label should always be specified (through innerHTML) or the label
	attribute.  It can be hidden via showLabel=false.</description>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormWidget"/>
    </mixins>
    <examples>
      <example>	&lt;button dojoType="dijit.form.Button" onClick="..."&gt;Hello world&lt;/button&gt;</example>
      <example>	var button1 = new dijit.form.Button({label: "hello world", onClick: foo});
		dojo.body().appendChild(button1.domNode);</example>
    </examples>
    <properties>
      <property name="label" scope="prototype" type="HTML">
        <summary>String
	Text to display in button.
	If the label is hidden (showLabel=false) then and no title has
	been specified, then label is also set as title attribute of icon.</summary>
      </property>
      <property name="showLabel" scope="prototype" type="Boolean">
        <summary>Set this to true to hide the label text and display only the icon.
	(If showLabel=false then iconClass must be specified.)
	Especially useful for toolbars.
	If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
	The exception case is for computers in high-contrast mode, where the label
	will still be displayed, since the icon doesn't appear.</summary>
      </property>
      <property name="iconClass" scope="prototype" type="String">
        <summary>Class to apply to DOMNode in button to make it display an icon</summary>
      </property>
      <property name="type" scope="prototype" type="String">
        <summary>Defines the type of button.  &amp;quot;button&amp;quot;, &amp;quot;submit&amp;quot;, or &amp;quot;reset&amp;quot;.</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_onClick" scope="prototype">
        <summary>Internal function to handle click actions</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="user click actions"/>
        </return-types>
      </method>
      <method name="_onButtonClick" scope="prototype">
        <summary>Handler when the user activates the button portion.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fillContent" scope="prototype">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_setShowLabelAttr" scope="prototype">
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Callback for when button is clicked.
	If type=&amp;quot;submit&amp;quot;, return true to perform submit, or false to cancel it.
	type:
	callback</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_clicked" scope="prototype">
        <summary>Internal overridable function for when the button is clicked</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="prototype">
        <summary>Deprecated.  Use attr('label', ...) instead.</summary>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setLabelAttr" scope="prototype">
        <summary>Hook for attr('label', ...) to work.</summary>
        <description>Set the label (text) of the button; takes an HTML string.</description>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form.Button.attributeMap">
    <properties>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.Button.containerNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.Button.titleNode" type="">
    <properties>
      <property name="title" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.form.DropDownButton" type="Function" classlike="true" superclass="dijit.form.Button">
    <summary>A button with a drop down</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="prototype" location="dijit._HasDropDown.prototype"/>
      <mixin scope="instance" location="dijit.form.Button"/>
      <mixin scope="instance" location="dijit._Container"/>
      <mixin scope="instance" location="dijit._HasDropDown"/>
    </mixins>
    <examples>
      <example>	&lt;button dojoType="dijit.form.DropDownButton" label="Hello world"&gt;
			&lt;div dojotype="dijit.Menu"&gt;...&lt;/div&gt;
		&lt;/button&gt;</example>
      <example>	var button1 = new dijit.form.DropDownButton({ label: "hi", dropDown: new dijit.Menu(...) });
		dojo.body().appendChild(button1);</example>
    </examples>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="dropDownContainer" scope="prototype" type=""/>
      <property name="dropDown" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_fillContent" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="isLoaded" scope="prototype"/>
      <method name="loadDropDown" scope="prototype"/>
      <method name="isFocusable" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.ComboButton" type="Function" classlike="true" superclass="dijit.form.DropDownButton">
    <summary>A combination button and drop-down button.
	Users can click one side to &amp;quot;press&amp;quot; the button, or click an arrow
	icon to display the drop down.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.DropDownButton"/>
    </mixins>
    <examples>
      <example>	&lt;button dojoType="dijit.form.ComboButton" onClick="..."&gt;
			&lt;span&gt;Hello world&lt;/span&gt;
			&lt;div dojoType="dijit.Menu"&gt;...&lt;/div&gt;
		&lt;/button&gt;</example>
      <example>	var button1 = new dijit.form.ComboButton({label: "hello world", onClick: foo, dropDown: "myMenu"});
		dojo.body().appendChild(button1.domNode);</example>
    </examples>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="optionsTitle" scope="prototype" type="String">
        <summary>Text that describes the options menu (accessibility)</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="_focusedNode" scope="prototype" type="Object"/>
      <property name="_focalNodes" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_onNodeFocus" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onNodeBlur" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype"/>
      <method name="_onButtonKeyPress" scope="prototype">
        <summary>Handler for right arrow key when focus is on left part of button</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onArrowKeyPress" scope="prototype">
        <summary>Handler for left arrow key when focus is on right part of button</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <summary>Focuses this widget to according to position, if specified,
	otherwise on arrow node</summary>
        <parameters>
          <parameter name="position" type="String" usage="required">
            <summary>&amp;quot;start&amp;quot; or &amp;quot;end&amp;quot;</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form.ToggleButton" type="Function" classlike="true" superclass="dijit.form.Button">
    <summary>A button that can be in two states (checked or not).
	Can be base class for things like tabs or checkbox or radio buttons</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.Button"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="checked" scope="prototype" type="Boolean">
        <summary>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.
	In markup, specified as &amp;quot;checked='checked'&amp;quot; or just &amp;quot;checked&amp;quot;.
	True if the button is depressed, or the checkbox is checked,
	or the radio button is selected, etc.</summary>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="_hasBeenBlurred" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_clicked" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setCheckedAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setChecked" scope="prototype">
        <summary>Deprecated.   Use attr('checked', true/false) instead.</summary>
        <parameters>
          <parameter name="checked" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <summary>Reset the widget's value to what it was at initialization time</summary>
      </method>
    </methods>
  </object>
  <object location="style" type="">
    <properties>
      <property name="width" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.CheckBox" type="Function" classlike="true" superclass="dijit.form.ToggleButton">
    <summary>Same as an HTML checkbox, but with fancy styling.</summary>
    <description>User interacts with real html inputs.
	On onclick (which occurs by mouse click, space-bar, or
	using the arrow keys to switch the selected radio button),
	we update the state of the checkbox/radio.
	There are two modes:
	1. High contrast mode
	2. Normal mode
	In case 1, the regular html inputs are shown and used by the user.
	In case 2, the regular html inputs are invisible but still used by
	the user. They are turned quasi-invisible and overlay the background-image.</description>
    <mixins>
      <mixin scope="instance" location="dijit.form.ToggleButton"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="type" scope="prototype" type="String">
        <summary>type attribute on &amp;lt;input&amp;gt; node.
	Overrides &lt;code&gt;dijit.form.Button.type&lt;/code&gt;.   Users should not change this value.</summary>
      </property>
      <property name="value" scope="prototype" type="String">
        <summary>As an initialization parameter, equivalent to value field on normal checkbox
	(if checked, the value is passed as the value when form is submitted).
	However, attr('value') will return either the string or false depending on
	whether or not the checkbox is checked.
	attr('value', string) will check the checkbox and change the value to the
	specified string
	attr('value', boolean) will change the checked state.</summary>
      </property>
      <property name="readOnly" scope="prototype" type="Boolean">
        <summary>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;readOnly&amp;quot;.
	Similar to disabled except readOnly form values are submitted.</summary>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="checkedAttrSetting" scope="prototype" type=""/>
      <property name="_hasBeenBlurred" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setReadOnlyAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Handler for value= attribute to constructor, and also calls to
	attr('value', val).</summary>
        <description>During initialization, just saves as attribute to the &lt;input type=checkbox&gt;.
	After initialization,
	when passed a boolean, controls whether or not the CheckBox is checked.
	If passed a string, changes the value attribute of the CheckBox (the one
	specified as "value" when the CheckBox was constructed (ex: &lt;input
	dojoType="dijit.CheckBox" value="chicken"&gt;)</description>
        <parameters>
          <parameter name="newValue" type="String" usage="required">
            <summary>or Boolean</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>Hook so attr('value') works.</summary>
        <description>If the CheckBox is checked, returns the value attribute.
	Otherwise returns false.</description>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_fillContent" scope="prototype">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
      <method name="_onFocus" scope="prototype"/>
      <method name="_onBlur" scope="prototype"/>
      <method name="_onClick" scope="prototype">
        <summary>Internal function to handle click actions - need to check
	readOnly, since button no longer does that check.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form.RadioButton" type="Function" classlike="true" superclass="dijit.form.CheckBox">
    <summary>Same as an HTML radio, but with fancy styling.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.CheckBox"/>
    </mixins>
    <properties>
      <property name="type" scope="prototype" type="String"/>
      <property name="baseClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setCheckedAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_clicked" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form._ComboBoxDataStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>Inefficient but small data store specialized for inlined &lt;code&gt;dijit.form.ComboBox&lt;/code&gt; data</summary>
    <description>Provides a store for inlined data like:
		&lt;select&gt;
			&lt;option value="AL"&gt;Alabama&lt;/option&gt;
			...
	Actually. just implements the subset of dojo.data.Read/Notification
	needed for ComboBox and FilteringSelect to work.
	Note that an item is just a pointer to the &lt;option&gt; DomNode.</description>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="root" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="root" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype"/>
      <method name="_fetchItems" scope="prototype">
        <summary>See dojo.data.util.simpleFetch.fetch()</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| args || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>Given the identity of an item, this method returns the item that has
	that identity through the onItem callback.
	Refer to dojo.data.api.Identity.fetchItemByIdentity() for more details.</summary>
        <description>Given arguments like:
			{identity: "CA", onItem: function(item){...}
	Call `onItem()` with the DOM node `&lt;option value="CA"&gt;California&lt;/option&gt;`</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="fetchSelectedItem" scope="prototype">
        <summary>Get the option marked as selected, like &lt;code&gt;&amp;lt;option selected&amp;gt;&lt;/code&gt;.
	Not part of dojo.data API.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.form.ComboBoxMixin" type="Function" classlike="true">
    <summary>Implements the base functionality for &lt;code&gt;dijit.form.ComboBox&lt;/code&gt;/&lt;code&gt;dijit.form.FilteringSelect&lt;/code&gt;</summary>
    <description>All widgets that mix in dijit.form.ComboBoxMixin must extend `dijit.form._FormValueWidget`.</description>
    <properties>
      <property name="item" scope="prototype" type="Object">
        <summary>This is the item returned by the dojo.data.store implementation that
	provides the data for this ComboBox, it's the currently selected item.</summary>
      </property>
      <property name="pageSize" scope="normal" type="Integer">
        <summary>Argument to data provider.
	Specifies number of search results per page (before hitting &amp;quot;next&amp;quot; button)</summary>
      </property>
      <property name="store" scope="prototype" type="Object">
        <summary>Reference to data provider object used by this ComboBox</summary>
      </property>
      <property name="fetchProperties" scope="instance-prototype" type="Object">
        <summary>Mixin to the dojo.data store's fetch.
	For example, to set the sort order of the ComboBox menu, pass:
		{ sort: {attribute:&amp;quot;name&amp;quot;,descending: true} }
	To override the default queryOptions so that deep=false, do:
		{ queryOptions: {ignoreCase: true, deep: false} }</summary>
      </property>
      <property name="query" scope="instance-prototype" type="Object">
        <summary>A query that can be passed to 'store' to initially filter the items,
	before doing further filtering based on &lt;code&gt;searchAttr&lt;/code&gt; and the key.
	Any reference to the &lt;code&gt;searchAttr&lt;/code&gt; is ignored.</summary>
      </property>
      <property name="autoComplete" scope="prototype" type="Boolean">
        <summary>If user types in a partial string, and then tab out of the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; box,
	automatically copy the first entry displayed in the drop down list to
	the &lt;code&gt;&amp;lt;input&amp;gt;&lt;/code&gt; field</summary>
      </property>
      <property name="highlightMatch" scope="prototype" type="String">
        <summary>One of: &amp;quot;first&amp;quot;, &amp;quot;all&amp;quot; or &amp;quot;none&amp;quot;.
	If the ComboBox/FilteringSelect opens with the search results and the searched
	string can be found, it will be highlighted.  If set to &amp;quot;all&amp;quot;
	then will probably want to change &lt;code&gt;queryExpr&lt;/code&gt; parameter to '*${0}*'
	Highlighting is only performed when &lt;code&gt;labelType&lt;/code&gt; is &amp;quot;text&amp;quot;, so as to not
	interfere with any HTML markup an HTML label might contain.</summary>
      </property>
      <property name="searchDelay" scope="prototype" type="Integer">
        <summary>Delay in milliseconds between when user types something and we start
	searching based on that value</summary>
      </property>
      <property name="searchAttr" scope="prototype" type="String">
        <summary>Search for items in the data store where this attribute (in the item)
	matches what the user typed</summary>
      </property>
      <property name="labelAttr" scope="prototype" type="String">
        <summary>The entries in the drop down list come from this attribute in the
	dojo.data items.
	If not specified, the searchAttr attribute is used instead.</summary>
      </property>
      <property name="labelType" scope="prototype" type="String">
        <summary>Specifies how to interpret the labelAttr in the data store items.
	Can be &amp;quot;html&amp;quot; or &amp;quot;text&amp;quot;.</summary>
      </property>
      <property name="queryExpr" scope="prototype" type="String">
        <summary>This specifies what query ComboBox/FilteringSelect sends to the data store,
	based on what the user has typed.  Changing this expression will modify
	whether the drop down shows only exact matches, a &amp;quot;starting with&amp;quot; match,
	etc.   Use it in conjunction with highlightMatch.
	dojo.data query expression pattern.
	&lt;code&gt;${0}&lt;/code&gt; will be substituted for the user text.
	&lt;code&gt;*&lt;/code&gt; is used for wildcards.
	&lt;code&gt;${0}*&lt;/code&gt; means &amp;quot;starts with&amp;quot;, &lt;code&gt;*${0}*&lt;/code&gt; means &amp;quot;contains&amp;quot;, &lt;code&gt;${0}&lt;/code&gt; means &amp;quot;is&amp;quot;</summary>
      </property>
      <property name="ignoreCase" scope="prototype" type="Boolean">
        <summary>Set true if the ComboBox/FilteringSelect should ignore case when matching possible items</summary>
      </property>
      <property name="hasDownArrow" scope="prototype" type="Boolean">
        <summary>Set this textbox to have a down arrow button, to display the drop down list.
	Defaults to true.</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="searchTimer" scope="prototype" type="Object"/>
      <property name="_fetchHandle" scope="prototype" type="Object"/>
      <property name="_popupWidget" scope="prototype" type="Object"/>
      <property name="_prev_key_backspace" scope="prototype" type="Object"/>
      <property name="_lastQuery" scope="prototype" type="Object"/>
      <property name="_isShowingNow" scope="prototype" type="Object"/>
      <property name="value" scope="prototype" type="String"/>
      <property name="_lastInput" scope="prototype" type=""/>
      <property name="_maxOptions" scope="prototype" type=""/>
      <property name="srcNodeRef" scope="prototype" type=""/>
      <property name="comboNode" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getCaretPos" scope="prototype">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_setCaretPos" scope="prototype">
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="location" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_abortQuery" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <summary>Handles keyboard events</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="throw out weird key combinations and spurious events"/>
        </return-types>
      </method>
      <method name="_autoCompleteText" scope="prototype">
        <summary>Fill in the textbox with the first item from the drop down
	list, and highlight the characters that were
	auto-completed. For example, if user typed &amp;quot;CA&amp;quot; and the
	drop down list appeared, the textbox would be changed to
	&amp;quot;California&amp;quot; and &amp;quot;ifornia&amp;quot; would be highlighted.</summary>
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_openResultList" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_showResultList" scope="prototype"/>
      <method name="_hideResultList" scope="prototype"/>
      <method name="_setBlurValue" scope="prototype"/>
      <method name="_onBlur" scope="prototype">
        <summary>Called magically when focus has shifted away from this widget and it's drop down</summary>
      </method>
      <method name="_setItemAttr" scope="prototype">
        <summary>Set the displayed valued in the input box, and the hidden value
	that gets submitted, based on a dojo.data store item.</summary>
        <description>Users shouldn't call this function; they should be calling
	attr('item', value)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_announceOption" scope="prototype">
        <summary>a11y code that puts the highlighted option in the textbox.
	This way screen readers will know what is happening in the
	menu.</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_selectOption" scope="prototype">
        <summary>Menu callback function, called when an item in the menu is selected.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onArrowMouseDown" scope="prototype">
        <summary>Callback when arrow is clicked</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearchAll" scope="prototype"/>
      <method name="_startSearchFromInput" scope="prototype"/>
      <method name="_getQueryString" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearch" scope="prototype">
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setMaxOptions" scope="prototype">
        <parameters>
          <parameter name="size" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueField" scope="prototype"/>
      <method name="_arrowPressed" scope="prototype"/>
      <method name="_arrowIdle" scope="prototype"/>
      <method name="compositionend" scope="prototype">
        <summary>When inputting characters using an input method, such as
	Asian languages, it will generate this event instead of
	onKeyDown event.
	Note: this event is only triggered in FF (not in IE/safari)</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype">
        <summary>Subclasses must call this method from their postCreate() methods</summary>
      </method>
      <method name="uninitialize" scope="prototype"/>
      <method name="_getMenuLabelFromItem" scope="prototype">
        <parameters>
          <parameter name="item" type="Item" usage="required"/>
        </parameters>
      </method>
      <method name="doHighlight" scope="prototype">
        <summary>Highlights the string entered by the user in the menu.  By default this
	highlights the first occurence found. Override this method
	to implement your custom highlighing.</summary>
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="find" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="returns String, (almost) valid HTML (entities encoded)"/>
        </return-types>
      </method>
      <method name="_escapeHtml" scope="prototype">
        <summary>Adds escape sequences for special characters in XML: &amp;amp;&amp;lt;&amp;gt;&amp;quot;'</summary>
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="open" scope="prototype">
        <summary>Opens the drop down menu.  TODO: rename to _open.</summary>
      </method>
      <method name="reset" scope="prototype"/>
      <method name="labelFunc" scope="prototype">
        <summary>Computes the label to display based on the dojo.data store item.</summary>
        <return-description>The label that the ComboBox should display</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="store" type="dojo.data.store" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit.form.ComboBoxMixin.focusNode" type="">
    <properties>
      <property name="value" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.form.ComboBoxMixin._popupWidget.domNode.style" type="">
    <properties>
      <property name="overflow" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form._ComboBoxMenu" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Focus-less menu for internal use in &lt;code&gt;dijit.form.ComboBox&lt;/code&gt;</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="_messages" scope="prototype" type="Object">
        <summary>Holds &amp;quot;next&amp;quot; and &amp;quot;previous&amp;quot; text for paging buttons on drop down</summary>
      </property>
      <property name="value" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Notifies ComboBox/FilteringSelect that user clicked an option in the drop down menu.
	Probably should be called onSelect.</summary>
        <parameters>
          <parameter name="value" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPage" scope="prototype">
        <summary>Notifies ComboBox/FilteringSelect that user clicked to advance to next/previous page.</summary>
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="onClose" scope="prototype">
        <summary>Callback from dijit.popup code to this widget, notifying it that it closed</summary>
      </method>
      <method name="_createOption" scope="prototype">
        <summary>Creates an option to appear on the popup menu subclassed by
	&lt;code&gt;dijit.form.FilteringSelect&lt;/code&gt;.</summary>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="labelFunc" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createOptions" scope="prototype">
        <summary>Fills in the items in the drop down list</summary>
        <parameters>
          <parameter name="results" type="Array" usage="required">
            <summary>of dojo.data items</summary>
          </parameter>
          <parameter name="dataObject" type="dojo.data" usage="required">
            <summary>store</summary>
          </parameter>
          <parameter name="labelFunc" type="Function" usage="required">
            <summary>to produce a label in the drop down list from a dojo.data item</summary>
          </parameter>
        </parameters>
      </method>
      <method name="clearResultList" scope="prototype">
        <summary>Clears the entries in the drop down list, but of course keeps the previous and next buttons.</summary>
      </method>
      <method name="_onMouseDown" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseUp" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOver" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseOut" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusOptionNode" scope="prototype">
        <summary>Does the actual highlight.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_blurOptionNode" scope="prototype">
        <summary>Removes highlight on highlighted option.</summary>
      </method>
      <method name="_highlightNextOption" scope="prototype">
        <summary>Highlight the item just below the current selection.
	If nothing selected, highlight first option.</summary>
      </method>
      <method name="highlightFirstOption" scope="prototype">
        <summary>Highlight the first real item in the list (not Previous Choices).</summary>
      </method>
      <method name="highlightLastOption" scope="prototype">
        <summary>Highlight the last real item in the list (not More Choices).</summary>
      </method>
      <method name="_highlightPrevOption" scope="prototype">
        <summary>Highlight the item just above the current selection.
	If nothing selected, highlight last option (if
	you select Previous and try to keep scrolling up the list).</summary>
      </method>
      <method name="_page" scope="prototype">
        <summary>Handles page-up and page-down keypresses</summary>
        <parameters>
          <parameter name="up" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="pageUp" scope="prototype">
        <summary>Handles pageup keypress.
	TODO: just call _page directly from handleKey().</summary>
      </method>
      <method name="pageDown" scope="prototype">
        <summary>Handles pagedown keypress.
	TODO: just call _page directly from handleKey().</summary>
      </method>
      <method name="getHighlightedOption" scope="prototype">
        <summary>Returns the highlighted option.</summary>
      </method>
      <method name="handleKey" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form._ComboBoxMenu.previousButton" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form._ComboBoxMenu.nextButton" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form._ComboBoxMenu.previousButton.style" type="">
    <properties>
      <property name="display" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form._ComboBoxMenu.nextButton.style" type="">
    <properties>
      <property name="display" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form._ComboBoxMenu.domNode" type="">
    <properties>
      <property name="lastChild" scope="prototype" type=""/>
      <property name="scrollTop" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form._ComboBoxMenu._highlighted_option" private="true">
    <properties>
      <property name="nextSibling" scope="prototype" type=""/>
      <property name="previousSibling" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form._ComboBoxMenu.domNode.firstChild" type="">
    <properties>
      <property name="nextSibling" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.ComboBox" type="Function" classlike="true" superclass="dijit.form.ValidationTextBox">
    <summary>Auto-completing text box, and base class for dijit.form.FilteringSelect.</summary>
    <description>The drop down box's values are populated from an class called
	a data provider, which returns a list of values based on the characters
	that the user has typed into the input box.
	If OPTION tags are used as the data provider via markup,
	then the OPTION tag's child text node is used as the widget value
	when selected.  The OPTION tag's value attribute is ignored.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	Some of the options to the ComboBox are actually arguments to the data
	provider.</description>
    <mixins>
      <mixin scope="prototype" location="dijit.form.ComboBoxMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.ValidationTextBox"/>
      <mixin scope="instance" location="dijit.form.ComboBoxMixin"/>
    </mixins>
    <properties>
      <property name="item" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', value) works.</summary>
        <description>Sets the value of the select.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form._ComboBoxDataStore.root" type="">
    <properties>
      <property name="selectedIndex" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.CurrencyTextBox" type="Function" classlike="true" superclass="dijit.form.NumberTextBox">
    <summary>A validating currency textbox</summary>
    <description>CurrencyTextBox is similar to `dijit.form.NumberTextBox` but has a few
	extra features related to currency:
	1. After specifying the currency type (american dollars, euros, etc.) it automatically
	sets parse/format options such as how many decimal places to show.
	2. The currency mark (dollar sign, euro mark, etc.) is displayed when the field is blurred
	but erased during editing, so that the user can just enter a plain number.</description>
    <mixins>
      <mixin scope="instance" location="dijit.form.NumberTextBox"/>
    </mixins>
    <properties>
      <property name="currency" scope="prototype" type="String">
        <summary>the [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like &amp;quot;USD&amp;quot;</summary>
      </property>
      <property name="constraints" scope="prototype" type="dijit.form.CurrencyTextBox.__Constraints">
        <summary>Despite the name, this parameter specifies both constraints on the input
	(including minimum/maximum allowed values) as well as
	formatting options.   See &lt;code&gt;dijit.form.CurrencyTextBox.__Constraints&lt;/code&gt; for details.</summary>
      </property>
      <property name="_formatter" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="regExpGen" scope="prototype">
        <parameters>
          <parameter name="constraints" type="" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="prototype">
        <summary>Parses string value as a Currency, according to the constraints object</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.CurrencyTextBox.__Constraints" type="Function" classlike="true" superclass="dijit.form.NumberTextBox.__Constraints" private="true">
    <summary>Specifies both the rules on valid/invalid values (minimum, maximum,
	number of required decimal places), and also formatting options for
	displaying the value when the field is not focused (currency symbol,
	etc.)</summary>
    <description>Follows the pattern of `dijit.form.NumberTextBox.constraints`.
	In general developers won't need to set this parameter</description>
    <mixins>
      <mixin scope="prototype" location="dojo.currency.__FormatOptions.prototype"/>
      <mixin scope="prototype" location="dojo.currency.__ParseOptions.prototype"/>
      <mixin scope="instance" location="dijit.form.NumberTextBox.__Constraints"/>
      <mixin scope="instance" location="dojo.currency.__FormatOptions"/>
      <mixin scope="instance" location="dojo.currency.__ParseOptions"/>
    </mixins>
    <examples>
      <example>To ensure that the user types in the cents (for example, 1.00 instead of just 1):
			{fractional:true}</example>
    </examples>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form.DateTextBox" type="Function" classlike="true" superclass="dijit.form._DateTimeTextBox">
    <summary>A validating, serializable, range-bound date text box with a drop down calendar
	Example:
		new dijit.form.DateTextBox({value: new Date(2009, 0, 20)})
	Example:
		&amp;lt;input dojotype='dijit.form.DateTextBox' value='2009-01-20'&amp;gt;</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form._DateTimeTextBox"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="popupClass" scope="prototype" type="String"/>
      <property name="_selector" scope="prototype" type="String"/>
      <property name="value" scope="prototype" type="Date">
        <summary>The value of this widget as a JavaScript Date object, with only year/month/day specified.
	If specified in markup, use the format specified in &lt;code&gt;dojo.date.stamp.fromISOString&lt;/code&gt;
	value.toString()=&amp;quot;NaN&amp;quot;</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form.FilteringSelect" type="Function" classlike="true" superclass="dijit.form.MappedTextBox">
    <summary>An enhanced version of the HTML SELECT tag, populated dynamically</summary>
    <description>An enhanced version of the HTML SELECT tag, populated dynamically. It works
	very nicely with very large data sets because it can load and page data as needed.
	It also resembles ComboBox, but does not allow values outside of the provided ones.
	If OPTION tags are used as the data provider via markup, then the
	OPTION tag's child text node is used as the displayed value when selected
	while the OPTION tag's value attribute is used as the widget value on form submit.
	To set the default value when using OPTION tags, specify the selected
	attribute on 1 of the child OPTION tags.
	Similar features:
	- There is a drop down list of possible values.
	- You can only enter a value from the drop down list.  (You can't
	enter an arbitrary value.)
	- The value submitted with the form is the hidden value (ex: CA),
	not the displayed value a.k.a. label (ex: California)
	Enhancements over plain HTML version:
	- If you type in some text then it will filter down the list of
	possible values in the drop down list.
	- List can be specified either as a static list or via a javascript
	function (that can get the list from a server)</description>
    <mixins>
      <mixin scope="prototype" location="dijit.form.ComboBoxMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.MappedTextBox"/>
      <mixin scope="instance" location="dijit.form.ComboBoxMixin"/>
    </mixins>
    <properties>
      <property name="_isvalid" scope="prototype" type="bool"/>
      <property name="required" scope="prototype" type="Boolean">
        <summary>True (default) if user is required to enter a value into this field.</summary>
      </property>
      <property name="_lastDisplayedValue" scope="prototype" type="String"/>
      <property name="item" scope="prototype" type="Object"/>
      <property name="_lastQuery" scope="prototype" type="Object"/>
      <property name="_fetchHandle" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="isValid" scope="prototype">
        <return-types>
          <return-type type="#5974"/>
        </return-types>
      </method>
      <method name="_callbackSetLabel" scope="prototype">
        <summary>Callback function that dynamically sets the label of the
	ComboBox</summary>
        <parameters>
          <parameter name="result" type="Array" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_openResultList" scope="prototype">
        <parameters>
          <parameter name="results" type="Object" usage="required"/>
          <parameter name="dataObject" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>Hook for attr('value') to work.</summary>
      </method>
      <method name="_getValueField" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', value) works.</summary>
        <description>Sets the value of the select.
	Also sets the label to the corresponding value by reverse lookup.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_setItemAttr" scope="prototype">
        <summary>Set the displayed valued in the input box, and the hidden value
	that gets submitted, based on a dojo.data store item.</summary>
        <description>Users shouldn't call this function; they should be calling
	attr('item', value)</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="displayedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getDisplayQueryString" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="prototype">
        <summary>Hook so attr('displayedValue', label) works.</summary>
        <description>Sets textbox to display label. Also performs reverse lookup
	to set the hidden value.</description>
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="undo" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.FilteringSelect.valueNode" type="">
    <properties>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.FilteringSelect.textbox" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.Form" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Widget corresponding to HTML form tag, for validation and serialization</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit.form._FormMixin.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit.form._FormMixin"/>
    </mixins>
    <examples>
      <example>	&lt;form dojoType="dijit.form.Form" id="myForm"&gt;
			Name: &lt;input type="text" name="name" /&gt;
		&lt;/form&gt;
		myObj = {name: "John Doe"};
		dijit.byId('myForm').attr('value', myObj);
		myObj=dijit.byId('myForm').attr('value');</example>
    </examples>
    <properties>
      <property name="name" scope="prototype" type="String">
        <summary>Name of form for scripting.</summary>
      </property>
      <property name="action" scope="prototype" type="String">
        <summary>Server-side form handler.</summary>
      </property>
      <property name="method" scope="prototype" type="String">
        <summary>HTTP method used to submit the form, either &amp;quot;GET&amp;quot; or &amp;quot;POST&amp;quot;.</summary>
      </property>
      <property name="encType" scope="prototype" type="String">
        <summary>Encoding type for the form, ex: application/x-www-form-urlencoded.</summary>
      </property>
      <property name="accept-charset" scope="prototype" type="String">
        <summary>List of supported charsets.</summary>
      </property>
      <property name="accept" scope="prototype" type="String">
        <summary>List of MIME types for file upload.</summary>
      </property>
      <property name="target" scope="prototype" type="String">
        <summary>Target frame for the document to be opened in.</summary>
      </property>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="nameAttrSetting" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="execute" scope="prototype">
        <summary>Deprecated: use submit()</summary>
        <parameters>
          <parameter name="formContents" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onExecute" scope="prototype">
        <summary>Deprecated: use onSubmit()</summary>
      </method>
      <method name="_setEncTypeAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="onReset" scope="prototype">
        <summary>Callback when user resets the form. This method is intended
	to be over-ridden. When the &lt;code&gt;reset&lt;/code&gt; method is called
	programmatically, the return value from &lt;code&gt;onReset&lt;/code&gt; is used
	to compute whether or not resetting should proceed</summary>
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_onReset" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onSubmit" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSubmit" scope="prototype">
        <summary>Callback when user submits the form.</summary>
        <description>This method is intended to be over-ridden, but by default it checks and
	returns the validity of form elements. When the `submit`
	method is called programmatically, the return value from
	`onSubmit` is used to compute whether or not submission
	should proceed</description>
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="submit" scope="prototype">
        <summary>programmatically submit form if and only if the &lt;code&gt;onSubmit&lt;/code&gt; returns true</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.form.Form.domNode" type="">
    <properties>
      <property name="encoding" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.HorizontalRule" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Hash marks for &lt;code&gt;dijit.form.HorizontalSlider&lt;/code&gt;</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="count" scope="prototype" type="Integer">
        <summary>Number of hash marks to generate</summary>
      </property>
      <property name="container" scope="prototype" type="String">
        <summary>For HorizontalSlider, this is either &amp;quot;topDecoration&amp;quot; or &amp;quot;bottomDecoration&amp;quot;,
	and indicates whether this rule goes above or below the slider.</summary>
      </property>
      <property name="ruleStyle" scope="prototype" type="String">
        <summary>CSS style to apply to individual hash marks</summary>
      </property>
      <property name="_positionPrefix" scope="prototype" type="String"/>
      <property name="_positionSuffix" scope="prototype" type="String"/>
      <property name="_suffix" scope="prototype" type="String"/>
      <property name="_isHorizontal" scope="prototype" type="Boolean">
        <summary>VerticalRule will override this...</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_genHTML" scope="prototype">
        <parameters>
          <parameter name="pos" type="" usage="required"/>
          <parameter name="ndx" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.HorizontalRule.domNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.HorizontalRuleLabels" type="Function" classlike="true" superclass="dijit.form.HorizontalRule">
    <summary>Labels for &lt;code&gt;dijit.form.HorizontalSlider&lt;/code&gt;</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.HorizontalRule"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="labelStyle" scope="prototype" type="String">
        <summary>CSS style to apply to individual text labels</summary>
      </property>
      <property name="labels" scope="prototype" type="String[]">
        <summary>Array of text labels to render - evenly spaced from left-to-right or bottom-to-top.
	Alternately, minimum and maximum can be specified, to get numeric labels.</summary>
      </property>
      <property name="numericMargin" scope="prototype" type="Integer">
        <summary>Number of generated numeric labels that should be rendered as '' on the ends when labels[] are not specified</summary>
      </property>
      <property name="minimum" scope="prototype" type="Number"/>
      <property name="maximum" scope="prototype" type="Number"/>
      <property name="_positionPrefix" scope="prototype" type="String"/>
      <property name="_labelPrefix" scope="prototype" type="String"/>
      <property name="_suffix" scope="prototype" type="String"/>
      <property name="count" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_calcPosition" scope="prototype">
        <summary>Returns the value to be used in HTML for the label as part of the left: attribute</summary>
        <parameters>
          <parameter name="pos" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_genHTML" scope="prototype">
        <parameters>
          <parameter name="pos" type="" usage="required"/>
          <parameter name="ndx" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabels" scope="prototype">
        <summary>Overridable function to return array of labels to use for this slider.
	Can specify a getLabels() method instead of a labels[] array, or min/max attributes.</summary>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.HorizontalRuleLabels.constraints">
    <summary>pattern, places, lang, et al (see dojo.number) for generated numeric labels when labels[] are not specified</summary>
    <properties>
      <property name="pattern" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.HorizontalRuleLabels.srcNodeRef" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.HorizontalSlider" type="Function" classlike="true" superclass="dijit.form._FormValueWidget">
    <summary>A form widget that allows one to select a value with a horizontally draggable handle</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit.form._FormValueWidget"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="value" scope="prototype" type="Number"/>
      <property name="showButtons" scope="prototype" type="Boolean">
        <summary>Show increment/decrement buttons at the ends of the slider?</summary>
      </property>
      <property name="minimum" scope="prototype" type="Integer">
        <summary>The minimum value the slider can be set to.</summary>
      </property>
      <property name="maximum" scope="prototype" type="Integer">
        <summary>The maximum value the slider can be set to.</summary>
      </property>
      <property name="discreteValues" scope="normal" type="Integer">
        <summary>If specified, indicates that the slider handle has only 'discreteValues' possible positions,
	and that after dragging the handle, it will snap to the nearest possible position.
	Thus, the slider has only 'discreteValues' possible values.
	For example, if minimum=10, maxiumum=30, and discreteValues=3, then the slider handle has
	three possible positions, representing values 10, 20, or 30.
	If discreteValues is not specified or if it's value is higher than the number of pixels
	in the slider bar, then the slider handle can be moved freely, and the slider's value will be
	computed/reported based on pixel position (in this case it will likely be fractional,
	such as 123.456789).</summary>
      </property>
      <property name="pageIncrement" scope="prototype" type="Integer">
        <summary>If discreteValues is also specified, this indicates the amount of clicks (ie, snap positions)
	that the slider handle is moved via pageup/pagedown keys.
	If discreteValues is not specified, it indicates the number of pixels.</summary>
      </property>
      <property name="clickSelect" scope="prototype" type="Boolean">
        <summary>If clicking the slider bar changes the value or not</summary>
      </property>
      <property name="slideDuration" scope="normal" type="Number">
        <summary>The time in ms to take to animate the slider handle from 0% to 100%,
	when clicking the slider bar to make the handle move.</summary>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="_mousePixelCoord" scope="prototype" type="String"/>
      <property name="_pixelCount" scope="prototype" type="String"/>
      <property name="_startingPixelCoord" scope="prototype" type="String"/>
      <property name="_startingPixelCount" scope="prototype" type="String"/>
      <property name="_handleOffsetCoord" scope="prototype" type="String"/>
      <property name="_progressPixelSize" scope="prototype" type="String"/>
      <property name="_inProgressAnim" scope="prototype" type="Object"/>
      <property name="_movable" scope="prototype" type="Object"/>
      <property name="_supportingWidgets" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_onKeyUp" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_isReversed" scope="prototype">
        <summary>Returns true if direction is from right to left</summary>
      </method>
      <method name="_onBarClick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="prototype">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean," usage="required">
            <summary>optional</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', value) works.</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean," usage="required">
            <summary>optional</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_bumpValue" scope="prototype">
        <parameters>
          <parameter name="signedChange" type="" usage="required"/>
          <parameter name="priorityChange" type="Boolean," usage="required">
            <summary>optional</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onClkBumper" scope="prototype">
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="prototype"/>
      <method name="_onClkDecBumper" scope="prototype"/>
      <method name="decrement" scope="prototype">
        <summary>Decrement slider</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="increment" scope="prototype">
        <summary>Increment slider</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="prototype">
        <summary>Event handler for mousewheel where supported</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="_typematicCallback" scope="prototype">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="button" type="Object" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.HorizontalSlider.valueNode" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.HorizontalSlider.incrementButton.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.HorizontalSlider.decrementButton.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form._SliderMover" type="Function" classlike="true" superclass="dojo.dnd.Mover">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Mover"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form._SliderMover.widget" type="">
    <properties>
      <property name="_abspos" scope="prototype" type="Object"/>
      <property name="_setPixelValue_" scope="prototype" type="Object"/>
      <property name="_isReversed_" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.form.MappedTextBox" type="Function" classlike="true" superclass="dijit.form.ValidationTextBox">
    <summary>A dijit.form.ValidationTextBox subclass which provides a base class for widgets that have
	a visible formatted display value, and a serializable
	value in a hidden input field which is actually sent to the server.</summary>
    <description>The visible display may
	be locale-dependent and interactive.  The value sent to the server is stored in a hidden
	input field which uses the `name` attribute declared by the original widget.  That value sent
	to the server is defined by the dijit.form.MappedTextBox.serialize method and is typically
	locale-neutral.</description>
    <mixins>
      <mixin scope="instance" location="dijit.form.ValidationTextBox"/>
    </mixins>
    <properties>
      <property name="nameAttrSetting" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="serialize" scope="prototype">
        <summary>Overridable function used to convert the attr('value') result to a canonical
	(non-localized) string.  For example, will print dates in ISO format, and
	numbers the same way as they are represented in javascript.</summary>
        <parameters>
          <parameter name="val" type="anything" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toString" scope="prototype">
        <summary>Returns widget as a printable string using the widget's value</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="validate" scope="prototype"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="reset" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.MultiSelect" type="Function" classlike="true" superclass="dijit.form._FormValueWidget">
    <summary>Widget version of a &amp;lt;select multiple=true&amp;gt; element,
	for selecting multiple options.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormValueWidget"/>
    </mixins>
    <properties>
      <property name="size" scope="prototype" type="Number">
        <summary>Number of elements to display on a page
	NOTE: may be removed in version 2.0, since elements may have variable height;
	set the size via style=&amp;quot;...&amp;quot; or CSS class names instead.
	for Form</summary>
      </property>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="_hasBeenBlurred" scope="prototype" type="bool"/>
      <property name="multiple" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="reset" scope="prototype">
        <summary>Reset the widget's value to what it was at initialization time</summary>
      </method>
      <method name="addSelected" scope="prototype">
        <summary>Move the selected nodes of a passed Select widget
	instance to this Select widget.</summary>
        <examples>
          <example>	// move all the selected values from "bar" to "foo"
	 	dijit.byId("foo").addSelected(dijit.byId("bar"));</example>
        </examples>
        <parameters>
          <parameter name="select" type="dijit.form.MultiSelect" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="prototype">
        <summary>Access the NodeList of the selected options directly</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>Hook so attr('value') works.</summary>
        <description>Returns an array of the selected options' values.</description>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', values) works.</summary>
        <description>Set the value(s) of this Select based on passed values</description>
        <parameters>
          <parameter name="values" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="invertSelection" scope="prototype">
        <summary>Invert the selection</summary>
        <parameters>
          <parameter name="onChange" type="Boolean" usage="required">
            <summary>If null, onChange is not fired.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onChange" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.NumberSpinner" type="Function" classlike="true" superclass="dijit.form._Spinner">
    <summary>Extends NumberTextBox to add up/down arrows and pageup/pagedown for incremental change to the value</summary>
    <description>A `dijit.form.NumberTextBox` extension to provide keyboard accessible value selection
	as well as icons for spinning direction. When using the keyboard, the typematic rules
	apply, meaning holding the key will gradually increarease or decrease the value and
	accelerate.</description>
    <mixins>
      <mixin scope="prototype" location="dijit.form.NumberTextBoxMixin.prototype"/>
      <mixin scope="instance" location="dijit.form._Spinner"/>
      <mixin scope="instance" location="dijit.form.NumberTextBoxMixin"/>
    </mixins>
    <examples>
      <example> new dijit.form.NumberSpinner({ constraints:{ max:300, min:100 }}, "someInput");</example>
    </examples>
    <methods>
      <method constructor="constructor"/>
      <method name="adjust" scope="prototype">
        <summary>Change Number val by the given amount</summary>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form.NumberSpinner.constraints" type="">
    <properties>
      <property name="min" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.NumberTextBox" type="Function" classlike="true" superclass="dijit.form.RangeBoundTextBox">
    <summary>A TextBox for entering numbers, with formatting and range checking</summary>
    <description>NumberTextBox is a textbox for entering and displaying numbers, supporting
	the following main features:
	1. Enforce minimum/maximum allowed values (as well as enforcing that the user types
	a number rather than a random string)
	2. NLS support (altering roles of comma and dot as "thousands-separator" and "decimal-point"
	depending on locale).
	3. Separate modes for editing the value and displaying it, specifically that
	the thousands separator character (typically comma) disappears when editing
	but reappears after the field is blurred.
	4. Formatting and constraints regarding the number of places (digits after the decimal point)
	allowed on input, and number of places displayed when blurred (see `constraints` parameter).</description>
    <mixins>
      <mixin scope="prototype" location="dijit.form.NumberTextBoxMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.RangeBoundTextBox"/>
      <mixin scope="instance" location="dijit.form.NumberTextBoxMixin"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form.NumberTextBox.__Constraints" type="Function" classlike="true" superclass="dijit.form.RangeBoundTextBox.__Constraints" private="true">
    <summary>Specifies both the rules on valid/invalid values (minimum, maximum,
	number of required decimal places), and also formatting options for
	displaying the value when the field is not focused.</summary>
    <mixins>
      <mixin scope="prototype" location="dojo.number.__FormatOptions.prototype"/>
      <mixin scope="prototype" location="dojo.number.__ParseOptions.prototype"/>
      <mixin scope="instance" location="dijit.form.RangeBoundTextBox.__Constraints"/>
      <mixin scope="instance" location="dojo.number.__FormatOptions"/>
      <mixin scope="instance" location="dojo.number.__ParseOptions"/>
    </mixins>
    <examples>
      <example>Minimum/maximum:
	To specify a field between 0 and 120:
			{min:0,max:120}
	To specify a field that must be an integer:
			{fractional:false}
	To specify a field where 0 to 3 decimal places are allowed on input,
	but after the field is blurred the value is displayed with 3 decimal places:
			{places:'0,3'}</example>
    </examples>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form.NumberTextBoxMixin" type="Function" classlike="true">
    <summary>A mixin for all number textboxes</summary>
    <properties>
      <property name="regExpGen" scope="normal" type=""/>
      <property name="value" scope="normal" type="Number">
        <summary>The value of this NumberTextBox as a javascript Number (ie, not a String).
	If the displayed value is blank, the value is NaN, and if the user types in
	an gibberish value (like &amp;quot;hello world&amp;quot;), the value is undefined
	(i.e. attr('value') returns undefined).
	Symetrically, attr('value', NaN) will clear the displayed value,
	whereas attr('value', undefined) will have no effect.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_formatter" scope="prototype">
        <summary>_formatter() is called by format().   It's the base routine for formatting a number,
	as a string, for example converting 12345 into &amp;quot;12,345&amp;quot;.</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <summary>The number to be converted into a string.</summary>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional">
            <summary>Formatting options</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_onFocus" scope="prototype"/>
      <method name="format" scope="prototype">
        <summary>Formats the value as a Number, according to constraints.</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="constraints" type="dojo.number.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="prototype">
        <summary>Parses the string value as a Number, according to constraints.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>String representing a number</summary>
          </parameter>
          <parameter name="constraints" type="dojo.number.__ParseOptions" usage="required">
            <summary>Formatting options</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getDisplayedValueAttr" scope="prototype"/>
      <method name="filter" scope="prototype">
        <summary>This is called with both the display value (string), and the actual value (a number).
	When called with the actual value it does corrections so that '' etc. are represented as NaN.
	Otherwise it dispatches to the superclass's filter() method.
	See &lt;code&gt;dijit.form.TextBox.filter&lt;/code&gt; for more details.</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="attr('value', null"/>
          <return-type type=""/>
          <return-type type="''"/>
          <return-type type="undefined) should fire onChange(NaN)"/>
        </return-types>
      </method>
      <method name="serialize" scope="prototype">
        <summary>Convert value (a Number) into a canonical string (ie, how the number literal is written in javascript/java/C/etc.)</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', ...) works.</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>Hook so attr('value') works.
	Returns Number, NaN for '', or undefined for unparsable text</summary>
        <return-types>
          <return-type type="return exponential Number or undefined for random text (may not be possible to do with the above RegExp check)"/>
          <return-type type="gibberish"/>
          <return-type type="Number or NaN for ''"/>
        </return-types>
      </method>
      <method name="isValid" scope="prototype">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="valid exponential number in range"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dijit.form.NumberTextBoxMixin.editOptions">
    <summary>Properties to mix into constraints when the value is being edited.
	This is here because we edit the number in the format &amp;quot;12345&amp;quot;, which is
	different than the display value (ex: &amp;quot;12,345&amp;quot;)</summary>
    <properties>
      <property name="pattern" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.NumberTextBoxMixin.constraints" type="dijit.form.NumberTextBox.__Constraints">
    <summary>Despite the name, this parameter specifies both constraints on the input
	(including minimum/maximum allowed values) as well as
	formatting options like places (the number of digits to display after
	the decimal point).   See &lt;code&gt;dijit.form.NumberTextBox.__Constraints&lt;/code&gt; for details.</summary>
    <properties>
      <property name="max" scope="prototype" type="Number"/>
      <property name="min" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dijit.form.NumberTextBoxMixin.textbox" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.RangeBoundTextBox" type="Function" classlike="true" superclass="dijit.form.MappedTextBox">
    <summary>Base class for textbox form widgets which defines a range of valid values.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.MappedTextBox"/>
    </mixins>
    <properties>
      <property name="rangeMessage" scope="prototype" type="String">
        <summary>The message to display if value is out-of-range</summary>
      </property>
      <property name="constraints" scope="prototype" type="dijit.form.RangeBoundTextBox.__Constraints"/>
      <property name="messages" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="rangeCheck" scope="prototype">
        <summary>Overridable function used to validate the range of the numeric input value.</summary>
        <parameters>
          <parameter name="primitive" type="Number" usage="required"/>
          <parameter name="constraints" type="dijit.form.RangeBoundTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="isInRange" scope="prototype">
        <summary>Tests if the value is in the min/max range specified in constraints</summary>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isDefinitelyOutOfRange" scope="prototype">
        <summary>Returns true if the value is out of range and will remain
	out of range even if the user types more characters</summary>
      </method>
      <method name="_isValidSubset" scope="prototype">
        <summary>Overrides &lt;code&gt;dijit.form.ValidationTextBox._isValidSubset&lt;/code&gt;.
	Returns true if the input is syntactically valid, and either within
	range or could be made in range by more typing.</summary>
      </method>
      <method name="isValid" scope="prototype">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getErrorMessage" scope="prototype">
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', ...) works.</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form._SelectMenu" type="Function" classlike="true" superclass="dijit.Menu">
    <summary>An internally-used menu for dropdown that allows us to more
	gracefully overflow our menu</summary>
    <mixins>
      <mixin scope="instance" location="dijit.Menu"/>
    </mixins>
    <properties>
      <property name="menuTableNode" scope="prototype" type=""/>
      <property name="domNode" scope="prototype" type="Object"/>
      <property name="tabIndex" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype">
        <summary>Stub in our own changes, so that our domNode is not a table
	otherwise, we won't respond correctly to heights/overflows</summary>
      </method>
      <method name="resize" scope="prototype">
        <summary>Overridden so that we are able to handle resizing our
	internal widget.  Note that this is not a &amp;quot;full&amp;quot; resize
	implementation - it only works correctly if you pass it a
	marginBox.</summary>
        <parameters>
          <parameter name="mb" type="Object" usage="required">
            <summary>The margin box to set this dropdown to.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form.Select" type="Function" classlike="true" superclass="dijit.form._FormSelectWidget">
    <summary>This is a &amp;quot;styleable&amp;quot; select box - it is basically a DropDownButton which
	can take a &amp;lt;select&amp;gt; as its input.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._HasDropDown.prototype"/>
      <mixin scope="instance" location="dijit.form._FormSelectWidget"/>
      <mixin scope="instance" location="dijit._HasDropDown"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object">
        <summary>Add in our style to be applied to the focus node</summary>
      </property>
      <property name="required" scope="prototype" type="Boolean">
        <summary>Can be true or false, default is false.</summary>
      </property>
      <property name="state" scope="prototype" type="String">
        <summary>Shows current state (ie, validation result) of input (Normal, Warning, or Error)</summary>
      </property>
      <property name="tooltipPosition" scope="prototype" type="String[]">
        <summary>See description of dijit.Tooltip.defaultPosition for details on this parameter.</summary>
      </property>
      <property name="emptyLabel" scope="prototype" type="string">
        <summary>What to display in an &amp;quot;empty&amp;quot; dropdown</summary>
      </property>
      <property name="_isLoaded" scope="prototype" type="Boolean">
        <summary>Whether or not we have been loaded</summary>
      </property>
      <property name="_childrenLoaded" scope="prototype" type="Boolean">
        <summary>Whether or not our children have been loaded</summary>
      </property>
      <property name="value" scope="prototype" type=""/>
      <property name="dropDown" scope="prototype" type="Object"/>
      <property name="_message" scope="prototype" type=""/>
      <property name="_missingMsg" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_fillContent" scope="prototype">
        <summary>Set the value to be the first, or the selected index</summary>
      </method>
      <method name="_getMenuItemForOption" scope="prototype">
        <summary>For the given option, return the menu item that should be
	used to display it.  This can be overridden as needed</summary>
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_addOptionItem" scope="prototype">
        <summary>For the given option, add an option to our dropdown.
	If the option doesn't have a value, then a separator is added
	in that place.</summary>
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_getChildren" scope="prototype"/>
      <method name="_loadChildren" scope="prototype">
        <summary>Resets the menu and the length attribute of the button - and
	ensures that the label is appropriately set.</summary>
        <parameters>
          <parameter name="loadMenuItems" type="Boolean" usage="required">
            <summary>actually loads the child menu items - we only do this when we are
	populating for showing the dropdown.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplay" scope="prototype">
        <summary>sets the display for the given value (or values)</summary>
        <parameters>
          <parameter name="newDisplay" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="validate" scope="prototype">
        <summary>Called by oninit, onblur, and onkeypress.</summary>
        <description>Show missing or invalid messages if appropriate, and highlight textbox field.
	Used when a select is initially set to no value and the user is required to
	set the value.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="prototype">
        <summary>Whether or not this is a valid value.   The only way a Select
	can be invalid is when it's required but nothing is selected.</summary>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <summary>Overridden so that the state will be cleared.</summary>
      </method>
      <method name="postMixInProperties" scope="prototype">
        <summary>set the missing message</summary>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="isLoaded" scope="prototype"/>
      <method name="loadDropDown" scope="prototype">
        <summary>populates the menu</summary>
        <parameters>
          <parameter name="loadCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="prototype">
        <parameters>
          <parameter name="preserveDom" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form.Select.srcNodeRef" type="">
    <properties>
      <property name="selectedIndex" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.Select.options" type="">
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.Select.containerNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.SimpleTextarea" type="Function" classlike="true" superclass="dijit.form.TextBox">
    <summary>A simple textarea that degrades, and responds to
	minimal LayoutContainer usage, and works with dijit.form.Form.
	Doesn't automatically size according to input, like Textarea.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.TextBox"/>
    </mixins>
    <examples>
      <example>	&lt;textarea dojoType="dijit.form.SimpleTextarea" name="foo" value="bar" rows=30 cols=40&gt;&lt;/textarea&gt;</example>
      <example>	new dijit.form.SimpleTextarea({ rows:20, cols:30 }, "foo");</example>
    </examples>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="rows" scope="prototype" type="Number">
        <summary>The number of characters per line.</summary>
      </property>
      <property name="cols" scope="prototype" type="String"/>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="value" scope="prototype" type=""/>
      <property name="_previousValue" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="filter" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_onInput" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form.SimpleTextarea.textbox" type="">
    <properties>
      <property name="selectionStart" scope="prototype" type=""/>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.TextBox" type="Function" classlike="true" superclass="dijit.form._FormValueWidget">
    <summary>A base class for textbox form inputs</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormValueWidget"/>
    </mixins>
    <properties>
      <property name="trim" scope="prototype" type="Boolean">
        <summary>Removes leading and trailing whitespace if true.  Default is false.</summary>
      </property>
      <property name="uppercase" scope="prototype" type="Boolean">
        <summary>Converts all characters to uppercase if true.  Default is false.</summary>
      </property>
      <property name="lowercase" scope="prototype" type="Boolean">
        <summary>Converts all characters to lowercase if true.  Default is false.</summary>
      </property>
      <property name="propercase" scope="prototype" type="Boolean">
        <summary>Converts the first character of each word to uppercase if true.</summary>
      </property>
      <property name="maxLength" scope="prototype" type="String">
        <summary>HTML INPUT tag maxLength declaration.</summary>
      </property>
      <property name="selectOnClick" scope="prototype" type="Boolean">
        <summary>If true, all text will be selected when focused with mouse</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="displayedValue" scope="prototype" type="String">
        <summary>For subclasses like ComboBox where the displayed value
	(ex: Kentucky) and the serialized value (ex: KY) are different,
	this represents the displayed value.
	Setting 'displayedValue' through attr('displayedValue', ...)
	updates 'value', and vice-versa.  Othewise 'value' is updated
	from 'displayedValue' periodically, like onBlur etc.
	TODO: move declaration to MappedTextBox?
	Problem is that ComboBox references displayedValue,
	for benefit of FilteringSelect.
	if the textbox is blank, what value should be reported</summary>
      </property>
      <property name="_blankValue" scope="prototype" type="String"/>
      <property name="_selectOnClickHandle" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getValueAttr" scope="prototype">
        <summary>Hook so attr('value') works as we like.</summary>
        <description>For `dijit.form.TextBox` this basically returns the value of the &lt;input&gt;.
	For `dijit.form.MappedTextBox` subclasses, which have both
	a "displayed value" and a separate "submit value",
	This treats the "displayed value" as the master value, computing the
	submit value from it via this.parse().</description>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', ...) works.</summary>
        <description>Sets the value of the widget to "value" which can be of
	any type as determined by the widget.</description>
        <parameters>
          <parameter name="value" type="The" usage="required">
            <summary>visual element value is also set to a corresponding,
	but not necessarily the same, value.</summary>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <summary>If true, an onChange event is fired immediately instead of
	waiting for the next blur event.</summary>
          </parameter>
          <parameter name="formattedValue" type="String" usage="optional">
            <summary>If specified, used to set the visual element value,
	otherwise a computed visual value is used.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getDisplayedValue" scope="prototype">
        <summary>Deprecated.   Use attr('displayedValue') instead.</summary>
      </method>
      <method name="_getDisplayedValueAttr" scope="prototype">
        <summary>Hook so attr('displayedValue') works.</summary>
        <description>Returns the displayed value (what the user sees on the screen),
	after filtering (ie, trimming spaces etc.).
	For some subclasses of TextBox (like ComboBox), the displayed value
	is different from the serialized value that's actually
	sent to the server (see dijit.form.ValidationTextBox.serialize)</description>
      </method>
      <method name="setDisplayedValue" scope="prototype">
        <summary>Deprecated.   Use attr('displayedValue', ...) instead.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplayedValueAttr" scope="prototype">
        <summary>Hook so attr('displayedValue', ...) works.</summary>
        <description>Sets the value of the visual element to the string "value".
	The widget value is also set to a corresponding,
	but not necessarily the same, value.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="prototype">
        <summary>Replacable function to convert a value to a properly formatted string.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="prototype">
        <summary>Replacable function to convert a formatted string to a value</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_refreshState" scope="prototype">
        <summary>After the user types some characters, etc., this method is
	called to check the field for validity etc.  The base method
	in &lt;code&gt;dijit.form.TextBox&lt;/code&gt; does nothing, but subclasses override.</summary>
      </method>
      <method name="_onInput" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="filter" scope="prototype">
        <summary>Auto-corrections (such as trimming) that are applied to textbox
	value on blur or form submit.</summary>
        <description>For MappedTextBox subclasses, this is called twice
	- once with the display value
	- once the value as set/returned by attr('value', ...)
	and attr('value'), ex: a Number for NumberTextBox.
	In the latter case it does corrections like converting null to NaN.  In
	the former case the NumberTextBox.filter() method calls this.inherited()
	to execute standard trimming code in TextBox.filter().
	TODO: break this into two methods in 2.0</description>
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setBlurValue" scope="prototype"/>
      <method name="_onBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype">
        <parameters>
          <parameter name="by" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.TextBox.textbox" type="">
    <properties>
      <property name="value" scope="prototype" type="String"/>
      <property name="selectionStart" scope="prototype" type="Object"/>
      <property name="selectionEnd" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.form.Textarea" type="Function" classlike="true" superclass="dijit.form.SimpleTextarea">
    <summary>A textarea widget that adjusts it's height according to the amount of data.</summary>
    <description>A textarea that dynamically expands/contracts (changing it's height) as
	the user types, to display all the text without requiring a scroll bar.
	Takes nearly all the parameters (name, value, etc.) that a vanilla textarea takes.
	Rows is not supported since this widget adjusts the height.</description>
    <mixins>
      <mixin scope="instance" location="dijit.form.SimpleTextarea"/>
    </mixins>
    <examples>
      <example>	&lt;textarea dojoType="dijit.form.TextArea"&gt;...&lt;/textarea&gt;</example>
    </examples>
    <properties>
      <property name="cols" scope="prototype" type="String"/>
      <property name="_previousNewlines" scope="prototype" type="Number"/>
      <property name="_strictMode" scope="prototype" type="bool"/>
      <property name="_needsHelpShrinking" scope="prototype" type="Object"/>
      <property name="_busyResizing" scope="prototype" type="bool"/>
      <property name="_setTimeoutHandle" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getHeight" scope="prototype">
        <parameters>
          <parameter name="textarea" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_estimateHeight" scope="prototype">
        <summary>Approximate the height when the textarea is invisible with the number of lines in the text.
	Fails when someone calls setValue with a long wrapping line, but the layout fixes itself when the user clicks inside so . . .
	In IE, the resize event is supposed to fire when the textarea becomes visible again and that will correct the size automatically.</summary>
        <parameters>
          <parameter name="textarea" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onInput" scope="prototype"/>
      <method name="_shrink" scope="prototype"/>
      <method name="resize" scope="prototype">
        <summary>Resizes the textarea vertically (should be called after a style/value change)</summary>
      </method>
      <method name="_setValueAttr" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.Textarea.textbox.style" type="">
    <properties>
      <property name="maxHeight" scope="prototype" type="String"/>
      <property name="height" scope="prototype" type=""/>
      <property name="paddingBottom" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.Textarea.textbox" type="">
    <properties>
      <property name="value" scope="prototype" type="String"/>
      <property name="scrollHeight" scope="prototype" type=""/>
      <property name="scrollTop" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dijit.form.TimeTextBox" type="Function" classlike="true" superclass="dijit.form._DateTimeTextBox">
    <summary>A validating, serializable, range-bound time text box with a drop down time picker</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form._DateTimeTextBox"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="popupClass" scope="prototype" type="String"/>
      <property name="_selector" scope="prototype" type="String"/>
      <property name="constraints" scope="prototype" type="dijit.form.TimeTextBox.__Constraints"/>
      <property name="value" scope="prototype" type="Date">
        <summary>The value of this widget as a JavaScript Date object, with only hours/minutes/seconds specified.
	Example:
		new dijit.form.TimeTextBox({value: dojo.date.local.fromISOString(&amp;quot;T:12:59:59&amp;quot;)})
	When passed to the parser in markup, must be specified according to locale-independent
	&lt;code&gt;dojo.date.stamp.fromISOString&lt;/code&gt; format.
	Example:
		&amp;lt;input dojotype='dijit.form.TimeTextBox' value='T12:34:00'&amp;gt;
	value.toString()=&amp;quot;NaN&amp;quot;</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form.TimeTextBox.__Constraints" type="Function" classlike="true" superclass="dijit.form._DateTimeTextBox.__Constraints" private="true">
    <mixins>
      <mixin scope="prototype" location="dijit._TimePicker.__Constraints.prototype"/>
      <mixin scope="instance" location="dijit.form._DateTimeTextBox.__Constraints"/>
      <mixin scope="instance" location="dijit._TimePicker.__Constraints"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form.ValidationTextBox" type="Function" classlike="true" superclass="dijit.form.TextBox">
    <summary>Base class for textbox widgets with the ability to validate content of various types and provide user feedback.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.TextBox"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="required" scope="prototype" type="Boolean">
        <summary>User is required to enter data into this field.</summary>
      </property>
      <property name="promptMessage" scope="prototype" type="String">
        <summary>If defined, display this hint string immediately on focus to the textbox, if empty.
	Think of this like a tooltip that tells the user what to do, not an error message
	that tells the user what they've done wrong.
	Message disappears when user starts typing.</summary>
      </property>
      <property name="invalidMessage" scope="prototype" type="String">
        <summary>The message to display if value is invalid.
	read from the message file if not overridden</summary>
      </property>
      <property name="regExp" scope="prototype" type="String">
        <summary>regular expression string used to validate the input
	Do not specify both regExp and regExpGen</summary>
      </property>
      <property name="state" scope="prototype" type="String">
        <summary>Shows current state (ie, validation result) of input (Normal, Warning, or Error)</summary>
      </property>
      <property name="tooltipPosition" scope="prototype" type="String[]">
        <summary>See description of &lt;code&gt;dijit.Tooltip.defaultPosition&lt;/code&gt; for details on this parameter.</summary>
      </property>
      <property name="_maskValidSubsetError" scope="prototype" type="Object"/>
      <property name="disabled" scope="prototype" type="Object"/>
      <property name="_message" scope="prototype" type="String">
        <summary>Currently displayed message</summary>
      </property>
      <property name="messages" scope="prototype" type="Object"/>
      <property name="_partialre" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="regExpGen" scope="prototype">
        <summary>Overridable function used to generate regExp when dependent on constraints.
	Do not specify both regExp and regExpGen.</summary>
        <parameters>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', ...) works.</summary>
      </method>
      <method name="validator" scope="prototype">
        <summary>Overridable function used to validate the text input against the regular expression.</summary>
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
      </method>
      <method name="_isValidSubset" scope="prototype">
        <summary>Returns true if the value is either already valid or could be made valid by appending characters.
	This is used for validation while the user [may be] still typing.</summary>
      </method>
      <method name="isValid" scope="prototype">
        <summary>Tests if value is valid.
	Can override with your own routine in a subclass.</summary>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_isEmpty" scope="prototype">
        <summary>Checks for whitespace</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getErrorMessage" scope="prototype">
        <summary>Return an error message to show if appropriate</summary>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getPromptMessage" scope="prototype">
        <summary>Return a hint message to show when widget is first focused</summary>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="validate" scope="prototype">
        <summary>Called by oninit, onblur, and onkeypress.</summary>
        <description>Show missing or invalid messages if appropriate, and highlight textbox field.</description>
        <parameters>
          <parameter name="isFocused" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="displayMessage" scope="prototype">
        <summary>Overridable method to display validation errors/hints.
	By default uses a tooltip.</summary>
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_refreshState" scope="prototype"/>
      <method name="constructor" scope="prototype"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="reset" scope="prototype"/>
      <method name="_onBlur" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form.ValidationTextBox.constraints" type="dijit.form.ValidationTextBox.__Constraints">
    <summary>user-defined object needed to pass parameters to the validator functions</summary>
    <properties>
      <property name="locale" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.ValidationTextBox.focusNode.style" type="">
    <properties>
      <property name="fontFamily" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.MappedTextBox.valueNode">
    <properties>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.form.ValidationTextBox.__Constraints" type="Function" classlike="true" private="true">
    <properties>
      <property name="locale" scope="instance" type="String">
        <summary>locale used for validation, picks up value from this widget's lang attribute</summary>
      </property>
      <property name="_flags_" scope="instance" type="anything">
        <summary>various flags passed to regExpGen function</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form.RangeBoundTextBox.__Constraints" type="Function" classlike="true" private="true">
    <properties>
      <property name="min" scope="instance" type="Number">
        <summary>Minimum signed value.  Default is -Infinity</summary>
      </property>
      <property name="max" scope="instance" type="Number">
        <summary>Maximum signed value.  Default is +Infinity</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form.VerticalRule" type="Function" classlike="true" superclass="dijit.form.HorizontalRule">
    <summary>Hash marks for the &lt;code&gt;dijit.form.VerticalSlider&lt;/code&gt;</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.HorizontalRule"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="_positionPrefix" scope="prototype" type="String"/>
      <property name="container" scope="prototype" type="String">
        <summary>This is either &amp;quot;leftDecoration&amp;quot; or &amp;quot;rightDecoration&amp;quot;,
	to indicate whether this rule goes to the left or to the right of the slider.
	Note that on RTL system, &amp;quot;leftDecoration&amp;quot; would actually go to the right, and vice-versa.</summary>
      </property>
      <property name="_isHorizontal" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form.VerticalRuleLabels" type="Function" classlike="true" superclass="dijit.form.HorizontalRuleLabels">
    <summary>Labels for the &lt;code&gt;dijit.form.VerticalSlider&lt;/code&gt;</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.HorizontalRuleLabels"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="_positionPrefix" scope="prototype" type="String"/>
      <property name="_labelPrefix" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_calcPosition" scope="prototype">
        <parameters>
          <parameter name="pos" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form.VerticalSlider" type="Function" classlike="true" superclass="dijit.form.HorizontalSlider">
    <summary>A form widget that allows one to select a value with a vertically draggable handle</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.HorizontalSlider"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_mousePixelCoord" scope="prototype" type="String"/>
      <property name="_pixelCount" scope="prototype" type="String"/>
      <property name="_startingPixelCoord" scope="prototype" type="String"/>
      <property name="_startingPixelCount" scope="prototype" type="String"/>
      <property name="_handleOffsetCoord" scope="prototype" type="String"/>
      <property name="_progressPixelSize" scope="prototype" type="String"/>
      <property name="_descending" scope="prototype" type="Boolean">
        <summary>Specifies if the slider values go from high-on-top (true), or low-on-top (false)
	TODO: expose this in 1.2 - the css progress/remaining bar classes need to be reversed</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="_isReversed" scope="prototype">
        <summary>Overrides HorizontalSlider._isReversed.
	Indicates if values are high on top (with low numbers on the bottom).</summary>
      </method>
      <method name="_rtlRectify" scope="prototype">
        <summary>Helper function on gecko.
	Rectify children nodes for left/right decoration in rtl case.
	Simply switch the rule and label child for each decoration node.</summary>
        <parameters>
          <parameter name="decorationNode" type="NodeList" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form._DateTimeTextBox" type="Function" classlike="true" superclass="dijit.form.RangeBoundTextBox">
    <summary>Base class for validating, serializable, range-bound date or time text box.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.RangeBoundTextBox"/>
    </mixins>
    <properties>
      <property name="regExpGen" scope="instance" type=""/>
      <property name="datePackage" scope="instance-prototype" type="String">
        <summary>JavaScript namespace to find calendar routines.  Uses Gregorian calendar routines
	at dojo.date, by default.</summary>
      </property>
      <property name="compare" scope="normal" type=""/>
      <property name="value" scope="instance-prototype" type="Date">
        <summary>The value of this widget as a JavaScript Date object.  Use attr(&amp;quot;value&amp;quot;) / attr(&amp;quot;value&amp;quot;, val) to manipulate.
	When passed to the parser in markup, must be specified according to &lt;code&gt;dojo.date.stamp.fromISOString&lt;/code&gt;
	value.toString()=&amp;quot;NaN&amp;quot;
	used by filter() when the textbox is blank</summary>
      </property>
      <property name="_blankValue" scope="prototype" type="Object"/>
      <property name="popupClass" scope="prototype" type="String">
        <summary>Name of the popup widget class used to select a date/time.
	Subclasses should specify this.
	default is no popup = text only</summary>
      </property>
      <property name="_selector" scope="prototype" type="String">
        <summary>Specifies constraints.selector passed to dojo.date functions, should be either
	&amp;quot;date&amp;quot; or &amp;quot;time&amp;quot;.
	Subclass must specify this.</summary>
      </property>
      <property name="_picker" scope="prototype" type="Object"/>
      <property name="_opened" scope="prototype" type="bool"/>
      <property name="_tabbingAway" scope="prototype" type="Object"/>
      <property name="dateClassObj" scope="instance" type="Object"/>
      <property name="dateLocaleModule" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="prototype">
        <summary>Formats the value as a Date, according to specified locale (second argument)</summary>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="prototype">
        <summary>Parses as string as a Date, according to constraints</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="serialize" scope="prototype">
        <parameters>
          <parameter name="val" type="anything" usage="required"/>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_onFocus" scope="prototype">
        <summary>open the popup</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Sets the date on this textbox.  Note that &lt;code&gt;value&lt;/code&gt; must be like a Javascript Date object.</summary>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
          <parameter name="formattedValue" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_open" scope="prototype">
        <summary>opens the TimePicker, and sets the onValueSelected value</summary>
      </method>
      <method name="_close" scope="prototype"/>
      <method name="_onBlur" scope="prototype">
        <summary>Called magically when focus has shifted away from this widget and it's dropdown</summary>
      </method>
      <method name="_getDisplayedValueAttr" scope="prototype"/>
      <method name="_setDisplayedValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <summary>Handler for keypress events</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form._DateTimeTextBox.__Constraints" type="Function" classlike="true" superclass="dijit.form.RangeBoundTextBox.__Constraints" private="true">
    <summary>Specifies both the rules on valid/invalid values (first/last date/time allowed),
	and also formatting options for how the date/time is displayed.</summary>
    <mixins>
      <mixin scope="prototype" location="dojo.date.locale.__FormatOptions.prototype"/>
      <mixin scope="instance" location="dijit.form.RangeBoundTextBox.__Constraints"/>
      <mixin scope="instance" location="dojo.date.locale.__FormatOptions"/>
    </mixins>
    <examples>
      <example>To restrict to dates within 2004, displayed in a long format like "December 25, 2005":
			{min:'2004-01-01',max:'2004-12-31', formatLength:'long'}</example>
    </examples>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form._DateTimeTextBox.constraints" type="dijit.form._DateTimeTextBox.__Constraints">
    <summary>Despite the name, this parameter specifies both constraints on the input
	(including starting/ending dates/times allowed) as well as
	formatting options like whether the date is displayed in long (ex: December 25, 2005)
	or short (ex: 12/25/2005) format.   See &lt;code&gt;dijit.form._DateTimeTextBox.__Constraints&lt;/code&gt; for details.</summary>
    <properties>
      <property name="selector" scope="prototype" type=""/>
      <property name="fullYear" scope="prototype" type="Object"/>
      <property name="min" scope="prototype" type="Object"/>
      <property name="max" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.form._FormMixin" type="Function" classlike="true">
    <summary>Mixin for containers of form widgets (i.e. widgets that represent a single value
	and can be children of a &amp;lt;form&amp;gt; node or dijit.form.Form widget)</summary>
    <description>Can extract all the form widgets
	values and combine them into a single javascript object, or alternately
	take such an object and set the values for all the contained
	form widgets</description>
    <examples>
      <example> { name: "John Smith", interests: ["sports", "movies"] }</example>
    </examples>
    <properties>
      <property name="_invalidWidgets" scope="prototype" type="Object"/>
      <property name="_lastValidState" scope="prototype" type=""/>
      <property name="_changeConnections" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="reset" scope="prototype"/>
      <method name="validate" scope="prototype">
        <summary>returns if the form is valid - same as isValid - but
	provides a few additional (ui-specific) features.
	1 - it will highlight any sub-widgets that are not
	valid
	2 - it will call focus() on the first invalid
	sub-widget</summary>
      </method>
      <method name="setValues" scope="prototype">
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Fill in form values from according to an Object (in the format returned by attr('value'))</summary>
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype"/>
      <method name="_getValueAttr" scope="prototype">
        <summary>Returns Object representing form values.</summary>
        <description>Returns name/value hash for each form element.
	If there are multiple elements w/the same name, value is an array,
	unless they are radio buttons in which case value is a scalar since only
	one can be checked at a time.
	If the name is a dot separated list (like a.b.c.d), creates a nested structure.
	Only works on widget form elements.</description>
        <examples>
          <example> { name: "John Smith", interests: ["sports", "movies"] }</example>
        </examples>
      </method>
      <method name="isValid" scope="prototype">
        <summary>Returns true if all of the widgets are valid</summary>
      </method>
      <method name="onValidStateChange" scope="prototype">
        <summary>Stub function to connect to if you want to do something
	(like disable/enable a submit button) when the valid
	state changes on the form as a whole.</summary>
        <parameters>
          <parameter name="isValid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_widgetChange" scope="prototype">
        <summary>Connected to a widget's onChange function - update our
	valid state, if needed.</summary>
        <parameters>
          <parameter name="widget" type="" usage="required"/>
        </parameters>
      </method>
      <method name="connectChildren" scope="prototype">
        <summary>Connects to the onChange function of all children to
	track valid state changes.  You can call this function
	directly, ex. in the event that you programmatically
	add a widget to the form *after* the form has been
	initialized.</summary>
      </method>
      <method name="startup" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form._FormSelectWidget" type="Function" classlike="true" superclass="dijit.form._FormValueWidget">
    <summary>Extends _FormValueWidget in order to provide &amp;quot;select-specific&amp;quot;
	values - i.e., those values that are unique to &amp;lt;select&amp;gt; elements.
	This also provides the mechanism for reading the elements from
	a store, if desired.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormValueWidget"/>
    </mixins>
    <properties>
      <property name="multiple" scope="prototype" type="Boolean">
        <summary>Whether or not we are multi-valued</summary>
      </property>
      <property name="store" scope="prototype" type="dojo.data.api.Identity">
        <summary>A store which, at the very least impelements dojo.data.api.Identity
	to use for getting our list of options - rather than reading them
	from the &amp;lt;option&amp;gt; html tags.</summary>
      </property>
      <property name="query" scope="prototype" type="object">
        <summary>A query to use when fetching items from our store</summary>
      </property>
      <property name="queryOptions" scope="prototype" type="object">
        <summary>Query options to use when fetching from the store</summary>
      </property>
      <property name="sortByLabel" scope="prototype" type="boolean">
        <summary>Flag to sort the options returned from a store by the label of
	the store.</summary>
      </property>
      <property name="loadChildrenOnOpen" scope="prototype" type="boolean">
        <summary>By default loadChildren is called when the items are fetched from the
	store.  This property allows delaying loadChildren (and the creation
	of the options/menuitems) until the user opens the click the button.
	dropdown
	remove when _FormWidget:getValue is removed</summary>
      </property>
      <property name="_notifyConnections" scope="prototype" type="Array"/>
      <property name="_onChangeActive" scope="prototype" type="bool"/>
      <property name="_loadingStore" scope="prototype" type="Object"/>
      <property name="_pendingValue" scope="prototype" type=""/>
      <property name="value" scope="prototype" type="Object"/>
      <property name="_getValueDeprecated" scope="prototype" type="bool"/>
      <property name="_oValue" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onFetch" scope="prototype">
        <summary>A callback to do with an onFetch - but before any items are actually
	iterated over (i.e. to filter even futher what you want to add)</summary>
      </method>
      <method name="getOptions" scope="prototype">
        <summary>Returns a given option (or options).</summary>
        <return-description>The option corresponding with the given value or index.  null
	is returned if any of the following are true:
	- A string value is passed in which doesn't exist
	- An index is passed in which is outside the bounds of the array of options
	- A dijit.form.__SelectOption is passed in which is not a part of the select</return-description>
        <parameters>
          <parameter name="valueOrIdx" type="anything" usage="required">
            <summary>If passed in as a string, that string is used to look up the option
	in the array of options - based on the value property.
	(See dijit.form.__SelectOption).
	If passed in a number, then the option with the given index (0-based)
	within this select will be returned.
	If passed in a dijit.form.__SelectOption, the same option will be
	returned if and only if it exists within this select.
	If passed an array, then an array will be returned with each element
	in the array being looked up.
	If not passed a value, then all options will be returned</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.form.__SelectOption[]"/>
          <return-type type="dijit.form.__SelectOption"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="addOption" scope="prototype">
        <summary>Adds an option or options to the end of the select.  If value
	of the option is empty or missing, a separator is created instead.
	Passing in an array of options will yield slightly better performance
	since the children are only loaded once.</summary>
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption," usage="required">
            <summary>dijit.form.__SelectOption[]</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeOption" scope="prototype">
        <summary>Removes the given option or options.  You can remove by string
	(in which case the value is removed), number (in which case the
	index in the options array is removed), or select option (in
	which case, the select option with a matching value is removed).
	You can also pass in an array of those values for a slightly
	better performance since the children are only loaded once.</summary>
        <parameters>
          <parameter name="valueOrIdx" type="string," usage="required">
            <summary>dijit.form.__SelectOption, number, or array</summary>
          </parameter>
        </parameters>
      </method>
      <method name="updateOption" scope="prototype">
        <summary>Updates the values of the given option.  The option to update
	is matched based on the value of the entered option.  Passing
	in an array of new options will yeild better performance since
	the children will only be loaded once.</summary>
        <parameters>
          <parameter name="newOption" type="dijit.form.__SelectOption," usage="required">
            <summary>dijit.form.__SelectOption[]</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setStore" scope="prototype">
        <summary>Sets the store you would like to use with this select widget.
	The selected value is the value of the new store to set.  This
	function returns the original store, in case you want to reuse
	it or something.</summary>
        <parameters>
          <parameter name="store" type="dojo.data.api.Identity" usage="required">
            <summary>The store you would like to use - it MUST implement Identity,
	and MAY implement Notification.</summary>
          </parameter>
          <parameter name="selectedValue" type="anything" usage="optional">
            <summary>The value that this widget should set itself to *after* the store
	has been loaded</summary>
          </parameter>
          <parameter name="fetchArgs" type="Object" usage="optional">
            <summary>The arguments that will be passed to the store's fetch() function</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.data.api.Identity"/>
        </return-types>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>set the value of the widget.
	If a string is passed, then we set our value from looking it up.</summary>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean," usage="required">
            <summary>optional</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getDisplayedValueAttr" scope="prototype">
        <summary>returns the displayed value of the widget</summary>
      </method>
      <method name="getValue" scope="prototype">
        <summary>get the value of the widget.</summary>
      </method>
      <method name="undo" scope="prototype">
        <summary>restore the value to the last value passed to onChange</summary>
      </method>
      <method name="_loadChildren" scope="prototype">
        <summary>Loads the children represented by this widget's options.
	reset the menu to make it &amp;quot;populatable on the next click</summary>
      </method>
      <method name="_updateSelection" scope="prototype">
        <summary>Sets the &amp;quot;selected&amp;quot; class on the item for styling purposes</summary>
      </method>
      <method name="_getValueFromOpts" scope="prototype">
        <summary>Returns the value of the widget by reading the options for
	the selected flag</summary>
      </method>
      <method name="_onNewItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_getOptionObjForItem" scope="prototype">
        <summary>Returns an option object based off the given item.  The &amp;quot;value&amp;quot;
	of the option item will be the identity of the item, the &amp;quot;label&amp;quot;
	of the option will be the label of the item.  If the item contains
	children, the children value of the item will be set</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit.form.__SelectOption"/>
        </return-types>
      </method>
      <method name="_addOptionForItem" scope="prototype">
        <summary>Creates (and adds) the option for the given item</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Saves off our value, if we have an initial one set so we
	can use it if we have a store as well (see startup())</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fillContent" scope="prototype">
        <summary>Loads our options and sets up our dropdown correctly.  We
	don't want any content, so we don't call any inherit chain
	function.</summary>
      </method>
      <method name="postCreate" scope="prototype">
        <summary>sets up our event handling that we need for functioning
	as a select</summary>
      </method>
      <method name="startup" scope="prototype">
        <summary>Connects in our store, if we have one defined</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Clean up our connections</summary>
      </method>
      <method name="_addOptionItem" scope="prototype">
        <summary>User-overridable function which, for the given option, adds an
	item to the select.  If the option doesn't have a value, then a
	separator is added in that place.  Make sure to store the option
	in the created option widget.</summary>
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_removeOptionItem" scope="prototype">
        <summary>User-overridable function which, for the given option, removes
	its item from the select.</summary>
        <parameters>
          <parameter name="option" type="dijit.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisplay" scope="prototype">
        <summary>Overridable function which will set the display for the
	widget.  newDisplay is either a string (in the case of
	single selects) or array of strings (in the case of multi-selects)</summary>
        <parameters>
          <parameter name="newDisplay" type="String" usage="required">
            <summary>or String[]</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getChildren" scope="prototype">
        <summary>Overridable function to return the children that this widget contains.</summary>
      </method>
      <method name="_getSelectedOptionsAttr" scope="prototype">
        <summary>hooks into this.attr to provide a mechanism for getting the
	option items for the current value of the widget.</summary>
      </method>
      <method name="_pseudoLoadChildren" scope="prototype">
        <summary>a function that will &amp;quot;fake&amp;quot; loading children, if needed, and
	if we have set to not load children until the widget opens.</summary>
        <parameters>
          <parameter name="items" type="item[]" usage="required">
            <summary>An array of items that will be loaded, when needed</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onSetStore" scope="prototype">
        <summary>a function that can be connected to in order to receive a
	notification that the store has finished loading and all options
	from that store are available</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.form._FormSelectWidget.options" type="dijit.form.__SelectOption[]">
    <summary>The set of options for our select item.  Roughly corresponds to
	the html &amp;lt;option&amp;gt; tag.</summary>
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form.__SelectOption" type="Function" classlike="true" private="true">
    <properties>
      <property name="value" scope="instance" type="String">
        <summary>The value of the option.  Setting to empty (or missing) will
	place a separator at that location</summary>
      </property>
      <property name="label" scope="instance" type="String">
        <summary>The label for our option.  It can contain html tags.</summary>
      </property>
      <property name="selected" scope="instance" type="Boolean">
        <summary>Whether or not we are a selected option</summary>
      </property>
      <property name="disabled" scope="instance" type="Boolean">
        <summary>Whether or not this specific option is disabled</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.form._FormWidget" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Base class for widgets corresponding to native HTML elements such as &amp;lt;checkbox&amp;gt; or &amp;lt;button&amp;gt;,
	which can be children of a &amp;lt;form&amp;gt; node or a &lt;code&gt;dijit.form.Form&lt;/code&gt; widget.</summary>
    <description>Represents a single HTML element.
	All these widgets should have these attributes just like native HTML input elements.
	You can set them during widget construction or afterwards, via `dijit._Widget.attr`.
	They also share some common methods.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String">
        <summary>Root CSS class of the widget (ex: dijitTextBox), used to add CSS classes of widget
	(ex: &amp;quot;dijitTextBox dijitTextBoxInvalid dijitTextBoxFocused dijitTextBoxInvalidFocused&amp;quot;)
	See _setStateClass().</summary>
      </property>
      <property name="name" scope="prototype" type="String">
        <summary>Name used when submitting form; same as &amp;quot;name&amp;quot; attribute or plain HTML elements</summary>
      </property>
      <property name="alt" scope="prototype" type="String">
        <summary>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</summary>
      </property>
      <property name="value" scope="prototype" type="String">
        <summary>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</summary>
      </property>
      <property name="type" scope="prototype" type="String">
        <summary>Corresponds to the native HTML &amp;lt;input&amp;gt; element's attribute.</summary>
      </property>
      <property name="tabIndex" scope="prototype" type="Integer">
        <summary>Order fields are traversed when user hits the tab key</summary>
      </property>
      <property name="disabled" scope="prototype" type="Boolean">
        <summary>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;disabled='disabled'&amp;quot;, or just &amp;quot;disabled&amp;quot;.</summary>
      </property>
      <property name="intermediateChanges" scope="prototype" type="Boolean">
        <summary>Fires onChange for each value change or only on demand</summary>
      </property>
      <property name="scrollOnFocus" scope="prototype" type="Boolean">
        <summary>On focus, should this widget scroll into view?</summary>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="nameAttrSetting" scope="prototype" type=""/>
      <property name="_hovering" scope="prototype" type="bool"/>
      <property name="_active" scope="prototype" type="Object"/>
      <property name="stateModifier" scope="prototype" type="Object"/>
      <property name="_mouseDown" scope="prototype" type="Object"/>
      <property name="_stateClasses" scope="prototype" type=""/>
      <property name="_onChangeActive" scope="prototype" type="Boolean">
        <summary>Indicates that changes to the value should call onChange() callback.
	This is false during widget initialization, to avoid calling onChange()
	when the initial value is set.</summary>
      </property>
      <property name="_lastValue" scope="prototype" type=""/>
      <property name="_resetValue" scope="prototype" type=""/>
      <property name="_lastValueReported" scope="prototype" type=""/>
      <property name="_onChangeHandle" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="prototype">
        <summary>Deprecated.   Use attr('disabled', ...) instead.</summary>
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouse" scope="prototype">
        <summary>Sets _hovering, _active, and stateModifier properties depending on mouse state,
	then calls setStateClass() to set appropriate CSS classes for this.domNode.
	To get a different CSS class for hover, send onmouseover and onmouseout events to this method.
	To get a different CSS class while mouse button is depressed, send onmousedown to this method.</summary>
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="isFocusable" scope="prototype">
        <summary>Tells if this widget is focusable or not.   Used internally by dijit.</summary>
      </method>
      <method name="focus" scope="prototype">
        <summary>Put focus on this widget</summary>
      </method>
      <method name="_setStateClass" scope="prototype">
        <summary>Update the visual state of the widget by setting the css classes on this.domNode
	(or this.stateNode if defined) by combining this.baseClass with
	various suffixes that represent the current widget state(s).</summary>
        <description>In the case where a widget has multiple
	states, it sets the class based on all possible
	combinations.  For example, an invalid form widget that is being hovered
	will be "dijitInput dijitInputInvalid dijitInputHover dijitInputInvalidHover".
	For complex widgets with multiple regions, there can be various hover/active states,
	such as "Hover" or "CloseButtonHover" (for tab buttons).
	This is controlled by a stateModifier="CloseButton" attribute on the close button node.
	The widget may have one or more of the following states, determined
	by this.state, this.checked, this.valid, and this.selected:
	- Error - ValidationTextBox sets this.state to "Error" if the current input value is invalid
	- Checked - ex: a checkmark or a ToggleButton in a checked state, will have this.checked==true
	- Selected - ex: currently selected tab will have this.selected==true
	In addition, it may have one or more of the following states,
	based on this.disabled and flags set in _onMouse (this._active, this._hovering, this._focused):
	- Disabled	- if the widget is disabled
	- Active		- if the mouse (or space/enter key?) is being pressed down
	- Focused		- if the widget has focus
	- Hover		- if the mouse is over the widget</description>
      </method>
      <method name="compare" scope="prototype">
        <summary>Compare 2 values (as returned by attr('value') for this widget).</summary>
        <parameters>
          <parameter name="val1" type="anything" usage="required"/>
          <parameter name="val2" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Callback when this widget's value is changed.</summary>
        <parameters>
          <parameter name="newValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="prototype">
        <summary>Called when the value of the widget is set.  Calls onChange() if appropriate</summary>
        <parameters>
          <parameter name="newValue" type="anything" usage="required">
            <summary>the new value</summary>
          </parameter>
          <parameter name="priorityChange" type="Boolean" usage="optional">
            <summary>For a slider, for example, dragging the slider is priorityChange==false,
	but on mouse up, it's priorityChange==true.  If intermediateChanges==true,
	onChange is only called form priorityChange=true events.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="create" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="setValue" scope="prototype">
        <summary>Deprecated.   Use attr('value', ...) instead.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>Deprecated.   Use attr('value') instead.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.form._FormWidget.stateNode">
    <properties>
      <property name="className" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.form._FormValueWidget" type="Function" classlike="true" superclass="dijit.form._FormWidget">
    <summary>Base class for widgets corresponding to native HTML elements such as &amp;lt;input&amp;gt; or &amp;lt;select&amp;gt; that have user changeable values.</summary>
    <description>Each _FormValueWidget represents a single input value, and has a (possibly hidden) &lt;input&gt; element,
	to which it serializes it's input value, so that form submission (either normal submission or via FormBind?)
	works as expected.</description>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormWidget"/>
    </mixins>
    <properties>
      <property name="readOnly" scope="prototype" type="Boolean">
        <summary>Should this widget respond to user input?
	In markup, this is specified as &amp;quot;readOnly&amp;quot;.
	Similar to disabled except readOnly form values are submitted.</summary>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="_resetValue" scope="prototype" type=""/>
      <property name="value" scope="prototype" type=""/>
      <property name="_hasBeenBlurred" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setReadOnlyAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', value) works.</summary>
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="anything" usage="required"/>
          <parameter name="priorityChange" type="Boolean," usage="required">
            <summary>optional</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>Hook so attr('value') works.</summary>
      </method>
      <method name="undo" scope="prototype">
        <summary>Restore the value to the last value passed to onChange</summary>
      </method>
      <method name="reset" scope="prototype">
        <summary>Reset the widget's value to what it was at initialization time</summary>
      </method>
      <method name="_onKeyDown" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutHackIE7" scope="prototype">
        <summary>Work around table sizing bugs on IE7 by forcing redraw</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.form._FormValueWidget.domNode" type="">
    <properties>
      <property name="firstChild" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.form._FormValueWidget.domNode.firstChild.style" type="">
    <properties>
      <property name="filter" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form._Spinner" type="Function" classlike="true" superclass="dijit.form.RangeBoundTextBox">
    <summary>Mixin for validation widgets with a spinner.</summary>
    <description>This class basically (conceptually) extends `dijit.form.ValidationTextBox`.
	It modifies the template to have up/down arrows, and provides related handling code.</description>
    <mixins>
      <mixin scope="instance" location="dijit.form.RangeBoundTextBox"/>
    </mixins>
    <properties>
      <property name="defaultTimeout" scope="prototype" type="Number">
        <summary>Number of milliseconds before a held arrow key or up/down button becomes typematic</summary>
      </property>
      <property name="timeoutChangeRate" scope="prototype" type="Number">
        <summary>Fraction of time used to change the typematic timer between events.
	1.0 means that each typematic event fires at defaultTimeout intervals.
	&amp;lt; 1.0 means that each typematic event fires at an increasing faster rate.</summary>
      </property>
      <property name="smallDelta" scope="prototype" type="Number">
        <summary>Adjust the value by this much when spinning using the arrow keys/buttons</summary>
      </property>
      <property name="largeDelta" scope="prototype" type="Number">
        <summary>Adjust the value by this much when spinning using the PgUp/Dn keys</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="_active" scope="prototype" type=""/>
      <property name="stateModifier" scope="prototype" type="Object"/>
      <property name="_wheelTimer" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="adjust" scope="prototype">
        <summary>Overridable function used to adjust a primitive value(Number/Date/...) by the delta amount specified.
	The val is adjusted in a way that makes sense to the object type.</summary>
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowState" scope="prototype">
        <summary>Called when an arrow key is pressed to update the relevant CSS classes</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="pressed" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowPressed" scope="prototype">
        <summary>Handler for arrow button or arrow key being pressed</summary>
        <parameters>
          <parameter name="nodePressed" type="Node" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="increment" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_arrowReleased" scope="prototype">
        <summary>Handler for arrow button or arrow key being released</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_typematicCallback" scope="prototype">
        <parameters>
          <parameter name="count" type="Number" usage="required"/>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseWheeled" scope="prototype">
        <summary>Mouse wheel listener where supported</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.layout">
    <summary>Layout related widgets</summary>
    <methods>
      <method name="marginBox2contentBox" scope="normal">
        <summary>Given the margin-box size of a node, return its content box size.
	Functions like dojo.contentBox() but is more reliable since it doesn't have
	to wait for the browser to compute sizes.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="mb" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="layoutChildren" scope="normal">
        <parameters>
          <parameter name="container" type="DomNode" usage="required">
            <summary>parent node</summary>
          </parameter>
          <parameter name="dim" type="Object" usage="required">
            <summary>{l, t, w, h} object specifying dimensions of container into which to place children</summary>
          </parameter>
          <parameter name="children" type="Object[]" usage="required">
            <summary>an array like [ {domNode: foo, layoutAlign: &amp;quot;bottom&amp;quot; }, {domNode: bar, layoutAlign: &amp;quot;client&amp;quot;} ]</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout.AccordionContainer" type="Function" classlike="true" superclass="dijit.layout.StackContainer">
    <summary>Holds a set of panes where every pane's title is visible, but only one pane's content is visible at a time,
	and switching between panes is visualized by sliding the other panes up/down.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.layout.StackContainer"/>
    </mixins>
    <examples>
      <example> 	&lt;div dojoType="dijit.layout.AccordionContainer"&gt;
			&lt;div dojoType="dijit.layout.ContentPane" title="pane 1"&gt;
			&lt;/div&gt;
			&lt;div dojoType="dijit.layout.ContentPane" title="pane 2"&gt;
				&lt;p&gt;This is some text&lt;/p&gt;
			&lt;/div&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="duration" scope="normal" type="Integer">
        <summary>Amount of time (in ms) it takes to slide panes</summary>
      </property>
      <property name="buttonWidget" scope="prototype" type="String">
        <summary>The name of the widget used to display the title of each pane</summary>
      </property>
      <property name="_verticalSpace" scope="prototype" type="Number">
        <summary>Pixels of space available for the open pane
	(my content box size minus the cumulative size of all the title bars)</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="selectedChildWidget" scope="prototype" type=""/>
      <property name="_contentBox" scope="prototype" type=""/>
      <property name="_containerContentBox" scope="prototype" type="Object"/>
      <property name="_inTransition" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_getTargetHeight" scope="prototype">
        <summary>For the given node, returns the height that should be
	set to achieve our vertical space (subtract any padding
	we may have).
	This is used by the animations.
	TODO: I don't think this works correctly in IE quirks when an elements
	style.height including padding and borders</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="prototype"/>
      <method name="_setupChild" scope="prototype">
        <parameters>
          <parameter name="child" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="child" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="_transition" scope="prototype">
        <parameters>
          <parameter name="newWidget" type="Widget" usage="optional"/>
          <parameter name="oldWidget" type="Widget" usage="optional"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <summary>Handle keypress events</summary>
        <description>This is called from a handler on AccordionContainer.domNode
	(setup in StackContainer), and is also called directly from
	the click handler for accordion labels</description>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
          <parameter name="fromTitle" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout.AccordionContainer.domNode.style" type="">
    <properties>
      <property name="overflow" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.layout.AccordionContainer.selectedChildWidget.containerNode" type=""/>
  <object location="dijit.layout.AccordionContainer.selectedChildWidget.containerNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
      <property name="overflow" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.layout._AccordionButton" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>The title bar to click to open up an accordion pane.
	Internal widget used by AccordionContainer.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="selected" scope="prototype" type=""/>
      <property name="contentWidget" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getParent" scope="prototype">
        <summary>Returns the parent.</summary>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="getTitleHeight" scope="prototype">
        <summary>Returns the height of the title dom node.</summary>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_onTitleClick" scope="prototype">
        <summary>Callback when someone clicks my title.</summary>
      </method>
      <method name="_onTitleEnter" scope="prototype">
        <summary>Callback when someone hovers over my title.</summary>
      </method>
      <method name="_onTitleLeave" scope="prototype">
        <summary>Callback when someone stops hovering over my title.</summary>
      </method>
      <method name="_onTitleKeyPress" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedState" scope="prototype">
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_handleFocus" scope="prototype">
        <summary>Handle the blur and focus state of this widget.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="prototype">
        <summary>Change the selected state on this pane.</summary>
        <parameters>
          <parameter name="isSelected" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout.AccordionPane" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <summary>Deprecated widget.   Use &lt;code&gt;dijit.layout.ContentPane&lt;/code&gt; instead.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="onSelected" scope="prototype">
        <summary>called when this pane is selected</summary>
      </method>
    </methods>
  </object>
  <object location="dijit._Widget.prototype" type="">
    <properties>
      <property name="maxSize" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dijit.layout.BorderContainer" type="Function" classlike="true" superclass="dijit.layout._LayoutWidget">
    <summary>Provides layout in up to 5 regions, a mandatory center with optional borders along its 4 sides.</summary>
    <description>A BorderContainer is a box with a specified size, such as style="width: 500px; height: 500px;",
	that contains a child widget marked region="center" and optionally children widgets marked
	region equal to "top", "bottom", "leading", "trailing", "left" or "right".
	Children along the edges will be laid out according to width or height dimensions and may
	include optional splitters (splitter="true") to make them resizable by the user.  The remaining
	space is designated for the center region.
	NOTE: Splitters must not be more than 50 pixels in width.
	The outer size must be specified on the BorderContainer node.  Width must be specified for the sides
	and height for the top and bottom, respectively.  No dimensions should be specified on the center;
	it will fill the remaining space.  Regions named "leading" and "trailing" may be used just like
	"left" and "right" except that they will be reversed in right-to-left environments.</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout._LayoutWidget"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dijit.layout.BorderContainer" design="sidebar" gutters="false"
							style="width: 400px; height: 300px;"&gt;
			&lt;div dojoType="ContentPane" region="top"&gt;header text&lt;/div&gt;
			&lt;div dojoType="ContentPane" region="right" splitter="true" style="width: 200px;"&gt;table of contents&lt;/div&gt;
			&lt;div dojoType="ContentPane" region="center"&gt;client area&lt;/div&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="design" scope="prototype" type="String">
        <summary>Which design is used for the layout:
	- &amp;quot;headline&amp;quot; (default) where the top and bottom extend
	the full width of the container
	- &amp;quot;sidebar&amp;quot; where the left and right sides extend from top to bottom.</summary>
      </property>
      <property name="gutters" scope="prototype" type="Boolean">
        <summary>Give each pane a border and margin.
	Margin determined by domNode.paddingLeft.
	When false, only resizable panes have a gutter (i.e. draggable splitter) for resizing.</summary>
      </property>
      <property name="liveSplitters" scope="prototype" type="Boolean">
        <summary>Specifies whether splitters resize as you drag (true) or only upon mouseup (false)</summary>
      </property>
      <property name="persist" scope="prototype" type="Boolean">
        <summary>Save splitter positions in a cookie.</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="_splitterClass" scope="prototype" type="String">
        <summary>Optional hook to override the default Splitter widget used by BorderContainer</summary>
      </property>
      <property name="domNode" scope="prototype" type=""/>
      <property name="cs" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_setupChild" scope="prototype">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_computeSplitterThickness" scope="prototype">
        <parameters>
          <parameter name="region" type="" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="prototype"/>
      <method name="addChild" scope="prototype">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype"/>
      <method name="getSplitter" scope="prototype">
        <summary>Returns the widget responsible for rendering the splitter associated with region</summary>
        <parameters>
          <parameter name="region" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="newSize" type="" usage="required"/>
          <parameter name="currentSize" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_layoutChildren" scope="prototype">
        <summary>This is the main routine for setting size/position of each child</summary>
        <parameters>
          <parameter name="changedRegion" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.layout.BorderContainer.pe">
    <properties>
      <property name="r" scope="prototype" type="Object"/>
      <property name="b" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.layout.BorderContainer._splitters" private="true">
    <properties>
      <property name="top" scope="prototype" type=""/>
      <property name="bottom" scope="prototype" type=""/>
      <property name="left" scope="prototype" type=""/>
      <property name="right" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout.BorderContainer._splitterThickness" private="true">
    <properties>
      <property name="top" scope="prototype" type="Number"/>
      <property name="left" scope="prototype" type="Number"/>
      <property name="right" scope="prototype" type="Number"/>
      <property name="bottom" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dijit.layout.BorderContainer._splitters.top.style" type="">
    <properties>
      <property name="top" scope="prototype" type="String"/>
      <property name="width" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout.BorderContainer._splitters.bottom.style" type="">
    <properties>
      <property name="bottom" scope="prototype" type="String"/>
      <property name="width" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout.BorderContainer._splitters.left.style" type="">
    <properties>
      <property name="left" scope="prototype" type="String"/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout.BorderContainer._splitters.right.style" type="">
    <properties>
      <property name="right" scope="prototype" type="String"/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout._Splitter" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A draggable spacer between two items in a &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt;.</summary>
    <description>This is instantiated by `dijit.layout.BorderContainer`.  Users should not
	create it directly.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="container" scope="prototype" type="dijit.layout.BorderContainer">
        <summary>Pointer to the parent BorderContainer</summary>
      </property>
      <property name="region" scope="prototype" type="String">
        <summary>Region of pane associated with this splitter.
	&amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;.</summary>
      </property>
      <property name="live" scope="prototype" type="Boolean">
        <summary>If true, the child's size changes and the child widget is redrawn as you drag the splitter;
	otherwise, the size doesn't change until you drop the splitter (by mouse-up)</summary>
      </property>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="horizontal" scope="prototype" type="Object"/>
      <property name="_factor" scope="prototype" type=""/>
      <property name="_cookieName" scope="prototype" type="String"/>
      <property name="cover" scope="prototype" type="Object"/>
      <property name="_resize" scope="prototype" type="Object"/>
      <property name="fake" scope="prototype" type="Object"/>
      <property name="_handlers" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_computeMaxSize" scope="prototype">
        <summary>Compute the maximum size that my corresponding pane can be set to</summary>
      </method>
      <method name="_startDrag" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_drag" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
          <parameter name="forceResize" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouse" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_stopDrag" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupHandlers" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.layout._Splitter.child" type="dijit.layout._LayoutWidget">
    <summary>Pointer to the pane associated with this splitter</summary>
    <properties>
      <property name="minSize" scope="prototype" type="Number"/>
      <property name="domNode" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout._Splitter.domNode" type="">
    <properties>
      <property name="style" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout._Gutter" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Just a spacer div to separate side pane from center pane.
	Basically a trick to lookup the gutter/splitter width from the theme.</summary>
    <description>Instantiated by `dijit.layout.BorderContainer`.  Users should not
	create directly.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="horizontal" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.layout.ContentPane" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget that acts as a container for mixed HTML and widgets, and includes an Ajax interface</summary>
    <description>A widget that can be used as a stand alone widget
	or as a base class for other widgets.
	Handles replacement of document fragment using either external uri or javascript
	generated markup or DOM content, instantiating widgets within that content.
	Don't confuse it with an iframe, it only needs/wants document fragments.
	It's useful as a child of LayoutContainer, SplitContainer, or TabContainer.
	But note that those classes can contain any widget as a child.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <examples>
      <example>Some quick samples:
	To change the innerHTML use .attr('content', '&lt;b&gt;new content&lt;/b&gt;')
	Or you can send it a NodeList, .attr('content', dojo.query('div [class=selected]', userSelection))
	please note that the nodes in NodeList will copied, not moved
	To do a ajax update use .attr('href', url)</example>
    </examples>
    <properties>
      <property name="href" scope="prototype" type="String">
        <summary>The href of the content that displays now.
	Set this at construction if you want to load data externally when the
	pane is shown.  (Set preload=true to load it immediately.)
	Changing href after creation doesn't have any effect; use attr('href', ...);</summary>
      </property>
      <property name="content" scope="prototype" type="String">
        <summary>|| DomNode || NodeList || dijit._Widget
	The innerHTML of the ContentPane.
	Note that the initialization parameter / argument to attr(&amp;quot;content&amp;quot;, ...)
	can be a String, DomNode, Nodelist, or _Widget.</summary>
      </property>
      <property name="extractContent" scope="prototype" type="Boolean">
        <summary>Extract visible content from inside of &amp;lt;body&amp;gt; .... &amp;lt;/body&amp;gt;.
	I.e., strip &amp;lt;html&amp;gt; and &amp;lt;head&amp;gt; (and it's contents) from the href</summary>
      </property>
      <property name="parseOnLoad" scope="prototype" type="Boolean">
        <summary>Parse content and create the widgets, if any.</summary>
      </property>
      <property name="preventCache" scope="prototype" type="Boolean">
        <summary>Prevent caching of data from href's by appending a timestamp to the href.</summary>
      </property>
      <property name="preload" scope="prototype" type="Boolean">
        <summary>Force load of data on initialization even if pane is hidden.</summary>
      </property>
      <property name="refreshOnShow" scope="prototype" type="Boolean">
        <summary>Refresh (re-download) content when pane goes from hidden to shown</summary>
      </property>
      <property name="loadingMessage" scope="prototype" type="String">
        <summary>Message that shows while downloading</summary>
      </property>
      <property name="errorMessage" scope="prototype" type="String">
        <summary>Message that shows if an error occurs</summary>
      </property>
      <property name="isLoaded" scope="prototype" type="Boolean">
        <summary>True if the ContentPane has data in it, either specified
	during initialization (via href or inline content), or set
	via attr('content', ...) / attr('href', ...)
	False if it doesn't have any content, or if ContentPane is
	still in the process of downloading href.</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="doLayout" scope="prototype" type="Boolean">
        <summary>- false - don't adjust size of children
	- true - if there is a single visible child widget, set it's size to
	however big the ContentPane is</summary>
      </property>
      <property name="ioArgs" scope="prototype" type="Object">
        <summary>Parameters to pass to xhrGet() request, for example:
		&amp;lt;div dojoType=&amp;quot;dijit.layout.ContentPane&amp;quot; href=&amp;quot;./bar&amp;quot; ioArgs=&amp;quot;{timeout: 500}&amp;quot;&amp;gt;</summary>
      </property>
      <property name="isContainer" scope="prototype" type="Boolean">
        <summary>Indicates that this widget acts as a &amp;quot;parent&amp;quot; to the descendant widgets.
	When the parent is started it will call startup() on the child widgets.
	See also &lt;code&gt;isLayoutContainer&lt;/code&gt;.</summary>
      </property>
      <property name="isLayoutContainer" scope="prototype" type="Boolean">
        <summary>Indicates that this widget will call resize() on it's child widgets
	when they become visible.</summary>
      </property>
      <property name="onLoadDeferred" scope="prototype" type="dojo.Deferred">
        <summary>This is the &lt;code&gt;dojo.Deferred&lt;/code&gt; returned by attr('href', ...) and refresh().
	Calling onLoadDeferred.addCallback() or addErrback() registers your
	callback to be called only once, when the prior attr('href', ...) call or
	the initial href parameter to the constructor finishes loading.
	This is different than an onLoad() handler which gets called any time any href is loaded.</summary>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="containerNode" scope="prototype" type=""/>
      <property name="_childOfLayoutWidget" scope="prototype" type=""/>
      <property name="_needLayout" scope="prototype" type="Object"/>
      <property name="_singleChild" scope="prototype" type=""/>
      <property name="_hrefChanged" scope="prototype" type="Object"/>
      <property name="_isDownloaded" scope="prototype" type="bool"/>
      <property name="_resizeCalled" scope="prototype" type="Object"/>
      <property name="_contentBox" scope="prototype" type="Object"/>
      <property name="_wasShown" scope="prototype" type="Object"/>
      <property name="_xhrDfd" scope="prototype" type="Object"/>
      <property name="_contentSetter" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype">
        <summary>See &lt;code&gt;dijit.layout._LayoutWidget.startup&lt;/code&gt; for description.
	Although ContentPane doesn't extend _LayoutWidget, it does implement
	the same API.</summary>
      </method>
      <method name="_checkIfSingleChild" scope="prototype">
        <summary>Test if we have exactly one visible widget as a child,
	and if so assume that we are a container for that widget,
	and should propogate startup() and resize() calls to it.
	Skips over things like data stores since they aren't visible.</summary>
        <return-types>
          <return-type type="or a regexp for hidden elements like script"/>
          <return-type type="area"/>
          <return-type type="map"/>
          <return-type type="etc.."/>
        </return-types>
      </method>
      <method name="setHref" scope="prototype">
        <summary>Deprecated.   Use attr('href', ...) instead.</summary>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required"/>
        </parameters>
      </method>
      <method name="_setHrefAttr" scope="prototype">
        <summary>Hook so attr(&amp;quot;href&amp;quot;, ...) works.</summary>
        <description>Reset the (external defined) content of this pane and replace with new url
	Note: It delays the download until widget is shown if preload is false.</description>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required">
            <summary>url to the page you want to get, must be within the same domain as your mainpage</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="setContent" scope="prototype">
        <summary>Deprecated.   Use attr('content', ...) instead.</summary>
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="_setContentAttr" scope="prototype">
        <summary>Hook to make attr(&amp;quot;content&amp;quot;, ...) work.
	Replaces old content with data content, include style classes from old content</summary>
        <parameters>
          <parameter name="data" type="String|DomNode|Nodelist" usage="required">
            <summary>the new Content may be String, DomNode or NodeList
	if data is a NodeList (or an array of nodes) nodes are copied
	so you can import nodes from another document implicitly</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_getContentAttr" scope="prototype">
        <summary>Hook to make attr(&amp;quot;content&amp;quot;) work</summary>
      </method>
      <method name="cancel" scope="prototype">
        <summary>Cancels an in-flight download of content</summary>
      </method>
      <method name="uninitialize" scope="prototype"/>
      <method name="destroyRecursive" scope="prototype">
        <summary>Destroy the ContentPane and its contents</summary>
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <summary>See &lt;code&gt;dijit.layout._LayoutWidget.resize&lt;/code&gt; for description.
	Although ContentPane doesn't extend _LayoutWidget, it does implement
	the same API.</summary>
        <parameters>
          <parameter name="changeSize" type="" usage="required"/>
          <parameter name="resultSize" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_isShown" scope="prototype">
        <summary>Returns true if the content is currently shown.</summary>
        <description>If I am a child of a layout widget then it actually returns true if I've ever been visible,
	not whether I'm currently visible, since that's much faster than tracing up the DOM/widget
	tree every call, and at least solves the performance problem on page load by deferring loading
	hidden ContentPanes until they are first shown</description>
        <return-types>
          <return-type type="for TitlePane, etc."/>
        </return-types>
      </method>
      <method name="_onShow" scope="prototype">
        <summary>Called when the ContentPane is made visible</summary>
        <description>For a plain ContentPane, this is called on initialization, from startup().
	If the ContentPane is a hidden pane of a TabContainer etc., then it's
	called whenever the pane is made visible.
	Does necessary processing, including href download and layout/resize of
	child widget(s)</description>
      </method>
      <method name="refresh" scope="prototype">
        <summary>[Re]download contents of href and display</summary>
        <description>1. cancels any currently in-flight requests
	2. posts "loading..." message
	3. sends XHR to download new data</description>
      </method>
      <method name="_load" scope="prototype">
        <summary>Load/reload the href specified in this.href</summary>
      </method>
      <method name="_onLoadHandler" scope="prototype">
        <summary>This is called whenever new content is being loaded</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onUnloadHandler" scope="prototype">
        <summary>This is called whenever the content is being unloaded</summary>
      </method>
      <method name="destroyDescendants" scope="prototype">
        <summary>Destroy all the widgets inside the ContentPane and empty containerNode</summary>
      </method>
      <method name="_setContent" scope="prototype">
        <summary>Insert the content into the container node</summary>
        <parameters>
          <parameter name="cont" type="" usage="required"/>
          <parameter name="isFakeContent" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onError" scope="prototype">
        <parameters>
          <parameter name="type" type="" usage="required"/>
          <parameter name="err" type="" usage="required"/>
          <parameter name="consoleText" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_scheduleLayout" scope="prototype">
        <summary>Call resize() on each of my child layout widgets, either now
	(if I'm currently visible) or when I become visible</summary>
      </method>
      <method name="_layoutChildren" scope="prototype">
        <summary>Since I am a Container widget, each of my children expects me to
	call resize() or layout() on them.</summary>
        <description>Should be called on initialization and also whenever we get new content
	(from an href, or from attr('content', ...))... but deferred until
	the ContentPane is visible</description>
      </method>
      <method name="onLoad" scope="prototype">
        <summary>Event hook, is called after everything is loaded and widgetified</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onUnload" scope="prototype">
        <summary>Event hook, is called before old content is cleared</summary>
      </method>
      <method name="onDownloadStart" scope="prototype">
        <summary>Called before download starts.</summary>
        <description>The string returned by this function will be the html
	that tells the user we are loading something.
	Override with your own function if you want to change text.</description>
      </method>
      <method name="onContentError" scope="prototype">
        <summary>Called on DOM faults, require faults etc. in content.
	In order to display an error message in the pane, return
	the error message from this method, as an HTML string.
	By default (if this method is not overriden), it returns
	nothing, so the error message is just printed to the console.</summary>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadError" scope="prototype">
        <summary>Called when download error occurs.
	In order to display an error message in the pane, return
	the error message from this method, as an HTML string.
	Default behavior (if this method is not overriden) is to display
	the error message inside the pane.</summary>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloadEnd" scope="prototype">
        <summary>Called when download is finished.</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.layout.ContentPane.domNode" type="">
    <properties>
      <property name="title" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.layout.LayoutContainer" type="Function" classlike="true" superclass="dijit.layout._LayoutWidget">
    <summary>Deprecated.  Use &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt; instead.</summary>
    <description>Provides Delphi-style panel layout semantics.
	A LayoutContainer is a box with a specified size (like style="width: 500px; height: 500px;"),
	that contains children widgets marked with "layoutAlign" of "left", "right", "bottom", "top", and "client".
	It takes it's children marked as left/top/bottom/right, and lays them out along the edges of the box,
	and then it takes the child marked "client" and puts it into the remaining space in the middle.
	Left/right positioning is similar to CSS's "float: left" and "float: right",
	and top/bottom positioning would be similar to "float: top" and "float: bottom", if there were such
	CSS.
	Note that there can only be one client element, but there can be multiple left, right, top,
	or bottom elements.</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout._LayoutWidget"/>
    </mixins>
    <examples>
      <example>	&lt;style&gt;
			html, body{ height: 100%; width: 100%; }
		&lt;/style&gt;
		&lt;div dojoType="dijit.layout.LayoutContainer" style="width: 100%; height: 100%"&gt;
			&lt;div dojoType="dijit.layout.ContentPane" layoutAlign="top"&gt;header text&lt;/div&gt;
			&lt;div dojoType="dijit.layout.ContentPane" layoutAlign="left" style="width: 200px;"&gt;table of contents&lt;/div&gt;
			&lt;div dojoType="dijit.layout.ContentPane" layoutAlign="client"&gt;client area&lt;/div&gt;
		&lt;/div&gt;
	Lays out each child in the natural order the children occur in.
	Basically each child is laid out into the "remaining space", where "remaining space" is initially
	the content area of this widget, but is reduced to a smaller rectangle each time a child is added.</example>
    </examples>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="layout" scope="prototype"/>
      <method name="addChild" scope="prototype">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout.LinkPane" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <summary>A ContentPane with an href where (when declared in markup)
	the title is specified as innerHTML rather than as a title attribute.</summary>
    <description>LinkPane is just a ContentPane that is declared in markup similarly
	to an anchor.  The anchor's body (the words between `&lt;a&gt;` and `&lt;/a&gt;`)
	become the title of the widget (used for TabContainer, AccordionContainer, etc.)</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example> &lt;a href="foo.html"&gt;my title&lt;/a&gt;</example>
    </examples>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_fillContent" scope="prototype">
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout.ScrollingTabController" type="Function" classlike="true" superclass="dijit.layout.TabController">
    <summary>Set of tabs with left/right arrow keys and a menu to switch between tabs not
	all fitting on a single row.
	Works only for horizontal tabs (either above or below the content, not to the left
	or right).</summary>
    <mixins>
      <mixin scope="instance" location="dijit.layout.TabController"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="useMenu" scope="prototype" type="Boolean">
        <summary>True if a menu should be used to select tabs when they are too
	wide to fit the TabContainer, false otherwise.</summary>
      </property>
      <property name="useSlider" scope="prototype" type="Boolean">
        <summary>True if a slider should be used to select tabs when they are too
	wide to fit the TabContainer, false otherwise.</summary>
      </property>
      <property name="tabStripClass" scope="prototype" type="String">
        <summary>The css class to apply to the tab strip, if it is visible.</summary>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="_minScroll" scope="prototype" type="Number">
        <summary>The distance in pixels from the edge of the tab strip which,
	if a scroll animation is less than, forces the scroll to
	go all the way to the left/right.</summary>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="domNode" scope="prototype" type=""/>
      <property name="_postStartup" scope="prototype" type="Object"/>
      <property name="_selectedTab" scope="prototype" type="Object"/>
      <property name="_menuChildren" scope="prototype" type="Object"/>
      <property name="_btnWidth" scope="prototype" type="Number"/>
      <property name="_buttons" scope="prototype" type="Object"/>
      <property name="_menu" scope="prototype" type="Object"/>
      <property name="_dim" scope="prototype" type=""/>
      <property name="_anim" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="onStartup" scope="prototype"/>
      <method name="onAddChild" scope="prototype">
        <parameters>
          <parameter name="page" type="" usage="required"/>
          <parameter name="insertIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="prototype">
        <parameters>
          <parameter name="page" type="" usage="required"/>
          <parameter name="insertIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_initButtons" scope="prototype">
        <summary>Creates the buttons used to scroll to view tabs that
	may not be visible if the TabContainer is too narrow.</summary>
      </method>
      <method name="_getTabsWidth" scope="prototype"/>
      <method name="_enableBtn" scope="prototype">
        <summary>Determines if the tabs are wider than the width of the TabContainer, and
	thus that we need to display left/right/menu navigation buttons.</summary>
        <parameters>
          <parameter name="width" type="" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <summary>Hides or displays the buttons used to scroll the tab list and launch the menu
	that selects tabs.</summary>
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getScroll" scope="prototype">
        <summary>Returns the current scroll of the tabs where 0 means
	&amp;quot;scrolled all the way to the left&amp;quot; and some positive number, based on #
	of pixels of possible scroll (ex: 1000) means &amp;quot;scrolled all the way to the right&amp;quot;</summary>
      </method>
      <method name="_convertToScrollLeft" scope="prototype">
        <summary>Given a scroll value where 0 means &amp;quot;scrolled all the way to the left&amp;quot;
	and some positive number, based on # of pixels of possible scroll (ex: 1000)
	means &amp;quot;scrolled all the way to the right&amp;quot;, return value to set this.scrollNode.scrollLeft
	to achieve that scroll.
	This method is to adjust for RTL funniness in various browsers and versions.</summary>
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="prototype">
        <summary>Smoothly scrolls to a tab when it is selected.</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getScrollBounds" scope="prototype">
        <summary>Returns the minimum and maximum scroll setting to show the leftmost and rightmost
	tabs (respectively)</summary>
      </method>
      <method name="_getScrollForSelectedTab" scope="prototype">
        <summary>Returns the scroll value setting so that the selected tab
	will appear in the center</summary>
      </method>
      <method name="createSmoothScroll" scope="prototype">
        <summary>Creates a dojo._Animation object that smoothly scrolls the tab list
	either to a fixed horizontal pixel value, or to the selected tab.</summary>
        <description>If an number argument is passed to the function, that horizontal
	pixel position is scrolled to.  Otherwise the currently selected
	tab is scrolled to.</description>
        <parameters>
          <parameter name="x" type="Integer" usage="optional">
            <summary>An optional pixel value to scroll to, indicating distance from left.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo._Animation"/>
        </return-types>
      </method>
      <method name="_getBtnNode" scope="prototype">
        <summary>Gets a button DOM node from a mouse click event.</summary>
        <parameters>
          <parameter name="e" type="The" usage="required">
            <summary>mouse click event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="doSlideRight" scope="prototype">
        <summary>Scrolls the menu to the right.</summary>
        <parameters>
          <parameter name="e" type="The" usage="required">
            <summary>mouse click event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="doSlideLeft" scope="prototype">
        <summary>Scrolls the menu to the left.</summary>
        <parameters>
          <parameter name="e" type="The" usage="required">
            <summary>mouse click event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="doSlide" scope="prototype">
        <summary>Scrolls the tab list to the left or right by 75% of the widget width.</summary>
        <parameters>
          <parameter name="direction" type="If" usage="required">
            <summary>the direction is 1, the widget scrolls to the right, if it is
	-1, it scrolls to the left.</summary>
          </parameter>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setButtonClass" scope="prototype">
        <summary>Adds or removes a class to the left and right scroll buttons
	to indicate whether each one is enabled/disabled.</summary>
        <description>If the tabs are scrolled all the way to the left, the class
	'dijitTabBtnDisabled' is added to the left button.
	If the tabs are scrolled all the way to the right, the class
	'dijitTabBtnDisabled' is added to the right button.</description>
        <parameters>
          <parameter name="scroll" type="Integer" usage="required">
            <summary>amount of horizontal scroll</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout.ScrollingTabController.scrollNode.style" type="">
    <properties>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.layout.ScrollingTabController._contentBox" private="true">
    <properties>
      <property name="h" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout.ScrollingTabController._leftBtn" type="">
    <properties>
      <property name="layoutAlign" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.layout.ScrollingTabController._rightBtn" type="">
    <properties>
      <property name="layoutAlign" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.layout.ScrollingTabController._menuBtn" type="">
    <properties>
      <property name="layoutAlign" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout.ScrollingTabController.scrollNode" type="">
    <properties>
      <property name="scrollLeft" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout._ScrollingTabControllerButton" type="Function" classlike="true" superclass="dijit.form.Button">
    <mixins>
      <mixin scope="instance" location="dijit.form.Button"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="buttonType" scope="prototype" type="String"/>
      <property name="buttonClass" scope="prototype" type="String"/>
      <property name="tabPosition" scope="prototype" type="String"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="tabIndex" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.layout.SplitContainer" type="Function" classlike="true" superclass="dijit.layout._LayoutWidget">
    <summary>Deprecated.  Use &lt;code&gt;dijit.layout.BorderContainer&lt;/code&gt; instead.</summary>
    <description>A Container widget with sizing handles in-between each child.
	Contains multiple children widgets, all of which are displayed side by side
	(either horizontally or vertically); there's a bar between each of the children,
	and you can adjust the relative size of each child by dragging the bars.
	You must specify a size (width and height) for the SplitContainer.</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout._LayoutWidget"/>
    </mixins>
    <properties>
      <property name="activeSizing" scope="prototype" type="Boolean">
        <summary>If true, the children's size changes as you drag the bar;
	otherwise, the sizes don't change until you drop the bar (by mouse-up)</summary>
      </property>
      <property name="sizerWidth" scope="prototype" type="Integer">
        <summary>Size in pixels of the bar between each child
	FIXME: this should be a CSS attribute (at 7 because css wants it to be 7 until we fix to css)</summary>
      </property>
      <property name="orientation" scope="prototype" type="String">
        <summary>either 'horizontal' or vertical; indicates whether the children are
	arranged side-by-side or up/down.</summary>
      </property>
      <property name="persist" scope="prototype" type="Boolean">
        <summary>Save splitter positions in a cookie</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="isHorizontal" scope="prototype" type="bool"/>
      <property name="sizers" scope="prototype" type="Array"/>
      <property name="virtualSizer" scope="prototype" type=""/>
      <property name="paneWidth" scope="prototype" type=""/>
      <property name="paneHeight" scope="prototype" type=""/>
      <property name="isSizing" scope="prototype" type="bool"/>
      <property name="sizingSplitter" scope="prototype" type=""/>
      <property name="cover" scope="prototype" type="Object"/>
      <property name="originPos" scope="prototype" type="Object"/>
      <property name="startPoint" scope="prototype" type=""/>
      <property name="lastPoint" scope="prototype" type="String"/>
      <property name="screenToClientOffset" scope="prototype" type="Number"/>
      <property name="dragOffset" scope="prototype" type="Number"/>
      <property name="_ownconnects" scope="prototype" type="Array"/>
      <property name="isDraggingLeft" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_setupChild" scope="prototype">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onSizerMouseDown" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_addSizer" scope="prototype">
        <parameters>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <summary>Remove sizer, but only if widget is really our child and
	we have at least one sizer to throw away</summary>
        <parameters>
          <parameter name="widget" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="prototype">
        <summary>Add a child widget to the container</summary>
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required">
            <summary>a widget to add</summary>
          </parameter>
          <parameter name="insertIndex" type="Integer" usage="optional">
            <summary>postion in the &amp;quot;stack&amp;quot; to add the child widget</summary>
          </parameter>
        </parameters>
      </method>
      <method name="layout" scope="prototype">
        <summary>Do layout of panels</summary>
      </method>
      <method name="_movePanel" scope="prototype">
        <parameters>
          <parameter name="panel" type="" usage="required"/>
          <parameter name="pos" type="" usage="required"/>
          <parameter name="size" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_moveSlider" scope="prototype">
        <parameters>
          <parameter name="slider" type="" usage="required"/>
          <parameter name="pos" type="" usage="required"/>
          <parameter name="size" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_growPane" scope="prototype">
        <parameters>
          <parameter name="growth" type="" usage="required"/>
          <parameter name="pane" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_checkSizes" scope="prototype"/>
      <method name="beginSizing" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
          <parameter name="i" type="" usage="required"/>
        </parameters>
      </method>
      <method name="changeSizing" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="endSizing" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="movePoint" scope="prototype"/>
      <method name="legaliseSplitPoint" scope="prototype">
        <parameters>
          <parameter name="a" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSize" scope="prototype"/>
      <method name="_showSizingLine" scope="prototype"/>
      <method name="_hideSizingLine" scope="prototype"/>
      <method name="_moveSizingLine" scope="prototype"/>
      <method name="_getCookieName" scope="prototype">
        <parameters>
          <parameter name="i" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_restoreState" scope="prototype"/>
      <method name="_saveState" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.layout.SplitContainer.domNode.style" type="">
    <properties>
      <property name="overflow" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.layout.SplitContainer.cover.style" type="">
    <properties>
      <property name="zIndex" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dijit.layout.SplitContainer.sizingSplitter.style" type="">
    <properties>
      <property name="zIndex" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dijit.layout.SplitContainer.paneBefore" type="">
    <properties>
      <property name="position" scope="prototype" type=""/>
      <property name="sizeActual" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dijit.layout.SplitContainer.paneAfter" type="">
    <properties>
      <property name="position" scope="prototype" type="String"/>
      <property name="sizeActual" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dijit.layout.SplitContainer.virtualSizer.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.layout.StackContainer" type="Function" classlike="true" superclass="dijit.layout._LayoutWidget">
    <summary>A container that has multiple children, but shows only
	one child at a time</summary>
    <description>A container for widgets (ContentPanes, for example) That displays
	only one Widget at a time.
	Publishes topics [widgetId]-addChild, [widgetId]-removeChild, and [widgetId]-selectChild
	Can be base class for container, Wizard, Show, etc.</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout._LayoutWidget"/>
    </mixins>
    <properties>
      <property name="doLayout" scope="prototype" type="Boolean">
        <summary>If true, change the size of my currently displayed child to match my size</summary>
      </property>
      <property name="persist" scope="prototype" type="Boolean">
        <summary>Remembers the selected child across sessions</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="selectedChildWidget" scope="prototype" type="dijit._Widget">
        <summary>References the currently selected child widget, if any.
	Adjust selected child with selectChild() method.</summary>
      </property>
      <property name="_hasBeenShown" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="resize" scope="prototype"/>
      <method name="_setupChild" scope="prototype">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="prototype">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="selectChild" scope="prototype">
        <summary>Show the given widget (which must be one of my children)</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget|String" usage="required">
            <summary>Reference to child widget or id of child widget</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_transition" scope="prototype">
        <summary>Hide the old widget and display the new widget.
	Subclasses should override this.</summary>
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="required"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_adjacent" scope="prototype">
        <summary>Gets the next/previous child widget in this container from the current selection.</summary>
        <parameters>
          <parameter name="forward" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="forward" scope="prototype">
        <summary>Advance to next page.</summary>
      </method>
      <method name="back" scope="prototype">
        <summary>Go back to previous page.</summary>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="prototype"/>
      <method name="_showChild" scope="prototype">
        <summary>Show the specified child by changing it's CSS, and call _onShow()/onShow() so
	it can do any updates it needs regarding loading href's etc.</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="prototype">
        <summary>Hide the specified child by changing it's CSS, and call _onHide() so
	it's notified.</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="closeChild" scope="prototype">
        <summary>Callback when user clicks the [X] to remove a page.
	If onClose() returns true then remove and destroy the child.</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="destroyDescendants" scope="prototype">
        <parameters>
          <parameter name="preserveDom" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout.StackController" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Set of buttons to select a page in a page list.</summary>
    <description>Monitors the specified StackContainer, and whenever a page is
	added, deleted, or selected, updates itself accordingly.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="containerId" scope="prototype" type="String">
        <summary>The id of the page container that I point to</summary>
      </property>
      <property name="buttonWidget" scope="prototype" type="String">
        <summary>The name of the button widget to create to correspond to each page</summary>
      </property>
      <property name="pane2button" scope="prototype" type="Object"/>
      <property name="pane2handles" scope="prototype" type="Object"/>
      <property name="_currentChild" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="onStartup" scope="prototype">
        <summary>Called after StackContainer has finished initializing</summary>
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="onAddChild" scope="prototype">
        <summary>Called whenever a page is added to the container.
	Create button corresponding to the page.</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="prototype">
        <summary>Called whenever a page is removed from the container.
	Remove the button corresponding to the page.</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="prototype">
        <summary>Called when a page has been selected in the StackContainer, either by me or by another StackController</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onButtonClick" scope="prototype">
        <summary>Called whenever one of my child buttons is pressed in an attempt to select a page</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onCloseButtonClick" scope="prototype">
        <summary>Called whenever one of my child buttons [X] is pressed in an attempt to close a page</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="adjacent" scope="prototype">
        <summary>Helper for onkeypress to find next/previous button</summary>
        <parameters>
          <parameter name="forward" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dijit._Widget"/>
        </return-types>
      </method>
      <method name="onkeypress" scope="prototype">
        <summary>Handle keystrokes on the page list, for advancing to next/previous button
	and closing the current page if the page is closable.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onContainerKeyPress" scope="prototype">
        <summary>Called when there was a keypress on the container</summary>
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout._StackButton" type="Function" classlike="true" superclass="dijit.form.ToggleButton">
    <summary>Internal widget used by StackContainer.</summary>
    <description>The button-like or tab-like object you click to select or delete a page</description>
    <mixins>
      <mixin scope="instance" location="dijit.form.ToggleButton"/>
    </mixins>
    <properties>
      <property name="tabIndex" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>This is for TabContainer where the tabs are &amp;lt;span&amp;gt; rather than button,
	so need to set focus explicitly (on some browsers)
	Note that you shouldn't override this method, but you can connect to it.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClickCloseButton" scope="prototype">
        <summary>StackContainer connects to this function; if your widget contains a close button
	then clicking it should call this function.
	Note that you shouldn't override this method, but you can connect to it.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout.TabContainer" type="Function" classlike="true" superclass="dijit.layout._TabContainerBase">
    <summary>A Container with tabs to select each child (only one of which is displayed at a time).</summary>
    <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout._TabContainerBase"/>
    </mixins>
    <properties>
      <property name="useMenu" scope="prototype" type="Boolean">
        <summary>True if a menu should be used to select tabs when they are too
	wide to fit the TabContainer, false otherwise.</summary>
      </property>
      <property name="useSlider" scope="prototype" type="Boolean">
        <summary>True if a slider should be used to select tabs when they are too
	wide to fit the TabContainer, false otherwise.</summary>
      </property>
      <property name="controllerWidget" scope="prototype" type="String">
        <summary>An optional parameter to override the widget used to display the tab labels</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_makeController" scope="prototype">
        <summary>Instantiate tablist controller widget and return reference to it.
	Callback from _TabContainerBase.postCreate().</summary>
        <parameters>
          <parameter name="srcNode" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.layout.TabController" type="Function" classlike="true" superclass="dijit.layout.StackController">
    <summary>Set of tabs (the things with titles and a close button, that you click to show a tab panel).
	Used internally by &lt;code&gt;dijit.layout.TabContainer&lt;/code&gt;.</summary>
    <description>Lets the user select the currently shown pane in a TabContainer or StackContainer.
	TabController also monitors the TabContainer, and whenever a pane is
	added or deleted updates itself accordingly.</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout.StackController"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="tabPosition" scope="prototype" type="String">
        <summary>Defines where tabs go relative to the content.
	&amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;left-h&amp;quot;, &amp;quot;right-h&amp;quot;</summary>
      </property>
      <property name="buttonWidget" scope="prototype" type="String">
        <summary>The name of the tab widget to create to correspond to each page</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_rectifyRtlTabList" scope="prototype">
        <summary>For left/right TabContainer when page is RTL mode, rectify the width of all tabs to be equal, otherwise the tab widths are different in IE</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.layout._TabButton" type="Function" classlike="true" superclass="dijit.layout._StackButton">
    <summary>A tab (the thing you click to select a pane).</summary>
    <description>Contains the title of the pane, and optionally a close-button to destroy the pane.
	This is an internal widget and should not be instantiated directly.</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout._StackButton"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String">
        <summary>The CSS class applied to the domNode.</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="scrollOnFocus" scope="prototype" type="bool"/>
      <property name="iconClass" scope="prototype" type="String"/>
      <property name="domNode" scope="prototype" type=""/>
      <property name="closeButton" scope="prototype" type=""/>
      <property name="_closeMenu" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_setCloseButtonAttr" scope="prototype">
        <parameters>
          <parameter name="disp" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="_onCloseButtonEnter" scope="prototype">
        <summary>Handler when mouse is moved over the close icon (the X)</summary>
      </method>
      <method name="_onCloseButtonLeave" scope="prototype">
        <summary>Handler when mouse is moved off the close icon (the X)</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.layout._TabButton.closeNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.layout._LayoutWidget" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Base class for a _Container widget which is responsible for laying out its children.
	Widgets which mixin this code must define layout() to manage placement and sizing of the children.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Container"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String">
        <summary>This class name is applied to the widget's domNode
	and also may be used to generate names for sub nodes,
	for example dijitTabContainer-content.</summary>
      </property>
      <property name="isLayoutContainer" scope="prototype" type="Boolean">
        <summary>Indicates that this widget is going to call resize() on its
	children widgets, setting their size, when they become visible.</summary>
      </property>
      <property name="getParent" scope="prototype" type=""/>
      <property name="domNode" scope="prototype" type=""/>
      <property name="_borderBox" scope="prototype" type="Object"/>
      <property name="_contentBox" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype">
        <summary>Called after all the widgets have been instantiated and their
	dom nodes have been inserted somewhere under dojo.doc.body.
	Widgets should override this method to do any initialization
	dependent on other widgets existing, and then call
	this superclass method to finish things off.
	startup() in subclasses shouldn't do anything
	size related because the size of the widget hasn't been set yet.</summary>
      </method>
      <method name="resize" scope="prototype">
        <summary>Call this to resize a widget, or after its size has changed.</summary>
        <description>Change size mode:
	When changeSize is specified, changes the marginBox of this widget
	and forces it to relayout its contents accordingly.
	changeSize may specify height, width, or both.
	If resultSize is specified it indicates the size the widget will
	become after changeSize has been applied.
	Notification mode:
	When changeSize is null, indicates that the caller has already changed
	the size of the widget, or perhaps it changed because the browser
	window was resized.  Tells widget to relayout its contents accordingly.
	If resultSize is also specified it indicates the size the widget has
	become.
	In either mode, this method also:
	1. Sets this._borderBox and this._contentBox to the new size of
	the widget.  Queries the current domNode size if necessary.
	2. Calls layout() to resize contents (and maybe adjust child widgets).</description>
        <parameters>
          <parameter name="changeSize" type="Object" usage="optional">
            <summary>Sets the widget to this margin-box size and position.
	May include any/all of the following properties:
		{w: int, h: int, l: int, t: int}</summary>
          </parameter>
          <parameter name="resultSize" type="Object" usage="optional">
            <summary>The margin-box size of this widget after applying changeSize (if
	changeSize is specified).  If caller knows this size and
	passes it in, we don't need to query the browser to get the size.
		{w: int, h: int}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="layout" scope="prototype">
        <summary>Widgets override this method to size and position their contents/children.
	When this is called this._contentBox is guaranteed to be set (see resize()).
	This is called after startup(), and also when the widget's size has been
	changed.</summary>
      </method>
      <method name="_setupChild" scope="prototype">
        <summary>Common setup for initial children and children which are added after startup</summary>
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="prototype">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.layout._LayoutWidget.domNode.style" type="">
    <properties>
      <property name="top" scope="prototype" type="String"/>
      <property name="left" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dijit.layout._TabContainerBase" type="Function" classlike="true" superclass="dijit.layout.StackContainer">
    <summary>Abstract base class for TabContainer.   Must define _makeController() to instantiate
	and return the widget that displays the tab labels</summary>
    <description>A TabContainer is a container that has multiple panes, but shows only
	one pane at a time.  There are a set of tabs corresponding to each pane,
	where each tab has the name (aka title) of the pane, and optionally a close button.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit.layout.StackContainer"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="tabPosition" scope="prototype" type="String">
        <summary>Defines where tabs go relative to tab content.
	&amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;, &amp;quot;left-h&amp;quot;, &amp;quot;right-h&amp;quot;</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="tabStrip" scope="prototype" type="Boolean">
        <summary>Defines whether the tablist gets an extra class for layouting, putting a border/shading
	around the set of tabs.</summary>
      </property>
      <property name="nested" scope="prototype" type="Boolean">
        <summary>If true, use styling for a TabContainer nested inside another TabContainer.
	For tundra etc., makes tabs look like links, and hides the outer
	border since the outer TabContainer already has a border.</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_containerContentBox" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setupChild" scope="prototype">
        <parameters>
          <parameter name="tab" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="layout" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.layout._TabContainerBase.tablist">
    <properties>
      <property name="layoutAlign" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="doh.robot" type="">
    <methods>
      <method name="_position" scope="normal">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollIntoView" scope="normal">
        <summary>Scroll the passed node into view, if it is not.
	Stub to be replaced in dijit.robot.</summary>
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_getWindowChain" scope="normal">
        <parameters>
          <parameter name="n" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_updateDocument" scope="normal"/>
      <method name="_resolveNode" scope="normal">
        <parameters>
          <parameter name="n" type="String||DOMNode||Function" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="normal">
        <summary>Scroll the passed node into view, if it is not.</summary>
        <parameters>
          <parameter name="node" type="String||DOMNode||Function" usage="required">
            <summary>The id of the node, or the node itself, to move the mouse to.
	If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
	This is useful if you need to move the mouse to an node that is not yet present.</summary>
          </parameter>
          <parameter name="delay" type="Number," usage="required">
            <summary>Delay, in milliseconds, to wait before firing.
	The delay is a delta with respect to the previous automation call.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="mouseMoveAt" scope="normal">
        <summary>Moves the mouse over the specified node at the specified relative x,y offset.</summary>
        <description>Moves the mouse over the specified node at the specified relative x,y offset.
	You should manually scroll off-screen nodes into view; use dijit.robot for automatic scrolling support.
	If you do not specify an offset, mouseMove will default to move to the middle of the node.
	Example: to move the mouse over a ComboBox's down arrow node, call doh.mouseMoveAt(dijit.byId('setvaluetest').downArrowNode);</description>
        <parameters>
          <parameter name="node" type="String||DOMNode||Function" usage="required">
            <summary>The id of the node, or the node itself, to move the mouse to.
	If you pass an id or a function that returns a node, the node will not be evaluated until the movement executes.
	This is useful if you need to move the mouse to an node that is not yet present.</summary>
          </parameter>
          <parameter name="delay" type="Integer," usage="required">
            <summary>Delay, in milliseconds, to wait before firing.
	The delay is a delta with respect to the previous automation call.
	For example, the following code ends after 600ms:
	doh.robot.mouseClick({left:true}, 100) // first call; wait 100ms
	doh.robot.typeKeys(&amp;quot;dij&amp;quot;, 500) // 500ms AFTER previous call; 600ms in all</summary>
          </parameter>
          <parameter name="duration" type="Integer," usage="required">
            <summary>Approximate time Robot will spend moving the mouse
	The default is 100ms.</summary>
          </parameter>
          <parameter name="offsetX" type="Number," usage="required">
            <summary>x offset relative to the node, in pixels, to move the mouse. The default is half the node's width.</summary>
          </parameter>
          <parameter name="offsetY" type="Number," usage="required">
            <summary>y offset relative to the node, in pixels, to move the mouse. The default is half the node's height.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="initRobot" scope="normal">
        <summary>Opens the application at the specified URL for testing, redirecting dojo to point to the application environment instead of the test environment.</summary>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <summary>URL to open. Any of the test's dojo.doc calls (e.g. dojo.byId()), and any dijit.registry calls (e.g. dijit.byId()) will point to elements and widgets inside this application.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="waitForPageToLoad" scope="normal">
        <summary>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
	returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.</summary>
        <description>Notifies DOH that the doh.robot is about to make a page change in the application it is driving,
	returning a doh.Deferred object the user should return in their runTest function as part of a DOH test.
	Example:
	runTest:function(){
	return waitForPageLoad(function(){ doh.robot.keyPress(dojo.keys.ENTER, 500); });
	}</description>
        <parameters>
          <parameter name="submitActions" type="Function" usage="required">
            <summary>The doh.robot will execute the actions the test passes into the submitActions argument (like clicking the submit button),
	expecting these actions to create a page change (like a form submit).
	After these actions execute and the resulting page loads, the next test will start.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.tree"/>
  <object location="dijit.tree.ForestStoreModel" type="Function" classlike="true" superclass="dijit.tree.TreeStoreModel">
    <summary>Interface between Tree and a dojo.store that doesn't have a root item,
	i.e. has multiple &amp;quot;top level&amp;quot; items.
	description
	Use this class to wrap a dojo.store, making all the items matching the specified query
	appear as children of a fabricated &amp;quot;root item&amp;quot;.  If no query is specified then all the
	items returned by fetch() on the underlying store become children of the root item.
	It allows dijit.Tree to assume a single root item, even if the store doesn't have one.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.tree.TreeStoreModel"/>
    </mixins>
    <examples>
      <example>	{type:'continent'}</example>
    </examples>
    <properties>
      <property name="rootId" scope="prototype" type="String">
        <summary>ID of fabricated root item</summary>
      </property>
      <property name="rootLabel" scope="prototype" type="String">
        <summary>Label of fabricated root item</summary>
      </property>
      <property name="query" scope="prototype" type="String">
        <summary>Specifies the set of children of the root item.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Sets up variables, etc.</summary>
        <parameters>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="prototype">
        <summary>Tells if an item has or may have children.  Implementing logic here
	avoids showing +/- expando icon for nodes that we know don't have children.
	(For efficiency reasons we may not want to check if an element actually
	has children until user clicks the expando node)</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype">
        <summary>Calls onComplete() with array of child items of given parent item, all loaded.</summary>
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="callback" type="function(items)" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <summary>Creates a new item.   See dojo.data.api.Write for details on args.
	Used in drag &amp;amp; drop when item from external source dropped onto tree.</summary>
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onNewRootItem" scope="prototype">
        <summary>User can override this method to modify a new element that's being
	added to the root of the tree, for example to add a flag like root=true</summary>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="prototype">
        <summary>Move or copy an item from one parent item to another.
	Used in drag &amp;amp; drop</summary>
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onAddToRoot" scope="prototype">
        <summary>Called when item added to root of tree; user must override this method
	to modify the item so that it matches the query for top level items</summary>
        <examples>
          <example>	store.setValue(item, "root", true);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onLeaveRoot" scope="prototype">
        <summary>Called when item removed from root of tree; user must override this method
	to modify the item so it doesn't match the query for top level items</summary>
        <examples>
          <example>	store.unsetAttribute(item, "root");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_requeryTop" scope="prototype"/>
      <method name="onNewItem" scope="prototype">
        <summary>Handler for when new items appear in the store.  Developers should override this
	method to be more efficient based on their app/data.</summary>
        <description>Note that the default implementation requeries the top level items every time
	a new item is created, since any new item could be a top level item (even in
	addition to being a child of another item, since items can have multiple parents).
	Developers can override this function to do something more efficient if they can
	detect which items are possible top level items (based on the item and the
	parentInfo parameters).  Often all top level items have parentInfo==null, but
	that will depend on which store you use and what your data is like.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteItem" scope="prototype">
        <summary>Handler for delete notifications from underlying store</summary>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.tree.ForestStoreModel.root">
    <properties>
      <property name="children" scope="prototype" type="Array"/>
    </properties>
  </object>
  <object location="dijit.tree.TreeStoreModel" type="Function" classlike="true">
    <summary>Implements dijit.Tree.model connecting to a store with a single
	root item.  Any methods passed into the constructor will override
	the ones defined here.</summary>
    <examples>
      <example>	{id:'ROOT'}</example>
    </examples>
    <properties>
      <property name="store" scope="instance-prototype" type="dojo.data.Store">
        <summary>Underlying store</summary>
      </property>
      <property name="childrenAttrs" scope="prototype" type="String[]">
        <summary>One or more attribute names (attributes in the dojo.data item) that specify that item's children</summary>
      </property>
      <property name="newItemIdAttr" scope="prototype" type="String">
        <summary>Name of attribute in the Object passed to newItem() that specifies the id.
	If newItemIdAttr is set then it's used when newItem() is called to see if an
	item with the same id already exists, and if so just links to the old item
	(so that the old item ends up with two parents).
	Setting this to null or &amp;quot;&amp;quot; will make every drop create a new item.</summary>
      </property>
      <property name="labelAttr" scope="prototype" type="String">
        <summary>If specified, get label for tree node from this attribute, rather
	than by calling store.getLabel()</summary>
      </property>
      <property name="root" scope="prototype" type="dojo.data.Item">
        <summary>Pointer to the root item (read only, not a parameter)</summary>
      </property>
      <property name="query" scope="prototype" type="anything">
        <summary>Specifies datastore query to return the root item for the tree.
	Must only return a single item.   Alternately can just pass in pointer
	to root item.</summary>
      </property>
      <property name="deferItemLoadingUntilExpand" scope="prototype" type="Boolean">
        <summary>Setting this to true will cause the TreeStoreModel to defer calling loadItem on nodes
	until they are expanded. This allows for lazying loading where only one
	loadItem (and generally one network call, consequently) per expansion
	(rather than one for each child).
	This relies on partial loading of the children items; each children item of a
	fully loaded item should contain the label and info about having children.</summary>
      </property>
      <property name="connects" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Passed the arguments listed above (store, etc)</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="getRoot" scope="prototype">
        <summary>Calls onItem with the root item for the tree, possibly a fabricated item.
	Calls onError on error.</summary>
        <parameters>
          <parameter name="onItem" type="" usage="required"/>
          <parameter name="onError" type="" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="prototype">
        <summary>Tells if an item has or may have children.  Implementing logic here
	avoids showing +/- expando icon for nodes that we know don't have children.
	(For efficiency reasons we may not want to check if an element actually
	has children until user clicks the expando node)</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype">
        <summary>Calls onComplete() with array of child items of given parent item, all loaded.</summary>
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items)" usage="required"/>
          <parameter name="onError" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>Get the label for an item</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="newItem" scope="prototype">
        <summary>Creates a new item.   See &lt;code&gt;dojo.data.api.Write&lt;/code&gt; for details on args.
	Used in drag &amp;amp; drop when item from external source dropped onto tree.</summary>
        <description>Developers will need to override this method if new items get added
	to parents with multiple children attributes, in order to define which
	children attribute points to the new item.</description>
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="prototype">
        <summary>Move or copy an item from one parent item to another.
	Used in drag &amp;amp; drop</summary>
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Callback whenever an item has changed, so that Tree
	can update the label, icon, etc.   Note that changes
	to an item's children or parent(s) will trigger an
	onChildrenChange() so you can ignore those changes here.</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="prototype">
        <summary>Callback to do notifications about new, updated, or deleted items.</summary>
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="onDelete" scope="prototype">
        <summary>Callback when an item has been deleted.</summary>
        <description>Note that there will also be an onChildrenChange() callback for the parent
	of this item.</description>
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
      <method name="onNewItem" scope="prototype">
        <summary>Handler for when new items appear in the store, either from a drop operation
	or some other way.   Updates the tree view (if necessary).</summary>
        <description>If the new item is a child of an existing item,
	calls onChildrenChange() with the new list of children
	for that existing item.</description>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
          <parameter name="parentInfo" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteItem" scope="prototype">
        <summary>Handler for delete notifications from underlying store</summary>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSetItem" scope="prototype">
        <summary>Updates the tree view according to changes in the data store.</summary>
        <description>Handles updates to an item's children by calling onChildrenChange(), and
	other updates to an item by calling onChange().
	See `onNewItem` for more details on handling updates to an item's children.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <summary>| array</summary>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <summary>| array</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.tree._dndContainer" type="Function" classlike="true">
    <summary>This is a base class for &lt;code&gt;dijit.tree._dndSelector&lt;/code&gt;, and isn't meant to be used directly.
	It's modeled after &lt;code&gt;dojo.dnd.Container&lt;/code&gt;.</summary>
    <properties>
      <property name="current" scope="instance-prototype" type="DomNode">
        <summary>The currently hovered TreeNode.rowNode (which is the DOM node
	associated w/a given node in the tree, excluding it's descendants)</summary>
      </property>
      <property name="node" scope="instance-prototype" type="Object"/>
      <property name="parent" scope="prototype" type="Object"/>
      <property name="currentWidget" scope="prototype" type="Object"/>
      <property name="tree" scope="instance" type="Node">
        <summary>Node or node's id to build the container on
	params: dijit.tree.__SourceArgs
	A dict of parameters, which gets mixed into the object</summary>
      </property>
      <property name="map" scope="instance" type="Object"/>
      <property name="containerState" scope="instance" type="String"/>
      <property name="events" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="tree" type="Node" usage="required">
            <summary>Node or node's id to build the container on</summary>
          </parameter>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required">
            <summary>A dict of parameters, which gets mixed into the object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>A constructor of the Container</summary>
        <parameters>
          <parameter name="tree" type="Node" usage="required">
            <summary>Node or node's id to build the container on</summary>
          </parameter>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required">
            <summary>A dict of parameters, which gets mixed into the object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getItem" scope="prototype">
        <summary>Returns the dojo.dnd.Item (representing a dragged node) by it's key (id).
	Called by dojo.dnd.Source.checkAcceptance().</summary>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.dnd.Item"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Prepares this object to be garbage-collected</summary>
      </method>
      <method name="onMouseOver" scope="prototype">
        <summary>Called when mouse is moved over a TreeNode</summary>
        <parameters>
          <parameter name="widget" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <summary>Called when mouse is moved away from a TreeNode</summary>
        <parameters>
          <parameter name="widget" type="TreeNode" usage="required"/>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_changeState" scope="prototype">
        <summary>Changes a named state to new state value</summary>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <summary>A name of the state to change</summary>
          </parameter>
          <parameter name="newState" type="String" usage="required">
            <summary>new state</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addItemClass" scope="prototype">
        <summary>Adds a class with prefix &amp;quot;dojoDndItem&amp;quot;</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>A node</summary>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <summary>A variable suffix for a class name</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_removeItemClass" scope="prototype">
        <summary>Removes a class with prefix &amp;quot;dojoDndItem&amp;quot;</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>A node</summary>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <summary>A variable suffix for a class name</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="prototype">
        <summary>This function is called once, when mouse is over our container</summary>
      </method>
      <method name="onOutEvent" scope="prototype">
        <summary>This function is called once, when mouse is out of our container</summary>
      </method>
    </methods>
  </object>
  <object location="dijit.tree._dndSelector" type="Function" classlike="true" superclass="dijit.tree._dndContainer">
    <summary>This is a base class for &lt;code&gt;dijit.tree.dndSource&lt;/code&gt; , and isn't meant to be used directly.
	It's based on &lt;code&gt;dojo.dnd.Selector&lt;/code&gt;.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.tree._dndContainer"/>
    </mixins>
    <properties>
      <property name="selection" scope="instance-prototype" type="Hash&lt;String,">
        <summary>DomNode&amp;gt;
	(id, DomNode) map for every TreeNode that's currently selected.
	The DOMNode is the TreeNode.rowNode.</summary>
      </property>
      <property name="singular" scope="prototype" type="Boolean">
        <summary>Allows selection of only one element, if true.
	Tree hasn't been tested in singular=true mode, unclear if it works.</summary>
      </property>
      <property name="anchor" scope="instance-prototype" type="Object"/>
      <property name="simpleSelection" scope="instance-prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="tree" type="" usage="required"/>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialization</summary>
        <parameters>
          <parameter name="tree" type="" usage="required"/>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedNodes" scope="prototype">
        <summary>Returns the set of selected nodes.
	Used by dndSource on the start of a drag.</summary>
      </method>
      <method name="selectNone" scope="prototype">
        <summary>Unselects all items</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Prepares the object to be garbage-collected</summary>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>Event processor for onmousedown</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="ignore right-click"/>
        </return-types>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>Event processor for onmouseup</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_removeSelection" scope="prototype">
        <summary>Unselects all items</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_removeAnchor" scope="prototype">
        <summary>Removes the Anchor CSS class from a node.
	According to &lt;code&gt;dojo.dnd.Selector&lt;/code&gt;, anchor means that
	&amp;quot;an item is selected, and is an anchor for a 'shift' selection&amp;quot;.
	It's not relevant for Tree at this point, since we don't support multiple selection.</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="forInSelectedItems" scope="prototype">
        <summary>Iterates over selected items;
	see &lt;code&gt;dojo.dnd.Container.forInItems()&lt;/code&gt; for details</summary>
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.tree.dndSource" type="Function" classlike="true" superclass="dijit.tree._dndSelector" private="true">
    <summary>Handles drag and drop operations (as a source or a target) for &lt;code&gt;dijit.Tree&lt;/code&gt;</summary>
    <mixins>
      <mixin scope="instance" location="dijit.tree._dndSelector"/>
    </mixins>
    <properties>
      <property name="isSource" scope="instance-prototype" type="Boolean">
        <summary>Can be used as a DnD source.</summary>
      </property>
      <property name="accept" scope="instance-prototype" type="String[]">
        <summary>List of accepted types (text strings) for the Tree; defaults to
	[&amp;quot;text&amp;quot;]</summary>
      </property>
      <property name="copyOnly" scope="prototype" type="Boolean">
        <summary>Copy items, if true, use a state of Ctrl key otherwise</summary>
      </property>
      <property name="dragThreshold" scope="prototype" type="Number">
        <summary>The move delay in pixels before detecting a drag; 5 by default</summary>
      </property>
      <property name="betweenThreshold" scope="prototype" type="Integer">
        <summary>Distance from upper/lower edge of node to allow drop to reorder nodes</summary>
      </property>
      <property name="targetAnchor" scope="instance-prototype" type="Object"/>
      <property name="current" scope="prototype" type=""/>
      <property name="currentWidget" scope="prototype" type=""/>
      <property name="dropPosition" scope="instance-prototype" type="String"/>
      <property name="targetBox" scope="instance-prototype" type="Object"/>
      <property name="mouseDown" scope="instance-prototype" type="bool"/>
      <property name="mouseButton" scope="prototype" type=""/>
      <property name="_lastX" scope="instance-prototype" type="Number"/>
      <property name="_lastY" scope="instance-prototype" type="Number"/>
      <property name="isDragging" scope="instance-prototype" type="bool"/>
      <property name="sourceState" scope="instance" type="String"/>
      <property name="targetState" scope="instance" type="String"/>
      <property name="topics" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="tree" type="dijit.Tree" usage="required"/>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>a constructor of the Tree DnD Source</summary>
        <parameters>
          <parameter name="tree" type="dijit.Tree" usage="required"/>
          <parameter name="params" type="dijit.tree.__SourceArgs" usage="required"/>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="prototype">
        <summary>Checks if the target can accept nodes from this source</summary>
        <parameters>
          <parameter name="source" type="dijit.tree.dndSource" usage="required">
            <summary>The source which provides items</summary>
          </parameter>
          <parameter name="nodes" type="DOMNode[]" usage="required">
            <summary>Array of DOM nodes corresponding to nodes being dropped, dijitTreeRow nodes if
	source is a dijit.Tree.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="copyState" scope="prototype">
        <summary>Returns true, if we need to copy items, false to move.
	It is separated to be overwritten dynamically, if needed.</summary>
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <summary>The &amp;quot;copy&amp;quot; control key was pressed</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Prepares the object to be garbage-collected.</summary>
      </method>
      <method name="_onDragMouse" scope="prototype">
        <summary>Helper method for processing onmousemove/onmouseover events while drag is in progress.
	Keeps track of current drop target.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <summary>Called for any onmousemove events over the Tree</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>onmousemouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>Event processor for onmousedown</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>onmousedown event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>Event processor for onmouseup</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>onmouseup event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <summary>Event processor for when mouse is moved away from a TreeNode</summary>
      </method>
      <method name="checkItemAcceptance" scope="prototype">
        <summary>Stub function to be overridden if one wants to check for the ability to drop at the node/item level</summary>
        <description>In the base case, this is called to check if target can become a child of source.
	When betweenThreshold is set, position="before" or "after" means that we
	are asking if the source node can be dropped before/after the target node.</description>
        <parameters>
          <parameter name="target" type="DOMNode" usage="required">
            <summary>The dijitTreeRoot DOM node inside of the TreeNode that we are dropping on to
	Use dijit.getEnclosingWidget(target) to get the TreeNode.</summary>
          </parameter>
          <parameter name="source" type="dijit.tree.dndSource" usage="required">
            <summary>The (set of) nodes we are dropping</summary>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <summary>&amp;quot;over&amp;quot;, &amp;quot;before&amp;quot;, or &amp;quot;after&amp;quot;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="prototype">
        <summary>Topic event processor for /dnd/source/over, called when detected a current source.</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>The dijit.tree.dndSource / dojo.dnd.Source which has the mouse over it</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDndStart" scope="prototype">
        <summary>Topic event processor for /dnd/start, called to initiate the DnD operation</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>The dijit.tree.dndSource / dojo.dnd.Source which is providing the items</summary>
          </parameter>
          <parameter name="nodes" type="DomNode[]" usage="required">
            <summary>The list of transferred items, dndTreeNode nodes if dragging from a Tree</summary>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <summary>Copy items, if true, move items otherwise</summary>
          </parameter>
        </parameters>
      </method>
      <method name="itemCreator" scope="prototype">
        <summary>Returns objects passed to &lt;code&gt;Tree.model.newItem()&lt;/code&gt; based on DnD nodes
	dropped onto the tree.   Developer must override this method to enable
	dropping from external sources onto this Tree, unless the Tree.model's items
	happen to look like {id: 123, name: &amp;quot;Apple&amp;quot; } with no other attributes.</summary>
        <description>For each node in nodes[], which came from source, create a hash of name/value
	pairs to be passed to Tree.model.newItem().  Returns array of those hashes.</description>
        <return-description>Object[]
	Array of name/value hashes for each new item to be added to the Tree, like:
		[
			{ id: 123, label: "apple", foo: "bar" },
			{ id: 456, label: "pear", zaz: "bam" }
		]</return-description>
        <parameters>
          <parameter name="nodes" type="DomNode[]" usage="required"/>
          <parameter name="target" type="" usage="required"/>
          <parameter name="source" type="dojo.dnd.Source" usage="required"/>
        </parameters>
      </method>
      <method name="onDndDrop" scope="prototype">
        <summary>Topic event processor for /dnd/drop, called to finish the DnD operation.</summary>
        <description>Updates data store items according to where node was dragged from and dropped
	to.   The tree will then respond to those data store updates and redraw itself.</description>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>The dijit.tree.dndSource / dojo.dnd.Source which is providing the items</summary>
          </parameter>
          <parameter name="nodes" type="DomNode[]" usage="required">
            <summary>The list of transferred items, dndTreeNode nodes if dragging from a Tree</summary>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <summary>Copy items, if true, move items otherwise</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="prototype">
        <summary>Topic event processor for /dnd/cancel, called to cancel the DnD operation</summary>
      </method>
      <method name="onOverEvent" scope="prototype">
        <summary>This method is called when mouse is moved over our container (like onmouseenter)</summary>
      </method>
      <method name="onOutEvent" scope="prototype">
        <summary>This method is called when mouse is moved out of our container (like onmouseleave)</summary>
      </method>
      <method name="_isParentChildDrop" scope="prototype">
        <summary>Checks whether the dragged items are parent rows in the tree which are being
	dragged into their own children.</summary>
        <parameters>
          <parameter name="source" type="The" usage="required">
            <summary>DragSource object.</summary>
          </parameter>
          <parameter name="targetRow" type="The" usage="required">
            <summary>tree row onto which the dragged nodes are being dropped.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="prototype">
        <summary>Removes hover class of the current target anchor</summary>
      </method>
      <method name="_markDndStatus" scope="prototype">
        <summary>Changes source's state based on &amp;quot;copy&amp;quot; status</summary>
        <parameters>
          <parameter name="copy" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.tree.dndSource.tree" type="">
    <properties>
      <property name="model" scope="prototype" type=""/>
      <property name="item" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.tree.__SourceArgs" type="Function" classlike="true" private="true">
    <summary>A dict of parameters for Tree source configuration.</summary>
    <properties>
      <property name="isSource" scope="instance" type="Boolean">
        <summary>Can be used as a DnD source. Defaults to true.</summary>
      </property>
      <property name="accept" scope="instance" type="String[]">
        <summary>List of accepted types (text strings) for a target; defaults to
	[&amp;quot;text&amp;quot;, &amp;quot;treeNode&amp;quot;]</summary>
      </property>
      <property name="autoSync" scope="instance" type=""/>
      <property name="copyOnly" scope="instance" type="Boolean">
        <summary>Copy items, if true, use a state of Ctrl key otherwise,</summary>
      </property>
      <property name="dragThreshold" scope="instance" type="Number">
        <summary>The move delay in pixels before detecting a drag; 0 by default</summary>
      </property>
      <property name="betweenThreshold" scope="instance" type="Integer">
        <summary>Distance from upper/lower edge of node to allow drop to reorder nodes</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dijit.tree.model" type="Function" classlike="true">
    <summary>Contract for any data provider object for the tree.</summary>
    <description>Tree passes in values to the constructor to specify the callbacks.
	"item" is typically a dojo.data.Item but it's just a black box so
	it could be anything.
	This (like `dojo.data.api.Read`) is just documentation, and not meant to be used.</description>
    <methods>
      <method constructor="constructor"/>
      <method name="destroy" scope="prototype">
        <summary>Destroys this object, releasing connections to the store</summary>
      </method>
      <method name="getRoot" scope="prototype">
        <summary>Calls onItem with the root item for the tree, possibly a fabricated item.
	Throws exception on error.</summary>
        <parameters>
          <parameter name="onItem" type="" usage="required"/>
        </parameters>
      </method>
      <method name="mayHaveChildren" scope="prototype">
        <summary>Tells if an item has or may have children.  Implementing logic here
	avoids showing +/- expando icon for nodes that we know don't have children.
	(For efficiency reasons we may not want to check if an element actually
	has children until user clicks the expando node)</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="getChildren" scope="prototype">
        <summary>Calls onComplete() with array of child items of given parent item, all loaded.
	Throws exception on error.</summary>
        <parameters>
          <parameter name="parentItem" type="dojo.data.Item" usage="required"/>
          <parameter name="onComplete" type="function(items)" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <summary>Returns true if *something* is an item and came from this model instance.
	Returns false if *something* is a literal, an item from another model instance,
	or is any object other than an item.</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>Given the identity of an item, this method returns the item that has
	that identity through the onItem callback.  Conforming implementations
	should return null if there is no item with the given identity.
	Implementations of fetchItemByIdentity() may sometimes return an item
	from a local cache and may sometimes fetch an item from a remote server.</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>Returns identity for an item</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>Get the label for an item</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <summary>Creates a new item.   See &lt;code&gt;dojo.data.api.Write&lt;/code&gt; for details on args.</summary>
        <parameters>
          <parameter name="args" type="dojo.dnd.Item" usage="required"/>
          <parameter name="parent" type="Item" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="pasteItem" scope="prototype">
        <summary>Move or copy an item from one parent item to another.
	Used in drag &amp;amp; drop.
	If oldParentItem is specified and bCopy is false, childItem is removed from oldParentItem.
	If newParentItem is specified, childItem is attached to newParentItem.</summary>
        <parameters>
          <parameter name="childItem" type="Item" usage="required"/>
          <parameter name="oldParentItem" type="Item" usage="required"/>
          <parameter name="newParentItem" type="Item" usage="required"/>
          <parameter name="bCopy" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Callback whenever an item has changed, so that Tree
	can update the label, icon, etc.   Note that changes
	to an item's children or parent(s) will trigger an
	onChildrenChange() so you can ignore those changes here.</summary>
        <parameters>
          <parameter name="item" type="dojo.data.Item" usage="required"/>
        </parameters>
      </method>
      <method name="onChildrenChange" scope="prototype">
        <summary>Callback to do notifications about new, updated, or deleted items.</summary>
        <parameters>
          <parameter name="parent" type="dojo.data.Item" usage="required"/>
          <parameter name="newChildrenList" type="dojo.data.Item[]" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.AdapterRegistry" type="Function" classlike="true">
    <summary>A registry to make contextual calling/searching easier.</summary>
    <description>Objects of this class keep list of arrays in the form [name, check,
	wrap, directReturn] that are used to determine what the contextual
	result of a set of checked arguments is. All check/wrap functions
	in this registry should be of the same arity.</description>
    <examples>
      <example>	// create a new registry
		var reg = new dojo.AdapterRegistry();
		reg.register("handleString",
			dojo.isString,
			function(str){
				// do something with the string here
			}
		);
		reg.register("handleArr",
			dojo.isArray,
			function(arr){
				// do something with the array here
			}
		);
		// now we can pass reg.match() *either* an array or a string and
		// the value we pass will get handled by the right function
		reg.match("someValue"); // will call the first function
		reg.match(["someValue"]); // will call the second</example>
    </examples>
    <properties>
      <property name="pairs" scope="instance" type="Array"/>
      <property name="returnWrappers" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="returnWrappers" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="register" scope="prototype">
        <summary>register a check function to determine if the wrap function or
	object gets selected</summary>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <summary>a way to identify this matcher.</summary>
          </parameter>
          <parameter name="check" type="Function" usage="required">
            <summary>a function that arguments are passed to from the adapter's
	match() function.  The check function should return true if the
	given arguments are appropriate for the wrap function.</summary>
          </parameter>
          <parameter name="wrap" type="Function" usage="required"/>
          <parameter name="directReturn" type="Boolean" usage="optional">
            <summary>If directReturn is true, the value passed in for wrap will be
	returned instead of being called. Alternately, the
	AdapterRegistry can be set globally to &amp;quot;return not call&amp;quot; using
	the returnWrappers property. Either way, this behavior allows
	the registry to act as a &amp;quot;search&amp;quot; function instead of a
	function interception library.</summary>
          </parameter>
          <parameter name="override" type="Boolean" usage="optional">
            <summary>If override is given and true, the check function will be given
	highest priority. Otherwise, it will be the lowest priority
	adapter.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="match" scope="prototype">
        <summary>Find an adapter for the given arguments. If no suitable adapter
	is found, throws an exception. match() accepts any number of
	arguments, all of which are passed to all matching functions
	from the registered pairs.</summary>
      </method>
      <method name="unregister" scope="prototype">
        <summary>Remove a named adapter from the registry</summary>
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.DeferredList" type="Function" classlike="true" superclass="dojo.Deferred">
    <summary>Provides event handling for a group of Deferred objects.</summary>
    <description>DeferredList takes an array of existing deferreds and returns a new deferred of its own
	this new deferred will typically have its callback fired when all of the deferreds in
	the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	fireOnOneErrback, will fire before all the deferreds as appropriate</description>
    <mixins>
      <mixin scope="instance" location="dojo.Deferred"/>
    </mixins>
    <properties>
      <property name="list" scope="instance" type="The">
        <summary>list of deferreds to be synchronizied with this DeferredList</summary>
      </property>
      <property name="resultList" scope="instance" type="Object"/>
      <property name="chain" scope="instance" type="Array"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="fired" scope="instance" type="Number"/>
      <property name="paused" scope="instance" type="Number"/>
      <property name="results" scope="instance" type="Array"/>
      <property name="canceller" scope="instance" type="A">
        <summary>deferred canceller function, see dojo.Deferred</summary>
      </property>
      <property name="silentlyCancelled" scope="instance" type="bool"/>
      <property name="finishedCount" scope="instance" type="Number"/>
      <property name="fireOnOneCallback" scope="instance" type="Will">
        <summary>cause the DeferredLists callback to be fired as soon as any
	of the deferreds in its list have been fired instead of waiting until
	the entire list has finished
	fireonOneErrback:
	Will cause the errback to fire upon any of the deferreds errback</summary>
      </property>
      <property name="fireOnOneErrback" scope="instance" type=""/>
      <property name="consumeErrors" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="list" type="Array" usage="required">
            <summary>The list of deferreds to be synchronizied with this DeferredList</summary>
          </parameter>
          <parameter name="fireOnOneCallback" type="Boolean" usage="optional">
            <summary>Will cause the DeferredLists callback to be fired as soon as any
	of the deferreds in its list have been fired instead of waiting until
	the entire list has finished
	fireonOneErrback:
	Will cause the errback to fire upon any of the deferreds errback</summary>
          </parameter>
          <parameter name="fireOnOneErrback" type="Boolean" usage="optional"/>
          <parameter name="consumeErrors" type="Boolean" usage="optional"/>
          <parameter name="canceller" type="Function" usage="optional">
            <summary>A deferred canceller function, see dojo.Deferred</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Provides event handling for a group of Deferred objects.</summary>
        <description>DeferredList takes an array of existing deferreds and returns a new deferred of its own
	this new deferred will typically have its callback fired when all of the deferreds in
	the given list have fired their own deferreds.  The parameters `fireOnOneCallback` and
	fireOnOneErrback, will fire before all the deferreds as appropriate</description>
        <parameters>
          <parameter name="list" type="Array" usage="required">
            <summary>The list of deferreds to be synchronizied with this DeferredList</summary>
          </parameter>
          <parameter name="fireOnOneCallback" type="Boolean" usage="optional">
            <summary>Will cause the DeferredLists callback to be fired as soon as any
	of the deferreds in its list have been fired instead of waiting until
	the entire list has finished
	fireonOneErrback:
	Will cause the errback to fire upon any of the deferreds errback</summary>
          </parameter>
          <parameter name="fireOnOneErrback" type="Boolean" usage="optional"/>
          <parameter name="consumeErrors" type="Boolean" usage="optional"/>
          <parameter name="canceller" type="Function" usage="optional">
            <summary>A deferred canceller function, see dojo.Deferred</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_cbDeferred" scope="prototype">
        <summary>The DeferredLists' callback handler</summary>
        <parameters>
          <parameter name="index" type="" usage="required"/>
          <parameter name="succeeded" type="" usage="required"/>
          <parameter name="result" type="" usage="required"/>
        </parameters>
      </method>
      <method name="gatherResults" scope="prototype">
        <summary>Gathers the results of the deferreds for packaging
	as the parameters to the Deferred Lists' callback</summary>
        <parameters>
          <parameter name="deferredList" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.NodeList" type="Function" classlike="true">
    <summary>dojo.NodeList is an of Array subclass which adds syntactic
	sugar for chaining, common iteration operations, animation, and
	node manipulation. NodeLists are most often returned as the
	result of dojo.query() calls.</summary>
    <description>dojo.NodeList instances provide many utilities that reflect
	core Dojo APIs for Array iteration and manipulation, DOM
	manipulation, and event handling. Instead of needing to dig up
	functions in the dojo.* namespace, NodeLists generally make the
	full power of Dojo available for DOM manipulation tasks in a
	simple, chainable way.</description>
    <examples>
      <example>create a node list from a node
		new dojo.NodeList(dojo.byId("foo"));</example>
      <example>get a NodeList from a CSS query and iterate on it
		var l = dojo.query(".thinger");
		l.forEach(function(node, index, nodeList){
			console.log(index, node.innerHTML);
		});</example>
      <example>use native and Dojo-provided array methods to manipulate a
	NodeList without needing to use dojo.* functions explicitly:
		var l = dojo.query(".thinger");
		// since NodeLists are real arrays, they have a length
		// property that is both readable and writable and
		// push/pop/shift/unshift methods
		console.log(l.length);
		l.push(dojo.create("span"));
		// dojo's normalized array methods work too:
		console.log( l.indexOf(dojo.byId("foo")) );
		// ...including the special "function as string" shorthand
		console.log( l.every("item.nodeType == 1") );
		// NodeLists can be [..] indexed, or you can use the at()
		// function to get specific items wrapped in a new NodeList:
		var node = l[3]; // the 4th element
		var newList = l.at(1, 3); // the 2nd and 4th elements</example>
      <example>the style functions you expect are all there too:
		// style() as a getter...
		var borders = dojo.query(".thinger").style("border");
		// ...and as a setter:
		dojo.query(".thinger").style("border", "1px solid black");
		// class manipulation
		dojo.query("li:nth-child(even)").addClass("even");
		// even getting the coordinates of all the items
		var coords = dojo.query(".thinger").coords();</example>
      <example>DOM manipulation functions from the dojo.* namespace area also
	available:
		// remove all of the elements in the list from their
		// parents (akin to "deleting" them from the document)
		dojo.query(".thinger").orphan();
		// place all elements in the list at the front of #foo
		dojo.query(".thinger").place("foo", "first");</example>
      <example>Event handling couldn't be easier. `dojo.connect` is mapped in,
	and shortcut handlers are provided for most DOM events:
		// like dojo.connect(), but with implicit scope
		dojo.query("li").connect("onclick", console, "log");
		// many common event handlers are already available directly:
		dojo.query("li").onclick(console, "log");
		var toggleHovered = dojo.hitch(dojo, "toggleClass", "hovered");
		dojo.query("p")
			.onmouseenter(toggleHovered)
			.onmouseleave(toggleHovered);</example>
      <example>chainability is a key advantage of NodeLists:
		dojo.query(".thinger")
			.onclick(function(e){ /* ... */ })
			.at(1, 3, 8) // get a subset
				.style("padding", "5px")
				.forEach(console.log);</example>
    </examples>
    <properties>
      <property name="_wrap" scope="normal" type=""/>
      <property name="_adaptAsMap" scope="normal" type=""/>
      <property name="_adaptAsForEach" scope="normal" type=""/>
      <property name="_adaptAsFilter" scope="normal" type=""/>
      <property name="_adaptWithCondition" scope="normal" type=""/>
      <property name="events" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_anim" scope="prototype">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="wipeIn" scope="prototype">
        <summary>wipe in all elements of this NodeList. Returns an instance of dojo.Animation</summary>
        <examples>
          <example>Fade in all tables with class "blah":
		dojo.query("table.blah").wipeIn().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeOut" scope="prototype">
        <summary>wipe out all elements of this NodeList. Returns an instance of dojo.Animation</summary>
        <examples>
          <example>Wipe out all tables with class "blah":
		dojo.query("table.blah").wipeOut().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideTo" scope="prototype">
        <summary>slide all elements of the node list to the specified place.
	Returns an instance of dojo.Animation</summary>
        <examples>
          <example>	Move all tables with class "blah" to 300/300:
		dojo.query("table.blah").slideTo({
			left: 40,
			top: 50
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeIn" scope="prototype">
        <summary>fade in all elements of this NodeList. Returns an instance of dojo.Animation</summary>
        <examples>
          <example>Fade in all tables with class "blah":
		dojo.query("table.blah").fadeIn().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeOut" scope="prototype">
        <summary>fade out all elements of this NodeList. Returns an instance of dojo.Animation</summary>
        <examples>
          <example>Fade out all elements with class "zork":
		dojo.query(".zork").fadeOut().play();</example>
          <example>Fade them on a delay and do something at the end:
		var fo = dojo.query(".zork").fadeOut();
		dojo.connect(fo, "onEnd", function(){ /*...*/ });
		fo.play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateProperty" scope="prototype">
        <summary>see dojo.animateProperty(). Animate all elements of this
	NodeList across the properties specified.</summary>
        <examples>
          <example>	dojo.query(".zork").animateProperty({
			duration: 500,
			properties: {
				color:		{ start: "black", end: "white" },
				left:		{ end: 300 }
			}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="anim" scope="prototype">
        <summary>Animate one or more CSS properties for all nodes in this list.
	The returned animation object will already be playing when it
	is returned. See the docs for &lt;code&gt;dojo.anim&lt;/code&gt; for full details.</summary>
        <examples>
          <example>Another way to fade out:
		dojo.query(".thinger").anim({ opacity: 0 });</example>
          <example>animate all elements with the "thigner" class to a width of 500
	pixels over half a second
		dojo.query(".thinger").anim({ width: 500 }, 700);</example>
        </examples>
        <parameters>
          <parameter name="properties" type="Object" usage="required">
            <summary>the properties to animate</summary>
          </parameter>
          <parameter name="duration" type="Integer" usage="optional">
            <summary>Optional. The time to run the animations for</summary>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <summary>Optional. The easing function to use.</summary>
          </parameter>
          <parameter name="onEnd" type="Function" usage="optional">
            <summary>A function to be called when the animation ends</summary>
          </parameter>
          <parameter name="delay" type="Integer" usage="optional">
            <summary>how long to delay playing the returned animation</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="html" scope="prototype">
        <summary>see the information for &amp;quot;innerHTML&amp;quot;. &amp;quot;html&amp;quot; is an alias for &amp;quot;innerHTML&amp;quot;, but is
	only defined if dojo.NodeList-html has not been loaded.</summary>
        <description>An alias for the "innerHTML" method, but only defined if there is not an existing
	"html" method on dojo.NodeList. Be careful if you are working in an environment
	where it is possible that dojo.NodeList-html could have been loaded, since its
	definition of "html" will take precedence. If you are not sure if dojo.NodeList-html
	could be loaded, use the "innerHTML" method.</description>
        <return-description>if no value is passed, the result is String, the innerHTML of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <examples>
          <example> dojo.query(".thingList").html("&lt;li dojoType='dojo.dnd.Moveable'&gt;1&lt;/li&gt;&lt;li dojoType='dojo.dnd.Moveable'&gt;2&lt;/li&gt;&lt;li dojoType='dojo.dnd.Moveable'&gt;3&lt;/li&gt;",
	 {
	 	parseContent: true,
	 	onBegin: function(){
	 		this.content = this.content.replace(/([0-9])/g, this.id + ": $1");
	 		this.inherited("onBegin", arguments);
	 	}
	 }).removeClass("notdone").addClass("done");</example>
        </examples>
        <parameters>
          <parameter name="content" type="" usage="required"/>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="innerHTML" scope="prototype">
        <summary>allows setting the innerHTML of each node in the NodeList,
	if there is a value passed in, otherwise, reads the innerHTML value of the first node.</summary>
        <description>This method is simpler than the dojo.NodeList.html() method provided by
	`dojo.NodeList-html`. This method just does proper innerHTML insertion of HTML fragments,
	and it allows for the innerHTML to be read for the first node in the node list.
	Since dojo.NodeList-html already took the "html" name, this method is called
	"innerHTML". However, if dojo.NodeList-html has not been loaded yet, this
	module will define an "html" method that can be used instead. Be careful if you
	are working in an environment where it is possible that dojo.NodeList-html could
	have been loaded, since its definition of "html" will take precedence.
	The nodes represented by the value argument will be cloned if more than one
	node is in this NodeList. The nodes in this NodeList are returned in the "set"
	usage of this method, not the HTML that was inserted.</description>
        <return-description>if no value is passed, the result is String, the innerHTML of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;/div&gt;
	This code inserts &lt;p&gt;Hello World&lt;/p&gt; into both divs:
		dojo.query("div").innerHTML("&lt;p&gt;Hello World&lt;/p&gt;");</example>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	This code returns "&lt;p&gt;Hello Mars&lt;/p&gt;":
		var message = dojo.query("div").innerHTML();</example>
        </examples>
        <parameters>
          <parameter name="value" type="String||DOMNode|NodeList" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="text" scope="prototype">
        <summary>allows setting the text value of each node in the NodeList,
	if there is a value passed in, otherwise, returns the text value for all the
	nodes in the NodeList in one string.</summary>
        <return-description>if no value is passed, the result is String, the text value of the first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;/div&gt;
	This code inserts "Hello World" into both divs:
		dojo.query("div").text("Hello World");</example>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars &lt;span&gt;today&lt;/span&gt;&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	This code returns "Hello Mars today":
		var message = dojo.query("div").text();</example>
        </examples>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="append" scope="prototype">
        <summary>appends the content to every node in the NodeList.</summary>
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").append("&lt;span&gt;append&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;span&gt;append&lt;/span&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;span&gt;append&lt;/span&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String||DOMNode||NodeList" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="appendTo" scope="prototype">
        <summary>appends nodes in this NodeList to the nodes matched by
	the query passed to appendTo.</summary>
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;append&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").appendTo("p");
	Results in this DOM structure:
		&lt;p&gt;Hello Mars&lt;span&gt;append&lt;/span&gt;&lt;/p&gt;
		&lt;p&gt;Hello World&lt;span&gt;append&lt;/span&gt;&lt;/p&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="prepend" scope="prototype">
        <summary>prepends the content to every node in the NodeList.</summary>
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.
	assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").prepend("&lt;span&gt;prepend&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;span&gt;prepend&lt;/span&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;span&gt;prepend&lt;/span&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;</return-description>
        <parameters>
          <parameter name="content" type="String||DOMNode||NodeList" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="prependTo" scope="prototype">
        <summary>prepends nodes in this NodeList to the nodes matched by
	the query passed to prependTo.</summary>
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;prepend&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").prependTo("p");
	Results in this DOM structure:
		&lt;p&gt;&lt;span&gt;prepend&lt;/span&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;&lt;span&gt;prepend&lt;/span&gt;Hello World&lt;/p&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="after" scope="prototype">
        <summary>Places the content after every node in the NodeList.</summary>
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").after("&lt;span&gt;after&lt;/span&gt;");
	Results in this DOM structure:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;&lt;span&gt;after&lt;/span&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;&lt;span&gt;after&lt;/span&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String||Element||NodeList" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="insertAfter" scope="prototype">
        <summary>The nodes in this NodeList will be placed after the nodes
	matched by the query passed to insertAfter.</summary>
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;after&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").insertAfter("p");
	Results in this DOM structure:
		&lt;p&gt;Hello Mars&lt;/p&gt;&lt;span&gt;after&lt;/span&gt;
		&lt;p&gt;Hello World&lt;/p&gt;&lt;span&gt;after&lt;/span&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="before" scope="prototype">
        <summary>Places the content before every node in the NodeList.</summary>
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the appended content.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;
	Running this code:
		dojo.query("div").before("&lt;span&gt;before&lt;/span&gt;");
	Results in this DOM structure:
		&lt;span&gt;before&lt;/span&gt;&lt;div id="foo"&gt;&lt;p&gt;Hello Mars&lt;/p&gt;&lt;/div&gt;
		&lt;span&gt;before&lt;/span&gt;&lt;div id="bar"&gt;&lt;p&gt;Hello World&lt;/p&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String||DOMNode||NodeList" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="insertBefore" scope="prototype">
        <summary>The nodes in this NodeList will be placed after the nodes
	matched by the query passed to insertAfter.</summary>
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>dojo.NodeList, the nodes currently in this NodeList will be returned,
	not the matched nodes from the query.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;span&gt;before&lt;/span&gt;
		&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;p&gt;Hello World&lt;/p&gt;
	Running this code:
		dojo.query("span").insertBefore("p");
	Results in this DOM structure:
		&lt;span&gt;before&lt;/span&gt;&lt;p&gt;Hello Mars&lt;/p&gt;
		&lt;span&gt;before&lt;/span&gt;&lt;p&gt;Hello World&lt;/p&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="remove" scope="prototype">
        <summary>alias for dojo.NodeList's orphan method. Removes elements
	in this list that match the simple filter from their parents
	and returns them as a new NodeList.</summary>
        <return-description>dojo.NodeList</return-description>
        <parameters>
          <parameter name="simpleFilter" type="String" usage="required">
            <summary>single-expression CSS rule. For example, &amp;quot;.thinger&amp;quot; or
	&amp;quot;#someId[attrName='value']&amp;quot; but not &amp;quot;div &amp;gt; span&amp;quot;. In short,
	anything which does not invoke a descent to evaluate but
	can instead be used to test a single node is acceptable.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrap" scope="prototype">
        <summary>Wrap each node in the NodeList with html passed to wrap.</summary>
        <description>html will be cloned if the NodeList has more than one
	element. Only DOM nodes are cloned, not any attached
	event handlers.</description>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;b&gt;one&lt;/b&gt;
		&lt;b&gt;two&lt;/b&gt;
	Running this code:
		dojo.query("b").wrap("&lt;div&gt;&lt;span&gt;&lt;/span&gt;&lt;/div&gt;");
	Results in this DOM structure:
		&lt;div&gt;&lt;span&gt;&lt;b&gt;one&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;
		&lt;div&gt;&lt;span&gt;&lt;b&gt;two&lt;/b&gt;&lt;/span&gt;&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="html" type="String||DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrapAll" scope="prototype">
        <summary>Insert html where the first node in this NodeList lives, then place all
	nodes in this NodeList as the child of the html.</summary>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").wrapAll('&lt;div class="allRed"&gt;&lt;/div&gt;');
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="allRed"&gt;
				&lt;div class="red"&gt;Red One&lt;/div&gt;
				&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="html" type="String||DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="wrapInner" scope="prototype">
        <summary>For each node in the NodeList, wrap all its children with the passed in html.</summary>
        <description>html will be cloned if the NodeList has more than one
	element. Only DOM nodes are cloned, not any attached
	event handlers.</description>
        <return-description>dojo.NodeList, the nodes in the current NodeList will be returned,
	not the nodes from html argument.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").wrapInner('&lt;span class="special"&gt;&lt;/span&gt;');
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;&lt;span class="special"&gt;Red One&lt;/span&gt;&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;&lt;span class="special"&gt;Red Two&lt;/span&gt;&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="html" type="String||DOMNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="replaceWith" scope="prototype">
        <summary>Replaces each node in ths NodeList with the content passed to replaceWith.</summary>
        <description>The content will be cloned if the length of NodeList
	is greater than 1. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>The nodes currently in this NodeList will be returned, not the replacing content.
	Note that the returned nodes have been removed from the DOM.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").replaceWith('&lt;div class="green"&gt;Green&lt;/div&gt;');
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="green"&gt;Green&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="green"&gt;Green&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="content" type="String||DOMNode||NodeList" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="replaceAll" scope="prototype">
        <summary>replaces nodes matched by the query passed to replaceAll with the nodes
	in this NodeList.</summary>
        <description>The nodes in this NodeList will be cloned if the query
	matches more than one element. Only the DOM nodes are cloned, not
	any attached event handlers.</description>
        <return-description>The nodes currently in this NodeList will be returned, not the matched nodes
	from the query. The nodes currently in this NodeLIst could have
	been cloned, so the returned NodeList will include the cloned nodes.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").replaceAll(".blue");
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="spacer"&gt;___&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="clone" scope="prototype">
        <summary>Clones all the nodes in this NodeList and returns them as a new NodeList.</summary>
        <description>Only the DOM nodes are cloned, not any attached event handlers.</description>
        <return-description>dojo.NodeList, a cloned set of the original nodes.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").clone().appendTo(".container");
	Results in this DOM structure:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
		&lt;/div&gt;</example>
        </examples>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_buildArrayFromCallback" scope="prototype">
        <summary>builds a new array of possibly differing size based on the input list.
	Since the returned array is likely of different size than the input array,
	the array's map function cannot be used.</summary>
        <parameters>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_filterQueryResult" scope="prototype">
        <parameters>
          <parameter name="nodeList" type="" usage="required"/>
          <parameter name="query" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getUniqueAsNodeList" scope="prototype">
        <summary>given a list of nodes, make sure only unique
	elements are returned as our NodeList object.
	Does not call _stash().</summary>
        <parameters>
          <parameter name="nodes" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_getUniqueNodeListWithParent" scope="prototype">
        <summary>gets unique element nodes, filters them further
	with an optional query and then calls _stash to track parent NodeList.</summary>
        <parameters>
          <parameter name="nodes" type="" usage="required"/>
          <parameter name="query" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_getRelatedUniqueNodes" scope="prototype">
        <summary>cycles over all the nodes and calls a callback
	to collect nodes for a possible inclusion in a result.
	The callback will get two args: callback(node, ary),
	where ary is the array being used to collect the nodes.</summary>
        <parameters>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="children" scope="prototype">
        <summary>Returns all immediate child elements for nodes in this dojo.NodeList.
	Optionally takes a query to filter the child elements.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, all immediate child elements for the nodes in this dojo.NodeList.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".container").children();
	returns the four divs that are children of the container div.
	Running this code:
		dojo.query(".container").children(".red");
	returns the two divs that have the class "red".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <summary>a CSS selector.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="closest" scope="prototype">
        <summary>Returns closest parent that matches query, including current node in this
	dojo.NodeList if it matches the query.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, the closest parent that matches the query, including the current
	node in this dojo.NodeList if it matches the query.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".red").closest(".container");
	returns the div with class "container".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <summary>a CSS selector.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="To make rhino strict checking happy."/>
        </return-types>
      </method>
      <method name="parent" scope="prototype">
        <summary>Returns immediate parent elements for nodes in this dojo.NodeList.
	Optionally takes a query to filter the parent elements.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, immediate parent elements for nodes in this dojo.NodeList.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;&lt;span class="text"&gt;Blue One&lt;/span&gt;&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;&lt;span class="text"&gt;Blue Two&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".text").parent();
	returns the two divs with class "blue".
	Running this code:
		dojo.query(".text").parent(".first");
	returns the one div with class "blue" and "first".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <summary>a CSS selector.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="parents" scope="prototype">
        <summary>Returns all parent elements for nodes in this dojo.NodeList.
	Optionally takes a query to filter the child elements.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, all parent elements for nodes in this dojo.NodeList.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;&lt;span class="text"&gt;Blue One&lt;/span&gt;&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;&lt;span class="text"&gt;Blue Two&lt;/span&gt;&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".text").parents();
	returns the two divs with class "blue", the div with class "container",
		the body element and the html element.
	Running this code:
		dojo.query(".text").parents(".container");
	returns the one div with class "container".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <summary>a CSS selector.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="siblings" scope="prototype">
        <summary>Returns all sibling elements for nodes in this dojo.NodeList.
	Optionally takes a query to filter the sibling elements.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, all sibling elements for nodes in this dojo.NodeList.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").siblings();
	returns the two divs with class "red" and the other div
		with class "blue" that does not have "first".
	Running this code:
		dojo.query(".first").siblings(".red");
	returns the two div with class "red".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <summary>a CSS selector.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="next" scope="prototype">
        <summary>Returns the next element for nodes in this dojo.NodeList.
	Optionally takes a query to filter the next elements.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, the next element for nodes in this dojo.NodeList.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue last"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").next();
	returns the div with class "red" and has innerHTML of "Red Two".
	Running this code:
		dojo.query(".last").next(".red");
	does not return any elements.</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <summary>a CSS selector.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="nextAll" scope="prototype">
        <summary>Returns all sibling elements that come after the nodes in this dojo.NodeList.
	Optionally takes a query to filter the sibling elements.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, all sibling elements that come after the nodes in this dojo.NodeList.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red next"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue next"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").nextAll();
	returns the two divs with class of "next".
	Running this code:
		dojo.query(".first").nextAll(".red");
	returns the one div with class "red" and innerHTML "Red Two".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <summary>a CSS selector.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="prev" scope="prototype">
        <summary>Returns the previous element for nodes in this dojo.NodeList.
	Optionally takes a query to filter the previous elements.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, the previous element for nodes in this dojo.NodeList.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".first").prev();
	returns the div with class "red" and has innerHTML of "Red One".
	Running this code:
		dojo.query(".first").prev(".blue");
	does not return any elements.</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <summary>a CSS selector.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="prevAll" scope="prototype">
        <summary>Returns all sibling elements that come before the nodes in this dojo.NodeList.
	Optionally takes a query to filter the sibling elements.</summary>
        <description>The returned nodes will be in reverse DOM order -- the first node in the list will
	be the node closest to the original node/NodeList.
	.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, all sibling elements that come before the nodes in this dojo.NodeList.</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red prev"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue prev"&gt;Blue One&lt;/div&gt;
			&lt;div class="red second"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".second").prevAll();
	returns the two divs with class of "prev".
	Running this code:
		dojo.query(".first").prevAll(".red");
	returns the one div with class "red prev" and innerHTML "Red One".</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="optional">
            <summary>a CSS selector.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="andSelf" scope="prototype">
        <summary>Adds the nodes from the previous dojo.NodeList to the current dojo.NodeList.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red prev"&gt;Red One&lt;/div&gt;
			Some Text
			&lt;div class="blue prev"&gt;Blue One&lt;/div&gt;
			&lt;div class="red second"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".second").prevAll().andSelf();
	returns the two divs with class of "prev", as well as the div with class "second".</example>
        </examples>
      </method>
      <method name="first" scope="prototype">
        <summary>Returns the first node in this dojo.NodeList as a dojo.NodeList.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, with the first node in this dojo.NodeList</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue last"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".blue").first();
	returns the div with class "blue" and "first".</example>
        </examples>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="last" scope="prototype">
        <summary>Returns the last node in this dojo.NodeList as a dojo.NodeList.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, with the last node in this dojo.NodeList</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="red"&gt;Red One&lt;/div&gt;
			&lt;div class="blue first"&gt;Blue One&lt;/div&gt;
			&lt;div class="red"&gt;Red Two&lt;/div&gt;
			&lt;div class="blue last"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".blue").last();
	returns the last div with class "blue",</example>
        </examples>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="even" scope="prototype">
        <summary>Returns the even nodes in this dojo.NodeList as a dojo.NodeList.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, with the even nodes in this dojo.NodeList</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="interior red"&gt;Red One&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="interior red"&gt;Red Two&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".interior").even();
	returns the two divs with class "blue"</example>
        </examples>
      </method>
      <method name="odd" scope="prototype">
        <summary>Returns the odd nodes in this dojo.NodeList as a dojo.NodeList.</summary>
        <description>.end() can be used on the returned dojo.NodeList to get back to the
	original dojo.NodeList.</description>
        <return-description>dojo.NodeList, with the odd nodes in this dojo.NodeList</return-description>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div class="container"&gt;
			&lt;div class="interior red"&gt;Red One&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue One&lt;/div&gt;
			&lt;div class="interior red"&gt;Red Two&lt;/div&gt;
			&lt;div class="interior blue"&gt;Blue Two&lt;/div&gt;
		&lt;/div&gt;
	Running this code:
		dojo.query(".interior").odd();
	returns the two divs with class "red"</example>
        </examples>
      </method>
      <method name="_normalize" scope="prototype">
        <summary>normalizes data to an array of items to insert.</summary>
        <description>If content is an object, it can have special properties "template" and
	"parse". If "template" is defined, then the template value is run through
	dojo.string.substitute (if dojo.string.substitute has been dojo.required elsewhere),
	or if templateFunc is a function on the content, that function will be used to
	transform the template into a final string to be used for for passing to dojo._toDom.
	If content.parse is true, then it is remembered for later, for when the content
	nodes are inserted into the DOM. At that point, the nodes will be parsed for widgets
	(if dojo.parser has been dojo.required elsewhere).</description>
        <parameters>
          <parameter name="content" type="String||Element||Object||NodeList" usage="required"/>
          <parameter name="refNode" type="DOMNode" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_cloneNode" scope="prototype">
        <summary>private utiltity to clone a node. Not very interesting in the vanilla
	dojo.NodeList case, but delegates could do interesting things like
	clone event handlers if that is derivable from the node.</summary>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
        </parameters>
      </method>
      <method name="_place" scope="prototype">
        <summary>private utility to handle placing an array of nodes relative to another node.</summary>
        <description>Allows for cloning the nodes in the array, and for
	optionally parsing widgets, if ary._runParse is true.</description>
        <parameters>
          <parameter name="ary" type="Array" usage="required"/>
          <parameter name="refNode" type="DOMNode" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
          <parameter name="useClone" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="end" scope="prototype">
        <summary>Ends use of the current &lt;code&gt;dojo.NodeList&lt;/code&gt; by returning the previous dojo.NodeList
	that generated the current dojo.NodeList.</summary>
        <description>Returns the `dojo.NodeList` that generated the current `dojo.NodeList`. If there
	is no parent dojo.NodeList, an empty dojo.NodeList is returned.</description>
        <examples>
          <example>	dojo.query("a")
			.filter(".disabled")
				// operate on the anchors that only have a disabled class
				.style("color", "grey")
			.end()
			// jump back to the list of anchors
			.style(...)</example>
        </examples>
      </method>
      <method name="slice" scope="prototype">
        <summary>Returns a new NodeList, maintaining this one in place</summary>
        <description>This method behaves exactly like the Array.slice method
	with the caveat that it returns a dojo.NodeList and not a
	raw Array. For more details, see Mozilla's (slice
	documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:slice]</description>
        <parameters>
          <parameter name="begin" type="Integer" usage="required">
            <summary>Can be a positive or negative integer, with positive
	integers noting the offset to begin at, and negative
	integers denoting an offset from the end (i.e., to the left
	of the end)</summary>
          </parameter>
          <parameter name="end" type="Integer" usage="optional">
            <summary>Optional parameter to describe what position relative to
	the NodeList's zero index to end the slice at. Like begin,
	can be positive or negative.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="splice" scope="prototype">
        <summary>Returns a new NodeList, manipulating this NodeList based on
	the arguments passed, potentially splicing in new elements
	at an offset, optionally deleting elements</summary>
        <description>This method behaves exactly like the Array.splice method
	with the caveat that it returns a dojo.NodeList and not a
	raw Array. For more details, see Mozilla's (splice
	documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:splice]
	For backwards compatibility, calling .end() on the spliced NodeList
	does not return the original NodeList -- splice alters the NodeList in place.</description>
        <return-description>dojo.NodeList</return-description>
        <parameters>
          <parameter name="index" type="Integer" usage="required">
            <summary>begin can be a positive or negative integer, with positive
	integers noting the offset to begin at, and negative
	integers denoting an offset from the end (i.e., to the left
	of the end)</summary>
          </parameter>
          <parameter name="howmany" type="Integer" usage="optional">
            <summary>Optional parameter to describe what position relative to
	the NodeList's zero index to end the slice at. Like begin,
	can be positive or negative.</summary>
          </parameter>
          <parameter name="item" type="Object" usage="optional">
            <summary>Any number of optional parameters may be passed in to be
	spliced into the NodeList</summary>
          </parameter>
        </parameters>
      </method>
      <method name="indexOf" scope="prototype">
        <summary>see dojo.indexOf(). The primary difference is that the acted-on
	array is implicitly this NodeList</summary>
        <description>For more details on the behavior of indexOf, see Mozilla's
	(indexOf
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:indexOf]</description>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <parameters>
          <parameter name="value" type="Object:" usage="required">
            <summary>The value to search for.</summary>
          </parameter>
          <parameter name="fromIndex" type="Integer:" usage="optional">
            <summary>The loction to start searching from. Optional. Defaults to 0.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="lastIndexOf" scope="prototype">
        <summary>see dojo.lastIndexOf(). The primary difference is that the
	acted-on array is implicitly this NodeList</summary>
        <description>For more details on the behavior of lastIndexOf, see
	Mozilla's (lastIndexOf
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:lastIndexOf]</description>
        <return-description>Positive Integer or 0 for a match, -1 of not found.</return-description>
        <parameters>
          <parameter name="value" type="Object" usage="required">
            <summary>The value to search for.</summary>
          </parameter>
          <parameter name="fromIndex" type="Integer" usage="optional">
            <summary>The loction to start searching from. Optional. Defaults to 0.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="every" scope="prototype">
        <summary>see &lt;code&gt;dojo.every()&lt;/code&gt; and the (Array.every
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:every].
	Takes the same structure of arguments and returns as
	dojo.every() with the caveat that the passed array is
	implicitly this NodeList</summary>
        <parameters>
          <parameter name="callback" type="Function:" usage="required">
            <summary>the callback</summary>
          </parameter>
          <parameter name="thisObject" type="Object:" usage="optional">
            <summary>the context</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="prototype">
        <summary>Takes the same structure of arguments and returns as
	&lt;code&gt;dojo.some()&lt;/code&gt; with the caveat that the passed array is
	implicitly this NodeList.  See &lt;code&gt;dojo.some()&lt;/code&gt; and Mozilla's
	(Array.some
	documentation)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:some].</summary>
        <parameters>
          <parameter name="callback" type="Function:" usage="required">
            <summary>the callback</summary>
          </parameter>
          <parameter name="thisObject" type="Object:" usage="optional">
            <summary>the context</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="concat" scope="prototype">
        <summary>Returns a new NodeList comprised of items in this NodeList
	as well as items passed in as parameters</summary>
        <description>This method behaves exactly like the Array.concat method
	with the caveat that it returns a `dojo.NodeList` and not a
	raw Array. For more details, see the (Array.concat
	docs)[http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:concat]</description>
        <return-description>dojo.NodeList</return-description>
        <parameters>
          <parameter name="item" type="Object" usage="optional">
            <summary>Any number of optional parameters may be passed in to be
	spliced into the NodeList</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="map" scope="prototype">
        <summary>see dojo.map(). The primary difference is that the acted-on
	array is implicitly this NodeList and the return is a
	dojo.NodeList (a subclass of Array)
	/return d.map(this, func, obj, d.NodeList); // dojo.NodeList</summary>
        <parameters>
          <parameter name="func" type="Function" usage="required"/>
          <parameter name="obj" type="Function" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="forEach" scope="prototype">
        <summary>see &lt;code&gt;dojo.forEach()&lt;/code&gt;. The primary difference is that the acted-on
	array is implicitly this NodeList. If you want the option to break out
	of the forEach loop, use every() or some() instead.</summary>
        <parameters>
          <parameter name="callback" type="" usage="required"/>
          <parameter name="thisObj" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="coords" scope="prototype">
        <summary>Returns the box objects of all elements in a node list as
	an Array (*not* a NodeList). Acts like &lt;code&gt;dojo.coords&lt;/code&gt;, though assumes
	the node passed is each node in this list.</summary>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="position" scope="prototype">
        <summary>Returns border-box objects (x/y/w/h) of all elements in a node list
	as an Array (*not* a NodeList). Acts like &lt;code&gt;dojo.position&lt;/code&gt;, though
	assumes the node passed is each node in this list.</summary>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="addClass" scope="prototype">
        <summary>adds the specified class to every node in the list</summary>
        <parameters>
          <parameter name="className" type="String|Array" usage="required">
            <summary>A String class name to add, or several space-separated class names,
	or an array of class names.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="removeClass" scope="prototype">
        <summary>removes the specified class from every node in the list</summary>
        <return-description>dojo.NodeList, this list</return-description>
        <parameters>
          <parameter name="className" type="String|Array" usage="optional">
            <summary>An optional String class name to remove, or several space-separated
	class names, or an array of class names. If omitted, all class names
	will be deleted.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="toggleClass" scope="prototype">
        <summary>Adds a class to node if not present, or removes if present.
	Pass a boolean condition if you want to explicitly add or remove.</summary>
        <parameters>
          <parameter name="className" type="String" usage="required">
            <summary>the CSS class to add</summary>
          </parameter>
          <parameter name="condition" type="Boolean" usage="optional">
            <summary>If passed, true means to add the class, false means to remove.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="connect" scope="prototype">
        <summary>attach event handlers to every item of the NodeList. Uses dojo.connect()
	so event properties are normalized</summary>
        <examples>
          <example>add an onclick handler to every button on the page
		dojo.query("div:nth-child(odd)").connect("onclick", function(e){
			console.log("clicked!");
		});</example>
          <example>attach foo.bar() to every odd div's onmouseover
		dojo.query("div:nth-child(odd)").connect("onmouseover", foo, "bar");</example>
        </examples>
        <parameters>
          <parameter name="methodName" type="String" usage="required">
            <summary>the name of the method to attach to. For DOM events, this should be
	the lower-case name of the event</summary>
          </parameter>
          <parameter name="objOrFunc" type="Object|Function|String" usage="required">
            <summary>if 2 arguments are passed (methodName, objOrFunc), objOrFunc should
	reference a function or be the name of the function in the global
	namespace to attach. If 3 arguments are provided
	(methodName, objOrFunc, funcName), objOrFunc must be the scope to
	locate the bound function in</summary>
          </parameter>
          <parameter name="funcName" type="String" usage="optional">
            <summary>optional. A string naming the function in objOrFunc to bind to the
	event. May also be a function reference.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="empty" scope="prototype">
        <summary>clears all content from each node in the list. Effectively
	equivalent to removing all child nodes from every item in
	the list.</summary>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="place" scope="prototype">
        <summary>places elements of this node list relative to the first element matched
	by queryOrNode. Returns the original NodeList. See: &lt;code&gt;dojo.place&lt;/code&gt;</summary>
        <parameters>
          <parameter name="queryOrNode" type="String||Node" usage="required">
            <summary>may be a string representing any valid CSS3 selector or a DOM node.
	In the selector case, only the first matching element will be used
	for relative positioning.</summary>
          </parameter>
          <parameter name="position" type="String" usage="required">
            <summary>can be one of:
		&amp;quot;last&amp;quot; (default)
		&amp;quot;first&amp;quot;
		&amp;quot;before&amp;quot;
		&amp;quot;after&amp;quot;
		&amp;quot;only&amp;quot;
		&amp;quot;replace&amp;quot;
	or an offset in the childNodes property</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="orphan" scope="prototype">
        <summary>removes elements in this list that match the simple filter
	from their parents and returns them as a new NodeList.</summary>
        <return-description>`dojo.NodeList` containing the orpahned elements</return-description>
        <parameters>
          <parameter name="simpleFilter" type="String" usage="optional">
            <summary>single-expression CSS rule. For example, &amp;quot;.thinger&amp;quot; or
	&amp;quot;#someId[attrName='value']&amp;quot; but not &amp;quot;div &amp;gt; span&amp;quot;. In short,
	anything which does not invoke a descent to evaluate but
	can instead be used to test a single node is acceptable.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="adopt" scope="prototype">
        <summary>places any/all elements in queryOrListOrNode at a
	position relative to the first element in this list.
	Returns a dojo.NodeList of the adopted elements.</summary>
        <parameters>
          <parameter name="queryOrListOrNode" type="String||Array||DomNode" usage="required">
            <summary>a DOM node or a query string or a query result.
	Represents the nodes to be adopted relative to the
	first element of this NodeList.</summary>
          </parameter>
          <parameter name="position" type="String" usage="optional">
            <summary>can be one of:
		&amp;quot;last&amp;quot; (default)
		&amp;quot;first&amp;quot;
		&amp;quot;before&amp;quot;
		&amp;quot;after&amp;quot;
		&amp;quot;only&amp;quot;
		&amp;quot;replace&amp;quot;
	or an offset in the childNodes property</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="query" scope="prototype">
        <summary>Returns a new list whose memebers match the passed query,
	assuming elements of the current NodeList as the root for
	each search.</summary>
        <examples>
          <example>assume a DOM created by this markup:
		&lt;div id="foo"&gt;
			&lt;p&gt;
				bacon is tasty, &lt;span&gt;dontcha think?&lt;/span&gt;
			&lt;/p&gt;
		&lt;/div&gt;
		&lt;div id="bar"&gt;
			&lt;p&gt;great commedians may not be funny &lt;span&gt;in person&lt;/span&gt;&lt;/p&gt;
		&lt;/div&gt;
	If we are presented with the following defintion for a NodeList:
		var l = new dojo.NodeList(dojo.byId("foo"), dojo.byId("bar"));
	it's possible to find all span elements under paragraphs
	contained by these elements with this sub-query:
	 	var spans = l.query("p span");</example>
        </examples>
        <parameters>
          <parameter name="queryStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="filter" scope="prototype">
        <summary>&amp;quot;masks&amp;quot; the built-in javascript filter() method (supported
	in Dojo via &lt;code&gt;dojo.filter&lt;/code&gt;) to support passing a simple
	string filter in addition to supporting filtering function
	objects.</summary>
        <examples>
          <example>"regular" JS filter syntax as exposed in dojo.filter:
		dojo.query("*").filter(function(item){
			// highlight every paragraph
			return (item.nodeName == "p");
		}).style("backgroundColor", "yellow");</example>
          <example>the same filtering using a CSS selector
		dojo.query("*").filter("p").styles("backgroundColor", "yellow");</example>
        </examples>
        <parameters>
          <parameter name="simpleFilter" type="String|Function" usage="required">
            <summary>If a string, a single-expression CSS rule. For example,
	&amp;quot;.thinger&amp;quot; or &amp;quot;#someId[attrName='value']&amp;quot; but not &amp;quot;div &amp;gt;
	span&amp;quot;. In short, anything which does not invoke a descent
	to evaluate but can instead be used to test a single node
	is acceptable.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="instantiate" scope="prototype">
        <summary>Create a new instance of a specified class, using the
	specified properties and each node in the nodeList as a
	srcNodeRef.</summary>
        <examples>
          <example>Grabs all buttons in the page and converts them to diji.form.Buttons.
		var buttons = dojo.query("button").instantiate("dijit.form.Button", {showLabel: true});</example>
        </examples>
        <parameters>
          <parameter name="declaredClass" type="String|Object" usage="required"/>
          <parameter name="properties" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="at" scope="prototype">
        <summary>Returns a new NodeList comprised of items in this NodeList
	at the given index or indices.</summary>
        <return-description>dojo.NodeList</return-description>
        <parameters>
          <parameter name="index" type="Integer" usage="one-or-more">
            <summary>One or more 0-based indices of items in the current
	NodeList.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="dtl" scope="prototype">
        <parameters>
          <parameter name="template" type="dojox.dtl.__StringArgs|String" usage="required">
            <summary>The template string or location</summary>
          </parameter>
          <parameter name="context" type="dojox.dtl.__ObjectArgs|Object" usage="required">
            <summary>The context object or location</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addClassFx" scope="prototype">
        <summary>Animate the effects of adding a class to all nodes in this list.
	see &lt;code&gt;dojox.fx.addClass&lt;/code&gt;</summary>
        <examples>
          <example>	// fade all elements with class "bar" to to 50% opacity
		dojo.query(".bar").addClassFx("bar").play();</example>
        </examples>
        <parameters>
          <parameter name="cssClass" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="removeClassFx" scope="prototype">
        <summary>Animate the effect of removing a class to all nodes in this list.
	see &lt;code&gt;dojox.fx.removeClass&lt;/code&gt;</summary>
        <examples>
          <example> dojo.query(".box").removeClassFx("bar").play();</example>
        </examples>
        <parameters>
          <parameter name="cssClass" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="toggleClassFx" scope="prototype">
        <summary>Animate the effect of adding or removing a class to all nodes in this list.
	see &lt;code&gt;dojox.fx.toggleClass&lt;/code&gt;</summary>
        <examples>
          <example> dojo.query(".box").toggleClass("bar").play();</example>
        </examples>
        <parameters>
          <parameter name="cssClass" type="" usage="required"/>
          <parameter name="force" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="sizeTo" scope="prototype">
        <summary>size all elements of this NodeList. Returns an instance of dojo.Animation</summary>
        <examples>
          <example>	// size all divs with class "blah"
		dojo.query("div.blah").sizeTo({
			width:50,
			height:50
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideBy" scope="prototype">
        <summary>slide all elements of this NodeList. Returns an instance of dojo.Animation</summary>
        <examples>
          <example>	// slide all tables with class "blah" 10 px
		dojo.query("table.blah").slideBy({ top:10, left:10 }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="highlight" scope="prototype">
        <summary>highlight all elements of the node list.
	Returns an instance of dojo.Animation</summary>
        <examples>
          <example>	// highlight all links with class "foo"
		dojo.query("a.foo").hightlight().play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="fadeTo" scope="prototype">
        <summary>fade all elements of the node list to a specified opacity</summary>
        <examples>
          <example>	// fade all elements with class "bar" to to 50% opacity
		dojo.query(".bar").fadeTo({ end: 0.5 }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="wipeTo" scope="prototype">
        <summary>Wipe all elements of the NodeList to a specified width: or height:</summary>
        <examples>
          <example> dojo.query(".box").wipeTo({ width: 300px }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.NodeList._placeMultiple" type="Function" classlike="true" private="true">
    <summary>private method for inserting queried nodes into all nodes in this NodeList
	at different positions. Differs from NodeList.place because it will clone
	the nodes in this NodeList if the query matches more than one element.</summary>
    <properties>
      <property name="length" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="query" type="String||Node||NodeList" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.NodeList.val" type="Function" classlike="true">
    <summary>If a value is passed, allows seting the value property of form elements in this
	NodeList, or properly selecting/checking the right value for radio/checkbox/select
	elements. If no value is passed, the value of the first node in this NodeList
	is returned.</summary>
    <examples>
      <example>assume a DOM created by this markup:
		&lt;input type="text" value="foo"&gt;
		&lt;select multiple&gt;
			&lt;option value="red" selected&gt;Red&lt;/option&gt;
			&lt;option value="blue"&gt;Blue&lt;/option&gt;
			&lt;option value="yellow" selected&gt;Yellow&lt;/option&gt;
		&lt;/select&gt;
	This code gets and sets the values for the form fields above:
		dojo.query('[type="text"]').val(); //gets value foo
		dojo.query('[type="text"]').val("bar"); //sets the input's value to "bar"
		dojo.query("select").val() //gets array value ["red", "yellow"]
		dojo.query("select").val(["blue", "yellow"]) //Sets the blue and yellow options to selected.</example>
    </examples>
    <methods>
      <method constructor="constructor">
        <return-description>if no value is passed, the result is String or an Array, for the value of the
	first node.
	If a value is passed, the return is this dojo.NodeList</return-description>
        <parameters>
          <parameter name="value" type="String||Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
          <return-type type="String"/>
          <return-type type=""/>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.NodeList.val.0" type="">
    <properties>
      <property name="type" scope="instance" type=""/>
      <property name="options" scope="instance" type=""/>
      <property name="checked" scope="instance" type="bool"/>
      <property name="value" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojo.NodeList.prototype" type="">
    <properties>
      <property name="remove" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojo.Color" type="Function" classlike="true">
    <summary>Takes a named string, hex string, array of rgb or rgba values,
	an object with r, g, b, and a properties, or another &lt;code&gt;dojo.Color&lt;/code&gt; object
	and creates a new Color instance to work from.</summary>
    <examples>
      <example>Work with a Color instance:
	 var c = new dojo.Color();
	 c.setColor([0,0,0]); // black
	 var hex = c.toHex(); // #000000</example>
      <example>Work with a node's color:
	 var color = dojo.style("someNode", "backgroundColor");
	 var n = new dojo.Color(color);
	 // adjust the color some
	 n.r *= .5;
	 console.log(n.toString()); // rgb(128, 255, 255);</example>
    </examples>
    <properties>
      <property name="r" scope="prototype" type="Number"/>
      <property name="g" scope="prototype" type="Number"/>
      <property name="b" scope="prototype" type="Number"/>
      <property name="a" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="color" type="Array|String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="prototype">
        <parameters>
          <parameter name="r" type="" usage="required"/>
          <parameter name="g" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
          <parameter name="a" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setColor" scope="prototype">
        <summary>Takes a named string, hex string, array of rgb or rgba values,
	an object with r, g, b, and a properties, or another &lt;code&gt;dojo.Color&lt;/code&gt; object
	and sets this color instance to that value.</summary>
        <examples>
          <example>	var c = new dojo.Color(); // no color
		c.setColor("#ededed"); // greyish</example>
        </examples>
        <parameters>
          <parameter name="color" type="Array|String|Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="sanitize" scope="prototype">
        <summary>makes sure that the object has correct attributes</summary>
        <description>the default implementation does nothing, include dojo.colors to
	augment it with real checks</description>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="toRgb" scope="prototype">
        <summary>Returns 3 component array of rgb values</summary>
        <examples>
          <example>	var c = new dojo.Color("#000000");
	 	console.log(c.toRgb()); // [0,0,0]</example>
        </examples>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="toRgba" scope="prototype">
        <summary>Returns a 4 component array of rgba values from the color
	represented by this object.</summary>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="toHex" scope="prototype">
        <summary>Returns a CSS color string in hexadecimal representation</summary>
        <examples>
          <example> 	console.log(new dojo.Color([0,0,0]).toHex()); // #000000</example>
        </examples>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toCss" scope="prototype">
        <summary>Returns a css color string in rgb(a) representation</summary>
        <examples>
          <example>	var c = new dojo.Color("#FFF").toCss();
		console.log(c); // rgb('255','255','255')</example>
        </examples>
        <parameters>
          <parameter name="includeAlpha" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toString" scope="prototype">
        <summary>Returns a visual representation of the color</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.Color.named">
    <properties>
      <property name="black" scope="normal" type="Array"/>
      <property name="silver" scope="normal" type="Array"/>
      <property name="gray" scope="normal" type="Array"/>
      <property name="white" scope="normal" type="Array"/>
      <property name="maroon" scope="normal" type="Array"/>
      <property name="red" scope="normal" type="Array"/>
      <property name="purple" scope="normal" type="Array"/>
      <property name="fuchsia" scope="normal" type="Array"/>
      <property name="green" scope="normal" type="Array"/>
      <property name="lime" scope="normal" type="Array"/>
      <property name="olive" scope="normal" type="Array"/>
      <property name="yellow" scope="normal" type="Array"/>
      <property name="navy" scope="normal" type="Array"/>
      <property name="blue" scope="normal" type="Array"/>
      <property name="teal" scope="normal" type="Array"/>
      <property name="aqua" scope="normal" type="Array"/>
      <property name="transparent" scope="normal" type="Array"/>
      <property name="aliceblue" scope="normal" type="Array"/>
      <property name="antiquewhite" scope="normal" type="Array"/>
      <property name="aquamarine" scope="normal" type="Array"/>
      <property name="azure" scope="normal" type="Array"/>
      <property name="beige" scope="normal" type="Array"/>
      <property name="bisque" scope="normal" type="Array"/>
      <property name="blanchedalmond" scope="normal" type="Array"/>
      <property name="blueviolet" scope="normal" type="Array"/>
      <property name="brown" scope="normal" type="Array"/>
      <property name="burlywood" scope="normal" type="Array"/>
      <property name="cadetblue" scope="normal" type="Array"/>
      <property name="chartreuse" scope="normal" type="Array"/>
      <property name="chocolate" scope="normal" type="Array"/>
      <property name="coral" scope="normal" type="Array"/>
      <property name="cornflowerblue" scope="normal" type="Array"/>
      <property name="cornsilk" scope="normal" type="Array"/>
      <property name="crimson" scope="normal" type="Array"/>
      <property name="cyan" scope="normal" type="Array"/>
      <property name="darkblue" scope="normal" type="Array"/>
      <property name="darkcyan" scope="normal" type="Array"/>
      <property name="darkgoldenrod" scope="normal" type="Array"/>
      <property name="darkgray" scope="normal" type="Array"/>
      <property name="darkgreen" scope="normal" type="Array"/>
      <property name="darkgrey" scope="normal" type="Array"/>
      <property name="darkkhaki" scope="normal" type="Array"/>
      <property name="darkmagenta" scope="normal" type="Array"/>
      <property name="darkolivegreen" scope="normal" type="Array"/>
      <property name="darkorange" scope="normal" type="Array"/>
      <property name="darkorchid" scope="normal" type="Array"/>
      <property name="darkred" scope="normal" type="Array"/>
      <property name="darksalmon" scope="normal" type="Array"/>
      <property name="darkseagreen" scope="normal" type="Array"/>
      <property name="darkslateblue" scope="normal" type="Array"/>
      <property name="darkslategray" scope="normal" type="Array"/>
      <property name="darkslategrey" scope="normal" type="Array"/>
      <property name="darkturquoise" scope="normal" type="Array"/>
      <property name="darkviolet" scope="normal" type="Array"/>
      <property name="deeppink" scope="normal" type="Array"/>
      <property name="deepskyblue" scope="normal" type="Array"/>
      <property name="dimgray" scope="normal" type="Array"/>
      <property name="dimgrey" scope="normal" type="Array"/>
      <property name="dodgerblue" scope="normal" type="Array"/>
      <property name="firebrick" scope="normal" type="Array"/>
      <property name="floralwhite" scope="normal" type="Array"/>
      <property name="forestgreen" scope="normal" type="Array"/>
      <property name="gainsboro" scope="normal" type="Array"/>
      <property name="ghostwhite" scope="normal" type="Array"/>
      <property name="gold" scope="normal" type="Array"/>
      <property name="goldenrod" scope="normal" type="Array"/>
      <property name="greenyellow" scope="normal" type="Array"/>
      <property name="grey" scope="normal" type="Array"/>
      <property name="honeydew" scope="normal" type="Array"/>
      <property name="hotpink" scope="normal" type="Array"/>
      <property name="indianred" scope="normal" type="Array"/>
      <property name="indigo" scope="normal" type="Array"/>
      <property name="ivory" scope="normal" type="Array"/>
      <property name="khaki" scope="normal" type="Array"/>
      <property name="lavender" scope="normal" type="Array"/>
      <property name="lavenderblush" scope="normal" type="Array"/>
      <property name="lawngreen" scope="normal" type="Array"/>
      <property name="lemonchiffon" scope="normal" type="Array"/>
      <property name="lightblue" scope="normal" type="Array"/>
      <property name="lightcoral" scope="normal" type="Array"/>
      <property name="lightcyan" scope="normal" type="Array"/>
      <property name="lightgoldenrodyellow" scope="normal" type="Array"/>
      <property name="lightgray" scope="normal" type="Array"/>
      <property name="lightgreen" scope="normal" type="Array"/>
      <property name="lightgrey" scope="normal" type="Array"/>
      <property name="lightpink" scope="normal" type="Array"/>
      <property name="lightsalmon" scope="normal" type="Array"/>
      <property name="lightseagreen" scope="normal" type="Array"/>
      <property name="lightskyblue" scope="normal" type="Array"/>
      <property name="lightslategray" scope="normal" type="Array"/>
      <property name="lightslategrey" scope="normal" type="Array"/>
      <property name="lightsteelblue" scope="normal" type="Array"/>
      <property name="lightyellow" scope="normal" type="Array"/>
      <property name="limegreen" scope="normal" type="Array"/>
      <property name="linen" scope="normal" type="Array"/>
      <property name="magenta" scope="normal" type="Array"/>
      <property name="mediumaquamarine" scope="normal" type="Array"/>
      <property name="mediumblue" scope="normal" type="Array"/>
      <property name="mediumorchid" scope="normal" type="Array"/>
      <property name="mediumpurple" scope="normal" type="Array"/>
      <property name="mediumseagreen" scope="normal" type="Array"/>
      <property name="mediumslateblue" scope="normal" type="Array"/>
      <property name="mediumspringgreen" scope="normal" type="Array"/>
      <property name="mediumturquoise" scope="normal" type="Array"/>
      <property name="mediumvioletred" scope="normal" type="Array"/>
      <property name="midnightblue" scope="normal" type="Array"/>
      <property name="mintcream" scope="normal" type="Array"/>
      <property name="mistyrose" scope="normal" type="Array"/>
      <property name="moccasin" scope="normal" type="Array"/>
      <property name="navajowhite" scope="normal" type="Array"/>
      <property name="oldlace" scope="normal" type="Array"/>
      <property name="olivedrab" scope="normal" type="Array"/>
      <property name="orange" scope="normal" type="Array"/>
      <property name="orangered" scope="normal" type="Array"/>
      <property name="orchid" scope="normal" type="Array"/>
      <property name="palegoldenrod" scope="normal" type="Array"/>
      <property name="palegreen" scope="normal" type="Array"/>
      <property name="paleturquoise" scope="normal" type="Array"/>
      <property name="palevioletred" scope="normal" type="Array"/>
      <property name="papayawhip" scope="normal" type="Array"/>
      <property name="peachpuff" scope="normal" type="Array"/>
      <property name="peru" scope="normal" type="Array"/>
      <property name="pink" scope="normal" type="Array"/>
      <property name="plum" scope="normal" type="Array"/>
      <property name="powderblue" scope="normal" type="Array"/>
      <property name="rosybrown" scope="normal" type="Array"/>
      <property name="royalblue" scope="normal" type="Array"/>
      <property name="saddlebrown" scope="normal" type="Array"/>
      <property name="salmon" scope="normal" type="Array"/>
      <property name="sandybrown" scope="normal" type="Array"/>
      <property name="seagreen" scope="normal" type="Array"/>
      <property name="seashell" scope="normal" type="Array"/>
      <property name="sienna" scope="normal" type="Array"/>
      <property name="skyblue" scope="normal" type="Array"/>
      <property name="slateblue" scope="normal" type="Array"/>
      <property name="slategray" scope="normal" type="Array"/>
      <property name="slategrey" scope="normal" type="Array"/>
      <property name="snow" scope="normal" type="Array"/>
      <property name="springgreen" scope="normal" type="Array"/>
      <property name="steelblue" scope="normal" type="Array"/>
      <property name="tan" scope="normal" type="Array"/>
      <property name="thistle" scope="normal" type="Array"/>
      <property name="tomato" scope="normal" type="Array"/>
      <property name="turquoise" scope="normal" type="Array"/>
      <property name="violet" scope="normal" type="Array"/>
      <property name="wheat" scope="normal" type="Array"/>
      <property name="whitesmoke" scope="normal" type="Array"/>
      <property name="yellowgreen" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojo._base" private="true">
    <properties>
      <property name="Color" scope="normal" type="Object"/>
      <property name="Deferred" scope="normal" type="Object"/>
      <property name="NodeList" scope="normal" type="Object"/>
      <property name="array" scope="normal" type="Object"/>
      <property name="browser" scope="normal" type="Object"/>
      <property name="connect" scope="normal" type="Object"/>
      <property name="declare" scope="normal" type="Object"/>
      <property name="event" scope="normal" type="Object"/>
      <property name="fx" scope="normal" type="Object"/>
      <property name="html" scope="normal" type="Object"/>
      <property name="json" scope="normal" type="Object"/>
      <property name="lang" scope="normal" type="Object"/>
      <property name="query" scope="normal" type="Object"/>
      <property name="window" scope="normal" type="Object"/>
      <property name="xhr" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojo.Deferred" type="Function" classlike="true">
    <summary>Encapsulates a sequence of callbacks in response to a value that
	may not yet be available.  This is modeled after the Deferred class
	from Twisted &amp;lt;http://twistedmatrix.com&amp;gt;.</summary>
    <description>JavaScript has no threads, and even if it did, threads are hard.
	Deferreds are a way of abstracting non-blocking events, such as the
	final response to an XMLHttpRequest. Deferreds create a promise to
	return a response a some point in the future and an easy way to
	register your interest in receiving that response.
	The most important methods for Deffered users are:
	* addCallback(handler)
	* addErrback(handler)
	* callback(result)
	* errback(result)
	In general, when a function returns a Deferred, users then "fill
	in" the second half of the contract by registering callbacks and
	error handlers. You may register as many callback and errback
	handlers as you like and they will be executed in the order
	registered when a result is provided. Usually this result is
	provided as the result of an asynchronous operation. The code
	"managing" the Deferred (the code that made the promise to provide
	an answer later) will use the callback() and errback() methods to
	communicate with registered listeners about the result of the
	operation. At this time, all registered result handlers are called
	*with the most recent result value*.
	Deferred callback handlers are treated as a chain, and each item in
	the chain is required to return a value that will be fed into
	successive handlers. The most minimal callback may be registered
	like this:
		var d = new dojo.Deferred();
		d.addCallback(function(result){ return result; });
	Perhaps the most common mistake when first using Deferreds is to
	forget to return a value (in most cases, the value you were
	passed).
	The sequence of callbacks is internally represented as a list of
	2-tuples containing the callback/errback pair.  For example, the
	following call sequence:
		var d = new dojo.Deferred();
		d.addCallback(myCallback);
		d.addErrback(myErrback);
		d.addBoth(myBoth);
		d.addCallbacks(myCallback, myErrback);
	is translated into a Deferred with the following internal
	representation:
		[
			[myCallback, null],
			[null, myErrback],
			[myBoth, myBoth],
			[myCallback, myErrback]
		]
	The Deferred also keeps track of its current status (fired).  Its
	status may be one of three things:
	* -1: no value yet (initial condition)
	* 0: success
	* 1: error
	A Deferred will be in the error state if one of the following three
	conditions are met:
	1. The result given to callback or errback is "instanceof" Error
	2. The previous callback or errback raised an exception while
	executing
	3. The previous callback or errback returned a value
	"instanceof" Error
	Otherwise, the Deferred will be in the success state. The state of
	the Deferred determines the next element in the callback sequence
	to run.
	When a callback or errback occurs with the example deferred chain,
	something equivalent to the following will happen (imagine
	that exceptions are caught and returned):
		// d.callback(result) or d.errback(result)
		if(!(result instanceof Error)){
			result = myCallback(result);
		}
		if(result instanceof Error){
			result = myErrback(result);
		}
		result = myBoth(result);
		if(result instanceof Error){
			result = myErrback(result);
		}else{
			result = myCallback(result);
		}
	The result is then stored away in case another step is added to the
	callback sequence.	Since the Deferred already has a value
	available, any new callbacks added will be called immediately.
	There are two other "advanced" details about this implementation
	that are useful:
	Callbacks are allowed to return Deferred instances themselves, so
	you can build complicated sequences of events with ease.
	The creator of the Deferred may specify a canceller.  The canceller
	is a function that will be called if Deferred.cancel is called
	before the Deferred fires. You can use this to implement clean
	aborting of an XMLHttpRequest, etc. Note that cancel will fire the
	deferred with a CancelledError (unless your canceller returns
	another kind of error), so the errbacks should be prepared to
	handle that error for cancellable Deferreds.</description>
    <examples>
      <example>	var deferred = new dojo.Deferred();
		setTimeout(function(){ deferred.callback({success: true}); }, 1000);
		return deferred;</example>
      <example>Deferred objects are often used when making code asynchronous. It
	may be easiest to write functions in a synchronous manner and then
	split code using a deferred to trigger a response to a long-lived
	operation. For example, instead of register a callback function to
	denote when a rendering operation completes, the function can
	simply return a deferred:
		// callback style:
		function renderLotsOfData(data, callback){
			var success = false
			try{
				for(var x in data){
					renderDataitem(data[x]);
				}
				success = true;
			}catch(e){ }
			if(callback){
				callback(success);
			}
		}
		// using callback style
		renderLotsOfData(someDataObj, function(success){
			// handles success or failure
			if(!success){
				promptUserToRecover();
			}
		});
		// NOTE: no way to add another callback here!!</example>
      <example>Using a Deferred doesn't simplify the sending code any, but it
	provides a standard interface for callers and senders alike,
	providing both with a simple way to service multiple callbacks for
	an operation and freeing both sides from worrying about details
	such as "did this get called already?". With Deferreds, new
	callbacks can be added at any time.
		// Deferred style:
		function renderLotsOfData(data){
			var d = new dojo.Deferred();
			try{
				for(var x in data){
					renderDataitem(data[x]);
				}
				d.callback(true);
			}catch(e){
				d.errback(new Error("rendering failed"));
			}
			return d;
		}
		// using Deferred style
		renderLotsOfData(someDataObj).addErrback(function(){
			promptUserToRecover();
		});
		// NOTE: addErrback and addCallback both return the Deferred
		// again, so we could chain adding callbacks or save the
		// deferred for later should we need to be notified again.</example>
      <example>In this example, renderLotsOfData is syncrhonous and so both
	versions are pretty artificial. Putting the data display on a
	timeout helps show why Deferreds rock:
		// Deferred style and async func
		function renderLotsOfData(data){
			var d = new dojo.Deferred();
			setTimeout(function(){
				try{
					for(var x in data){
						renderDataitem(data[x]);
					}
					d.callback(true);
				}catch(e){
					d.errback(new Error("rendering failed"));
				}
			}, 100);
			return d;
		}
		// using Deferred style
		renderLotsOfData(someDataObj).addErrback(function(){
			promptUserToRecover();
		});
	Note that the caller doesn't have to change his code at all to
	handle the asynchronous case.</example>
    </examples>
    <properties>
      <property name="_nextId" scope="prototype" type="Object"/>
      <property name="chain" scope="instance" type="Array"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="fired" scope="instance" type="Number"/>
      <property name="paused" scope="instance" type="Number"/>
      <property name="results" scope="instance" type="Array"/>
      <property name="canceller" scope="instance" type=""/>
      <property name="silentlyCancelled" scope="instance" type="bool"/>
      <property name="isFiring" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="canceller" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="callback" scope="prototype">
        <summary>Begin the callback sequence with a non-error value.</summary>
        <parameters>
          <parameter name="res" type="" usage="required"/>
        </parameters>
      </method>
      <method name="errback" scope="prototype">
        <summary>Begin the callback sequence with an error result.</summary>
        <parameters>
          <parameter name="res" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="addBoth" scope="prototype">
        <summary>Add the same function as both a callback and an errback as the
	next element on the callback sequence.This is useful for code
	that you want to guarantee to run, e.g. a finalizer.</summary>
        <parameters>
          <parameter name="cb" type="Function|Object" usage="required"/>
          <parameter name="cbfn" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="addCallback" scope="prototype">
        <summary>Add a single callback to the end of the callback sequence.</summary>
        <parameters>
          <parameter name="cb" type="Function|Object" usage="required"/>
          <parameter name="cbfn" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="addErrback" scope="prototype">
        <summary>Add a single callback to the end of the callback sequence.</summary>
        <parameters>
          <parameter name="cb" type="" usage="required"/>
          <parameter name="cbfn" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="addCallbacks" scope="prototype">
        <summary>Add separate callback and errback to the end of the callback
	sequence.</summary>
        <parameters>
          <parameter name="cb" type="" usage="required"/>
          <parameter name="eb" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.Deferred.cancel" type="Function" classlike="true">
    <summary>Cancels a Deferred that has not yet received a value, or is
	waiting on another Deferred as its value.</summary>
    <description>If a canceller is defined, the canceller is called. If the
	canceller did not return an error, or there was no canceller,
	then the errback chain is started.</description>
    <properties>
      <property name="silentlyCancelled" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.Deferred._resback" type="Function" classlike="true" private="true">
    <summary>The private primitive that means either callback or errback</summary>
    <properties>
      <property name="fired" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="res" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.Deferred._check" type="Function" classlike="true" private="true">
    <properties>
      <property name="silentlyCancelled" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.Deferred._fire" type="Function" classlike="true" private="true">
    <summary>Used internally to exhaust the callback sequence when a result
	is available.</summary>
    <properties>
      <property name="isFiring" scope="instance" type="bool"/>
      <property name="chain" scope="instance" type=""/>
      <property name="fired" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.NodeList._stash" type="Function" classlike="true" private="true">
    <summary>private function to hold to a parent NodeList. end() to return the parent NodeList.</summary>
    <examples>
      <example>How to make a `dojo.NodeList` method that only returns the third node in
	the dojo.NodeList but allows access to the original NodeList by using this._stash:
		dojo.extend(dojo.NodeList, {
			third: function(){
				var newNodeList = dojo.NodeList(this[2]);
				return newNodeList._stash(this);
			}
		});
		// then see how _stash applies a sub-list, to be .end()'ed out of
		dojo.query(".foo")
			.third()
				.addClass("thirdFoo")
			.end()
			// access to the orig .foo list
			.removeClass("foo")</example>
    </examples>
    <properties>
      <property name="_parent" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="parent" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.NodeList.attr" type="Function">
    <summary>gets or sets the DOM attribute for every element in the
	NodeList. See also &lt;code&gt;dojo.attr&lt;/code&gt;</summary>
    <examples>
      <example>Make all nodes with a particular class focusabl:
		dojo.query(".focusable").attr("tabIndex", -1);</example>
      <example>Disable a group of buttons:
		dojo.query("button.group").attr("disalbed", true);</example>
      <example>innerHTML can be assigned or retreived as well:
		// get the innerHTML (as an array) for each list item
		var ih = dojo.query("li.replaceable").attr("innerHTML");</example>
    </examples>
    <methods>
      <method name="safetyCheck" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.NodeList.style" type="Function">
    <summary>gets or sets the CSS property for every element in the NodeList</summary>
    <methods>
      <method name="safetyCheck" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.NodeList.addContent" type="Function">
    <summary>add a node, NodeList or some HTML as a string to every item in the
	list.  Returns the original list.</summary>
    <description>a copy of the HTML content is added to each item in the
	list, with an optional position argument. If no position
	argument is provided, the content is appended to the end of
	each item.</description>
    <examples>
      <example>appends content to the end if the position is ommitted
		dojo.query("h3 &gt; p").addContent("hey there!");</example>
      <example>add something to the front of each element that has a
	"thinger" property:
		dojo.query("[thinger]").addContent("...", "first");</example>
      <example>adds a header before each element of the list
		dojo.query(".note").addContent("&lt;h4&gt;NOTE:&lt;/h4&gt;", "before");</example>
      <example>add a clone of a DOM node to the end of every element in
	the list, removing it from its existing parent.
		dojo.query(".note").addContent(dojo.byId("foo"));</example>
      <example>Append nodes from a templatized string.
	dojo.require("dojo.string");
	dojo.query(".note").addContent({
	template: '&lt;b&gt;${id}: &lt;/b&gt;&lt;span&gt;${name}&lt;/span&gt;',
	id: "user332",
	name: "Mr. Anderson"
	});</example>
      <example>Append nodes from a templatized string that also has widgets parsed.
	dojo.require("dojo.string");
	dojo.require("dojo.parser");
	var notes = dojo.query(".note").addContent({
	template: '&lt;button dojoType="dijit.form.Button"&gt;${text}&lt;/button&gt;',
	parse: true,
	text: "Send"
	});</example>
    </examples>
    <methods>
      <method name="safetyCheck" scope="normal">
        <parameters>
          <parameter name="content" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="Array" type="">
    <properties>
      <property name="slice" scope="normal" type=""/>
      <property name="concat" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="_wrap" scope="normal">
        <parameters>
          <parameter name="arr" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox">
    <summary>DojoX: the home for Dojo eXtensions</summary>
    <description>DojoX is a collection of subprojects provided by Dojo committers and subject to
	the generous licensing and policies of the [Dojo CLA](http://dojotoolkit.org/cla)
	Each subproject in DojoX has its own top-level directory and a README file with
	status information and project status and a stability rating (experimental, beta, stable)
	Projects may or may not depend on other top-level Dojo projects, like Dojo or Dijit.
	Unlike Dojo and Dijit, code is not subject to i18n and a11y restrictions and may vary
	in quality (experimental code is encouraged in DojoX, but currently prohibited in Dojo
	and Dijit)
	DojoX projects may mature to a stable state and stay in DojoX, or on occasion
	after proving themselves may migrate to Dojo Core or Dijit.  Dojo and Dijit projects
	are constrained both by development resources as well as design goals, so DojoX is
	a natural place to provide enhanced behavior or extend Dojo Core or Dijit primitives.
	DojoX can also be an incubator for entirely new projects.</description>
    <properties>
      <property name="_scopeName" scope="normal" type="String"/>
      <property name="jq" scope="normal" type="Object">
        <summary>A JQuery compatibility layer</summary>
      </property>
      <property name="portlet" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="djConfig">
    <properties>
      <property name="isDebug" scope="normal" type="bool"/>
      <property name="debugAtAllCosts" scope="normal" type="bool"/>
      <property name="baseUrl" scope="normal" type=""/>
      <property name="urchin" scope="normal" type="String">
        <summary>Used by &lt;code&gt;dojox.analytics.Urchin&lt;/code&gt; as the default UA-123456-7 account
	number used when being created. Alternately, you can pass an acct:&amp;quot;&amp;quot;
	parameter to the constructor a la: new dojox.analytics.Urchin({ acct:&amp;quot;UA-123456-7&amp;quot; });</summary>
      </property>
      <property name="preloadImages" scope="normal" type="Array">
        <summary>An optional array of urls to preload immediately upon
	page load. Uses &lt;code&gt;dojox.image&lt;/code&gt;, and is unused if not present.</summary>
      </property>
    </properties>
  </object>
  <object location="dojo.version" type="Function" classlike="true">
    <summary>Version number of the Dojo Toolkit</summary>
    <properties>
      <property name="major" scope="instance" type="Integer">
        <summary>Major version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 1</summary>
      </property>
      <property name="minor" scope="instance" type="Integer">
        <summary>Minor version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 2</summary>
      </property>
      <property name="patch" scope="instance" type="Integer">
        <summary>Patch version. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be 0</summary>
      </property>
      <property name="flag" scope="instance" type="String">
        <summary>Descriptor flag. If total version is &amp;quot;1.2.0beta1&amp;quot;, will be &amp;quot;beta1&amp;quot;</summary>
      </property>
      <property name="revision" scope="instance" type="Number">
        <summary>The SVN rev from which dojo was pulled</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="toString" scope="normal">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.config">
    <properties>
      <property name="baseUrl" scope="normal" type="Object"/>
      <property name="ieForceActiveXXhr" scope="normal" type="Object"/>
      <property name="modulePaths" scope="normal" type=""/>
      <property name="useXDomain" scope="normal" type="Object"/>
      <property name="addOnLoad" scope="normal" type=""/>
      <property name="hashPollFrequency" scope="normal" type="Number"/>
      <property name="extraLocale" scope="normal" type="Array"/>
      <property name="dojoBlankHtmlUrl" scope="normal" type="Object"/>
      <property name="debugContainerId" scope="normal" type="String"/>
      <property name="debugHeight" scope="normal" type="Number"/>
      <property name="consoleLogFuncs" scope="normal" type="Array"/>
      <property name="timezoneFileBasePath" scope="normal" type="Object"/>
      <property name="timezoneLoadingScheme" scope="normal" type="String"/>
      <property name="uploaderPath" scope="normal" type="Object"/>
      <property name="ioPublish" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="navigator" type="">
    <properties>
      <property name="userAgent" scope="normal" type=""/>
      <property name="appVersion" scope="normal" type=""/>
      <property name="cookieEnabled" scope="normal" type="bool"/>
    </properties>
  </object>
  <object location="document" type="">
    <properties>
      <property name="documentMode" scope="normal" type=""/>
      <property name="cookie" scope="normal" type=""/>
      <property name="styleSheets" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="vmlElems" type="Array">
    <properties>
      <property name="length" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="console">
    <properties>
      <property name="warn" scope="normal" type=""/>
      <property name="error" scope="normal" type=""/>
      <property name="info" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="log" scope="normal">
        <parameters>
          <parameter name="m" type="" usage="required"/>
        </parameters>
      </method>
      <method name="debug" scope="normal"/>
    </methods>
  </object>
  <object location="e" type="">
    <properties>
      <property name="stack" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojo._modulePrefixes" private="true"/>
  <object location="dojo._modulePrefixes.dojo">
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="value" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojo._modulePrefixes.doh">
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="value" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojo._modulePrefixes.tests">
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="value" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojo._Url" type="Function" classlike="true" private="true">
    <summary>Constructor to create an object representing a URL.
	It is marked as private, since we might consider removing
	or simplifying it.</summary>
    <description>Each argument is evaluated in order relative to the next until
	a canonical uri is produced. To get an absolute Uri relative to
	the current document use:
	new dojo._Url(document.baseURI, url)</description>
    <properties>
      <property name="uri" scope="instance" type="Object"/>
      <property name="scheme" scope="instance" type=""/>
      <property name="authority" scope="instance" type=""/>
      <property name="path" scope="instance" type=""/>
      <property name="query" scope="instance" type=""/>
      <property name="fragment" scope="instance" type=""/>
      <property name="user" scope="instance" type="Object"/>
      <property name="password" scope="instance" type="Object"/>
      <property name="host" scope="instance" type="Object"/>
      <property name="port" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="toString" scope="normal"/>
    </methods>
  </object>
  <object location="window" type="">
    <properties>
      <property name="dojo" scope="normal" type=""/>
      <property name="dijit" scope="normal" type=""/>
      <property name="dojox" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojo._xdDebugQueue" type="Array" private="true">
    <properties>
      <property name="currentResourceName" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojo._base._loader" private="true">
    <properties>
      <property name="loader_debug" scope="normal" type="Object"/>
      <property name="loader_xd" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojo._xdDefList" type="Array" private="true">
    <properties>
      <property name="length" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojo._listener" private="true">
    <methods>
      <method name="getDispatcher" scope="normal"/>
      <method name="add" scope="normal">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="normal">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="Object" type="">
    <properties>
      <property name="toString" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="inherited" scope="normal">
        <summary>Calls a super method.</summary>
        <description>This method is used inside method of classes produced with
	dojo.declare to call a super method (next in the chain). It is
	used for manually controlled chaining. Consider using the regular
	chaining, because it is faster. Use "this.inherited()" only in
	complex cases.
	This method cannot me called from automatically chained
	constructors including the case of a special (legacy)
	constructor chaining. It cannot be called from chained methods.
	If "this.inherited()" cannot find the next-in-chain method, it
	does nothing and returns "undefined". The last method in chain
	can be a default method implemented in Object, which will be
	called last.
	If "name" is specified, it is assumed that the method that
	received "args" is the parent method for this call. It is looked
	up in the chain list and if it is found the next-in-chain method
	is called. If it is not found, the first-in-chain method is
	called.
	If "name" is not specified, it will be derived from the calling
	method (using a methoid property "nom").</description>
        <return-description>Whatever is returned by a super method, or a super method itself,
	if "true" was specified as newArgs.</return-description>
        <examples>
          <example>	var B = dojo.declare(A, {
			method1: function(a, b, c){
				this.inherited(arguments);
			},
			method2: function(a, b){
				return this.inherited(arguments, [a + b]);
			}
		});
		// next method is not in the chain list because it is added
		// manually after the class was created.
		B.prototype.method3 = function(){
			console.log("This is a dynamically-added method.");
			this.inherited("method3", arguments);
		};</example>
          <example>	var B = dojo.declare(A, {
			method: function(a, b){
				var super = this.inherited(arguments, true);
				// ...
				if(!super){
					console.log("there is no super method");
					return 0;
				}
				return super.apply(this, arguments);
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <summary>The optional method name. Should be the same as the caller's
	name. Usually &amp;quot;name&amp;quot; is specified in complex dynamic cases, when
	the calling method was dynamically added, undecorated by
	dojo.declare, and it cannot be determined.</summary>
          </parameter>
          <parameter name="args" type="Arguments" usage="required">
            <summary>The caller supply this argument, which should be the original
	&amp;quot;arguments&amp;quot;.</summary>
          </parameter>
          <parameter name="newArgs" type="Object" usage="optional">
            <summary>If &amp;quot;true&amp;quot;, the found function will be returned without
	executing it.
	If Array, it will be used to call a super method. Otherwise
	&amp;quot;args&amp;quot; will be used.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getInherited" scope="normal">
        <summary>Returns a super method.</summary>
        <description>This method is a convenience method for "this.inherited()".
	It uses the same algorithm but instead of executing a super
	method, it returns it, or "undefined" if not found.</description>
        <return-description>Returns a super method (Function) or "undefined".</return-description>
        <examples>
          <example>	var B = dojo.declare(A, {
			method: function(a, b){
				var super = this.getInherited(arguments);
				// ...
				if(!super){
					console.log("there is no super method");
					return 0;
				}
				return super.apply(this, arguments);
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <summary>The optional method name. Should be the same as the caller's
	name. Usually &amp;quot;name&amp;quot; is specified in complex dynamic cases, when
	the calling method was dynamically added, undecorated by
	dojo.declare, and it cannot be determined.</summary>
          </parameter>
          <parameter name="args" type="Arguments" usage="required">
            <summary>The caller supply this argument, which should be the original
	&amp;quot;arguments&amp;quot;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="isInstanceOf" scope="normal">
        <summary>Checks the inheritance cahin to see if it is inherited from this
	class.</summary>
        <description>This method is used with instances of classes produced with
	dojo.declare to determine of they support a certain interface or
	not. It models "instanceof" operator.</description>
        <return-description>"true", if this object is inherited from this class, "false"
	otherwise.</return-description>
        <examples>
          <example>	var A = dojo.declare(null, {
			// constructor, properties, and methods go here
			// ...
		});
		var B = dojo.declare(null, {
			// constructor, properties, and methods go here
			// ...
		});
		var C = dojo.declare([A, B], {
			// constructor, properties, and methods go here
			// ...
		});
		var D = dojo.declare(A, {
			// constructor, properties, and methods go here
			// ...
		});
		var a = new A(), b = new B(), c = new C(), d = new D();
		console.log(a.isInstanceOf(A)); // true
		console.log(b.isInstanceOf(A)); // false
		console.log(c.isInstanceOf(A)); // true
		console.log(d.isInstanceOf(A)); // true
		console.log(a.isInstanceOf(B)); // false
		console.log(b.isInstanceOf(B)); // true
		console.log(c.isInstanceOf(B)); // true
		console.log(d.isInstanceOf(B)); // false
		console.log(a.isInstanceOf(C)); // false
		console.log(b.isInstanceOf(C)); // false
		console.log(c.isInstanceOf(C)); // true
		console.log(d.isInstanceOf(C)); // false
		console.log(a.isInstanceOf(D)); // false
		console.log(b.isInstanceOf(D)); // false
		console.log(c.isInstanceOf(D)); // false
		console.log(d.isInstanceOf(D)); // true</example>
        </examples>
        <parameters>
          <parameter name="cls" type="Function" usage="required">
            <summary>Class constructor.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="extend" scope="normal">
        <summary>Adds all properties and methods of source to constructor's
	prototype, making them available to all instances created with
	constructor. This method is specific to constructors created with
	dojo.declare.</summary>
        <description>Adds source properties to the constructor's prototype. It can
	override existing properties.
	This method is similar to dojo.extend function, but it is specific
	to constructors produced by dojo.declare. It is implemented
	using dojo.safeMixin, and it skips a constructor property,
	and properly decorates copied functions.</description>
        <examples>
          <example>	var A = dojo.declare(null, {
			m1: function(){},
			s1: "Popokatepetl"
		});
		A.extend({
			m1: function(){},
			m2: function(){},
			f1: true,
			d1: 42
		});</example>
        </examples>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>Source object which properties are going to be copied to the
	constructor's prototype.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo._event_listener" private="true">
    <methods>
      <method name="add" scope="normal">
        <parameters>
          <parameter name="node" type="DOMNode" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="fp" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="normal">
        <summary>clobbers the listener from the node</summary>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <summary>DOM node to attach the event to</summary>
          </parameter>
          <parameter name="event" type="String" usage="required">
            <summary>the name of the handler to remove the function from</summary>
          </parameter>
          <parameter name="handle" type="Handle" usage="required">
            <summary>the handle returned from add</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizeEventName" scope="normal">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fixCallback" scope="normal">
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="fp" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fixEvent" scope="normal">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
          <parameter name="sender" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setKeyChar" scope="normal">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo._event_listener._punctMap" private="true">
    <properties>
      <property name="106" scope="normal" type="Number"/>
      <property name="111" scope="normal" type="Number"/>
      <property name="186" scope="normal" type="Number"/>
      <property name="187" scope="normal" type="Number"/>
      <property name="188" scope="normal" type="Number"/>
      <property name="189" scope="normal" type="Number"/>
      <property name="190" scope="normal" type="Number"/>
      <property name="191" scope="normal" type="Number"/>
      <property name="192" scope="normal" type="Number"/>
      <property name="219" scope="normal" type="Number"/>
      <property name="220" scope="normal" type="Number"/>
      <property name="221" scope="normal" type="Number"/>
      <property name="222" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojo.keys">
    <summary>Definitions for common key values
	the apple key on macs
	virtual key mapping</summary>
    <properties>
      <property name="BACKSPACE" scope="normal" type="Number"/>
      <property name="TAB" scope="normal" type="Number"/>
      <property name="CLEAR" scope="normal" type="Number"/>
      <property name="ENTER" scope="normal" type="Number"/>
      <property name="SHIFT" scope="normal" type="Number"/>
      <property name="CTRL" scope="normal" type="Number"/>
      <property name="ALT" scope="normal" type="Number"/>
      <property name="META" scope="normal" type=""/>
      <property name="PAUSE" scope="normal" type="Number"/>
      <property name="CAPS_LOCK" scope="normal" type="Number"/>
      <property name="ESCAPE" scope="normal" type="Number"/>
      <property name="SPACE" scope="normal" type="Number"/>
      <property name="PAGE_UP" scope="normal" type="Number"/>
      <property name="PAGE_DOWN" scope="normal" type="Number"/>
      <property name="END" scope="normal" type="Number"/>
      <property name="HOME" scope="normal" type="Number"/>
      <property name="LEFT_ARROW" scope="normal" type="Number"/>
      <property name="UP_ARROW" scope="normal" type="Number"/>
      <property name="RIGHT_ARROW" scope="normal" type="Number"/>
      <property name="DOWN_ARROW" scope="normal" type="Number"/>
      <property name="INSERT" scope="normal" type="Number"/>
      <property name="DELETE" scope="normal" type="Number"/>
      <property name="HELP" scope="normal" type="Number"/>
      <property name="LEFT_WINDOW" scope="normal" type="Number"/>
      <property name="RIGHT_WINDOW" scope="normal" type="Number"/>
      <property name="SELECT" scope="normal" type="Number"/>
      <property name="NUMPAD_0" scope="normal" type="Number"/>
      <property name="NUMPAD_1" scope="normal" type="Number"/>
      <property name="NUMPAD_2" scope="normal" type="Number"/>
      <property name="NUMPAD_3" scope="normal" type="Number"/>
      <property name="NUMPAD_4" scope="normal" type="Number"/>
      <property name="NUMPAD_5" scope="normal" type="Number"/>
      <property name="NUMPAD_6" scope="normal" type="Number"/>
      <property name="NUMPAD_7" scope="normal" type="Number"/>
      <property name="NUMPAD_8" scope="normal" type="Number"/>
      <property name="NUMPAD_9" scope="normal" type="Number"/>
      <property name="NUMPAD_MULTIPLY" scope="normal" type="Number"/>
      <property name="NUMPAD_PLUS" scope="normal" type="Number"/>
      <property name="NUMPAD_ENTER" scope="normal" type="Number"/>
      <property name="NUMPAD_MINUS" scope="normal" type="Number"/>
      <property name="NUMPAD_PERIOD" scope="normal" type="Number"/>
      <property name="NUMPAD_DIVIDE" scope="normal" type="Number"/>
      <property name="F1" scope="normal" type="Number"/>
      <property name="F2" scope="normal" type="Number"/>
      <property name="F3" scope="normal" type="Number"/>
      <property name="F4" scope="normal" type="Number"/>
      <property name="F5" scope="normal" type="Number"/>
      <property name="F6" scope="normal" type="Number"/>
      <property name="F7" scope="normal" type="Number"/>
      <property name="F8" scope="normal" type="Number"/>
      <property name="F9" scope="normal" type="Number"/>
      <property name="F10" scope="normal" type="Number"/>
      <property name="F11" scope="normal" type="Number"/>
      <property name="F12" scope="normal" type="Number"/>
      <property name="F13" scope="normal" type="Number"/>
      <property name="F14" scope="normal" type="Number"/>
      <property name="F15" scope="normal" type="Number"/>
      <property name="NUM_LOCK" scope="normal" type="Number"/>
      <property name="SCROLL_LOCK" scope="normal" type="Number"/>
      <property name="copyKey" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojo.mouseButtons">
    <properties>
      <property name="LEFT" scope="normal" type="Number">
        <summary>Numeric value of the left mouse button for the platform.</summary>
      </property>
      <property name="MIDDLE" scope="normal" type="Number">
        <summary>Numeric value of the middle mouse button for the platform.</summary>
      </property>
      <property name="RIGHT" scope="normal" type="Number">
        <summary>Numeric value of the right mouse button for the platform.</summary>
      </property>
    </properties>
    <methods>
      <method name="isButton" scope="normal">
        <summary>Checks an event object for a pressed button</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event object to examine</summary>
          </parameter>
          <parameter name="button" type="Number" usage="required">
            <summary>The button value (example: dojo.mouseButton.LEFT)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isLeft" scope="normal">
        <summary>Checks an event object for the pressed left button</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event object to examine</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isMiddle" scope="normal">
        <summary>Checks an event object for the pressed middle button</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event object to examine</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isRight" scope="normal">
        <summary>Checks an event object for the pressed right button</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event object to examine</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo._ie_listener" private="true">
    <properties>
      <property name="handlers" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method name="add" scope="normal">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="listener" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="normal">
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="handle" type="Handle" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.Animation" type="Function" classlike="true">
    <summary>A generic animation class that fires callbacks into its handlers
	object at various states.</summary>
    <description>A generic animation class that fires callbacks into its handlers
	object at various states. Nearly all dojo animation functions
	return an instance of this method, usually without calling the
	.play() method beforehand. Therefore, you will likely need to
	call .play() on instances of `dojo.Animation` when one is
	returned.</description>
    <properties>
      <property name="duration" scope="prototype" type="Integer">
        <summary>The time in milliseonds the animation will take to run</summary>
      </property>
      <property name="curve" scope="instance-prototype" type="dojo._Line|Array">
        <summary>A two element array of start and end values, or a &lt;code&gt;dojo._Line&lt;/code&gt; instance to be
	used in the Animation.</summary>
      </property>
      <property name="repeat" scope="prototype" type="Integer">
        <summary>The number of times to loop the animation</summary>
      </property>
      <property name="rate" scope="prototype" type="Integer">
        <summary>the time in milliseconds to wait before advancing to next frame
	(used as a fps timer: 1000/rate = fps)</summary>
      </property>
      <property name="delay" scope="prototype" type="Integer">
        <summary>The time in milliseconds to wait before starting animation after it
	has been .play()'ed</summary>
      </property>
      <property name="beforeBegin" scope="prototype" type="Event">
        <summary>Synthetic event fired before a dojo.Animation begins playing (synchronous)</summary>
      </property>
      <property name="onBegin" scope="prototype" type="Event">
        <summary>Synthetic event fired as a dojo.Animation begins playing (useful?)</summary>
      </property>
      <property name="onAnimate" scope="prototype" type="Event">
        <summary>Synthetic event fired at each interval of a &lt;code&gt;dojo.Animation&lt;/code&gt;</summary>
      </property>
      <property name="onEnd" scope="prototype" type="Event">
        <summary>Synthetic event fired after the final frame of a &lt;code&gt;dojo.Animation&lt;/code&gt;</summary>
      </property>
      <property name="onPlay" scope="prototype" type="Event">
        <summary>Synthetic event fired any time a &lt;code&gt;dojo.Animation&lt;/code&gt; is play()'ed</summary>
      </property>
      <property name="onPause" scope="prototype" type="Event">
        <summary>Synthetic event fired when a &lt;code&gt;dojo.Animation&lt;/code&gt; is paused</summary>
      </property>
      <property name="onStop" scope="prototype" type="Event">
        <summary>Synthetic event fires when a &lt;code&gt;dojo.Animation&lt;/code&gt; is stopped</summary>
      </property>
      <property name="_percent" scope="prototype" type="Number"/>
      <property name="_startRepeatCount" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>The 'magic argument', mixing all the properties into this
	animation instance.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="easing" scope="prototype">
        <summary>A Function to adjust the acceleration (or deceleration) of the progress
	across a dojo._Line</summary>
      </method>
      <method name="_fire" scope="prototype">
        <summary>Convenience function.  Fire event &amp;quot;evt&amp;quot; and pass it the
	arguments specified in &amp;quot;args&amp;quot;.</summary>
        <description>Convenience function.  Fire event "evt" and pass it the
	arguments specified in "args".
	Fires the callback in the scope of the `dojo.Animation`
	instance.</description>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The event to fire.</summary>
          </parameter>
          <parameter name="args" type="Array" usage="optional">
            <summary>The arguments to pass to the event.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="play" scope="prototype">
        <summary>Start the animation.</summary>
        <return-description>dojo.Animation
	The instance to allow chaining.</return-description>
        <parameters>
          <parameter name="delay" type="int" usage="optional">
            <summary>How many milliseconds to delay before starting.</summary>
          </parameter>
          <parameter name="gotoStart" type="Boolean" usage="optional">
            <summary>If true, starts the animation from the beginning; otherwise,
	starts it from its current position.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_play" scope="prototype">
        <parameters>
          <parameter name="gotoStart" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="pause" scope="prototype">
        <summary>Pauses a running animation.</summary>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="gotoPercent" scope="prototype">
        <summary>Sets the progress of the animation.</summary>
        <parameters>
          <parameter name="percent" type="Decimal" usage="required">
            <summary>A percentage in decimal notation (between and including 0.0 and 1.0).</summary>
          </parameter>
          <parameter name="andPlay" type="Boolean" usage="optional">
            <summary>If true, play the animation after setting the progress.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="stop" scope="prototype">
        <summary>Stops a running animation.</summary>
        <parameters>
          <parameter name="gotoEnd" type="boolean" usage="optional">
            <summary>If true, the animation will end.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="status" scope="prototype">
        <summary>Returns a string token representation of the status of
	the animation, one of: &amp;quot;paused&amp;quot;, &amp;quot;playing&amp;quot;, &amp;quot;stopped&amp;quot;</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cycle" scope="prototype">
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_clearTimer" scope="prototype">
        <summary>Clear the play delay timer</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.Animation._getStep" type="Function" classlike="true" private="true">
    <properties>
      <property name="_percent" scope="instance" type=""/>
      <property name="easing" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.Animation._startTimer" type="Function" classlike="true" private="true">
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.Animation._stopTimer" type="Function" classlike="true" private="true">
    <properties>
      <property name="_timer" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.__AnimArgs" type="Function" classlike="true" superclass="dojo.__FadeArgs" private="true">
    <mixins>
      <mixin scope="instance" location="dojo.__FadeArgs"/>
    </mixins>
    <properties>
      <property name="properties" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo._Line" type="Function" classlike="true" private="true">
    <summary>dojo._Line is the object used to generate values from a start value
	to an end value</summary>
    <properties>
      <property name="start" scope="instance" type="int">
        <summary>Beginning value for range</summary>
      </property>
      <property name="end" scope="instance" type="int">
        <summary>Ending value for range</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="start" type="int" usage="required">
            <summary>Beginning value for range</summary>
          </parameter>
          <parameter name="end" type="int" usage="required">
            <summary>Ending value for range</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="normal">
        <summary>Returns the point on the line</summary>
        <parameters>
          <parameter name="n" type="float" usage="required">
            <summary>a floating point number greater than 0 and less than 1</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.__FadeArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="node" scope="instance" type="DOMNode|String">
        <summary>The node referenced in the animation</summary>
      </property>
      <property name="duration" scope="instance" type="Integer">
        <summary>Duration of the animation in milliseconds.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <summary>The node referenced in the animation</summary>
          </parameter>
          <parameter name="duration" type="Integer" usage="optional">
            <summary>Duration of the animation in milliseconds.</summary>
          </parameter>
          <parameter name="easing" type="Function" usage="optional">
            <summary>An easing function.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="easing" scope="instance">
        <summary>An easing function.</summary>
      </method>
    </methods>
  </object>
  <object location="dojo._extraNames" type="Array" private="true">
    <properties>
      <property name="length" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojo.query" type="Function">
    <summary>Returns nodes which match the given CSS3 selector, searching the
	entire document by default but optionally taking a node to scope
	the search by. Returns an instance of dojo.NodeList.</summary>
    <description>dojo.query() is the swiss army knife of DOM node manipulation in
	Dojo. Much like Prototype's "$$" (bling-bling) function or JQuery's
	"$" function, dojo.query provides robust, high-performance
	CSS-based node selector support with the option of scoping searches
	to a particular sub-tree of a document.
	Supported Selectors:
	--------------------
	dojo.query() supports a rich set of CSS3 selectors, including:
	* class selectors (e.g., `.foo`)
	* node type selectors like `span`
	* ` ` descendant selectors
	* `&gt;` child element selectors
	* `#foo` style ID selectors
	* `*` universal selector
	* `~`, the immediately preceeded-by sibling selector
	* `+`, the preceeded-by sibling selector
	* attribute queries:
		* `[foo]` attribute presence selector
		* `[foo='bar']` attribute value exact match
		* `[foo~='bar']` attribute value list item match
		* `[foo^='bar']` attribute start match
		* `[foo$='bar']` attribute end match
		* `[foo*='bar']` attribute substring match
	* `:first-child`, `:last-child`, and `:only-child` positional selectors
	* `:empty` content emtpy selector
	* `:checked` pseudo selector
	* `:nth-child(n)`, `:nth-child(2n+1)` style positional calculations
	* `:nth-child(even)`, `:nth-child(odd)` positional selectors
	* `:not(...)` negation pseudo selectors
	Any legal combination of these selectors will work with
	`dojo.query()`, including compound selectors ("," delimited).
	Very complex and useful searches can be constructed with this
	palette of selectors and when combined with functions for
	manipulation presented by dojo.NodeList, many types of DOM
	manipulation operations become very straightforward.
	Unsupported Selectors:
	----------------------
	While dojo.query handles many CSS3 selectors, some fall outside of
	what's resaonable for a programmatic node querying engine to
	handle. Currently unsupported selectors include:
	* namespace-differentiated selectors of any form
	* all `::` pseduo-element selectors
	* certain pseduo-selectors which don't get a lot of day-to-day use:
		* `:root`, `:lang()`, `:target`, `:focus`
	* all visual and state selectors:
		* `:root`, `:active`, `:hover`, `:visisted`, `:link`,
	`:enabled`, `:disabled`
	* `:*-of-type` pseudo selectors
	dojo.query and XML Documents:
	-----------------------------
	`dojo.query` (as of dojo 1.2) supports searching XML documents
	in a case-sensitive manner. If an HTML document is served with
	a doctype that forces case-sensitivity (e.g., XHTML 1.1
	Strict), dojo.query() will detect this and "do the right
	thing". Case sensitivity is dependent upon the document being
	searched and not the query used. It is therefore possible to
	use case-sensitive queries on strict sub-documents (iframes,
	etc.) or XML documents while still assuming case-insensitivity
	for a host/root document.
	Non-selector Queries:
	---------------------
	If something other than a String is passed for the query,
	`dojo.query` will return a new `dojo.NodeList` instance
	constructed from that parameter alone and all further
	processing will stop. This means that if you have a reference
	to a node or NodeList, you can quickly construct a new NodeList
	from the original by calling `dojo.query(node)` or
	`dojo.query(list)`.</description>
    <examples>
      <example>search the entire document for elements with the class "foo":
		dojo.query(".foo");
	these elements will match:
		&lt;span class="foo"&gt;&lt;/span&gt;
		&lt;span class="foo bar"&gt;&lt;/span&gt;
		&lt;p class="thud foo"&gt;&lt;/p&gt;</example>
      <example>search the entire document for elements with the classes "foo" *and* "bar":
		dojo.query(".foo.bar");
	these elements will match:
		&lt;span class="foo bar"&gt;&lt;/span&gt;
	while these will not:
		&lt;span class="foo"&gt;&lt;/span&gt;
		&lt;p class="thud foo"&gt;&lt;/p&gt;</example>
      <example>find `&lt;span&gt;` elements which are descendants of paragraphs and
	which have a "highlighted" class:
		dojo.query("p span.highlighted");
	the innermost span in this fragment matches:
		&lt;p class="foo"&gt;
			&lt;span&gt;...
				&lt;span class="highlighted foo bar"&gt;...&lt;/span&gt;
			&lt;/span&gt;
		&lt;/p&gt;</example>
      <example>set an "odd" class on all odd table rows inside of the table
	`#tabular_data`, using the `&gt;` (direct child) selector to avoid
	affecting any nested tables:
		dojo.query("#tabular_data &gt; tbody &gt; tr:nth-child(odd)").addClass("odd");</example>
      <example>remove all elements with the class "error" from the document
	and store them in a list:
		var errors = dojo.query(".error").orphan();</example>
      <example>add an onclick handler to every submit button in the document
	which causes the form to be sent via Ajax instead:
		dojo.query("input[type='submit']").onclick(function(e){
			dojo.stopEvent(e); // prevent sending the form
			var btn = e.target;
			dojo.xhrPost({
				form: btn.form,
				load: function(data){
					// replace the form with the response
					var div = dojo.doc.createElement("div");
					dojo.place(div, btn.form, "after");
					div.innerHTML = data;
					dojo.style(btn.form, "display", "none");
				}
			});
		});</example>
    </examples>
  </object>
  <object location="acme">
    <properties>
      <property name="doc" scope="normal" type=""/>
      <property name="NodeList" scope="normal" type=""/>
      <property name="isOpera" scope="normal" type=""/>
      <property name="isKhtml" scope="normal" type=""/>
      <property name="isWebKit" scope="normal" type="Object"/>
      <property name="isChrome" scope="normal" type="Object"/>
      <property name="isSafari" scope="normal" type="Number"/>
      <property name="isIE" scope="normal" type="Object"/>
      <property name="_NodeListCtor" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="trim" scope="normal">
        <summary>trims whitespaces from both sides of the string</summary>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="forEach" scope="normal">
        <summary>an iterator function that passes items, indexes,
	and the array to a callback</summary>
        <parameters>
          <parameter name="arr" type="String" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
          <parameter name="thisObject" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="byId" scope="normal">
        <summary>a function that return an element by ID, but also
	accepts nodes safely</summary>
        <parameters>
          <parameter name="id" type="" usage="required"/>
          <parameter name="doc" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="query" scope="normal">
        <summary>Returns nodes which match the given CSS3 selector, searching the
	entire document by default but optionally taking a node to scope
	the search by. Returns an instance of dojo.NodeList.</summary>
        <description>dojo.query() is the swiss army knife of DOM node manipulation in
	Dojo. Much like Prototype's "$$" (bling-bling) function or JQuery's
	"$" function, dojo.query provides robust, high-performance
	CSS-based node selector support with the option of scoping searches
	to a particular sub-tree of a document.
	Supported Selectors:
	--------------------
	dojo.query() supports a rich set of CSS3 selectors, including:
	* class selectors (e.g., `.foo`)
	* node type selectors like `span`
	* ` ` descendant selectors
	* `&gt;` child element selectors
	* `#foo` style ID selectors
	* `*` universal selector
	* `~`, the immediately preceeded-by sibling selector
	* `+`, the preceeded-by sibling selector
	* attribute queries:
		* `[foo]` attribute presence selector
		* `[foo='bar']` attribute value exact match
		* `[foo~='bar']` attribute value list item match
		* `[foo^='bar']` attribute start match
		* `[foo$='bar']` attribute end match
		* `[foo*='bar']` attribute substring match
	* `:first-child`, `:last-child`, and `:only-child` positional selectors
	* `:empty` content emtpy selector
	* `:checked` pseudo selector
	* `:nth-child(n)`, `:nth-child(2n+1)` style positional calculations
	* `:nth-child(even)`, `:nth-child(odd)` positional selectors
	* `:not(...)` negation pseudo selectors
	Any legal combination of these selectors will work with
	`dojo.query()`, including compound selectors ("," delimited).
	Very complex and useful searches can be constructed with this
	palette of selectors and when combined with functions for
	manipulation presented by dojo.NodeList, many types of DOM
	manipulation operations become very straightforward.
	Unsupported Selectors:
	----------------------
	While dojo.query handles many CSS3 selectors, some fall outside of
	what's resaonable for a programmatic node querying engine to
	handle. Currently unsupported selectors include:
	* namespace-differentiated selectors of any form
	* all `::` pseduo-element selectors
	* certain pseduo-selectors which don't get a lot of day-to-day use:
		* `:root`, `:lang()`, `:target`, `:focus`
	* all visual and state selectors:
		* `:root`, `:active`, `:hover`, `:visisted`, `:link`,
	`:enabled`, `:disabled`
	* `:*-of-type` pseudo selectors
	dojo.query and XML Documents:
	-----------------------------
	`dojo.query` (as of dojo 1.2) supports searching XML documents
	in a case-sensitive manner. If an HTML document is served with
	a doctype that forces case-sensitivity (e.g., XHTML 1.1
	Strict), dojo.query() will detect this and "do the right
	thing". Case sensitivity is dependent upon the document being
	searched and not the query used. It is therefore possible to
	use case-sensitive queries on strict sub-documents (iframes,
	etc.) or XML documents while still assuming case-insensitivity
	for a host/root document.
	Non-selector Queries:
	---------------------
	If something other than a String is passed for the query,
	`dojo.query` will return a new `dojo.NodeList` instance
	constructed from that parameter alone and all further
	processing will stop. This means that if you have a reference
	to a node or NodeList, you can quickly construct a new NodeList
	from the original by calling `dojo.query(node)` or
	`dojo.query(list)`.</description>
        <return-description>dojo.NodeList
	An instance of `dojo.NodeList`. Many methods are available on
	NodeLists for searching, iterating, manipulating, and handling
	events on the matched nodes in the returned list.</return-description>
        <examples>
          <example>search the entire document for elements with the class "foo":
		dojo.query(".foo");
	these elements will match:
		&lt;span class="foo"&gt;&lt;/span&gt;
		&lt;span class="foo bar"&gt;&lt;/span&gt;
		&lt;p class="thud foo"&gt;&lt;/p&gt;</example>
          <example>search the entire document for elements with the classes "foo" *and* "bar":
		dojo.query(".foo.bar");
	these elements will match:
		&lt;span class="foo bar"&gt;&lt;/span&gt;
	while these will not:
		&lt;span class="foo"&gt;&lt;/span&gt;
		&lt;p class="thud foo"&gt;&lt;/p&gt;</example>
          <example>find `&lt;span&gt;` elements which are descendants of paragraphs and
	which have a "highlighted" class:
		dojo.query("p span.highlighted");
	the innermost span in this fragment matches:
		&lt;p class="foo"&gt;
			&lt;span&gt;...
				&lt;span class="highlighted foo bar"&gt;...&lt;/span&gt;
			&lt;/span&gt;
		&lt;/p&gt;</example>
          <example>set an "odd" class on all odd table rows inside of the table
	`#tabular_data`, using the `&gt;` (direct child) selector to avoid
	affecting any nested tables:
		dojo.query("#tabular_data &gt; tbody &gt; tr:nth-child(odd)").addClass("odd");</example>
          <example>remove all elements with the class "error" from the document
	and store them in a list:
		var errors = dojo.query(".error").orphan();</example>
          <example>add an onclick handler to every submit button in the document
	which causes the form to be sent via Ajax instead:
		dojo.query("input[type='submit']").onclick(function(e){
			dojo.stopEvent(e); // prevent sending the form
			var btn = e.target;
			dojo.xhrPost({
				form: btn.form,
				load: function(data){
					// replace the form with the response
					var div = dojo.doc.createElement("div");
					dojo.place(div, btn.form, "after");
					div.innerHTML = data;
					dojo.style(btn.form, "display", "none");
				}
			});
		});</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <summary>The CSS3 expression to match against. For details on the syntax of
	CSS3 selectors, see &amp;lt;http://www.w3.org/TR/css3-selectors/#selectors&amp;gt;</summary>
          </parameter>
          <parameter name="root" type="String|DOMNode" usage="optional">
            <summary>A DOMNode (or node id) to scope the search from. Optional.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_filterQueryResult" scope="normal">
        <parameters>
          <parameter name="nodeList" type="" usage="required"/>
          <parameter name="simpleFilter" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="queryPortability" type="">
    <properties>
      <property name="trim" scope="normal" type=""/>
      <property name="forEach" scope="normal" type=""/>
      <property name="_NodeListCtor" scope="normal" type=""/>
      <property name="isWebKit" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="query" scope="normal">
        <summary>Returns nodes which match the given CSS3 selector, searching the
	entire document by default but optionally taking a node to scope
	the search by. Returns an instance of dojo.NodeList.</summary>
        <description>dojo.query() is the swiss army knife of DOM node manipulation in
	Dojo. Much like Prototype's "$$" (bling-bling) function or JQuery's
	"$" function, dojo.query provides robust, high-performance
	CSS-based node selector support with the option of scoping searches
	to a particular sub-tree of a document.
	Supported Selectors:
	--------------------
	dojo.query() supports a rich set of CSS3 selectors, including:
	* class selectors (e.g., `.foo`)
	* node type selectors like `span`
	* ` ` descendant selectors
	* `&gt;` child element selectors
	* `#foo` style ID selectors
	* `*` universal selector
	* `~`, the immediately preceeded-by sibling selector
	* `+`, the preceeded-by sibling selector
	* attribute queries:
		* `[foo]` attribute presence selector
		* `[foo='bar']` attribute value exact match
		* `[foo~='bar']` attribute value list item match
		* `[foo^='bar']` attribute start match
		* `[foo$='bar']` attribute end match
		* `[foo*='bar']` attribute substring match
	* `:first-child`, `:last-child`, and `:only-child` positional selectors
	* `:empty` content emtpy selector
	* `:checked` pseudo selector
	* `:nth-child(n)`, `:nth-child(2n+1)` style positional calculations
	* `:nth-child(even)`, `:nth-child(odd)` positional selectors
	* `:not(...)` negation pseudo selectors
	Any legal combination of these selectors will work with
	`dojo.query()`, including compound selectors ("," delimited).
	Very complex and useful searches can be constructed with this
	palette of selectors and when combined with functions for
	manipulation presented by dojo.NodeList, many types of DOM
	manipulation operations become very straightforward.
	Unsupported Selectors:
	----------------------
	While dojo.query handles many CSS3 selectors, some fall outside of
	what's resaonable for a programmatic node querying engine to
	handle. Currently unsupported selectors include:
	* namespace-differentiated selectors of any form
	* all `::` pseduo-element selectors
	* certain pseduo-selectors which don't get a lot of day-to-day use:
		* `:root`, `:lang()`, `:target`, `:focus`
	* all visual and state selectors:
		* `:root`, `:active`, `:hover`, `:visisted`, `:link`,
	`:enabled`, `:disabled`
	* `:*-of-type` pseudo selectors
	dojo.query and XML Documents:
	-----------------------------
	`dojo.query` (as of dojo 1.2) supports searching XML documents
	in a case-sensitive manner. If an HTML document is served with
	a doctype that forces case-sensitivity (e.g., XHTML 1.1
	Strict), dojo.query() will detect this and "do the right
	thing". Case sensitivity is dependent upon the document being
	searched and not the query used. It is therefore possible to
	use case-sensitive queries on strict sub-documents (iframes,
	etc.) or XML documents while still assuming case-insensitivity
	for a host/root document.
	Non-selector Queries:
	---------------------
	If something other than a String is passed for the query,
	`dojo.query` will return a new `dojo.NodeList` instance
	constructed from that parameter alone and all further
	processing will stop. This means that if you have a reference
	to a node or NodeList, you can quickly construct a new NodeList
	from the original by calling `dojo.query(node)` or
	`dojo.query(list)`.</description>
        <return-description>dojo.NodeList
	An instance of `dojo.NodeList`. Many methods are available on
	NodeLists for searching, iterating, manipulating, and handling
	events on the matched nodes in the returned list.</return-description>
        <examples>
          <example>search the entire document for elements with the class "foo":
		dojo.query(".foo");
	these elements will match:
		&lt;span class="foo"&gt;&lt;/span&gt;
		&lt;span class="foo bar"&gt;&lt;/span&gt;
		&lt;p class="thud foo"&gt;&lt;/p&gt;</example>
          <example>search the entire document for elements with the classes "foo" *and* "bar":
		dojo.query(".foo.bar");
	these elements will match:
		&lt;span class="foo bar"&gt;&lt;/span&gt;
	while these will not:
		&lt;span class="foo"&gt;&lt;/span&gt;
		&lt;p class="thud foo"&gt;&lt;/p&gt;</example>
          <example>find `&lt;span&gt;` elements which are descendants of paragraphs and
	which have a "highlighted" class:
		dojo.query("p span.highlighted");
	the innermost span in this fragment matches:
		&lt;p class="foo"&gt;
			&lt;span&gt;...
				&lt;span class="highlighted foo bar"&gt;...&lt;/span&gt;
			&lt;/span&gt;
		&lt;/p&gt;</example>
          <example>set an "odd" class on all odd table rows inside of the table
	`#tabular_data`, using the `&gt;` (direct child) selector to avoid
	affecting any nested tables:
		dojo.query("#tabular_data &gt; tbody &gt; tr:nth-child(odd)").addClass("odd");</example>
          <example>remove all elements with the class "error" from the document
	and store them in a list:
		var errors = dojo.query(".error").orphan();</example>
          <example>add an onclick handler to every submit button in the document
	which causes the form to be sent via Ajax instead:
		dojo.query("input[type='submit']").onclick(function(e){
			dojo.stopEvent(e); // prevent sending the form
			var btn = e.target;
			dojo.xhrPost({
				form: btn.form,
				load: function(data){
					// replace the form with the response
					var div = dojo.doc.createElement("div");
					dojo.place(div, btn.form, "after");
					div.innerHTML = data;
					dojo.style(btn.form, "display", "none");
				}
			});
		});</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <summary>The CSS3 expression to match against. For details on the syntax of
	CSS3 selectors, see &amp;lt;http://www.w3.org/TR/css3-selectors/#selectors&amp;gt;</summary>
          </parameter>
          <parameter name="root" type="String|DOMNode" usage="optional">
            <summary>A DOMNode (or node id) to scope the search from. Optional.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.NodeList"/>
        </return-types>
      </method>
      <method name="_filterQueryResult" scope="normal">
        <parameters>
          <parameter name="nodeList" type="" usage="required"/>
          <parameter name="simpleFilter" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.__XhrArgs" type="Function" classlike="true" superclass="dojo.__IoArgs" private="true">
    <summary>In addition to the properties listed for the dojo._IoArgs type,
	the following properties are allowed for dojo.xhr* methods.</summary>
    <mixins>
      <mixin scope="instance" location="dojo.__IoArgs"/>
    </mixins>
    <properties>
      <property name="handleAs" scope="instance" type="String">
        <summary>Acceptable values are: text (default), json, json-comment-optional,
	json-comment-filtered, javascript, xml. See &lt;code&gt;dojo.contentHandlers&lt;/code&gt;</summary>
      </property>
      <property name="sync" scope="instance" type="Boolean">
        <summary>false is default. Indicates whether the request should
	be a synchronous (blocking) request.</summary>
      </property>
      <property name="headers" scope="instance" type="Object">
        <summary>Additional HTTP headers to send in the request.</summary>
      </property>
      <property name="failOk" scope="instance" type="Boolean">
        <summary>false is default. Indicates whether a request should be
	allowed to fail (and therefore no console error message in
	the event of a failure)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>In addition to the properties listed for the dojo._IoArgs type,
	the following properties are allowed for dojo.xhr* methods.</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.contentHandlers">
    <summary>A map of availble XHR transport handle types. Name matches the
	&lt;code&gt;handleAs&lt;/code&gt; attribute passed to XHR calls.</summary>
    <description>A map of availble XHR transport handle types. Name matches the
	`handleAs` attribute passed to XHR calls. Each contentHandler is
	called, passing the xhr object for manipulation. The return value
	from the contentHandler will be passed to the `load` or `handle`
	functions defined in the original xhr call.</description>
    <examples>
      <example>Creating a custom content-handler:
		dojo.contentHandlers.makeCaps = function(xhr){
			return xhr.responseText.toUpperCase();
		}
		// and later:
		dojo.xhrGet({
			url:"foo.txt",
			handleAs:"makeCaps",
			load: function(data){ /* data is a toUpper version of foo.txt */ }
		});</example>
    </examples>
    <methods>
      <method name="text" scope="normal">
        <summary>A contentHandler which simply returns the plaintext response data</summary>
        <parameters>
          <parameter name="xhr" type="" usage="required"/>
        </parameters>
      </method>
      <method name="json" scope="normal">
        <summary>A contentHandler which returns a JavaScript object created from the response data</summary>
        <parameters>
          <parameter name="xhr" type="" usage="required"/>
        </parameters>
      </method>
      <method name="json-comment-filtered" scope="normal">
        <summary>A contentHandler which expects comment-filtered JSON.</summary>
        <description>A contentHandler which expects comment-filtered JSON.
	the json-comment-filtered option was implemented to prevent
	"JavaScript Hijacking", but it is less secure than standard JSON. Use
	standard JSON instead. JSON prefixing can be used to subvert hijacking.
	Will throw a notice suggesting to use application/json mimetype, as
	json-commenting can introduce security issues. To decrease the chances of hijacking,
	use the standard `json` contentHandler, and prefix your "JSON" with: {}&amp;&amp;
	use djConfig.useCommentedJson = true to turn off the notice</description>
        <parameters>
          <parameter name="xhr" type="" usage="required"/>
        </parameters>
      </method>
      <method name="javascript" scope="normal">
        <summary>A contentHandler which evaluates the response data, expecting it to be valid JavaScript</summary>
        <parameters>
          <parameter name="xhr" type="" usage="required"/>
        </parameters>
      </method>
      <method name="xml" scope="normal">
        <summary>A contentHandler returning an XML Document parsed from the response data</summary>
        <parameters>
          <parameter name="xhr" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
        </return-types>
      </method>
      <method name="json-comment-optional" scope="normal">
        <summary>A contentHandler which checks the presence of comment-filtered JSON and
	alternates between the &lt;code&gt;json&lt;/code&gt; and &lt;code&gt;json-comment-filtered&lt;/code&gt; contentHandlers.</summary>
        <parameters>
          <parameter name="xhr" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.__IoArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="url" scope="instance" type="String">
        <summary>URL to server endpoint.</summary>
      </property>
      <property name="content" scope="instance" type="Object">
        <summary>Contains properties with string values. These
	properties will be serialized as name1=value2 and
	passed in the request.</summary>
      </property>
      <property name="timeout" scope="instance" type="Integer">
        <summary>Milliseconds to wait for the response. If this time
	passes, the then error callbacks are called.</summary>
      </property>
      <property name="form" scope="instance" type="DOMNode">
        <summary>DOM node for a form. Used to extract the form values
	and send to the server.</summary>
      </property>
      <property name="preventCache" scope="instance" type="Boolean">
        <summary>Default is false. If true, then a
	&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
	with a value that changes with each request
	(timestamp). Useful only with GET-type requests.</summary>
      </property>
      <property name="handleAs" scope="instance" type="String">
        <summary>Acceptable values depend on the type of IO
	transport (see specific IO calls for more information).
	rawBody: String?
	Sets the raw body for an HTTP request. If this is used, then the content
	property is ignored. This is mostly useful for HTTP methods that have
	a body to their requests, like PUT or POST. This property can be used instead
	of postData and putData for dojo.rawXhrPost and dojo.rawXhrPut respectively.</summary>
      </property>
      <property name="ioPublish" scope="instance" type="Boolean">
        <summary>Set this explicitly to false to prevent publishing of topics related to
	IO operations. Otherwise, if djConfig.ioPublish is set to true, topics
	will be published via dojo.publish for different phases of an IO operation.
	See dojo.__IoPublish for a list of topics that are published.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="load" scope="instance">
        <summary>This function will be
	called on a successful HTTP response code.</summary>
        <parameters>
          <parameter name="response" type="Object" usage="required">
            <summary>The response in the format as defined with handleAs.</summary>
          </parameter>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required">
            <summary>Provides additional information about the request.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="error" scope="instance">
        <summary>This function will
	be called when the request fails due to a network or server error, the url
	is invalid, etc. It will also be called if the load or handle callback throws an
	exception, unless djConfig.debugAtAllCosts is true.  This allows deployed applications
	to continue to run even when a logic error happens in the callback, while making
	it easier to troubleshoot while in debug mode.</summary>
        <parameters>
          <parameter name="response" type="Object" usage="required">
            <summary>The response in the format as defined with handleAs.</summary>
          </parameter>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required">
            <summary>Provides additional information about the request.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="handle" scope="instance">
        <summary>This function will
	be called at the end of every request, whether or not an error occurs.</summary>
        <parameters>
          <parameter name="loadOrError" type="String" usage="required">
            <summary>Provides a string that tells you whether this function
	was called because of success (load) or failure (error).</summary>
          </parameter>
          <parameter name="response" type="Object" usage="required">
            <summary>The response in the format as defined with handleAs.</summary>
          </parameter>
          <parameter name="ioArgs" type="dojo.__IoCallbackArgs" usage="required">
            <summary>Provides additional information about the request.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.__IoCallbackArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="args" scope="instance" type="Object">
        <summary>the original object argument to the IO call.</summary>
      </property>
      <property name="xhr" scope="instance" type="XMLHttpRequest">
        <summary>For XMLHttpRequest calls only, the
	XMLHttpRequest object that was used for the
	request.</summary>
      </property>
      <property name="url" scope="instance" type="String">
        <summary>The final URL used for the call. Many times it
	will be different than the original args.url
	value.</summary>
      </property>
      <property name="query" scope="instance" type="String">
        <summary>For non-GET requests, the
	name1=value1&amp;amp;name2=value2 parameters sent up in
	the request.</summary>
      </property>
      <property name="handleAs" scope="instance" type="String">
        <summary>The final indicator on how the response will be
	handled.</summary>
      </property>
      <property name="id" scope="instance" type="String">
        <summary>For dojo.io.script calls only, the internal
	script ID used for the request.</summary>
      </property>
      <property name="canDelete" scope="instance" type="Boolean">
        <summary>For dojo.io.script calls only, indicates
	whether the script tag that represents the
	request can be deleted after callbacks have
	been called. Used internally to know when
	cleanup can happen on JSONP-type requests.</summary>
      </property>
      <property name="json" scope="instance" type="Object">
        <summary>For dojo.io.script calls only: holds the JSON
	response for JSONP-type requests. Used
	internally to hold on to the JSON responses.
	You should not need to access it directly --
	the same object should be passed to the success
	callbacks directly.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>the original object argument to the IO call.</summary>
          </parameter>
          <parameter name="xhr" type="XMLHttpRequest" usage="required">
            <summary>For XMLHttpRequest calls only, the
	XMLHttpRequest object that was used for the
	request.</summary>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <summary>The final URL used for the call. Many times it
	will be different than the original args.url
	value.</summary>
          </parameter>
          <parameter name="query" type="String" usage="required">
            <summary>For non-GET requests, the
	name1=value1&amp;amp;name2=value2 parameters sent up in
	the request.</summary>
          </parameter>
          <parameter name="handleAs" type="String" usage="required">
            <summary>The final indicator on how the response will be
	handled.</summary>
          </parameter>
          <parameter name="id" type="String" usage="required">
            <summary>For dojo.io.script calls only, the internal
	script ID used for the request.</summary>
          </parameter>
          <parameter name="canDelete" type="Boolean" usage="required">
            <summary>For dojo.io.script calls only, indicates
	whether the script tag that represents the
	request can be deleted after callbacks have
	been called. Used internally to know when
	cleanup can happen on JSONP-type requests.</summary>
          </parameter>
          <parameter name="json" type="Object" usage="required">
            <summary>For dojo.io.script calls only: holds the JSON
	response for JSONP-type requests. Used
	internally to hold on to the JSON responses.
	You should not need to access it directly --
	the same object should be passed to the success
	callbacks directly.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.__IoPublish" type="Function" classlike="true" private="true">
    <summary>This is a list of IO topics that can be published
	if djConfig.ioPublish is set to true. IO topics can be
	published for any Input/Output, network operation. So,
	dojo.xhr, dojo.io.script and dojo.io.iframe can all
	trigger these topics to be published.</summary>
    <properties>
      <property name="start" scope="instance" type="String">
        <summary>&amp;quot;/dojo/io/start&amp;quot; is sent when there are no outstanding IO
	requests, and a new IO request is started. No arguments
	are passed with this topic.</summary>
      </property>
      <property name="send" scope="instance" type="String">
        <summary>&amp;quot;/dojo/io/send&amp;quot; is sent whenever a new IO request is started.
	It passes the dojo.Deferred for the request with the topic.</summary>
      </property>
      <property name="load" scope="instance" type="String">
        <summary>&amp;quot;/dojo/io/load&amp;quot; is sent whenever an IO request has loaded
	successfully. It passes the response and the dojo.Deferred
	for the request with the topic.</summary>
      </property>
      <property name="error" scope="instance" type="String">
        <summary>&amp;quot;/dojo/io/error&amp;quot; is sent whenever an IO request has errored.
	It passes the error and the dojo.Deferred
	for the request with the topic.</summary>
      </property>
      <property name="done" scope="instance" type="String">
        <summary>&amp;quot;/dojo/io/done&amp;quot; is sent whenever an IO request has completed,
	either by loading or by erroring. It passes the error and
	the dojo.Deferred for the request with the topic.</summary>
      </property>
      <property name="stop" scope="instance" type="String">
        <summary>&amp;quot;/dojo/io/stop&amp;quot; is sent when all outstanding IO requests have
	finished. No arguments are passed with this topic.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="window.console">
    <properties>
      <property name="_connects" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method name="log" scope="normal">
        <summary>Sends arguments to console.</summary>
      </method>
      <method name="debug" scope="normal">
        <summary>Sends arguments to console. Missing finctionality to show script line of trace.</summary>
      </method>
      <method name="info" scope="normal">
        <summary>Sends arguments to console, highlighted with (I) icon.</summary>
      </method>
      <method name="warn" scope="normal">
        <summary>Sends warning arguments to console, highlighted with (!) icon and blue style.</summary>
      </method>
      <method name="error" scope="normal">
        <summary>Sends error arguments (object) to console, highlighted with (X) icon and yellow style
	NEW: error object now displays in object inspector</summary>
      </method>
      <method name="assert" scope="normal">
        <summary>Tests for true. Throws exception if false.</summary>
        <parameters>
          <parameter name="truth" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dir" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dirxml" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="group" scope="normal">
        <summary>collects log messages into a group, starting with this call and ending with
	groupEnd(). Missing collapse functionality</summary>
      </method>
      <method name="groupEnd" scope="normal">
        <summary>Closes group. See above</summary>
      </method>
      <method name="time" scope="normal">
        <summary>Starts timers assigned to name given in argument. Timer stops and displays on timeEnd(title);</summary>
        <examples>
          <example>	console.time("load");
		console.time("myFunction");
		console.timeEnd("load");
		console.timeEnd("myFunction");</example>
        </examples>
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
      </method>
      <method name="timeEnd" scope="normal">
        <summary>See above.</summary>
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
      </method>
      <method name="count" scope="normal">
        <summary>Not supported</summary>
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
      </method>
      <method name="trace" scope="normal">
        <parameters>
          <parameter name="_value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="profile" scope="normal">
        <summary>Not supported</summary>
      </method>
      <method name="profileEnd" scope="normal"/>
      <method name="clear" scope="normal">
        <summary>Clears message console. Do not call this directly</summary>
      </method>
      <method name="open" scope="normal">
        <summary>Opens message console. Do not call this directly</summary>
      </method>
      <method name="close" scope="normal">
        <summary>Closes message console. Do not call this directly</summary>
      </method>
      <method name="_restoreBorder" scope="normal"/>
      <method name="openDomInspector" scope="normal"/>
      <method name="_closeDomInspector" scope="normal"/>
      <method name="openConsole" scope="normal">
        <summary>Closes object inspector and opens message console. Do not call this directly</summary>
      </method>
      <method name="openObjectInspector" scope="normal"/>
      <method name="recss" scope="normal"/>
    </methods>
  </object>
  <object location="dojo._firebug" private="true">
    <properties>
      <property name="firebug" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojo.back">
    <properties>
      <property name="getHash" scope="normal" type=""/>
      <property name="setHash" scope="normal" type=""/>
      <property name="goBack" scope="normal" type=""/>
      <property name="goForward" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="init" scope="normal">
        <summary>Initializes the undo stack. This must be called from a &amp;lt;script&amp;gt;
	block that lives inside the &amp;lt;body&amp;gt; tag to prevent bugs on IE.</summary>
        <description>Only call this method before the page's DOM is finished loading. Otherwise
	it will not work. Be careful with xdomain loading or djConfig.debugAtAllCosts scenarios,
	in order for this method to work, dojo.back will need to be part of a build layer.</description>
        <return-types>
          <return-type type="prevent reinit"/>
        </return-types>
      </method>
      <method name="setInitialState" scope="normal">
        <summary>Sets the state object and back callback for the very first page
	that is loaded.</summary>
        <description>It is recommended that you call this method as part of an event
	listener that is registered via dojo.addOnLoad().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>See the addToHistory() function for the list of valid args properties.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addToHistory" scope="normal">
        <summary>adds a state object (args) to the history list.</summary>
        <description>To support getting back button notifications, the object
	argument should implement a function called either "back",
	"backButton", or "handle". The string "back" will be passed as
	the first and only argument to this callback.
	To support getting forward button notifications, the object
	argument should implement a function called either "forward",
	"forwardButton", or "handle". The string "forward" will be
	passed as the first and only argument to this callback.
	If you want the browser location string to change, define "changeUrl" on the object. If the
	value of "changeUrl" is true, then a unique number will be appended to the URL as a fragment
	identifier (http://some.domain.com/path#uniquenumber). If it is any other value that does
	not evaluate to false, that value will be used as the fragment identifier. For example,
	if changeUrl: 'page1', then the URL will look like: http://some.domain.com/path#page1</description>
        <examples>
          <example>	dojo.back.addToHistory({
			back: function(){ console.log('back pressed'); },
			forward: function(){ console.log('forward pressed'); },
			changeUrl: true
		});</example>
        </examples>
        <parameters>
          <parameter name="args" type="dojo.__backArgs" usage="required"/>
        </parameters>
      </method>
      <method name="_iframeLoaded" scope="normal">
        <summary>private method. Do not call this directly.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
          <parameter name="ifrLoc" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="window.frames" type="">
    <properties>
      <property name="dj_history" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojo.behavior" type="Function" classlike="true">
    <summary>Utility for unobtrusive/progressive event binding, DOM traversal,
	and manipulation.</summary>
    <description>A very simple, lightweight mechanism for applying code to
	existing documents, based around `dojo.query` (CSS3 selectors) for node selection,
	and a simple two-command API: `dojo.behavior.add()` and `dojo.behavior.apply()`;
	Behaviors apply to a given page, and are registered following the syntax
	options described by `dojo.behavior.add` to match nodes to actions, or "behaviors".
	Added behaviors are applied to the current DOM when .apply() is called,
	matching only new nodes found since .apply() was last called.</description>
    <properties>
      <property name="_behaviors" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="add" scope="instance">
        <summary>Add the specified behavior to the list of behaviors, ignoring existing
	matches.</summary>
        <description>Add the specified behavior to the list of behaviors which will
	be applied the next time apply() is called. Calls to add() for
	an already existing behavior do not replace the previous rules,
	but are instead additive. New nodes which match the rule will
	have all add()-ed behaviors applied to them when matched.
	The "found" method is a generalized handler that's called as soon
	as the node matches the selector. Rules for values that follow also
	apply to the "found" key.
	The "on*" handlers are attached with `dojo.connect()`, using the
	matching node
	If the value corresponding to the ID key is a function and not a
	list, it's treated as though it was the value of "found".
	dojo.behavior.add() can be called any number of times before
	the DOM is ready. `dojo.behavior.apply()` is called automatically
	by `dojo.addOnLoad`, though can be called to re-apply previously added
	behaviors anytime the DOM changes.
	There are a variety of formats permitted in the behaviorObject</description>
        <examples>
          <example>Simple list of properties. "found" is special. "Found" is assumed if
	no property object for a given selector, and property is a function.
		dojo.behavior.add({
			"#id": {
				"found": function(element){
					// node match found
				},
				"onclick": function(evt){
					// register onclick handler for found node
				}
			},
			"#otherid": function(element){
				// assumes "found" with this syntax
			}
		});</example>
          <example>If property is a string, a dojo.publish will be issued on the channel:
		dojo.behavior.add({
			// dojo.publish() whenever class="noclick" found on anchors
			"a.noclick": "/got/newAnchor",
			"div.wrapper": {
				"onclick": "/node/wasClicked"
			}
		});
		dojo.subscribe("/got/newAnchor", function(node){
			// handle node finding when dojo.behavior.apply() is called,
			// provided a newly matched node is found.
		});</example>
          <example>Scoping can be accomplished by passing an object as a property to
	a connection handle (on*):
		dojo.behavior.add({
			 	"#id": {
					// like calling dojo.hitch(foo,"bar"). execute foo.bar() in scope of foo
					"onmouseenter": { targetObj: foo, targetFunc: "bar" },
					"onmouseleave": { targetObj: foo, targetFunc: "baz" }
				}
		});</example>
          <example>Bahaviors match on CSS3 Selectors, powered by dojo.query. Example selectors:
		dojo.behavior.add({
			// match all direct descendants
			"#id4 &gt; *": function(element){
				// ...
			},
			// match the first child node that's an element
			"#id4 &gt; :first-child": { ... },
			// match the last child node that's an element
			"#id4 &gt; :last-child":  { ... },
			// all elements of type tagname
			"tagname": {
				// ...
			},
			"tagname1 tagname2 tagname3": {
				// ...
			},
			".classname": {
				// ...
			},
			"tagname.classname": {
				// ...
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="behaviorObj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="instance">
        <summary>Applies all currently registered behaviors to the document.</summary>
        <description>Applies all currently registered behaviors to the document,
	taking care to ensure that only incremental updates are made
	since the last time add() or apply() were called.
	If new matching nodes have been added, all rules in a behavior will be
	applied to that node. For previously matched nodes, only
	behaviors which have been added since the last call to apply()
	will be added to the nodes.
	apply() is called once automatically by `dojo.addOnLoad`, so
	registering behaviors with `dojo.behavior.add` before the DOM is
	ready is acceptable, provided the dojo.behavior module is ready.
	Calling appy() manually after manipulating the DOM is required
	to rescan the DOM and apply newly .add()ed behaviors, or to match
	nodes that match existing behaviors when those nodes are added to
	the DOM.</description>
      </method>
    </methods>
  </object>
  <object location="dojo.cache" type="Function">
    <summary>A getter and setter for storing the string content associated with the
	module and url arguments.</summary>
    <description>module and url are used to call `dojo.moduleUrl()` to generate a module URL.
	If value is specified, the cache value for the moduleUrl will be set to
	that value. Otherwise, dojo.cache will fetch the moduleUrl and store it
	in its internal cache and return that cached value for the URL. To clear
	a cache value pass null for value. Since XMLHttpRequest (XHR) is used to fetch the
	the URL contents, only modules on the same domain of the page can use this capability.
	The build system can inline the cache values though, to allow for xdomain hosting.</description>
    <examples>
      <example>To ask dojo.cache to fetch content and store it in the cache (the dojo["cache"] style
	of call is used to avoid an issue with the build system erroneously trying to intern
	this example. To get the build system to intern your dojo.cache calls, use the
	"dojo.cache" style of call):
		//If template.html contains "&lt;h1&gt;Hello&lt;/h1&gt;" that will be
		//the value for the text variable.
		var text = dojo["cache"]("my.module", "template.html");</example>
      <example>To ask dojo.cache to fetch content and store it in the cache, and sanitize the input
	(the dojo["cache"] style of call is used to avoid an issue with the build system
	erroneously trying to intern this example. To get the build system to intern your
	dojo.cache calls, use the "dojo.cache" style of call):
		//If template.html contains "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;", the
		//text variable will contain just "&lt;h1&gt;Hello&lt;/h1&gt;".
		var text = dojo["cache"]("my.module", "template.html", {sanitize: true});</example>
      <example>Same example as previous, but demostrates how an object can be passed in as
	the first argument, then the value argument can then be the second argument.
		//If template.html contains "&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;", the
		//text variable will contain just "&lt;h1&gt;Hello&lt;/h1&gt;".
		var text = dojo["cache"](new dojo._Url("my/module/template.html"), {sanitize: true});</example>
    </examples>
    <methods>
      <method name="_sanitize" scope="normal">
        <summary>Strips &amp;lt;?xml ...?&amp;gt; declarations so that external SVG and XML
	documents can be added to a document without worry. Also, if the string
	is an HTML document, only the part inside the body tag is returned.</summary>
        <description>Copied from dijit._Templated._sanitizeTemplateString.</description>
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.cldr.monetary">
    <methods>
      <method name="getData" scope="normal">
        <summary>A mapping of currency code to currency-specific formatting information. Returns a unique object with properties: places, round.</summary>
        <parameters>
          <parameter name="code" type="String" usage="required">
            <summary>an [ISO 4217](http://en.wikipedia.org/wiki/ISO_4217) currency code</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.cldr">
    <summary>transformation of relevant pieces of the Unicode.org Common Locale Data Repository
	(see http://unicode.org/cldr) to JSON from the original XML with associated utility classes</summary>
  </object>
  <object location="dojo.cldr.supplemental">
    <methods>
      <method name="getFirstDayOfWeek" scope="normal">
        <summary>Returns a zero-based index for first day of the week</summary>
        <description>Returns a zero-based index for first day of the week, as used by the local (Gregorian) calendar.
	e.g. Sunday (returns 0), or Monday (returns 1)</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_region" scope="normal">
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getWeekend" scope="normal">
        <summary>Returns a hash containing the start and end days of the weekend</summary>
        <description>Returns a hash containing the start and end days of the weekend according to local custom using locale,
	or by default in the user's locale.
	e.g. {start:6, end:0}</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.colors">
    <methods>
      <method name="makeGrey" scope="normal">
        <summary>creates a greyscale color with an optional alpha</summary>
        <parameters>
          <parameter name="g" type="Number" usage="required"/>
          <parameter name="a" type="Number" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.__cookieProps" type="Function" classlike="true" private="true">
    <properties>
      <property name="expires" scope="instance" type="Date|String|Number">
        <summary>If a number, the number of days from today at which the cookie
	will expire. If a date, the date past which the cookie will expire.
	If expires is in the past, the cookie will be deleted.
	If expires is omitted or is 0, the cookie will expire when the browser closes. &amp;lt;&amp;lt; FIXME: 0 seems to disappear right away? FF3.</summary>
      </property>
      <property name="path" scope="instance" type="String">
        <summary>The path to use for the cookie.</summary>
      </property>
      <property name="domain" scope="instance" type="String">
        <summary>The domain to use for the cookie.</summary>
      </property>
      <property name="secure" scope="instance" type="Boolean">
        <summary>Whether to only send the cookie on secure connections</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.cookie" type="Function">
    <summary>Get or set a cookie.</summary>
    <description>If one argument is passed, returns the value of the cookie
	For two or more arguments, acts as a setter.</description>
    <examples>
      <example>set a cookie with the JSON-serialized contents of an object which
	will expire 5 days from now:
		dojo.cookie("configObj", dojo.toJson(config), { expires: 5 });</example>
      <example>de-serialize a cookie back into a JavaScript object:
		var config = dojo.fromJson(dojo.cookie("configObj"));</example>
      <example>delete a cookie:
		dojo.cookie("configObj", null, {expires: -1});</example>
    </examples>
    <methods>
      <method name="isSupported" scope="normal">
        <summary>Use to determine if the current browser supports cookies or not.
	Returns true if user allows cookies.
	Returns false if user doesn't allow cookies.</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.currency">
    <summary>localized formatting and parsing routines for currencies</summary>
    <methods>
      <method name="_mixInDefaults" scope="normal">
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="normal">
        <summary>Format a Number as a currency, using locale-specific settings</summary>
        <description>Create a string from a Number using a known, localized pattern.
	[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Elements) appropriate to the locale are chosen from the [CLDR](http://unicode.org/cldr)
	as well as the appropriate symbols and delimiters.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <summary>the number to be formatted.</summary>
          </parameter>
          <parameter name="options" type="dojo.currency.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="regexp" scope="normal">
        <summary>Builds the regular needed to parse a currency value</summary>
        <description>Returns regular expression with positive and negative match, group and decimal separators
	Note: the options.places default, the number of decimal places to accept, is defined by the currency type.</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parse" scope="normal">
        <summary>Convert a properly formatted currency string to a primitive Number,
	using locale-specific settings.</summary>
        <description>Create a Number from a string using a known, localized pattern.
	[Formatting patterns](http://www.unicode.org/reports/tr35/#Number_Format_Patterns) are chosen appropriate to the locale.</description>
        <parameters>
          <parameter name="expression" type="String" usage="required">
            <summary>A string representation of a Number</summary>
          </parameter>
          <parameter name="options" type="dojo.currency.__ParseOptions" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.currency.__FormatOptions" type="Function" classlike="true" superclass="dojo.number.__FormatOptions" private="true">
    <mixins>
      <mixin scope="instance" location="dojo.number.__FormatOptions"/>
    </mixins>
    <properties>
      <property name="type" scope="prototype" type="String">
        <summary>Should not be set.  Value is assumed to be currency.
	currency: String?
	an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like &amp;quot;USD&amp;quot;.
	For use with dojo.currency only.</summary>
      </property>
      <property name="symbol" scope="prototype" type="String">
        <summary>localized currency symbol. The default will be looked up in table of supported currencies in &lt;code&gt;dojo.cldr&lt;/code&gt;
	A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.</summary>
      </property>
      <property name="places" scope="prototype" type="Number">
        <summary>number of decimal places to show.  Default is defined based on which currency is used.</summary>
      </property>
      <property name="fractional" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.currency.__ParseOptions" type="Function" classlike="true" superclass="dojo.number.__ParseOptions" private="true">
    <mixins>
      <mixin scope="instance" location="dojo.number.__ParseOptions"/>
    </mixins>
    <properties>
      <property name="type" scope="prototype" type="String">
        <summary>Should not be set.  Value is assumed to be currency.
	currency: String?
	an [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code, a three letter sequence like &amp;quot;USD&amp;quot;.
	For use with dojo.currency only.</summary>
      </property>
      <property name="symbol" scope="prototype" type="String">
        <summary>localized currency symbol. The default will be looked up in table of supported currencies in &lt;code&gt;dojo.cldr&lt;/code&gt;
	A [ISO4217](http://en.wikipedia.org/wiki/ISO_4217) currency code will be used if not found.</summary>
      </property>
      <property name="places" scope="prototype" type="Number">
        <summary>number of decimal places to accept.  Default is defined based on which currency is used.</summary>
      </property>
      <property name="fractional" scope="prototype" type="Boolean|Array">
        <summary>Whether to include the fractional portion, where the number of decimal places are implied by pattern
	or explicit 'places' parameter.  By default for currencies, it the fractional portion is optional.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.data">
    <summary>A uniform data access layer</summary>
  </object>
  <object location="dojo.data.ItemFileReadStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>The ItemFileReadStore implements the dojo.data.api.Read API and reads
	data from JSON files that have contents in this format --
	{ items: [
	{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	{ name:'Fozzie Bear', wears:['hat', 'tie']},
	{ name:'Miss Piggy', pets:'Foo-Foo'}
	]}
	Note that it can also contain an 'identifer' property that specified which attribute on the items
	in the array of items that acts as the unique identifier for that item.
	use &amp;quot;&amp;quot; rather than undefined for the benefit of the parser (#3539)</summary>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="_ccUrl" scope="instance-prototype" type="String"/>
      <property name="data" scope="instance-prototype" type="Object"/>
      <property name="typeMap" scope="prototype" type="Object"/>
      <property name="clearOnClose" scope="instance-prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="failOk" scope="instance-prototype" type="bool"/>
      <property name="hierarchical" scope="instance-prototype" type="Object"/>
      <property name="_jsonFileUrl" scope="instance-prototype" type=""/>
      <property name="_jsonData" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfTopLevelItems" scope="instance-prototype" type="Array"/>
      <property name="_itemsByIdentity" scope="instance-prototype" type="Object"/>
      <property name="_labelAttr" scope="prototype" type=""/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_storeRefPropName" scope="instance" type="String"/>
      <property name="_itemNumPropName" scope="instance" type="String"/>
      <property name="_rootItemPropName" scope="instance" type="String"/>
      <property name="_reverseRefMap" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>constructor</summary>
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <summary>Internal function for looking at the values contained by the item.</summary>
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The data item to examine for attribute values.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to inspect.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match.</summary>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <summary>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>See dojo.data.util.simpleFetch.fetch()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <summary>Internal function to execute delayed request in the store.
	Execute any deferred fetches now.</summary>
      </method>
      <method name="_getItemsArray" scope="prototype">
        <summary>Internal function to determine which list of items to search over.</summary>
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <summary>The query options parameter, if any.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getItemsFromLoadedData" scope="prototype">
        <summary>Function to parse the loaded data into item format and build the internal items array.</summary>
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <return-description>array
	Array of items in store item format.</return-description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required">
            <summary>The JS data object containing the raw data to convery into item format.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addReferenceToMap" scope="prototype">
        <summary>Method to add an reference map entry for an item and attribute.</summary>
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <summary>The item that is referenced.</summary>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <summary>The item that holds the new reference to refItem.</summary>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <summary>The attribute on parentItem that contains the new reference.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object"/>
          <return-type type=""/>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="prototype">
        <summary>Internal function to look an item up by its identity map.</summary>
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentifierAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="prototype">
        <summary>Internal function to force a load of the store if it hasn't occurred yet.  This is required
	for specific functions to work properly.</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.data.ItemFileReadStore._features.dojo.data.api" type="">
    <properties>
      <property name="Identity" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojo.data.ItemFileReadStore._datatypeMap" private="true">
    <properties>
      <property name="Date" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojo.data.ItemFileWriteStore" type="Function" classlike="true" superclass="dojo.data.ItemFileReadStore">
    <mixins>
      <mixin scope="instance" location="dojo.data.ItemFileReadStore"/>
    </mixins>
    <properties>
      <property name="referenceIntegrity" scope="instance-prototype" type="bool"/>
      <property name="_saveInProgress" scope="instance-prototype" type="bool"/>
      <property name="_pending" scope="instance-prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <summary>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <summary>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assert" scope="prototype">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getIdentifierAttribute" scope="prototype"/>
      <method name="newItem" scope="prototype">
        <summary>See dojo.data.api.Write.newItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="_removeArrayElement" scope="prototype">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="prototype">
        <summary>See dojo.data.api.Write.deleteItem()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>See dojo.data.api.Write.set()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <summary>anything</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="prototype">
        <summary>See dojo.data.api.Write.setValues()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <summary>See dojo.data.api.Write.unsetAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="prototype">
        <summary>Method to add an reference map entry for an item and attribute.</summary>
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <summary>The item that is referenced.</summary>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <summary>The item that holds the new reference to refItem.</summary>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <summary>The attribute on parentItem that contains the new reference.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_removeReferenceFromMap" scope="prototype">
        <summary>Method to remove an reference map entry for an item and attribute.</summary>
        <description>Method to remove an reference map entry for an item and attribute.  This will
	also perform cleanup on the map such that if there are no more references at all to
	the item, its reference object and entry are removed.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <summary>The item that is referenced.</summary>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <summary>The item holding a reference to refItem.</summary>
          </parameter>
          <parameter name="attribute" type="strin" usage="required">
            <summary>The attribute on parentItem that contains the reference.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="prototype">
        <summary>Function to dump the reverse reference map of all items in the store for debug purposes.</summary>
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_getValueOrValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_flatten" scope="prototype">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="prototype">
        <summary>Generate a string that can be saved to a file.
	The result should look similar to:
	http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json</summary>
      </method>
      <method name="_isEmpty" scope="prototype">
        <summary>Function to determine if an array or object has no properties or values.</summary>
        <parameters>
          <parameter name="something" type="The" usage="required">
            <summary>array or object to examine.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <summary>See dojo.data.api.Write.save()</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="prototype">
        <summary>See dojo.data.api.Write.revert()</summary>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="prototype">
        <summary>See dojo.data.api.Write.isDirty()</summary>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="prototype">
        <summary>See dojo.data.api.Notification.onSet()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <summary>| array</summary>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <summary>| array</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onNew" scope="prototype">
        <summary>See dojo.data.api.Notification.onNew()</summary>
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="prototype">
        <summary>See dojo.data.api.Notification.onDelete()</summary>
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>Over-ride of base close function of ItemFileReadStore to add in check for store state.</summary>
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.
	If the store is still dirty (unsaved changes), then an error will be thrown instead of
	clearing the internal state for reload from the url.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.data.ItemFileWriteStore._features.dojo.data.api" type="">
    <properties>
      <property name="Write" scope="instance" type="Object"/>
      <property name="Notification" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojo.data.ItemFileWriteStore._datatypeMap.Date" type="">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.data.api"/>
  <object location="dojo.data.api.Identity" type="Function" classlike="true" superclass="dojo.data.api.Read">
    <summary>This is an abstract API that data provider implementations conform to.
	This file defines methods signatures and intentionally leaves all the
	methods unimplemented.</summary>
    <mixins>
      <mixin scope="instance" location="dojo.data.api.Read"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>Returns a unique identifier for an item.  The return value will be
	either a string or something that has a toString() method (such as,
	for example, a dojox.uuid.Uuid object).</summary>
        <examples>
          <example>	var itemId = store.getIdentity(kermit);
		assert(kermit === store.findByIdentity(store.getIdentity(kermit)));</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item from the store from which to obtain its identifier.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>Returns an array of attribute names that are used to generate the identity.
	For most stores, this is a single attribute, but for some complex stores
	such as RDB backed stores that use compound (multi-attribute) identifiers
	it can be more than one.  If the identity is not composed of attributes
	on the item, it will return null.  This function is intended to identify
	the attributes that comprise the identity so that so that during a render
	of all attributes, the UI can hide the the identity information if it
	chooses.</summary>
        <examples>
          <example>	var itemId = store.getIdentity(kermit);
		var identifiers = store.getIdentityAttributes(itemId);
		assert(typeof identifiers === "array" || identifiers === null);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item from the store from which to obtain the array of public attributes that
	compose the identifier, if any.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>Given the identity of an item, this method returns the item that has
	that identity through the onItem callback.  Conforming implementations
	should return null if there is no item with the given identity.
	Implementations of fetchItemByIdentity() may sometimes return an item
	from a local cache and may sometimes fetch an item from a remote server,</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <summary>An anonymous object that defines the item to locate and callbacks to invoke when the
	item has been located and load has completed.  The format of the object is as follows:
	{
	identity: string|object,
	onItem: Function,
	onError: Function,
	scope: object
	}
	The *identity* parameter.
	The identity parameter is the identity of the item you wish to locate and load
	This attribute is required.  It should be a string or an object that toString()
	can be called on.
	The *onItem* parameter.
	Function(item)
	The onItem parameter is the callback to invoke when the item has been loaded.  It takes only one
	parameter, the item located, or null if none found.
	The *onError* parameter.
	Function(error)
	The onError parameter is the callback to invoke when the item load encountered an error.  It takes only one
	parameter, the error object
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onError, etc) will be invoked in the context of the scope object.
	In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global.
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global, item, request)</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.data.api.Notification" type="Function" classlike="true" superclass="dojo.data.api.Read">
    <summary>This is an abstract API that data provider implementations conform to.
	This file defines functions signatures and intentionally leaves all the
	functions unimplemented.</summary>
    <description>This API defines a set of APIs that all datastores that conform to the
	Notifications API must implement.  In general, most stores will implement
	these APIs as no-op functions for users who wish to monitor them to be able
	to connect to then via dojo.connect().  For non-users of dojo.connect,
	they should be able to just replace the function on the store to obtain
	notifications.  Both read-only and read-write stores may implement
	this feature.  In the case of a read-only store, this feature makes sense if
	the store itself does internal polling to a back-end server and periodically updates
	its cache of items (deletes, adds, and updates).</description>
    <mixins>
      <mixin scope="instance" location="dojo.data.api.Read"/>
    </mixins>
    <examples>
      <example>	function onSet(item, attribute, oldValue, newValue) {
			//Do something with the information...
		};
		var store = new some.newStore();
		dojo.connect(store, "onSet", onSet);</example>
    </examples>
    <methods>
      <method constructor="constructor"/>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="onSet" scope="prototype">
        <summary>This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.</summary>
        <description>This function is called any time an item is modified via setValue, setValues, unsetAttribute, etc.
	Its purpose is to provide a hook point for those who wish to monitor actions on items in the store
	in a simple manner.  The general expected usage is to dojo.connect() to the store's
	implementation and be called after the store function is called.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item being modified.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute being changed represented as a string name.</summary>
          </parameter>
          <parameter name="oldValue" type="object" usage="required">
            <summary>The old value of the attribute.  In the case of single value calls, such as setValue, unsetAttribute, etc,
	this value will be generally be an atomic value of some sort (string, int, etc, object).  In the case of
	multi-valued attributes, it will be an array.</summary>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <summary>The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
	generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
	it will be an array.  In the case of unsetAttribute, the new value will be 'undefined'.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onNew" scope="prototype">
        <summary>This function is called any time a new item is created in the store.
	It is called immediately after the store newItem processing has completed.</summary>
        <description>This function is called any time a new item is created in the store.
	It is called immediately after the store newItem processing has completed.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="newItem" type="item" usage="required">
            <summary>The item created.</summary>
          </parameter>
          <parameter name="parentInfo" type="object" usage="optional">
            <summary>An optional javascript object that is passed when the item created was placed in the store
	hierarchy as a value f another item's attribute, instead of a root level item.  Note that if this
	function is invoked with a value for parentInfo, then onSet is not invoked stating the attribute of
	the parent item was modified.  This is to avoid getting two notification  events occurring when a new item
	with a parent is created.  The structure passed in is as follows:
	{
	item: someItem,							//The parent item
	attribute:	&amp;quot;attribute-name-string&amp;quot;,	//The attribute the new item was assigned to.
	oldValue: something	//Whatever was the previous value for the attribute.
	//If it is a single-value attribute only, then this value will be a single value.
	//If it was a multi-valued attribute, then this will be an array of all the values minues the new one.
	newValue: something	//The new value of the attribute.  In the case of single value calls, such as setValue, this value will be
	//generally be an atomic value of some sort (string, int, etc, object).  In the case of multi-valued attributes,
	//it will be an array.
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDelete" scope="prototype">
        <summary>This function is called any time an item is deleted from the store.
	It is called immediately after the store deleteItem processing has completed.</summary>
        <description>This function is called any time an item is deleted from the store.
	It is called immediately after the store deleteItem processing has completed.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="deletedItem" type="item" usage="required">
            <summary>The item deleted.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.data.api.Read" type="Function" classlike="true">
    <summary>This is an abstract API that data provider implementations conform to.
	This file defines methods signatures and intentionally leaves all the
	methods unimplemented.  For more information on the dojo.data APIs,
	please visit: http://www.dojotoolkit.org/node/98</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="getValue" scope="prototype">
        <summary>Returns a single attribute value.
	Returns defaultValue if and only if *item* does not have a value for *attribute*.
	Returns null if and only if null was explicitly set as the attribute value.
	Returns undefined if and only if the item does not have a value for the
	given attribute (which is the same as saying the item does not have the attribute).</summary>
        <description>Saying that an "item x does not have a value for an attribute y"
	is identical to saying that an "item x does not have attribute y".
	It is an oxymoron to say "that attribute is present but has no values"
	or "the item has that attribute but does not have any attribute values".
	If store.hasAttribute(item, attribute) returns false, then
	store.getValue(item, attribute) will return undefined.</description>
        <examples>
          <example>	var darthVader = store.getValue(lukeSkywalker, "father");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to access values on.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to access represented as a string.</summary>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <summary>Optional. A default value to use for the getValue return in the attribute does not exist or has no value.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="a literal, an item, null, or undefined (never an array)"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>This getValues() method works just like the getValue() method, but getValues()
	always returns an array rather than a single attribute value.  The array
	may be empty, may contain a single attribute value, or may contain
	many attribute values.
	If the item does not have a value for the given attribute, then getValues()
	will return an empty array: [].  (So, if store.hasAttribute(item, attribute)
	has a return of false, then store.getValues(item, attribute) will return [].)</summary>
        <examples>
          <example>	var friendsOfLuke = store.getValues(lukeSkywalker, "friends");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to access values on.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to access represented as a string.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="an array that may contain literals and items"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>Returns an array with all the attributes that this item has.  This
	method will always return an array; if the item has no attributes
	at all, getAttributes() will return an empty array: [].</summary>
        <examples>
          <example>	var array = store.getAttributes(kermit);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to access attributes on.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>Returns true if the given *item* has a value for the given *attribute*.</summary>
        <examples>
          <example>	var trueOrFalse = store.hasAttribute(kermit, "color");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to access attributes on.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to access represented as a string.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>Returns true if the given *value* is one of the values that getValues()
	would return.</summary>
        <examples>
          <example>	var trueOrFalse = store.containsValue(kermit, "color", "green");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to access values on.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to access represented as a string.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match as a value for the attribute.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>Returns true if *something* is an item and came from the store instance.
	Returns false if *something* is a literal, an item from another store instance,
	or is any object other than an item.</summary>
        <examples>
          <example>	var yes = store.isItem(store.newItem());
		var no  = store.isItem("green");</example>
        </examples>
        <parameters>
          <parameter name="something" type="anything" usage="required">
            <summary>Can be anything.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>Returns false if isItem(something) is false.  Returns false if
	if isItem(something) is true but the the item is not yet loaded
	in local memory (for example, if the item has not yet been read
	from the server).</summary>
        <examples>
          <example>	var yes = store.isItemLoaded(store.newItem());
		var no  = store.isItemLoaded("green");</example>
        </examples>
        <parameters>
          <parameter name="something" type="anything" usage="required">
            <summary>Can be anything.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>Given an item, this method loads the item so that a subsequent call
	to store.isItemLoaded(item) will return true.  If a call to
	isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.  So, before invoking this method, check that
	the item has not already been loaded.</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <summary>An anonymous object that defines the item to load and callbacks to invoke when the
	load has completed.  The format of the object is as follows:
	{
	item: object,
	onItem: Function,
	onError: Function,
	scope: object
	}
	The *item* parameter.
	The item parameter is an object that represents the item in question that should be
	contained by the store.  This attribute is required.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <summary>Given a query and set of defined options, such as a start and count of items to return,
	this method executes the query and makes the results available as data items.
	The format and expectations of stores is that they operate in a generally asynchronous
	manner, therefore callbacks are always used to return items located by the fetch parameters.</summary>
        <description>A Request object will always be returned and is returned immediately.
	The basic request is nothing more than the keyword args passed to fetch and
	an additional function attached, abort().  The returned request object may then be used
	to cancel a fetch.  All data items returns are passed through the callbacks defined in the
	fetch parameters and are not present on the 'request' object.
	This does not mean that custom stores can not add methods and properties to the request object
	returned, only that the API does not require it.  For more info about the Request API,
	see dojo.data.api.Request</description>
        <return-description>The fetch() method will return a javascript object conforming to the API
	defined in dojo.data.api.Request.  In general, it will be the keywordArgs
	object returned with the required functions in Request.js attached.
	Its general purpose is to provide a convenient way for a caller to abort an
	ongoing fetch.
	The Request object may also have additional properties when it is returned
	such as request.store property, which is a pointer to the datastore object that
	fetch() is a method of.</return-description>
        <examples>
          <example>Fetch all books identified by the query and call 'showBooks' when complete
		var request = store.fetch({query:"all books", onComplete: showBooks});</example>
          <example>Fetch all items in the story and call 'showEverything' when complete.
		var request = store.fetch(onComplete: showEverything);</example>
          <example>Fetch only 10 books that match the query 'all books', starting at the fifth book found during the search.
	This demonstrates how paging can be done for specific queries.
		var request = store.fetch({query:"all books", start: 4, count: 10, onComplete: showBooks});</example>
          <example>Fetch all items that match the query, calling 'callback' each time an item is located.
		var request = store.fetch({query:"foo/bar", onItem:callback});</example>
          <example>Fetch the first 100 books by author King, call showKing when up to 100 items have been located.
		var request = store.fetch({query:{author:"King"}, start: 0, count:100, onComplete: showKing});</example>
          <example>Locate the books written by Author King, sort it on title and publisher, then return the first 100 items from the sorted items.
		var request = store.fetch({query:{author:"King"}, sort: [{ attribute: "title", descending: true}, {attribute: "publisher"}], ,start: 0, count:100, onComplete: 'showKing'});</example>
          <example>Fetch the first 100 books by authors starting with the name King, then call showKing when up to 100 items have been located.
		var request = store.fetch({query:{author:"King*"}, start: 0, count:100, onComplete: showKing});</example>
          <example>Fetch the first 100 books by authors ending with 'ing', but only have one character before it (King, Bing, Ling, Sing, etc.), then call showBooks when up to 100 items have been located.
		var request = store.fetch({query:{author:"?ing"}, start: 0, count:100, onComplete: showBooks});</example>
          <example>Fetch the first 100 books by author King, where the name may appear as King, king, KING, kInG, and so on, then call showKing when up to 100 items have been located.
		var request = store.fetch({query:{author:"King"}, queryOptions:(ignoreCase: true}, start: 0, count:100, onComplete: showKing});</example>
          <example>Paging
		var store = new dojo.data.LargeRdbmsStore({url:"jdbc:odbc:foobar"});
		var fetchArgs = {
			query: {type:"employees", name:"Hillary *"}, // string matching
			sort: [{attribute:"department", descending:true}],
			start: 0,
			count: 20,
			scope: displayer,
			onBegin: showThrobber,
			onItem: displayItem,
			onComplete: stopThrobber,
			onError: handleFetchError,
		};
		store.fetch(fetchArgs);
		...
	and then when the user presses the "Next Page" button...
		fetchArgs.start += 20;
		store.fetch(fetchArgs);  // get the next 20 items</example>
        </examples>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required">
            <summary>The keywordArgs parameter may either be an instance of
	conforming to dojo.data.api.Request or may be a simple anonymous object
	that may contain any of the following:
	{
	query: query-object or query-string,
	queryOptions: object,
	onBegin: Function,
	onItem: Function,
	onComplete: Function,
	onError: Function,
	scope: object,
	start: int
	count: int
	sort: array
	}
	All implementations should accept keywordArgs objects with any of
	the 9 standard properties: query, onBegin, onItem, onComplete, onError
	scope, sort, start, and count.  Some implementations may accept additional
	properties in the keywordArgs object as valid parameters, such as
	{includeOutliers:true}.
	The *query* parameter.
	The query may be optional in some data store implementations.
	The dojo.data.api.Read API does not specify the syntax or semantics
	of the query itself -- each different data store implementation
	may have its own notion of what a query should look like.
	However, as of dojo 0.9, 1.0, and 1.1, all the provided datastores in dojo.data
	and dojox.data support an object structure query, where the object is a set of
	name/value parameters such as { attrFoo: valueBar, attrFoo1: valueBar1}.  Most of the
	dijit widgets, such as ComboBox assume this to be the case when working with a datastore
	when they dynamically update the query.  Therefore, for maximum compatibility with dijit
	widgets the recommended query parameter is a key/value object.  That does not mean that the
	the datastore may not take alternative query forms, such as a simple string, a Date, a number,
	or a mix of such.  Ultimately, The dojo.data.api.Read API is agnostic about what the query
	format.
	Further note:  In general for query objects that accept strings as attribute
	value matches, the store should also support basic filtering capability, such as *
	(match any character) and ? (match single character).  An example query that is a query object
	would be like: { attrFoo: &amp;quot;value*&amp;quot;}.  Which generally means match all items where they have
	an attribute named attrFoo, with a value that starts with 'value'.
	The *queryOptions* parameter
	The queryOptions parameter is an optional parameter used to specify optiosn that may modify
	the query in some fashion, such as doing a case insensitive search, or doing a deep search
	where all items in a hierarchical representation of data are scanned instead of just the root
	items.  It currently defines two options that all datastores should attempt to honor if possible:
	{
	ignoreCase: boolean, //Whether or not the query should match case sensitively or not.  Default behaviour is false.
	deep: boolean 	//Whether or not a fetch should do a deep search of items and all child
	//items instead of just root-level items in a datastore.  Default is false.
	}
	The *onBegin* parameter.
	function(size, request);
	If an onBegin callback function is provided, the callback function
	will be called just once, before the first onItem callback is called.
	The onBegin callback function will be passed two arguments, the
	the total number of items identified and the Request object.  If the total number is
	unknown, then size will be -1.  Note that size is not necessarily the size of the
	collection of items returned from the query, as the request may have specified to return only a
	subset of the total set of items through the use of the start and count parameters.
	The *onItem* parameter.
	function(item, request);
	If an onItem callback function is provided, the callback function
	will be called as each item in the result is received. The callback
	function will be passed two arguments: the item itself, and the
	Request object.
	The *onComplete* parameter.
	function(items, request);
	If an onComplete callback function is provided, the callback function
	will be called just once, after the last onItem callback is called.
	Note that if the onItem callback is not present, then onComplete will be passed
	an array containing all items which matched the query and the request object.
	If the onItem callback is present, then onComplete is called as:
	onComplete(null, request).
	The *onError* parameter.
	function(errorData, request);
	If an onError callback function is provided, the callback function
	will be called if there is any sort of error while attempting to
	execute the query.
	The onError callback function will be passed two arguments:
	an Error object and the Request object.
	The *scope* parameter.
	If a scope object is provided, all of the callback functions (onItem,
	onComplete, onError, etc) will be invoked in the context of the scope
	object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global().
	For example, onItem.call(scope, item, request) vs.
	onItem.call(dojo.global(), item, request)
	The *start* parameter.
	If a start parameter is specified, this is a indication to the datastore to
	only start returning items once the start number of items have been located and
	skipped.  When this parameter is paired withh 'count', the store should be able
	to page across queries with millions of hits by only returning subsets of the
	hits for each query
	The *count* parameter.
	If a count parameter is specified, this is a indication to the datastore to
	only return up to that many items.  This allows a fetch call that may have
	millions of item matches to be paired down to something reasonable.
	The *sort* parameter.
	If a sort parameter is specified, this is a indication to the datastore to
	sort the items in some manner before returning the items.  The array is an array of
	javascript objects that must conform to the following format to be applied to the
	fetching of items:
	{
	attribute: attribute || attribute-name-string,
	descending: true|false;   // Optional.  Default is false.
	}
	Note that when comparing attributes, if an item contains no value for the attribute
	(undefined), then it the default ascending sort logic should push it to the bottom
	of the list.  In the descending order case, it such items should appear at the top of the list.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="an object conforming to the dojo.data.api.Request API"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>The getFeatures() method returns an simple keyword values object
	that specifies what interface features the datastore implements.
	A simple CsvStore may be read-only, and the only feature it
	implements will be the 'dojo.data.api.Read' interface, so the
	getFeatures() method will return an object like this one:
	{'dojo.data.api.Read': true}.
	A more sophisticated datastore might implement a variety of
	interface features, like 'dojo.data.api.Read', 'dojo.data.api.Write',
	'dojo.data.api.Identity', and 'dojo.data.api.Attribution'.</summary>
      </method>
      <method name="close" scope="prototype">
        <summary>The close() method is intended for instructing the store to 'close' out
	any information associated with a particular request.</summary>
        <description>The close() method is intended for instructing the store to 'close' out
	any information associated with a particular request.  In general, this API
	expects to recieve as a parameter a request object returned from a fetch.
	It will then close out anything associated with that request, such as
	clearing any internal datastore caches and closing any 'open' connections.
	For some store implementations, this call may be a no-op.</description>
        <examples>
          <example>	var request = store.fetch({onComplete: doSomething});
		...
		store.close(request);</example>
        </examples>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>An instance of a request for the store to use to identify what to close out.
	If no request is passed, then the store should clear all internal caches (if any)
	and close out all 'open' connections.  It does not render the store unusable from
	there on, it merely cleans out any current data and resets the store to initial
	state.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>Method to inspect the item and return a user-readable 'label' for the item
	that provides a general/adequate description of what the item is.</summary>
        <description>Method to inspect the item and return a user-readable 'label' for the item
	that provides a general/adequate description of what the item is.  In general
	most labels will be a specific attribute value or collection of the attribute
	values that combine to label the item in some manner.  For example for an item
	that represents a person it may return the label as:  "firstname lastlame" where
	the firstname and lastname are attributes on the item.  If the store is unable
	to determine an adequate human readable label, it should return undefined.  Users that wish
	to customize how a store instance labels items should replace the getLabel() function on
	their instance of the store, or extend the store and replace the function in
	the extension class.</description>
        <return-description>A user-readable string representing the item or undefined if no user-readable label can
	be generated.</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to return the label for.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>Method to inspect the item and return an array of what attributes of the item were used
	to generate its label, if any.</summary>
        <description>Method to inspect the item and return an array of what attributes of the item were used
	to generate its label, if any.  This function is to assist UI developers in knowing what
	attributes can be ignored out of the attributes an item has when displaying it, in cases
	where the UI is using the label as an overall identifer should they wish to hide
	redundant information.</description>
        <return-description>An array of attribute names that were used to generate the label, or null if public attributes
	were not used to generate the label.</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to return the list of label attributes for.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.data.api.Request" type="Function" classlike="true">
    <summary>This class defines out the semantics of what a 'Request' object looks like
	when returned from a fetch() method.  In general, a request object is
	nothing more than the original keywordArgs from fetch with an abort function
	attached to it to allow users to abort a particular request if they so choose.
	No other functions are required on a general Request object return.  That does not
	inhibit other store implementations from adding extentions to it, of course.
	This is an abstract API that data provider implementations conform to.
	This file defines methods signatures and intentionally leaves all the
	methods unimplemented.
	For more details on fetch, see dojo.data.api.Read.fetch().</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="abort" scope="prototype">
        <summary>This function is a hook point for stores to provide as a way for
	a fetch to be halted mid-processing.</summary>
        <description>This function is a hook point for stores to provide as a way for
	a fetch to be halted mid-processing.  For more details on the fetch() api,
	please see dojo.data.api.Read.fetch().</description>
      </method>
    </methods>
  </object>
  <object location="dojo.data.api.Write" type="Function" classlike="true" superclass="dojo.data.api.Read">
    <summary>This is an abstract API that data provider implementations conform to.
	This file defines function signatures and intentionally leaves all the
	functionss unimplemented.</summary>
    <mixins>
      <mixin scope="instance" location="dojo.data.api.Read"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="newItem" scope="prototype">
        <summary>Returns a newly created item.  Sets the attributes of the new
	item based on the *keywordArgs* provided.  In general, the attribute
	names in the keywords become the attributes in the new item and as for
	the attribute values in keywordArgs, they become the values of the attributes
	in the new item.  In addition, for stores that support hierarchical item
	creation, an optional second parameter is accepted that defines what item is the parent
	of the new item and what attribute of that item should the new item be assigned to.
	In general, this will assume that the attribute targetted is multi-valued and a new item
	is appended onto the list of values for that attribute.</summary>
        <examples>
          <example>	var kermit = store.newItem({name: "Kermit", color:[blue, green]});</example>
        </examples>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional">
            <summary>A javascript object defining the initial content of the item as a set of JavaScript 'property name: value' pairs.</summary>
          </parameter>
          <parameter name="parentInfo" type="Object" usage="optional">
            <summary>An optional javascript object defining what item is the parent of this item (in a hierarchical store.  Not all stores do hierarchical items),
	and what attribute of that parent to assign the new item to.  If this is present, and the attribute specified
	is a multi-valued attribute, it will append this item into the array of values for that attribute.  The structure
	of the object is as follows:
	{
	parent: someItem,
	attribute: &amp;quot;attribute-name-string&amp;quot;
	}</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="prototype">
        <summary>Deletes an item from the store.</summary>
        <examples>
          <example>	var success = store.deleteItem(kermit);</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to delete.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="prototype">
        <summary>Sets the value of an attribute on an item.
	Replaces any previous value or values.</summary>
        <examples>
          <example>	var success = store.set(kermit, "color", "green");</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to modify.</summary>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <summary>The attribute of the item to change represented as a string name.</summary>
          </parameter>
          <parameter name="value" type="almost" usage="required">
            <summary>The value to assign to the item.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="prototype">
        <summary>Adds each value in the *values* array as a value of the given
	attribute on the given item.
	Replaces any previous value or values.
	Calling store.setValues(x, y, []) (with *values* as an empty array) has
	the same effect as calling store.unsetAttribute(x, y).</summary>
        <examples>
          <example>	var success = store.setValues(kermit, "color", ["green", "aqua"]);
		success = store.setValues(kermit, "color", []);
		if (success) {assert(!store.hasAttribute(kermit, "color"));}</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to modify.</summary>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <summary>The attribute of the item to change represented as a string name.</summary>
          </parameter>
          <parameter name="values" type="array" usage="required">
            <summary>An array of values to assign to the attribute..</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <summary>Deletes all the values of an attribute on an item.</summary>
        <examples>
          <example>	var success = store.unsetAttribute(kermit, "color");
		if (success) {assert(!store.hasAttribute(kermit, "color"));}</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to modify.</summary>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <summary>The attribute of the item to unset represented as a string.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <summary>Saves to the server all the changes that have been made locally.
	The save operation may take some time and is generally performed
	in an asynchronous fashion.  The outcome of the save action is
	is passed into the set of supported callbacks for the save.</summary>
        <return-description>Nothing.  Since the saves are generally asynchronous, there is
	no need to return anything.  All results are passed via callbacks.</return-description>
        <examples>
          <example>	store.save({onComplete: onSave});
		store.save({scope: fooObj, onComplete: onSave, onError: saveFailed});</example>
        </examples>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <summary>{ onComplete: function
	onError: function
	scope: object
	}
	The *onComplete* parameter.
	function();
	If an onComplete callback function is provided, the callback function
	will be called just once, after the save has completed.  No parameters
	are generally passed to the onComplete.
	The *onError* parameter.
	function(errorData);
	If an onError callback function is provided, the callback function
	will be called if there is any sort of error while attempting to
	execute the save.  The onError function will be based one parameter, the
	error.
	The *scope* parameter.
	If a scope object is provided, all of the callback function (
	onComplete, onError, etc) will be invoked in the context of the scope
	object.  In the body of the callback function, the value of the &amp;quot;this&amp;quot;
	keyword will be the scope object.   If no scope object is provided,
	the callback functions will be called in the context of dojo.global.
	For example, onComplete.call(scope) vs.
	onComplete.call(dojo.global)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="revert" scope="prototype">
        <summary>Discards any unsaved changes.</summary>
        <description>Discards any unsaved changes.</description>
        <examples>
          <example>	var success = store.revert();</example>
        </examples>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="prototype">
        <summary>Given an item, isDirty() returns true if the item has been modified
	since the last save().  If isDirty() is called with no *item* argument,
	then this function returns true if any item has been modified since
	the last save().</summary>
        <examples>
          <example>	var trueOrFalse = store.isDirty(kermit); // true if kermit is dirty
		var trueOrFalse = store.isDirty();       // true if any item is dirty</example>
        </examples>
        <parameters>
          <parameter name="item" type="item" usage="optional">
            <summary>The item to check.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.data.util.filter">
    <methods>
      <method name="patternToRegExp" scope="normal">
        <summary>Helper function to convert a simple pattern to a regular expression for matching.</summary>
        <description>Returns a regular expression object that conforms to the defined conversion rules.
	For example:
	ca*   -&gt; /^ca.*$/
	*ca*  -&gt; /^.*ca.*$/
	*c\*a*  -&gt; /^.*c\*a.*$/
	*c\*a?*  -&gt; /^.*c\*a..*$/
	and so on.</description>
        <parameters>
          <parameter name="pattern" type="String" usage="required">
            <summary>string A simple matching pattern to convert that follows basic rules:
	* Means match anything, so ca* means match anything starting with ca
	? Means match single character.  So, b?b will match to bob and bab, and so on.
	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	represented by \\ to be treated as an ordinary \ character instead of an escape.</summary>
          </parameter>
          <parameter name="ignoreCase" type="boolean" usage="optional">
            <summary>An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	By default, it is assumed case sensitive.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="RegExp"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.data.util"/>
  <object location="dojo.data.util.simpleFetch">
    <methods>
      <method name="fetch" scope="normal">
        <summary>The simpleFetch mixin is designed to serve as a set of function(s) that can
	be mixed into other datastore implementations to accelerate their development.
	The simpleFetch mixin should work well for any datastore that can respond to a _fetchItems()
	call by returning an array of all the found items that matched the query.  The simpleFetch mixin
	is not designed to work for datastores that respond to a fetch() call by incrementally
	loading items, or sequentially loading partial batches of the result
	set.  For datastores that mixin simpleFetch, simpleFetch
	implements a fetch method that automatically handles eight of the fetch()
	arguments -- onBegin, onItem, onComplete, onError, start, count, sort and scope
	The class mixing in simpleFetch should not implement fetch(),
	but should instead implement a _fetchItems() method.  The _fetchItems()
	method takes three arguments, the keywordArgs object that was passed
	to fetch(), a callback function to be called when the result array is
	available, and an error callback to be called if something goes wrong.
	The _fetchItems() method should ignore any keywordArgs parameters for
	start, count, onBegin, onItem, onComplete, onError, sort, and scope.
	The _fetchItems() method needs to correctly handle any other keywordArgs
	parameters, including the query parameter and any optional parameters
	(such as includeChildren).  The _fetchItems() method should create an array of
	result items and pass it to the fetchHandler along with the original request object
	-- or, the _fetchItems() method may, if it wants to, create an new request object
	with other specifics about the request that are specific to the datastore and pass
	that as the request object to the handler.
	For more information on this specific function, see dojo.data.api.Read.fetch()</summary>
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.data.util.sorter">
    <methods>
      <method name="basicComparator" scope="normal">
        <summary>Basic comparision function that compares if an item is greater or less than another item</summary>
        <description>returns 1 if a &gt; b, -1 if a &lt; b, 0 if equal.
	'null' values (null, undefined) are treated as larger values so that they're pushed to the end of the list.
	And compared to each other, null is equivalent to undefined.</description>
        <parameters>
          <parameter name="a" type="anything" usage="required"/>
          <parameter name="b" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int {-1,0,1}"/>
        </return-types>
      </method>
      <method name="createSortFunction" scope="normal">
        <summary>Helper function to generate the sorting function based off the list of sort attributes.</summary>
        <description>The sort function creation will look for a property on the store called 'comparatorMap'.  If it exists
	it will look in the mapping for comparisons function for the attributes.  If one is found, it will
	use it instead of the basic comparator, which is typically used for strings, ints, booleans, and dates.
	Returns the sorting function for this particular list of attributes and sorting directions.</description>
        <parameters>
          <parameter name="sortSpec" type="attributes" usage="required">
            <summary>array A JS object that array that defines out what attribute names to sort on and whether it should be descenting or asending.
	The objects should be formatted as follows:
	{
	attribute: &amp;quot;attributeName-string&amp;quot; || attribute,
	descending: true|false;   // Default is false.
	}</summary>
          </parameter>
          <parameter name="store" type="dojo.data.core.Read" usage="required">
            <summary>object The datastore object to look up item values from.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.date.locale">
    <methods>
      <method name="_getZone" scope="normal">
        <summary>Returns the zone (or offset) for the given date and options.  This
	is broken out into a separate function so that it can be overridden
	by timezone-aware code.</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <summary>the date and/or time being formatted.</summary>
          </parameter>
          <parameter name="getName" type="boolean" usage="required">
            <summary>Whether to return the timezone string (if true), or the offset (if false)</summary>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional">
            <summary>The options being used for formatting</summary>
          </parameter>
        </parameters>
      </method>
      <method name="format" scope="normal">
        <summary>Format a Date object as a String, using locale-specific settings.</summary>
        <description>Create a string from a Date object using a known localized pattern.
	By default, this method formats both date and time from dateObject.
	Formatting patterns are chosen appropriate to the locale.  Different
	formatting lengths may be chosen, with "full" used by default.
	Custom patterns may be used or registered with translations using
	the dojo.date.locale.addCustomFormats method.
	Formatting patterns are implemented using [the syntax described at
	unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <summary>the date and/or time to be formatted.  If a time only is formatted,
	the values in the year, month, and day fields are irrelevant.  The
	opposite is true when formatting only dates.</summary>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="normal">
        <summary>Builds the regular needed to parse a localized date</summary>
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="normal">
        <parameters>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="normal">
        <summary>Convert a properly formatted string to a primitive Date object,
	using locale-specific settings.</summary>
        <description>Create a Date object from a string using a known localized pattern.
	By default, this method parses looking for both date and time in the string.
	Formatting patterns are chosen appropriate to the locale.  Different
	formatting lengths may be chosen, with "full" used by default.
	Custom patterns may be used or registered with translations using
	the dojo.date.locale.addCustomFormats method.
	Formatting patterns are implemented using [the syntax described at
	unicode.org](http://www.unicode.org/reports/tr35/tr35-4.html#Date_Format_Patterns)
	When two digit years are used, a century is chosen according to a sliding
	window of 80 years before and 20 years after present year, for both `yy` and `yyyy` patterns.
	year &lt; 100CE requires strict mode.</description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>A string representation of a date</summary>
          </parameter>
          <parameter name="options" type="dojo.date.locale.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="normal">
        <summary>Add a reference to a bundle containing localized custom formats to be
	used by date/time formatting and parsing routines.</summary>
        <description>The user may add custom localized formats where the bundle has properties following the
	same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	The pattern string should match the format used by the CLDR.
	See dojo.date.locale.format() for details.
	The resources must be loaded by dojo.requireLocalization() prior to use</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getGregorianBundle" scope="normal">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="normal">
        <summary>Used to get localized strings from dojo.cldr for day or month names.</summary>
        <parameters>
          <parameter name="item" type="String" usage="required">
            <summary>'months' || 'days'</summary>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <summary>'wide' || 'narrow' || 'abbr' (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)</summary>
          </parameter>
          <parameter name="context" type="String" usage="optional">
            <summary>'standAlone' || 'format' (default)</summary>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <summary>override locale used to find the names</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isWeekend" scope="normal">
        <summary>Determines if the date falls on a weekend, according to local custom.</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_getDayOfYear" scope="normal">
        <summary>gets the day of the year as represented by dateObject</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_getWeekOfYear" scope="normal">
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDayOfWeek" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.date.locale.__FormatOptions" type="Function" classlike="true" private="true">
    <properties>
      <property name="selector" scope="instance" type="String">
        <summary>choice of 'time','date' (default: date and time)</summary>
      </property>
      <property name="formatLength" scope="instance" type="String">
        <summary>choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'</summary>
      </property>
      <property name="datePattern" scope="instance" type="String">
        <summary>override pattern with this string</summary>
      </property>
      <property name="timePattern" scope="instance" type="String">
        <summary>override pattern with this string</summary>
      </property>
      <property name="am" scope="instance" type="String">
        <summary>override strings for am in times</summary>
      </property>
      <property name="pm" scope="instance" type="String">
        <summary>override strings for pm in times</summary>
      </property>
      <property name="locale" scope="instance" type="String">
        <summary>override the locale used to determine formatting rules</summary>
      </property>
      <property name="fullYear" scope="instance" type="Boolean">
        <summary>(format only) use 4 digit years whenever 2 digit years are called for</summary>
      </property>
      <property name="strict" scope="instance" type="Boolean">
        <summary>(parse only) strict parsing, off by default</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.date">
    <summary>Date manipulation utilities</summary>
    <methods>
      <method name="getDaysInMonth" scope="normal">
        <summary>Returns the number of days in the month used by dateObject</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="isLeapYear" scope="normal">
        <summary>Determines if the year of the dateObject is a leap year</summary>
        <description>Leap years are years with an additional day YYYY-02-29, where the
	year number is a multiple of four with the following exception: If
	a year is a multiple of 100, then it is only a leap year if it is
	also a multiple of 400. For example, 1900 was not a leap year, but
	2000 is one.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getTimezoneName" scope="normal">
        <summary>Get the user's time zone as provided by the browser</summary>
        <description>Try to get time zone info from toString or toLocaleString method of
	the Date object -- UTC offset is not a time zone.  See
	http://www.twinsun.com/tz/tz-link.htm Note: results may be
	inconsistent across browsers.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <summary>Needed because the timezone may vary with time (daylight savings)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="compare" scope="normal">
        <summary>Compare two date objects by date, time, or both.</summary>
        <description>Returns 0 if equal, positive if a &gt; b, else negative.</description>
        <parameters>
          <parameter name="date1" type="Date" usage="required">
            <summary>object</summary>
          </parameter>
          <parameter name="date2" type="Date" usage="optional">
            <summary>object.  If not specified, the current Date is used.</summary>
          </parameter>
          <parameter name="portion" type="String" usage="optional">
            <summary>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="add" scope="normal">
        <summary>Add to a Date in intervals of different size, from milliseconds to years</summary>
        <parameters>
          <parameter name="date" type="Date" usage="required">
            <summary>Date object to start with</summary>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <summary>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</summary>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <summary>How much to add to the date.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="difference" scope="normal">
        <summary>Get the difference in a specific unit of time (e.g., number of
	months, weeks, days, etc.) between two dates, rounded to the
	nearest integer.</summary>
        <parameters>
          <parameter name="date1" type="Date" usage="required">
            <summary>object</summary>
          </parameter>
          <parameter name="date2" type="Date" usage="optional">
            <summary>object.  If not specified, the current Date is used.</summary>
          </parameter>
          <parameter name="interval" type="String" usage="optional">
            <summary>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;quarter&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number (integer)"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.date.stamp">
    <properties>
      <property name="_isoRegExp" scope="normal" type="RegExp"/>
    </properties>
    <methods>
      <method name="fromISOString" scope="normal">
        <summary>Returns a Date object given a string formatted according to a subset of the ISO-8601 standard.</summary>
        <description>Accepts a string formatted according to a profile of ISO8601 as defined by
	[RFC3339](http://www.ietf.org/rfc/rfc3339.txt), except that partial input is allowed.
	Can also process dates as specified [by the W3C](http://www.w3.org/TR/NOTE-datetime)
	The following combinations are valid:
	* dates only
		* yyyy
		* yyyy-MM
		* yyyy-MM-dd
	* times only, with an optional time zone appended
		* THH:mm
		* THH:mm:ss
		* THH:mm:ss.SSS
	* and "datetimes" which could be any combination of the above
	timezones may be specified as Z (for UTC) or +/- followed by a time expression HH:mm
	Assumes the local time zone if not specified.  Does not validate.  Improperly formatted
	input may return null.  Arguments which are out of bounds will be handled
	by the Date constructor (e.g. January 32nd typically gets resolved to February 1st)
	Only years between 100 and 9999 are supported.</description>
        <parameters>
          <parameter name="formattedString" type="String" usage="required">
            <summary>A string such as 2005-06-30T08:05:00-07:00 or 2005-06-30 or T08:05:00</summary>
          </parameter>
          <parameter name="defaultTime" type="Number" usage="optional">
            <summary>Used for defaults for fields omitted in the formattedString.
	Uses 1970-01-01T00:00:00.0Z by default.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date or null"/>
        </return-types>
      </method>
      <method name="toISOString" scope="normal">
        <summary>Format a Date object as a string according a subset of the ISO-8601 standard</summary>
        <description>When options.selector is omitted, output follows [RFC3339](http://www.ietf.org/rfc/rfc3339.txt)
	The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
	Does not check bounds.  Only years between 100 and 9999 are supported.</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <summary>A Date object</summary>
          </parameter>
          <parameter name="options" type="dojo.date.stamp.__Options" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.date.stamp.__Options" type="Function" classlike="true" private="true">
    <properties>
      <property name="selector" scope="instance" type="String">
        <summary>&amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; for partial formatting of the Date object.
	Both date and time will be formatted by default.</summary>
      </property>
      <property name="zulu" scope="instance" type="Boolean">
        <summary>if true, UTC/GMT is used for a timezone</summary>
      </property>
      <property name="milliseconds" scope="instance" type="Boolean">
        <summary>if true, output milliseconds</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.dnd">
    <summary>Drag and Drop resources</summary>
    <properties>
      <property name="_manager" scope="normal" type="Object"/>
      <property name="V_TRIGGER_AUTOSCROLL" scope="normal" type="Number"/>
      <property name="H_TRIGGER_AUTOSCROLL" scope="normal" type="Number"/>
      <property name="V_AUTOSCROLL_VALUE" scope="normal" type="Number"/>
      <property name="H_AUTOSCROLL_VALUE" scope="normal" type="Number"/>
      <property name="autoscroll" scope="normal" type="Object"/>
      <property name="_uniqueId" scope="normal" type="Number"/>
      <property name="_empty" scope="normal" type="Object"/>
      <property name="common" scope="normal" type="Object"/>
      <property name="constrainedMover" scope="normal" type=""/>
      <property name="boxConstrainedMover" scope="normal" type=""/>
      <property name="parentConstrainedMover" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="_createNode" scope="normal">
        <summary>returns a function, which creates an element of given tag
	(SPAN by default) and sets its innerHTML to given text</summary>
        <parameters>
          <parameter name="tag" type="String" usage="required">
            <summary>a tag name or empty for SPAN</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_createTrTd" scope="normal">
        <summary>creates a TR/TD structure with given text as an innerHTML of TD</summary>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <summary>a text for TD</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_createSpan" scope="normal">
        <summary>creates a SPAN element with given text as its innerHTML</summary>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <summary>a text for SPAN</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_defaultCreator" scope="normal">
        <summary>takes a parent node, and returns an appropriate creator function</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a container node</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="manager" scope="normal">
        <summary>Returns the current DnD manager.  Creates one if it is not created yet.</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getViewport" scope="normal">
        <summary>Returns a viewport size (visible part of the window)</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="autoScroll" scope="normal">
        <summary>a handler for onmousemove event, which scrolls the window, if
	necesary</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>onmousemove event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="autoScrollNodes" scope="normal">
        <summary>a handler for onmousemove event, which scrolls the first avaialble
	Dom element, it falls back to dojo.dnd.autoScroll()</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>onmousemove event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getUniqueId" scope="normal">
        <summary>returns a unique string for use with any DOM element</summary>
      </method>
      <method name="isFormElement" scope="normal">
        <summary>returns true if user clicked on a form element</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Avatar" type="Function" classlike="true">
    <summary>Object that represents transferred DnD items visually
	manager: Object
	a DnD manager object</summary>
    <properties>
      <property name="isA11y" scope="prototype" type="Object"/>
      <property name="node" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="manager" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="manager" type="" usage="required"/>
        </parameters>
      </method>
      <method name="construct" scope="prototype">
        <summary>constructor function;
	it is separate so it can be (dynamically) overwritten in case of need</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>destructor for the avatar; called to remove all references so it can be garbage-collected</summary>
      </method>
      <method name="update" scope="prototype">
        <summary>updates the avatar to reflect the current DnD state</summary>
      </method>
      <method name="_generateText" scope="prototype">
        <summary>generates a proper text to reflect copying or moving of items</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Avatar.manager" type="">
    <properties>
      <property name="source" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojo.dnd.__ContainerArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="skipForm" scope="prototype" type="Boolean">
        <summary>don't start the drag operation, if clicked on form elements</summary>
      </property>
      <property name="dropParent" scope="prototype" type="Node||String">
        <summary>node or node's id to use as the parent node for dropped items
	(must be underneath the 'node' parameter in the DOM)</summary>
      </property>
      <property name="_skipStartup" scope="prototype" type="Boolean">
        <summary>skip startup(), which collects children, for deferred initialization
	(this is used in the markup mode)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="creator" scope="prototype">
        <summary>a creator function, which takes a data item, and returns an object like that:
	{node: newNode, data: usedData, type: arrayOfStrings}</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Container" type="Function" classlike="true">
    <summary>a Container object, which knows when mouse hovers over it,
	and over which element it hovers</summary>
    <properties>
      <property name="skipForm" scope="instance-prototype" type="bool"/>
      <property name="current" scope="instance-prototype" type="DomNode">
        <summary>The DOM node the mouse is currently hovered over</summary>
      </property>
      <property name="map" scope="instance-prototype" type="Hash&lt;String,">
        <summary>dojo.dnd.Item&amp;gt;
	Map from an item's id (which is also the DOMNode's id) to
	the dojo.dnd.Item itself.</summary>
      </property>
      <property name="creator" scope="instance-prototype" type="Object">
        <summary>creator function, dummy at the moment</summary>
      </property>
      <property name="node" scope="instance-prototype" type="Node">
        <summary>node or node's id to build the container on
	params: dojo.dnd.__ContainerArgs
	a dictionary of parameters</summary>
      </property>
      <property name="parent" scope="instance-prototype" type="Object"/>
      <property name="defaultCreator" scope="prototype" type="Object"/>
      <property name="containerState" scope="instance" type="String"/>
      <property name="events" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>node or node's id to build the container on</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__ContainerArgs" usage="required">
            <summary>a dictionary of parameters</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>a constructor of the Container</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>node or node's id to build the container on</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__ContainerArgs" usage="required">
            <summary>a dictionary of parameters</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getItem" scope="prototype">
        <summary>returns a data item by its key (id)</summary>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.dnd.Item"/>
        </return-types>
      </method>
      <method name="setItem" scope="prototype">
        <summary>associates a data item with its key (id)</summary>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="data" type="dojo.dnd.Item" usage="required"/>
        </parameters>
      </method>
      <method name="delItem" scope="prototype">
        <summary>removes a data item from the map by its key (id)</summary>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="forInItems" scope="prototype">
        <summary>iterates over a data map skipping members that
	are present in the empty object (IE and/or 3rd-party libraries).</summary>
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="clearItems" scope="prototype">
        <summary>removes all data items from the map</summary>
      </method>
      <method name="getAllNodes" scope="prototype">
        <summary>returns a list (an array) of all valid child nodes</summary>
        <return-types>
          <return-type type="NodeList"/>
        </return-types>
      </method>
      <method name="sync" scope="prototype">
        <summary>sync up the node list with the data map</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="insertNodes" scope="prototype">
        <summary>inserts an array of new nodes before/after an anchor node</summary>
        <parameters>
          <parameter name="data" type="Array" usage="required">
            <summary>a list of data items, which should be processed by the creator function</summary>
          </parameter>
          <parameter name="before" type="Boolean" usage="required">
            <summary>insert before the anchor, if true, and after the anchor otherwise</summary>
          </parameter>
          <parameter name="anchor" type="Node" usage="required">
            <summary>the anchor node to be used as a point of insertion</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <summary>prepares this object to be garbage-collected</summary>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype">
        <summary>collects valid child items and populate the map</summary>
      </method>
      <method name="onMouseOver" scope="prototype">
        <summary>event processor for onmouseover</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <summary>event processor for onmouseout</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectStart" scope="prototype">
        <summary>event processor for onselectevent and ondragevent</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="prototype">
        <summary>this function is called once, when mouse is over our container</summary>
      </method>
      <method name="onOutEvent" scope="prototype">
        <summary>this function is called once, when mouse is out of our container</summary>
      </method>
      <method name="_changeState" scope="prototype">
        <summary>changes a named state to new state value</summary>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <summary>a name of the state to change</summary>
          </parameter>
          <parameter name="newState" type="String" usage="required">
            <summary>new state</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addItemClass" scope="prototype">
        <summary>adds a class with prefix &amp;quot;dojoDndItem&amp;quot;</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node</summary>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <summary>a variable suffix for a class name</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_removeItemClass" scope="prototype">
        <summary>removes a class with prefix &amp;quot;dojoDndItem&amp;quot;</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node</summary>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <summary>a variable suffix for a class name</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getChildByEvent" scope="prototype">
        <summary>gets a child, which is under the mouse at the moment, or null</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>a mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizedCreator" scope="prototype">
        <summary>adds all necessary data to the output of the user-supplied creator function</summary>
        <parameters>
          <parameter name="item" type="dojo.dnd.Item" usage="required"/>
          <parameter name="hint" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Item" type="Function" classlike="true">
    <summary>Represents (one of) the source node(s) being dragged.
	Contains (at least) the &amp;quot;type&amp;quot; and &amp;quot;data&amp;quot; attributes.</summary>
    <properties>
      <property name="type" scope="instance" type="String[]">
        <summary>Type(s) of this item, by default this is [&amp;quot;text&amp;quot;]</summary>
      </property>
      <property name="data" scope="instance" type="Object">
        <summary>Logical representation of the object being dragged.
	If the drag object's type is &amp;quot;text&amp;quot; then data is a String,
	if it's another type then data could be a different Object,
	perhaps a name/value hash.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.dnd._defaultCreatorNodes" private="true">
    <properties>
      <property name="ul" scope="normal" type="String"/>
      <property name="ol" scope="normal" type="String"/>
      <property name="div" scope="normal" type="String"/>
      <property name="p" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojo.dnd.Manager" type="Function" classlike="true">
    <summary>the manager of DnD operations (usually a singleton)</summary>
    <properties>
      <property name="OFFSET_X" scope="prototype" type="Number"/>
      <property name="OFFSET_Y" scope="prototype" type="Number"/>
      <property name="target" scope="instance-prototype" type="Object"/>
      <property name="canDropFlag" scope="instance-prototype" type="bool"/>
      <property name="source" scope="instance-prototype" type="Object"/>
      <property name="nodes" scope="instance-prototype" type="Array"/>
      <property name="copy" scope="instance-prototype" type="Object"/>
      <property name="avatar" scope="instance-prototype" type="Object"/>
      <property name="events" scope="instance-prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="overSource" scope="prototype">
        <summary>called when a source detected a mouse-over condition</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>the reporter</summary>
          </parameter>
        </parameters>
      </method>
      <method name="outSource" scope="prototype">
        <summary>called when a source detected a mouse-out condition</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>the reporter</summary>
          </parameter>
        </parameters>
      </method>
      <method name="startDrag" scope="prototype">
        <summary>called to initiate the DnD operation</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>the source which provides items</summary>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <summary>the list of transferred items</summary>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <summary>copy items, if true, move items otherwise</summary>
          </parameter>
        </parameters>
      </method>
      <method name="stopDrag" scope="prototype">
        <summary>stop the DnD in progress</summary>
      </method>
      <method name="makeAvatar" scope="prototype">
        <summary>Makes the avatar, it is separate to be overwritten dynamically, if needed.</summary>
      </method>
      <method name="updateAvatar" scope="prototype">
        <summary>updates the avatar; it is separate to be overwritten dynamically, if needed</summary>
      </method>
      <method name="onMouseMove" scope="prototype">
        <summary>event processor for onmousemove</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>event processor for onmouseup</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <summary>event processor for onkeydown:
	watching for CTRL for copy/move status, watching for ESCAPE to cancel the drag</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>keyboard event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyUp" scope="prototype">
        <summary>event processor for onkeyup, watching for CTRL for copy/move status</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>keyboard event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setCopyStatus" scope="prototype">
        <summary>changes the copy status</summary>
        <parameters>
          <parameter name="copy" type="Boolean" usage="required">
            <summary>the copy status</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Manager.canDrop" type="Function" classlike="true">
    <summary>called to notify if the current target can accept items</summary>
    <properties>
      <property name="target" scope="instance" type=""/>
      <property name="canDropFlag" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="flag" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Manager.avatar.node" type=""/>
  <object location="dojo.dnd.Manager.avatar.node.style" type="">
    <properties>
      <property name="left" scope="prototype" type="String"/>
      <property name="top" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojo.dnd.__MoveableArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="handle" scope="prototype" type="Node||String">
        <summary>A node (or node's id), which is used as a mouse handle.
	If omitted, the node itself is used as a handle.</summary>
      </property>
      <property name="delay" scope="prototype" type="Number">
        <summary>delay move by this number of pixels</summary>
      </property>
      <property name="skip" scope="prototype" type="Boolean">
        <summary>skip move of form elements</summary>
      </property>
      <property name="mover" scope="normal" type="Object">
        <summary>a constructor of custom Mover</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.dnd.Moveable" type="Function" classlike="true">
    <summary>an object, which makes a node moveable</summary>
    <properties>
      <property name="handle" scope="instance-prototype" type="Object"/>
      <property name="delay" scope="instance-prototype" type="Number"/>
      <property name="skip" scope="instance-prototype" type="bool"/>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="node" scope="instance-prototype" type="Node">
        <summary>a node (or node's id) to be moved
	params: dojo.dnd.__MoveableArgs?
	optional parameters</summary>
      </property>
      <property name="_lastX" scope="prototype" type=""/>
      <property name="_lastY" scope="prototype" type=""/>
      <property name="mover" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__MoveableArgs" usage="optional">
            <summary>optional parameters</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>an object, which makes a node moveable</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__MoveableArgs" usage="optional">
            <summary>optional parameters</summary>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>stops watching for possible move, deletes all references, so the object can be garbage-collected</summary>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>event processor for onmousedown, creates a Mover for the node</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <summary>event processor for onmousemove, used only for delayed drags</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>event processor for onmouseup, used only for delayed drags</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectStart" scope="prototype">
        <summary>event processor for onselectevent and ondragevent</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDragDetected" scope="prototype">
        <summary>called when the drag is detected;
	responsible for creation of the mover</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStart" scope="prototype">
        <summary>called before every move operation</summary>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="prototype">
        <summary>called after every move operation</summary>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <summary>called during the very first move notification;
	can be used to initialize coordinates, can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="prototype">
        <summary>called during every move notification;
	should actually move the node; can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoving" scope="prototype">
        <summary>called before every incremental move; can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="prototype">
        <summary>called after every incremental move; can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Mover" type="Function" classlike="true">
    <summary>an object, which makes a node follow the mouse.
	Used as a default mover, and as a base class for custom movers.</summary>
    <properties>
      <property name="host" scope="instance-prototype" type="Object">
        <summary>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</summary>
      </property>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="mouseButton" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <summary>a mouse event, which started the move;
	only pageX and pageY properties are used</summary>
          </parameter>
          <parameter name="host" type="Object" usage="optional">
            <summary>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>an object, which makes a node follow the mouse.
	Used as a default mover, and as a base class for custom movers.</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <summary>a mouse event, which started the move;
	only pageX and pageY properties are used</summary>
          </parameter>
          <parameter name="host" type="Object" usage="optional">
            <summary>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <summary>event processor for onmousemove</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <summary>makes the node absolute; it is meant to be called only once.
	relative and absolutely positioned nodes are assumed to use pixel units</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>stops the move, deletes all references, so the object can be garbage-collected</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Mover.node" type="Node">
    <summary>a node (or node's id) to be moved
	e: Event
	a mouse event, which started the move;
	only pageX and pageY properties are used</summary>
  </object>
  <object location="dojo.dnd.Mover.node.style" type="">
    <properties>
      <property name="position" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojo.dnd.Mover.marginBox">
    <properties>
      <property name="l" scope="prototype" type="Number"/>
      <property name="t" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojo.dnd.__SelectorArgs" type="Function" classlike="true" superclass="dojo.dnd.__ContainerArgs" private="true">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.__ContainerArgs"/>
    </mixins>
    <properties>
      <property name="singular" scope="prototype" type="Boolean">
        <summary>allows selection of only one element, if true</summary>
      </property>
      <property name="autoSync" scope="prototype" type="Boolean">
        <summary>autosynchronizes the source with its list of DnD nodes,</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.dnd.Selector" type="Function" classlike="true" superclass="dojo.dnd.Container">
    <summary>a Selector object, which knows how to select its children</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Container"/>
    </mixins>
    <properties>
      <property name="selection" scope="instance-prototype" type="Set&lt;String&gt;">
        <summary>The set of id's that are currently selected, such that this.selection[id] == 1
	if the node w/that id is selected.  Can iterate over selected node's id's like:
			for(var id in this.selection)</summary>
      </property>
      <property name="singular" scope="instance-prototype" type="bool"/>
      <property name="anchor" scope="instance-prototype" type="Object"/>
      <property name="simpleSelection" scope="instance-prototype" type="bool"/>
      <property name="onmousemoveEvent" scope="prototype" type="Object"/>
      <property name="autoSync" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node||String" usage="required">
            <summary>node or node's id to build the selector on</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SelectorArgs" usage="optional">
            <summary>a dictionary of parameters</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>constructor of the Selector</summary>
        <parameters>
          <parameter name="node" type="Node||String" usage="required">
            <summary>node or node's id to build the selector on</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SelectorArgs" usage="optional">
            <summary>a dictionary of parameters</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getSelectedNodes" scope="prototype">
        <summary>returns a list (an array) of selected nodes</summary>
        <return-types>
          <return-type type="NodeList"/>
        </return-types>
      </method>
      <method name="selectNone" scope="prototype">
        <summary>unselects all items</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="selectAll" scope="prototype">
        <summary>selects all items</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="deleteSelectedNodes" scope="prototype">
        <summary>deletes all selected items</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="forInSelectedItems" scope="prototype">
        <summary>iterates over selected items;
	see &lt;code&gt;dojo.dnd.Container.forInItems()&lt;/code&gt; for details</summary>
        <parameters>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="sync" scope="prototype">
        <summary>sync up the node list with the data map</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="insertNodes" scope="prototype">
        <summary>inserts new data items (see &lt;code&gt;dojo.dnd.Container.insertNodes()&lt;/code&gt; method for details)</summary>
        <parameters>
          <parameter name="addSelected" type="Boolean" usage="required">
            <summary>all new nodes will be added to selected items, if true, no selection change otherwise</summary>
          </parameter>
          <parameter name="data" type="Array" usage="required">
            <summary>a list of data items, which should be processed by the creator function</summary>
          </parameter>
          <parameter name="before" type="Boolean" usage="required">
            <summary>insert before the anchor, if true, and after the anchor otherwise</summary>
          </parameter>
          <parameter name="anchor" type="Node" usage="required">
            <summary>the anchor node to be used as a point of insertion</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_normalizedCreator" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="hint" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>prepares the object to be garbage-collected</summary>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>event processor for onmousedown</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>event processor for onmouseup</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onOverEvent" scope="prototype">
        <summary>this function is called once, when mouse is over our container</summary>
      </method>
      <method name="onOutEvent" scope="prototype">
        <summary>this function is called once, when mouse is out of our container</summary>
      </method>
      <method name="_removeSelection" scope="prototype">
        <summary>unselects all items</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_removeAnchor" scope="prototype">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Source" type="Function" classlike="true" superclass="dojo.dnd.Selector">
    <summary>a Source object, which can be used as a DnD source, or a DnD target</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Selector"/>
    </mixins>
    <properties>
      <property name="isSource" scope="prototype" type="Object"/>
      <property name="horizontal" scope="prototype" type="bool"/>
      <property name="copyOnly" scope="prototype" type="bool"/>
      <property name="selfCopy" scope="prototype" type="bool"/>
      <property name="selfAccept" scope="prototype" type="Object"/>
      <property name="skipForm" scope="prototype" type="bool"/>
      <property name="withHandles" scope="prototype" type="bool"/>
      <property name="autoSync" scope="prototype" type="bool"/>
      <property name="delay" scope="prototype" type="Number"/>
      <property name="accept" scope="instance-prototype" type="Object"/>
      <property name="generateText" scope="prototype" type="Object"/>
      <property name="targetAnchor" scope="instance-prototype" type="Object"/>
      <property name="targetBox" scope="instance-prototype" type="Object"/>
      <property name="mouseDown" scope="instance-prototype" type="bool"/>
      <property name="_lastX" scope="instance-prototype" type="Number"/>
      <property name="_lastY" scope="instance-prototype" type="Number"/>
      <property name="isDragging" scope="instance-prototype" type="bool"/>
      <property name="before" scope="instance-prototype" type="Object"/>
      <property name="sourceState" scope="instance" type="String"/>
      <property name="targetState" scope="instance" type="String"/>
      <property name="topics" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <summary>node or node's id to build the source on</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional">
            <summary>any property of this class may be configured via the params
	object which is mixed-in to the &lt;code&gt;dojo.dnd.Source&lt;/code&gt; instance</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>a constructor of the Source</summary>
        <parameters>
          <parameter name="node" type="DOMNode|String" usage="required">
            <summary>node or node's id to build the source on</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__SourceArgs" usage="optional">
            <summary>any property of this class may be configured via the params
	object which is mixed-in to the &lt;code&gt;dojo.dnd.Source&lt;/code&gt; instance</summary>
          </parameter>
        </parameters>
      </method>
      <method name="checkAcceptance" scope="prototype">
        <summary>checks if the target can accept nodes from this source</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>the source which provides items</summary>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <summary>the list of transferred items</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="copyState" scope="prototype">
        <summary>Returns true if we need to copy items, false to move.
	It is separated to be overwritten dynamically, if needed.</summary>
        <parameters>
          <parameter name="keyPressed" type="Boolean" usage="required">
            <summary>the &amp;quot;copy&amp;quot; key was pressed</summary>
          </parameter>
          <parameter name="self" type="Boolean" usage="optional">
            <summary>optional flag that means that we are about to drop on itself</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <summary>prepares the object to be garbage-collected</summary>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <summary>event processor for onmousemove</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>event processor for onmousedown</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>event processor for onmouseup</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDndSourceOver" scope="prototype">
        <summary>topic event processor for /dnd/source/over, called when detected a current source</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>the source which has the mouse over it</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDndStart" scope="prototype">
        <summary>topic event processor for /dnd/start, called to initiate the DnD operation</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>the source which provides items</summary>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <summary>the list of transferred items</summary>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <summary>copy items, if true, move items otherwise</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDndDrop" scope="prototype">
        <summary>topic event processor for /dnd/drop, called to finish the DnD operation</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>the source which provides items</summary>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <summary>the list of transferred items</summary>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <summary>copy items, if true, move items otherwise</summary>
          </parameter>
          <parameter name="target" type="Object" usage="required">
            <summary>the target which accepts items</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDndCancel" scope="prototype">
        <summary>topic event processor for /dnd/cancel, called to cancel the DnD operation</summary>
      </method>
      <method name="onDrop" scope="prototype">
        <summary>called only on the current target, when drop is performed</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>the source which provides items</summary>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <summary>the list of transferred items</summary>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <summary>copy items, if true, move items otherwise</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDropExternal" scope="prototype">
        <summary>called only on the current target, when drop is performed
	from an external source</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required">
            <summary>the source which provides items</summary>
          </parameter>
          <parameter name="nodes" type="Array" usage="required">
            <summary>the list of transferred items</summary>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <summary>copy items, if true, move items otherwise</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_normalizedCreator" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="hint" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onDropInternal" scope="prototype">
        <summary>called only on the current target, when drop is performed
	from the same target/source</summary>
        <parameters>
          <parameter name="nodes" type="Array" usage="required">
            <summary>the list of transferred items</summary>
          </parameter>
          <parameter name="copy" type="Boolean" usage="required">
            <summary>copy items, if true, move items otherwise</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDraggingOver" scope="prototype">
        <summary>called during the active DnD operation, when items
	are dragged over this target, and it is not disabled</summary>
      </method>
      <method name="onDraggingOut" scope="prototype">
        <summary>called during the active DnD operation, when items
	are dragged away from this target, and it is not disabled</summary>
      </method>
      <method name="onOverEvent" scope="prototype">
        <summary>this function is called once, when mouse is over our container</summary>
      </method>
      <method name="onOutEvent" scope="prototype">
        <summary>this function is called once, when mouse is out of our container</summary>
      </method>
      <method name="_markTargetAnchor" scope="prototype">
        <summary>assigns a class to the current target anchor based on &amp;quot;before&amp;quot; status</summary>
        <parameters>
          <parameter name="before" type="Boolean" usage="required">
            <summary>insert before, if true, after otherwise</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="prototype">
        <summary>removes a class of the current target anchor based on &amp;quot;before&amp;quot; status</summary>
      </method>
      <method name="_markDndStatus" scope="prototype">
        <summary>changes source's state based on &amp;quot;copy&amp;quot; status</summary>
        <parameters>
          <parameter name="copy" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="prototype">
        <summary>checks if user clicked on &amp;quot;approved&amp;quot; items</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.Target" type="Function" classlike="true" superclass="dojo.dnd.Source">
    <summary>a Target object, which can be used as a DnD target</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Source"/>
    </mixins>
    <properties>
      <property name="isSource" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>a constructor of the Target --- see the &lt;code&gt;dojo.dnd.Source.constructor&lt;/code&gt; for details</summary>
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.AutoSource" type="Function" classlike="true" superclass="dojo.dnd.Source">
    <summary>a source that syncs its DnD nodes by default</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Source"/>
    </mixins>
    <properties>
      <property name="autoSync" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>constructor of the AutoSource --- see the Source constructor for details</summary>
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.__SourceArgs" type="Function" classlike="true" private="true">
    <summary>a dict of parameters for DnD Source configuration. Note that any
	property on Source elements may be configured, but this is the
	short-list</summary>
    <properties>
      <property name="isSource" scope="instance" type="Boolean">
        <summary>can be used as a DnD source. Defaults to true.</summary>
      </property>
      <property name="accept" scope="instance" type="Array">
        <summary>list of accepted types (text strings) for a target; defaults to
	[&amp;quot;text&amp;quot;]</summary>
      </property>
      <property name="autoSync" scope="instance" type="Boolean">
        <summary>if true refreshes the node list on every operation; false by default</summary>
      </property>
      <property name="copyOnly" scope="instance" type="Boolean">
        <summary>copy items, if true, use a state of Ctrl key otherwise,
	see selfCopy and selfAccept for more details</summary>
      </property>
      <property name="delay" scope="instance" type="Number">
        <summary>the move delay in pixels before detecting a drag; 0 by default</summary>
      </property>
      <property name="horizontal" scope="instance" type="Boolean">
        <summary>a horizontal container, if true, vertical otherwise or when omitted</summary>
      </property>
      <property name="selfCopy" scope="instance" type="Boolean">
        <summary>copy items by default when dropping on itself,
	false by default, works only if copyOnly is true</summary>
      </property>
      <property name="selfAccept" scope="instance" type="Boolean">
        <summary>accept its own items when copyOnly is true,
	true by default, works only if copyOnly is true</summary>
      </property>
      <property name="withHandles" scope="instance" type="Boolean">
        <summary>allows dragging only by handles, false by default</summary>
      </property>
      <property name="generateText" scope="instance" type="Boolean">
        <summary>generate text node for drag and drop, true by default</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.dnd.__TimedMoveableArgs" type="Function" classlike="true" superclass="dojo.dnd.__MoveableArgs" private="true">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.__MoveableArgs"/>
    </mixins>
    <properties>
      <property name="timeout" scope="prototype" type="Number">
        <summary>delay move by this number of ms,
	accumulating position changes during the timeout</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.dnd.TimedMoveable" type="Function" classlike="true" superclass="dojo.dnd.Moveable">
    <summary>A specialized version of Moveable to support an FPS throttling.
	This class puts an upper restriction on FPS, which may reduce
	the CPU load. The additional parameter &amp;quot;timeout&amp;quot; regulates
	the delay before actually moving the moveable object.</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Moveable"/>
    </mixins>
    <properties>
      <property name="timeout" scope="instance-prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node||String" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__TimedMoveableArgs" usage="required">
            <summary>object with additional parameters.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>an object that makes a node moveable with a timer</summary>
        <parameters>
          <parameter name="node" type="Node||String" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.__TimedMoveableArgs" usage="required">
            <summary>object with additional parameters.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="prototype">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="prototype">
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd._validNodes" private="true">
    <properties>
      <property name="div" scope="normal" type="Number"/>
      <property name="p" scope="normal" type="Number"/>
      <property name="td" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojo.dnd._validOverflow" private="true">
    <properties>
      <property name="auto" scope="normal" type="Number"/>
      <property name="scroll" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojo.dnd.move">
    <methods>
      <method name="constrainedMover" scope="normal">
        <summary>returns a constrained version of dojo.dnd.Mover</summary>
        <description>this function produces n object, which will put a constraint on
	the margin box of dragged object in absolute coordinates</description>
        <parameters>
          <parameter name="fun" type="Function" usage="required">
            <summary>called on drag, and returns a constraint box</summary>
          </parameter>
          <parameter name="within" type="Boolean" usage="required">
            <summary>if true, constraints the whole dragged object withtin the rectangle,
	otherwise the constraint is applied to the left-top corner</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="boxConstrainedMover" scope="normal">
        <summary>a specialization of dojo.dnd.constrainedMover, which constrains to the specified box</summary>
        <parameters>
          <parameter name="box" type="Object" usage="required">
            <summary>a constraint box (l, t, w, h)</summary>
          </parameter>
          <parameter name="within" type="Boolean" usage="required">
            <summary>if true, constraints the whole dragged object withtin the rectangle,
	otherwise the constraint is applied to the left-top corner</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="parentConstrainedMover" scope="normal">
        <summary>a specialization of dojo.dnd.constrainedMover, which constrains to the parent node</summary>
        <parameters>
          <parameter name="area" type="String" usage="required">
            <summary>&amp;quot;margin&amp;quot; to constrain within the parent's margin box, &amp;quot;border&amp;quot; for the border box,
	&amp;quot;padding&amp;quot; for the padding box, and &amp;quot;content&amp;quot; for the content box; &amp;quot;content&amp;quot; is the default value.</summary>
          </parameter>
          <parameter name="within" type="Boolean" usage="required">
            <summary>if true, constraints the whole dragged object within the rectangle,
	otherwise the constraint is applied to the left-top corner</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.move.__constrainedMoveableArgs" type="Function" classlike="true" superclass="dojo.dnd.__MoveableArgs" private="true">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.__MoveableArgs"/>
    </mixins>
    <properties>
      <property name="within" scope="prototype" type="Boolean">
        <summary>restrict move within boundaries.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constraints" scope="prototype">
        <summary>Calculates a constraint box.
	It is called in a context of the moveable object.</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.move.constrainedMoveable" type="Function" classlike="true" superclass="dojo.dnd.Moveable">
    <summary>an object that makes a node moveable</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Moveable"/>
    </mixins>
    <properties>
      <property name="within" scope="instance-prototype" type="bool"/>
      <property name="constraintBox" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__constrainedMoveableArgs" usage="optional">
            <summary>an optional object with additional parameters;
	the rest is passed to the base class</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constraints" scope="instance-prototype"/>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>an object that makes a node moveable</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__constrainedMoveableArgs" usage="optional">
            <summary>an optional object with additional parameters;
	the rest is passed to the base class</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <summary>called during the very first move notification;
	can be used to initialize coordinates, can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="prototype">
        <summary>called during every move notification;
	should actually move the node; can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
          <parameter name="leftTop" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.move.__boxConstrainedMoveableArgs" type="Function" classlike="true" superclass="dojo.dnd.move.__constrainedMoveableArgs" private="true">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.move.__constrainedMoveableArgs"/>
    </mixins>
    <properties>
      <property name="box" scope="prototype" type="Object">
        <summary>a constraint box</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.dnd.move.boxConstrainedMoveable" type="Function" classlike="true" superclass="dojo.dnd.move.constrainedMoveable">
    <summary>an object, which makes a node moveable</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.move.constrainedMoveable"/>
    </mixins>
    <properties>
      <property name="box" scope="prototype" type="object">
        <summary>attributes (for markup)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__boxConstrainedMoveableArgs" usage="optional">
            <summary>an optional object with parameters</summary>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>an object, which makes a node moveable</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__boxConstrainedMoveableArgs" usage="optional">
            <summary>an optional object with parameters</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constraints" scope="instance"/>
    </methods>
  </object>
  <object location="dojo.dnd.move.__parentConstrainedMoveableArgs" type="Function" classlike="true" superclass="dojo.dnd.move.__constrainedMoveableArgs" private="true">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.move.__constrainedMoveableArgs"/>
    </mixins>
    <properties>
      <property name="area" scope="prototype" type="String">
        <summary>A parent's area to restrict the move.
	Can be &amp;quot;margin&amp;quot;, &amp;quot;border&amp;quot;, &amp;quot;padding&amp;quot;, or &amp;quot;content&amp;quot;.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.dnd.move.parentConstrainedMoveable" type="Function" classlike="true" superclass="dojo.dnd.move.constrainedMoveable">
    <summary>an object, which makes a node moveable</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.move.constrainedMoveable"/>
    </mixins>
    <properties>
      <property name="area" scope="prototype" type="object">
        <summary>attributes (for markup)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__parentConstrainedMoveableArgs" usage="optional">
            <summary>an optional object with parameters</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="markupFactory" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>an object, which makes a node moveable</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>a node (or node's id) to be moved</summary>
          </parameter>
          <parameter name="params" type="dojo.dnd.move.__parentConstrainedMoveableArgs" usage="optional">
            <summary>an optional object with parameters</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="constraints" scope="instance">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.dnd.move.parentConstrainedMoveable.node" type="">
    <properties>
      <property name="parentNode" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojo.fx">
    <summary>Effects library on top of Base animations</summary>
    <methods>
      <method name="chain" scope="normal">
        <summary>Chain a list of &lt;code&gt;dojo.Animation&lt;/code&gt;s to run in sequence</summary>
        <description>Return a `dojo.Animation` which will play all passed
	`dojo.Animation` instances in sequence, firing its own
	synthesized events simulating a single animation. (eg:
	onEnd of this animation means the end of the chain,
	not the individual animations within)</description>
        <examples>
          <example>Once `node` is faded out, fade in `otherNode`
		dojo.fx.chain([
			dojo.fadeIn({ node:node }),
			dojo.fadeOut({ node:otherNode })
		]).play();</example>
        </examples>
        <parameters>
          <parameter name="animations" type="dojo.Animation[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="combine" scope="normal">
        <summary>Combine a list of &lt;code&gt;dojo.Animation&lt;/code&gt;s to run in parallel</summary>
        <description>Combine an array of `dojo.Animation`s to run in parallel,
	providing a new `dojo.Animation` instance encompasing each
	animation, firing standard animation events.</description>
        <examples>
          <example>Fade out `node` while fading in `otherNode` simultaneously
		dojo.fx.combine([
			dojo.fadeIn({ node:node }),
			dojo.fadeOut({ node:otherNode })
		]).play();</example>
          <example>When the longest animation ends, execute a function:
		var anim = dojo.fx.combine([
			dojo.fadeIn({ node: n, duration:700 }),
			dojo.fadeOut({ node: otherNode, duration: 300 })
		]);
		dojo.connect(anim, "onEnd", function(){
			// overall animation is done.
		});
		anim.play(); // play the animation</example>
        </examples>
        <parameters>
          <parameter name="animations" type="dojo.Animation[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeIn" scope="normal">
        <summary>Expand a node to it's natural height.</summary>
        <description>Returns an animation that will expand the
	node defined in 'args' object from it's current height to
	it's natural height (with no scrollbar).
	Node must have no margin/border/padding.</description>
        <examples>
          <example>	dojo.fx.wipeIn({
			node:"someId"
		}).play()</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>A hash-map of standard &lt;code&gt;dojo.Animation&lt;/code&gt; constructor properties
	(such as easing: node: duration: and so on)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeOut" scope="normal">
        <summary>Shrink a node to nothing and hide it.</summary>
        <description>Returns an animation that will shrink node defined in "args"
	from it's current height to 1px, and then hide it.</description>
        <examples>
          <example>	dojo.fx.wipeOut({ node:"someId" }).play()</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>A hash-map of standard &lt;code&gt;dojo.Animation&lt;/code&gt; constructor properties
	(such as easing: node: duration: and so on)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideTo" scope="normal">
        <summary>Slide a node to a new top/left position</summary>
        <description>Returns an animation that will slide "node"
	defined in args Object from its current position to
	the position defined by (args.left, args.top).</description>
        <examples>
          <example>	dojo.fx.slideTo({ node: node, left:"40", top:"50", units:"px" }).play()</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>A hash-map of standard &lt;code&gt;dojo.Animation&lt;/code&gt; constructor properties
	(such as easing: node: duration: and so on). Special args members
	are &lt;code&gt;top&lt;/code&gt; and &lt;code&gt;left&lt;/code&gt;, which indicate the new position to slide to.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.fx.Toggler" type="Function" classlike="true">
    <summary>A simple &lt;code&gt;dojo.Animation&lt;/code&gt; toggler API.</summary>
    <description>class constructor for an animation toggler. It accepts a packed
	set of arguments about what type of animation to use in each
	direction, duration, etc. All available members are mixed into
	these animations from the constructor (for example, `node`,
	`showDuration`, `hideDuration`).</description>
    <examples>
      <example>	var t = new dojo.fx.Toggler({
			node: "nodeId",
			showDuration: 500,
			// hideDuration will default to "200"
			showFunc: dojo.fx.wipeIn,
			// hideFunc will default to "fadeOut"
		});
		t.show(100); // delay showing for 100ms
		// ...time passes...
		t.hide();</example>
    </examples>
    <properties>
      <property name="node" scope="prototype" type="DomNode">
        <summary>the node to target for the showing and hiding animations</summary>
      </property>
      <property name="showDuration" scope="prototype" type="Time">
        <summary>in milliseconds to run the show Animation</summary>
      </property>
      <property name="hideDuration" scope="prototype" type="Time">
        <summary>in milliseconds to run the hide Animation</summary>
      </property>
      <property name="_showArgs" scope="prototype" type="Object"/>
      <property name="_showAnim" scope="prototype" type="Object"/>
      <property name="_hideArgs" scope="prototype" type="Object"/>
      <property name="_hideAnim" scope="prototype" type="Object"/>
      <property name="_isShowing" scope="prototype" type="bool"/>
      <property name="_isHiding" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="showFunc" scope="normal">
        <summary>The function that returns the &lt;code&gt;dojo.Animation&lt;/code&gt; to show the node</summary>
      </method>
      <method name="hideFunc" scope="normal">
        <summary>The function that returns the &lt;code&gt;dojo.Animation&lt;/code&gt; to hide the node</summary>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <summary>Toggle the node to showing</summary>
        <parameters>
          <parameter name="delay" type="Integer" usage="optional">
            <summary>Ammount of time to stall playing the show animation</summary>
          </parameter>
        </parameters>
      </method>
      <method name="hide" scope="prototype">
        <summary>Toggle the node to hidden</summary>
        <parameters>
          <parameter name="delay" type="Integer" usage="optional">
            <summary>Ammount of time to stall playing the hide animation</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.fx.easing">
    <summary>Collection of easing functions to use beyond the default
	&lt;code&gt;dojo._defaultEasing&lt;/code&gt; function.</summary>
    <description>Easing functions are used to manipulate the iteration through
	an `dojo.Animation`s _Line. _Line being the properties of an Animation,
	and the easing function progresses through that Line determing
	how quickly (or slowly) it should go. Or more accurately: modify
	the value of the _Line based on the percentage of animation completed.
	All functions follow a simple naming convention of "ease type" + "when".
	If the name of the function ends in Out, the easing described appears
	towards the end of the animation. "In" means during the beginning,
	and InOut means both ranges of the Animation will applied, both
	beginning and end.
	One does not call the easing function directly, it must be passed to
	the `easing` property of an animation.</description>
    <examples>
      <example>	dojo.require("dojo.fx.easing");
		var anim = dojo.fadeOut({
			node: 'node',
			duration: 2000,
			//	note there is no ()
			easing: dojo.fx.easing.quadIn
		}).play();</example>
    </examples>
    <methods>
      <method name="linear" scope="normal">
        <summary>A linear easing function</summary>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadIn" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quadInOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicIn" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="cubicInOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartIn" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quartInOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintIn" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="quintInOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineIn" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="sineInOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoIn" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="expoInOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circIn" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="circInOut" scope="normal">
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backIn" scope="normal">
        <summary>An easing function that starts away from the target,
	and quickly accelerates towards the end value.
	Use caution when the easing will cause values to become
	negative as some properties cannot be set to negative values.</summary>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backOut" scope="normal">
        <summary>An easing function that pops past the range briefly, and slowly comes back.</summary>
        <description>An easing function that pops past the range briefly, and slowly comes back.
	Use caution when the easing will cause values to become negative as some
	properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="backInOut" scope="normal">
        <summary>An easing function combining the effects of &lt;code&gt;backIn&lt;/code&gt; and &lt;code&gt;backOut&lt;/code&gt;</summary>
        <description>An easing function combining the effects of `backIn` and `backOut`.
	Use caution when the easing will cause values to become negative
	as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticIn" scope="normal">
        <summary>An easing function the elastically snaps from the start value</summary>
        <description>An easing function the elastically snaps from the start value
	Use caution when the elasticity will cause values to become negative
	as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticOut" scope="normal">
        <summary>An easing function that elasticly snaps around the target value,
	near the end of the Animation</summary>
        <description>An easing function that elasticly snaps around the target value,
	near the end of the Animation
	Use caution when the elasticity will cause values to become
	negative as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="elasticInOut" scope="normal">
        <summary>An easing function that elasticly snaps around the value, near
	the beginning and end of the Animation.</summary>
        <description>An easing function that elasticly snaps around the value, near
	the beginning and end of the Animation.
	Use caution when the elasticity will cause values to become
	negative as some properties cannot be set to negative values.</description>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceIn" scope="normal">
        <summary>An easing function that 'bounces' near the beginning of an Animation</summary>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
      <method name="bounceOut" scope="normal">
        <summary>An easing function that 'bounces' near the end of an Animation</summary>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
      </method>
      <method name="bounceInOut" scope="normal">
        <summary>An easing function that 'bounces' at the beginning and end of the Animation</summary>
        <parameters>
          <parameter name="n" type="Decimal" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.gears">
    <properties>
      <property name="available" scope="normal" type="bool">
        <summary>True if client is using Google Gears</summary>
      </property>
    </properties>
    <methods>
      <method name="_gearsObject" scope="normal">
        <summary>factory method to get a Google Gears plugin instance to
	expose in the browser runtime environment, if present</summary>
        <return-types>
          <return-type type="already defined elsewhere"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.html">
    <methods>
      <method name="_secureForInnerHtml" scope="normal">
        <summary>removes !DOCTYPE and title elements from the html string.
	khtml is picky about dom faults, you can't attach a style or &amp;lt;title&amp;gt; node as child of body
	must go into head, so we need to cut out those tags</summary>
        <parameters>
          <parameter name="cont" type="String" usage="required">
            <summary>An html string for insertion into the dom</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_emptyNode" scope="normal">
        <summary>removes all child nodes from the given node</summary>
        <parameters>
          <parameter name="node" type="DOMNode" usage="required">
            <summary>the parent element</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setNodeContent" scope="normal">
        <summary>inserts the given content into the given node</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>the parent element
	content:
	the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</summary>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="normal">
        <summary>inserts (replaces) the given content into the given node. dojo.place(cont, node, &amp;quot;only&amp;quot;)
	may be a better choice for simple HTML insertion.</summary>
        <description>Unless you need to use the params capabilities of this method, you should use
	dojo.place(cont, node, "only"). dojo.place() has more robust support for injecting
	an HTML string into the DOM, but it only handles inserting an HTML string as DOM
	elements, or inserting a DOM node. dojo.place does not handle NodeList insertions
	or the other capabilities as defined by the params object for this method.</description>
        <examples>
          <example>A safe string/node/nodelist content replacement/injection with hooks for extension
	Example Usage:
	dojo.html.set(node, "some string");
	dojo.html.set(node, contentNode, {options});
	dojo.html.set(node, myNode.childNodes, {options});</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>the parent element that will receive the content</summary>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required">
            <summary>the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</summary>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <summary>Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.html._ContentSetter" type="Function" classlike="true">
    <summary>Provides a configurable, extensible object to wrap the setting on content on a node
	call the set() method to actually set the content..</summary>
    <properties>
      <property name="node" scope="instance-prototype" type="DomNode|String">
        <summary>An node which will be the parent element that we set content into</summary>
      </property>
      <property name="content" scope="prototype" type="String|DomNode|DomNode[]">
        <summary>The content to be placed in the node. Can be an HTML string, a node reference, or a enumerable list of nodes</summary>
      </property>
      <property name="id" scope="instance-prototype" type="String">
        <summary>Usually only used internally, and auto-generated with each instance</summary>
      </property>
      <property name="cleanContent" scope="prototype" type="Boolean">
        <summary>Should the content be treated as a full html document,
	and the real content stripped of &amp;lt;html&amp;gt;, &amp;lt;body&amp;gt; wrapper before injection</summary>
      </property>
      <property name="extractContent" scope="prototype" type="Boolean">
        <summary>Should the content be treated as a full html document, and the real content stripped of &amp;lt;html&amp;gt;, &amp;lt;body&amp;gt; wrapper before injection</summary>
      </property>
      <property name="parseContent" scope="prototype" type="Boolean">
        <summary>Should the node by passed to the parser after the new content is set</summary>
      </property>
      <property name="parseResults" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Provides a configurable, extensible object to wrap the setting on content on a node
	call the set() method to actually set the content..</summary>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="prototype">
        <summary>front-end to the set-content sequence</summary>
        <parameters>
          <parameter name="cont" type="String|DomNode|NodeList" usage="optional">
            <summary>An html string, node or enumerable list of nodes for insertion into the dom
	If not provided, the object's content property will be used</summary>
          </parameter>
          <parameter name="params" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setContent" scope="prototype">
        <summary>sets the content on the node</summary>
      </method>
      <method name="empty" scope="prototype"/>
      <method name="onBegin" scope="prototype"/>
      <method name="onEnd" scope="prototype"/>
      <method name="tearDown" scope="prototype"/>
      <method name="onContentError" scope="prototype">
        <parameters>
          <parameter name="err" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_mixin" scope="prototype">
        <parameters>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="prototype">
        <summary>runs the dojo parser over the node contents, storing any results in this.parseResults
	Any errors resulting from parsing are passed to _onError for handling</summary>
      </method>
      <method name="_onError" scope="prototype">
        <summary>shows user the string that is returned by on[type]Error
	overide/implement on[type]Error and return your own string to customize</summary>
        <parameters>
          <parameter name="type" type="" usage="required"/>
          <parameter name="err" type="" usage="required"/>
          <parameter name="consoleText" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.i18n">
    <summary>Utility classes to enable loading of resources for internationalization (i18n)</summary>
    <methods>
      <method name="getLocalization" scope="normal">
        <summary>Returns an Object containing the localization for a given resource
	bundle in a package, matching the specified locale.</summary>
        <description>Returns a hash containing name/value pairs in its prototypesuch
	that values can be easily overridden.  Throws an exception if the
	bundle is not found.  Bundle must have already been loaded by
	`dojo.requireLocalization()` or by a build optimization step.  NOTE:
	try not to call this method as part of an object property
	definition (`var foo = { bar: dojo.i18n.getLocalization() }`).  In
	some loading situations, the bundle may not be available in time
	for the object definition.  Instead, call this method inside a
	function that is run after all modules load or the page loads (like
	in `dojo.addOnLoad()`), or in a widget lifecycle method.</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required">
            <summary>package which is associated with this resource</summary>
          </parameter>
          <parameter name="bundleName" type="String" usage="required">
            <summary>the base filename of the resource bundle (without the &amp;quot;.js&amp;quot; suffix)</summary>
          </parameter>
          <parameter name="locale" type="String" usage="optional">
            <summary>the variant to load (optional).  By default, the locale defined by
	the host environment: dojo.locale</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="normalizeLocale" scope="normal">
        <summary>Returns canonical form of locale, as used by Dojo.</summary>
        <description>All variants are case-insensitive and are separated by '-' as specified in [RFC 3066](http://www.ietf.org/rfc/rfc3066.txt).
	If no locale is specified, the dojo.locale is returned.  dojo.locale is defined by
	the user agent's locale unless overridden by djConfig.</description>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_requireLocalization" scope="normal">
        <summary>See dojo.requireLocalization()</summary>
        <description>Called by the bootstrap, but factored out so that it is only
	included in the build when needed.</description>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="availableFlatLocales" type="String" usage="optional"/>
          <parameter name="m" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_searchLocalePath" scope="normal">
        <summary>A helper method to assist in searching for locale-based resources.
	Will iterate through the variants of a particular locale, either up
	or down, executing a callback function.  For example, &amp;quot;en-us&amp;quot; and
	true will try &amp;quot;en-us&amp;quot; followed by &amp;quot;en&amp;quot; and finally &amp;quot;ROOT&amp;quot;.</summary>
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
          <parameter name="down" type="Boolean" usage="required"/>
          <parameter name="searchFunc" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_preloadLocalizations" scope="normal">
        <summary>Load built, flattened resource bundles, if available for all
	locales used in the page. Only called by built layer files.</summary>
        <parameters>
          <parameter name="bundlePrefix" type="String" usage="required"/>
          <parameter name="localesGenerated" type="Array" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.io.iframe">
    <summary>Sends an Ajax I/O call using and Iframe (for instance, to upload files)</summary>
    <properties>
      <property name="_currentDfd" scope="normal" type="Object"/>
      <property name="_dfdQueue" scope="normal" type="Array"/>
      <property name="_iframeName" scope="normal" type="String"/>
    </properties>
    <methods>
      <method name="create" scope="normal">
        <summary>Creates a hidden iframe in the page. Used mostly for IO
	transports.  You do not need to call this to start a
	dojo.io.iframe request. Just call send().</summary>
        <parameters>
          <parameter name="fname" type="String" usage="required">
            <summary>The name of the iframe. Used for the name attribute on the
	iframe.</summary>
          </parameter>
          <parameter name="onloadstr" type="String" usage="required">
            <summary>A string of JavaScript that will be executed when the content
	in the iframe loads.</summary>
          </parameter>
          <parameter name="uri" type="String" usage="optional">
            <summary>The value of the src attribute on the iframe element. If a
	value is not given, then dojo/resources/blank.html will be
	used.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setSrc" scope="normal">
        <summary>Sets the URL that is loaded in an IFrame. The replace parameter
	indicates whether location.replace() should be used when
	changing the location of the iframe.</summary>
        <parameters>
          <parameter name="iframe" type="DOMNode" usage="required"/>
          <parameter name="src" type="String" usage="required"/>
          <parameter name="replace" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="doc" scope="normal">
        <summary>Returns the document object associated with the iframe DOM Node argument.</summary>
        <parameters>
          <parameter name="iframeNode" type="DOMNode" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.io.iframe.__ioArgs" type="Function" classlike="true" superclass="dojo.__IoArgs" private="true">
    <summary>All the properties described in the dojo.__ioArgs type, apply
	to this type. The following additional properties are allowed
	for dojo.io.iframe.send():</summary>
    <mixins>
      <mixin scope="instance" location="dojo.__IoArgs"/>
    </mixins>
    <properties>
      <property name="method" scope="instance" type="String">
        <summary>The HTTP method to use. &amp;quot;GET&amp;quot; or &amp;quot;POST&amp;quot; are the only supported
	values.  It will try to read the value from the form node's
	method, then try this argument. If neither one exists, then it
	defaults to POST.</summary>
      </property>
      <property name="handleAs" scope="instance" type="String">
        <summary>Specifies what format the result data should be given to the
	load/handle callback. Valid values are: text, html, xml, json,
	javascript. IMPORTANT: For all values EXCEPT html and xml, The
	server response should be an HTML file with a textarea element.
	The response data should be inside the textarea element. Using an
	HTML document the only reliable, cross-browser way this
	transport can know when the response has loaded. For the html
	handleAs value, just return a normal HTML document.  NOTE: xml
	is now supported with this transport (as of 1.1+); a known issue
	is if the XML document in question is malformed, Internet Explorer
	will throw an uncatchable error.</summary>
      </property>
      <property name="content" scope="instance" type="Object">
        <summary>If &amp;quot;form&amp;quot; is one of the other args properties, then the content
	object properties become hidden form form elements. For
	instance, a content object of {name1 : &amp;quot;value1&amp;quot;} is converted
	to a hidden form element with a name of &amp;quot;name1&amp;quot; and a value of
	&amp;quot;value1&amp;quot;. If there is not a &amp;quot;form&amp;quot; property, then the content
	object is converted into a name=value&amp;amp;name=value string, by
	using dojo.objectToQuery().</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>All the properties described in the dojo.__ioArgs type, apply
	to this type. The following additional properties are allowed
	for dojo.io.iframe.send():</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.io">
    <summary>Additional I/O transports (Ajax)</summary>
  </object>
  <object location="dojo.io.iframe.send" type="Function" classlike="true">
    <summary>Function that sends the request to the server.
	This transport can only process one send() request at a time, so if send() is called
	multiple times, it will queue up the calls and only process one at a time.</summary>
    <properties>
      <property name="_frame" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="dojo.io.iframe.__ioArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.io.iframe._fireNextRequest" type="Function" classlike="true" private="true">
    <summary>Internal method used to fire the next request in the bind queue.</summary>
    <properties>
      <property name="_currentDfd" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.io.iframe._iframeOnload" type="Function" classlike="true" private="true">
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.io.iframe._iframeOnload._currentDfd" type="" private="true"/>
  <object location="dojo.io.iframe._iframeOnload._currentDfd.ioArgs" type="">
    <properties>
      <property name="args" scope="instance" type=""/>
      <property name="_contentToClean" scope="instance" type=""/>
      <property name="_finished" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojo.io.script">
    <properties>
      <property name="_deadScripts" scope="normal" type="Array"/>
      <property name="_counter" scope="normal" type="Number"/>
    </properties>
    <methods>
      <method name="get" scope="normal">
        <summary>sends a get request using a dynamically created script tag.</summary>
        <parameters>
          <parameter name="args" type="dojo.io.script.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="attach" scope="normal">
        <summary>creates a new &amp;lt;script&amp;gt; tag pointing to the specified URL and
	adds it to the document.</summary>
        <description>Attaches the script element to the DOM.  Use this method if you
	just want to attach a script to the DOM and do not care when or
	if it loads.</description>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="normal">
        <summary>removes the script element with the given id, from the given frameDocument.
	If no frameDocument is passed, the current document is used.</summary>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="_makeScriptDeferred" scope="normal">
        <summary>sets up a Deferred object for an IO request.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_deferredCancel" scope="normal">
        <summary>canceller function for dojo._ioSetArgs call.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredOk" scope="normal">
        <summary>okHandler function for dojo._ioSetArgs call.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredError" scope="normal">
        <summary>errHandler function for dojo._ioSetArgs call.</summary>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_addDeadScript" scope="normal">
        <summary>sets up an entry in the deadScripts array.</summary>
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_validCheck" scope="normal">
        <summary>inflight check function to see if dfd is still valid.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioCheck" scope="normal">
        <summary>inflight check function to see if IO finished.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_resHandle" scope="normal">
        <summary>inflight function to handle a completed response.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_canAttach" scope="normal">
        <summary>provides an override of dojo.io.script._canAttach to check for
	the existence of a the args.frameDoc property. If it is there, and it is a string,
	not a document, then create the iframe with an ID of frameDoc, and use that for the calls.
	If frameDoc is a document, then dojox.io.scriptFrame should not get involved.</summary>
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.io.script.__ioArgs" type="Function" classlike="true" superclass="dojo.__IoArgs" private="true">
    <summary>All the properties described in the dojo.__ioArgs type, apply to this
	type as well, EXCEPT &amp;quot;handleAs&amp;quot;. It is not applicable to
	dojo.io.script.get() calls, since it is implied by the usage of
	&amp;quot;jsonp&amp;quot; (response will be a JSONP call returning JSON)
	or the response is pure JavaScript defined in
	the body of the script that was attached.</summary>
    <mixins>
      <mixin scope="instance" location="dojo.__IoArgs"/>
    </mixins>
    <properties>
      <property name="callbackParamName" scope="instance" type="String">
        <summary>Deprecated as of Dojo 1.4 in favor of &amp;quot;jsonp&amp;quot;, but still supported for
	legacy code. See notes for jsonp property.</summary>
      </property>
      <property name="jsonp" scope="instance" type="c&quot;."/>
      <property name="checkString" scope="instance" type="String">
        <summary>A string of JavaScript that when evaluated like so:
	&amp;quot;typeof(&amp;quot; + checkString + &amp;quot;) != 'undefined'&amp;quot;
	being true means that the script fetched has been loaded.
	Do not use this if doing a JSONP type of call (use callbackParamName instead).</summary>
      </property>
      <property name="frameDoc" scope="instance" type="Document">
        <summary>The Document object for a child iframe. If this is passed in, the script
	will be attached to that document. This can be helpful in some comet long-polling
	scenarios with Firefox and Opera.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>All the properties described in the dojo.__ioArgs type, apply to this
	type as well, EXCEPT &amp;quot;handleAs&amp;quot;. It is not applicable to
	dojo.io.script.get() calls, since it is implied by the usage of
	&amp;quot;jsonp&amp;quot; (response will be a JSONP call returning JSON)
	or the response is pure JavaScript defined in
	the body of the script that was attached.</summary>
      </method>
    </methods>
  </object>
  <object location="dojo.io.script._jsonpCallback" type="Function" classlike="true" private="true">
    <summary>generic handler for jsonp callback. A pointer to this function
	is used for all jsonp callbacks.  NOTE: the &amp;quot;this&amp;quot; in this
	function will be the Deferred object that represents the script
	request.</summary>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="json" type="JSON" usage="required">
            <summary>Object</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.io.script._jsonpCallback.ioArgs" type="">
    <properties>
      <property name="json" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojo.number">
    <summary>localized formatting and parsing routines for Number</summary>
    <properties>
      <property name="_numberPatternRE" scope="normal" type="RegExp"/>
    </properties>
    <methods>
      <method name="format" scope="normal">
        <summary>Format a Number as a String, using locale-specific settings</summary>
        <description>Create a string from a Number using a known localized pattern.
	Formatting patterns appropriate to the locale are chosen from the
	[CLDR](http://unicode.org/cldr) as well as the appropriate symbols and
	delimiters.  See &lt;http://www.unicode.org/reports/tr35/#Number_Elements&gt;
	If value is Infinity, -Infinity, or is not a valid JavaScript number, return null.</description>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <summary>the number to be formatted</summary>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_applyPattern" scope="normal">
        <summary>Apply pattern to format value as a string using options. Gives no
	consideration to local customs.</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <summary>the number to be formatted.</summary>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <summary>a pattern string as described by
	[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)</summary>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatOptions" usage="optional">
            <summary>_applyPattern is usually called via &lt;code&gt;dojo.number.format()&lt;/code&gt; which
	populates an extra property in the options parameter, &amp;quot;customs&amp;quot;.
	The customs object specifies group and decimal parameters if set.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="round" scope="normal">
        <summary>Rounds to the nearest value with the given number of decimal places, away from zero</summary>
        <description>Rounds to the nearest value with the given number of decimal places, away from zero if equal.
	Similar to Number.toFixed(), but compensates for browser quirks. Rounding can be done by
	fractional increments also, such as the nearest quarter.
	NOTE: Subject to floating point errors.  See dojox.math.round for experimental workaround.</description>
        <examples>
          <example>&gt;&gt;&gt; dojo.number.round(-0.5)
	-1
	&gt;&gt;&gt; dojo.number.round(162.295, 2)
	162.29  // note floating point error.  Should be 162.3
	&gt;&gt;&gt; dojo.number.round(10.71, 0, 2.5)
	10.75</example>
        </examples>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <summary>The number to round</summary>
          </parameter>
          <parameter name="places" type="Number" usage="optional">
            <summary>The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	Must be non-negative.</summary>
          </parameter>
          <parameter name="increment" type="Number" usage="optional">
            <summary>Rounds next place to nearest value of increment/10.  10 by default.</summary>
          </parameter>
          <parameter name="v" type="" usage="required"/>
          <parameter name="p" type="" usage="required"/>
          <parameter name="m" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_formatAbsolute" scope="normal">
        <summary>Apply numeric pattern to absolute value using options. Gives no
	consideration to local customs.</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <summary>the number to be formatted, ignores sign</summary>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <summary>the number portion of a pattern (e.g. &lt;code&gt;#,##0.00&lt;/code&gt;)</summary>
          </parameter>
          <parameter name="options" type="dojo.number.__FormatAbsoluteOptions" usage="optional"/>
        </parameters>
      </method>
      <method name="regexp" scope="normal">
        <summary>Builds the regular needed to parse a number</summary>
        <description>Returns regular expression with positive and negative match, group
	and decimal separators</description>
        <parameters>
          <parameter name="options" type="dojo.number.__RegexpOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="normal">
        <parameters>
          <parameter name="options" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="parse" scope="normal">
        <summary>Convert a properly formatted string to a primitive Number, using
	locale-specific settings.</summary>
        <description>Create a Number from a string using a known localized pattern.
	Formatting patterns are chosen appropriate to the locale
	and follow the syntax described by
	[unicode.org TR35](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)</description>
        <parameters>
          <parameter name="expression" type="String" usage="required">
            <summary>A string representation of a Number</summary>
          </parameter>
          <parameter name="options" type="dojo.number.__ParseOptions" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="NaN"/>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_realNumberRegexp" scope="normal">
        <summary>Builds a regular expression to match a real number in exponential
	notation</summary>
        <parameters>
          <parameter name="flags" type="dojo.number.__RealNumberRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_integerRegexp" scope="normal">
        <summary>Builds a regular expression that matches an integer</summary>
        <parameters>
          <parameter name="flags" type="dojo.number.__IntegerRegexpFlags" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.number.__FormatOptions" type="Function" classlike="true" private="true">
    <properties>
      <property name="pattern" scope="instance" type="String">
        <summary>override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	with this string.  Default value is based on locale.  Overriding this property will defeat
	localization.</summary>
      </property>
      <property name="type" scope="instance" type="String">
        <summary>choose a format type based on the locale from the following:
	decimal, scientific (not yet supported), percent, currency. decimal by default.</summary>
      </property>
      <property name="places" scope="instance" type="Number">
        <summary>fixed number of decimal places to show.  This overrides any
	information in the provided pattern.</summary>
      </property>
      <property name="round" scope="instance" type="Number">
        <summary>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	means do not round.</summary>
      </property>
      <property name="locale" scope="instance" type="String">
        <summary>override the locale used to determine formatting rules</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.number.__FormatAbsoluteOptions" type="Function" classlike="true" private="true">
    <properties>
      <property name="decimal" scope="instance" type="String">
        <summary>the decimal separator</summary>
      </property>
      <property name="group" scope="instance" type="String">
        <summary>the group separator</summary>
      </property>
      <property name="places" scope="instance" type="Number|String">
        <summary>number of decimal places.  the range &amp;quot;n,m&amp;quot; will format to m places.</summary>
      </property>
      <property name="round" scope="instance" type="Number">
        <summary>5 rounds to nearest .5; 0 rounds to nearest whole (default). -1
	means don't round.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.number.__RegexpOptions" type="Function" classlike="true" private="true">
    <properties>
      <property name="pattern" scope="instance" type="String">
        <summary>override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	with this string.  Default value is based on locale.  Overriding this property will defeat
	localization.</summary>
      </property>
      <property name="type" scope="instance" type="String">
        <summary>choose a format type based on the locale from the following:
	decimal, scientific (not yet supported), percent, currency. decimal by default.</summary>
      </property>
      <property name="locale" scope="instance" type="String">
        <summary>override the locale used to determine formatting rules</summary>
      </property>
      <property name="strict" scope="instance" type="Boolean">
        <summary>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators</summary>
      </property>
      <property name="places" scope="instance" type="Number|String">
        <summary>number of decimal places to accept: Infinity, a positive number, or
	a range &amp;quot;n,m&amp;quot;.  Defined by pattern or Infinity if pattern not provided.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.number.__ParseOptions" type="Function" classlike="true" private="true">
    <properties>
      <property name="pattern" scope="instance" type="String">
        <summary>override [formatting pattern](http://www.unicode.org/reports/tr35/#Number_Format_Patterns)
	with this string.  Default value is based on locale.  Overriding this property will defeat
	localization.</summary>
      </property>
      <property name="type" scope="instance" type="String">
        <summary>choose a format type based on the locale from the following:
	decimal, scientific (not yet supported), percent, currency. decimal by default.</summary>
      </property>
      <property name="locale" scope="instance" type="String">
        <summary>override the locale used to determine formatting rules</summary>
      </property>
      <property name="strict" scope="instance" type="Boolean">
        <summary>strict parsing, false by default.  Strict parsing requires input as produced by the format() method.
	Non-strict is more permissive, e.g. flexible on white space, omitting thousands separators</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.number.__RealNumberRegexpFlags" type="Function" classlike="true" private="true">
    <properties>
      <property name="places" scope="instance" type="Number">
        <summary>The integer number of decimal places or a range given as &amp;quot;n,m&amp;quot;.  If
	not given, the decimal part is optional and the number of places is
	unlimited.</summary>
      </property>
      <property name="decimal" scope="instance" type="String">
        <summary>A string for the character used as the decimal point.  Default
	is &amp;quot;.&amp;quot;.</summary>
      </property>
      <property name="fractional" scope="instance" type="Boolean|Array">
        <summary>Whether decimal places are used.  Can be true, false, or [true,
	false].  Default is [true, false] which means optional.</summary>
      </property>
      <property name="exponent" scope="instance" type="Boolean|Array">
        <summary>Express in exponential notation.  Can be true, false, or [true,
	false]. Default is [true, false], (i.e. will match if the
	exponential part is present are not).</summary>
      </property>
      <property name="eSigned" scope="instance" type="Boolean|Array">
        <summary>The leading plus-or-minus sign on the exponent.  Can be true,
	false, or [true, false].  Default is [true, false], (i.e. will
	match if it is signed or unsigned).  flags in regexp.integer can be
	applied.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.number.__IntegerRegexpFlags" type="Function" classlike="true" private="true">
    <properties>
      <property name="signed" scope="instance" type="Boolean">
        <summary>The leading plus-or-minus sign. Can be true, false, or &lt;code&gt;[true,false]&lt;/code&gt;.
	Default is &lt;code&gt;[true, false]&lt;/code&gt;, (i.e. will match if it is signed
	or unsigned).</summary>
      </property>
      <property name="separator" scope="instance" type="String">
        <summary>The character used as the thousands separator. Default is no
	separator. For more than one symbol use an array, e.g. &lt;code&gt;[&amp;quot;,&amp;quot;, &amp;quot;&amp;quot;]&lt;/code&gt;,
	makes ',' optional.</summary>
      </property>
      <property name="groupSize" scope="instance" type="Number">
        <summary>group size between separators</summary>
      </property>
      <property name="groupSize2" scope="instance" type="Number">
        <summary>second grouping, where separators 2..n have a different interval than the first separator (for India)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo.regexp">
    <summary>Regular expressions and Builder resources</summary>
    <methods>
      <method name="escapeString" scope="normal">
        <summary>Adds escape sequences for special characters in regular expressions</summary>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="except" type="String" usage="optional">
            <summary>a String with special characters to be left unescaped</summary>
          </parameter>
        </parameters>
      </method>
      <method name="buildGroupRE" scope="normal">
        <summary>Builds a regular expression that groups subexpressions</summary>
        <description>A utility function used by some of the RE generators. The
	subexpressions are constructed by the function, re, in the second
	parameter.  re builds one subexpression for each elem in the array
	a, in the first parameter. Returns a string for a regular
	expression that groups all the subexpressions.</description>
        <parameters>
          <parameter name="arr" type="Object|Array" usage="required">
            <summary>A single value or an array of values.</summary>
          </parameter>
          <parameter name="re" type="Function" usage="required">
            <summary>A function. Takes one parameter and converts it to a regular
	expression.</summary>
          </parameter>
          <parameter name="nonCapture" type="Boolean" usage="optional">
            <summary>If true, uses non-capturing match, otherwise matches are retained
	by regular expression. Defaults to false</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="group" scope="normal">
        <summary>adds group match to expression</summary>
        <parameters>
          <parameter name="expression" type="String" usage="required"/>
          <parameter name="nonCapture" type="Boolean" usage="optional">
            <summary>If true, uses non-capturing match, otherwise matches are retained
	by regular expression.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojo.rpc">
    <summary>Dojo remote-procedure-call resources</summary>
  </object>
  <object location="dojo.rpc.JsonService" type="Function" classlike="true" superclass="dojo.rpc.RpcService">
    <mixins>
      <mixin scope="instance" location="dojo.rpc.RpcService"/>
    </mixins>
    <properties>
      <property name="bustCache" scope="prototype" type="bool"/>
      <property name="contentType" scope="prototype" type="String"/>
      <property name="lastSubmissionId" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="callRemote" scope="prototype">
        <summary>call an arbitrary remote method without requiring it to be
	predefined with SMD</summary>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <summary>the name of the remote method you want to call.</summary>
          </parameter>
          <parameter name="params" type="array" usage="required">
            <summary>array of parameters to pass to method</summary>
          </parameter>
        </parameters>
      </method>
      <method name="bind" scope="prototype">
        <summary>JSON-RPC bind method. Takes remote method, parameters,
	deferred, and a url, calls createRequest to make a JSON-RPC
	envelope and passes that off with bind.</summary>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <summary>The name of the method we are calling</summary>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <summary>The parameters we are passing off to the method</summary>
          </parameter>
          <parameter name="deferredRequestHandler" type="deferred" usage="required">
            <summary>The Deferred object for this particular request</summary>
          </parameter>
          <parameter name="url" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createRequest" scope="prototype">
        <summary>create a JSON-RPC envelope for the request</summary>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <summary>The name of the method we are creating the requst for</summary>
          </parameter>
          <parameter name="params" type="array" usage="required">
            <summary>The array of parameters for this request;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="parseResults" scope="prototype">
        <summary>parse the result envelope and pass the results back to
	the callback function</summary>
        <parameters>
          <parameter name="obj" type="anything" usage="required">
            <summary>Object Object containing envelope of data we recieve from the server</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.rpc.JsonpService" type="Function" classlike="true" superclass="dojo.rpc.RpcService">
    <summary>Generic JSONP service.  Minimally extends RpcService to allow
	easy definition of nearly any JSONP style service. Example
	SMD files exist in dojox.data</summary>
    <mixins>
      <mixin scope="instance" location="dojo.rpc.RpcService"/>
    </mixins>
    <properties>
      <property name="strictArgChecks" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="" usage="required"/>
          <parameter name="requiredArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
          <parameter name="requiredArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="bind" scope="prototype">
        <summary>JSONP bind method. Takes remote method, parameters,
	deferred, and a url, calls createRequest to make a JSON-RPC
	envelope and passes that off with bind.</summary>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <summary>The name of the method we are calling</summary>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <summary>The parameters we are passing off to the method</summary>
          </parameter>
          <parameter name="deferredRequestHandler" type="deferred" usage="required">
            <summary>The Deferred object for this particular request</summary>
          </parameter>
          <parameter name="url" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createRequest" scope="prototype">
        <summary>create a JSONP req
	params: array
	The array of parameters for this request;</summary>
        <parameters>
          <parameter name="parameters" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.rpc.RpcService" type="Function" classlike="true">
    <summary>Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
	as a definition for the service</summary>
    <properties>
      <property name="strictArgChecks" scope="instance-prototype" type="Object"/>
      <property name="serviceUrl" scope="instance-prototype" type="Object"/>
      <property name="required" scope="prototype" type=""/>
      <property name="smd" scope="prototype" type=""/>
      <property name="timeout" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <summary>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
	as a definition for the service</summary>
        <parameters>
          <parameter name="args" type="object" usage="required">
            <summary>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="parseResults" scope="prototype">
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <summary>Object that is the return results from an rpc request</summary>
          </parameter>
        </parameters>
      </method>
      <method name="errorCallback" scope="prototype">
        <summary>create callback that calls the Deferres errback method</summary>
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required">
            <summary>Deferred The deferred object handling a request.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="resultCallback" scope="prototype">
        <summary>create callback that calls the Deferred's callback method</summary>
        <parameters>
          <parameter name="deferredRequestHandler" type="dojo.Deferred" usage="required">
            <summary>Deferred The deferred object handling a request.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="generateMethod" scope="prototype">
        <summary>generate the local bind methods for the remote object</summary>
        <parameters>
          <parameter name="method" type="string" usage="required">
            <summary>The name of the method we are generating</summary>
          </parameter>
          <parameter name="parameters" type="array" usage="required">
            <summary>the array of parameters for this call.</summary>
          </parameter>
          <parameter name="url" type="string" usage="required">
            <summary>the service url for this call</summary>
          </parameter>
        </parameters>
      </method>
      <method name="processSmd" scope="prototype">
        <summary>callback method for reciept of a smd object.  Parse the smd
	and generate functions based on the description</summary>
        <parameters>
          <parameter name="object" type="smd" usage="required">
            <summary>object defining this service.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.string">
    <summary>String utilities for Dojo</summary>
    <methods>
      <method name="rep" scope="normal">
        <summary>Efficiently replicate a string &lt;code&gt;n&lt;/code&gt; times.</summary>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <summary>the string to replicate</summary>
          </parameter>
          <parameter name="num" type="Integer" usage="required">
            <summary>number of times to replicate the string</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="pad" scope="normal">
        <summary>Pad a string to guarantee that it is at least &lt;code&gt;size&lt;/code&gt; length by
	filling with the character &lt;code&gt;ch&lt;/code&gt; at either the start or end of the
	string. Pads at the start, by default.</summary>
        <examples>
          <example>	// Fill the string to length 10 with "+" characters on the right.  Yields "Dojo++++++".
		dojo.string.pad("Dojo", 10, "+", true);</example>
        </examples>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <summary>the string to pad</summary>
          </parameter>
          <parameter name="size" type="Integer" usage="required">
            <summary>length to provide padding</summary>
          </parameter>
          <parameter name="ch" type="String" usage="optional">
            <summary>character to pad, defaults to '0'</summary>
          </parameter>
          <parameter name="end" type="Boolean" usage="optional">
            <summary>adds padding at the end if true, otherwise pads at start</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="substitute" scope="normal">
        <summary>Performs parameterized substitutions on a string. Throws an
	exception if any parameter is unmatched.</summary>
        <examples>
          <example>Substitutes two expressions in a string from an Array or Object
		// returns "File 'foo.html' is not found in directory '/temp'."
		// by providing substitution data in an Array
		dojo.string.substitute(
			"File '${0}' is not found in directory '${1}'.",
			["foo.html","/temp"]
		);
		// also returns "File 'foo.html' is not found in directory '/temp'."
		// but provides substitution data in an Object structure.  Dotted
		// notation may be used to traverse the structure.
		dojo.string.substitute(
			"File '${name}' is not found in directory '${info.dir}'.",
			{ name: "foo.html", info: { dir: "/temp" } }
		);</example>
          <example>Use a transform function to modify the values:
		// returns "file 'foo.html' is not found in directory '/temp'."
		dojo.string.substitute(
			"${0} is not found in ${1}.",
			["foo.html","/temp"],
			function(str){
				// try to figure out the type
				var prefix = (str.charAt(0) == "/") ? "directory": "file";
				return prefix + " '" + str + "'";
			}
		);</example>
          <example>Use a formatter
		// returns "thinger -- howdy"
		dojo.string.substitute(
			"${0:postfix}", ["thinger"], null, {
				postfix: function(value, key){
					return value + " -- howdy";
				}
			}
		);</example>
        </examples>
        <parameters>
          <parameter name="template" type="String" usage="required">
            <summary>a string with expressions in the form &lt;code&gt;${key}&lt;/code&gt; to be replaced or
	&lt;code&gt;${key:format}&lt;/code&gt; which specifies a format function. keys are case-sensitive.</summary>
          </parameter>
          <parameter name="map" type="Object|Array" usage="required">
            <summary>hash to search for substitutions</summary>
          </parameter>
          <parameter name="transform" type="Function" usage="optional">
            <summary>a function to process all parameters before substitution takes
	place, e.g. mylib.encodeXML</summary>
          </parameter>
          <parameter name="thisObject" type="Object" usage="optional">
            <summary>where to look for optional format function; default to the global
	namespace</summary>
          </parameter>
        </parameters>
      </method>
      <method name="trim" scope="normal">
        <summary>Trims whitespace from both sides of the string</summary>
        <description>This version of trim() was taken from [Steven Levithan's blog](http://blog.stevenlevithan.com/archives/faster-trim-javascript).
	The short yet performant version of this function is dojo.trim(),
	which is part of Dojo base.  Uses String.prototype.trim instead, if available.</description>
        <return-description>String
	Returns the trimmed string</return-description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <summary>String to be trimmed</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.analytics" type="Function" classlike="true">
    <summary>Website analytics and client monitoring system</summary>
    <properties>
      <property name="_data" scope="instance" type="Array"/>
      <property name="_id" scope="instance" type="Number"/>
      <property name="sendInterval" scope="instance" type="Number"/>
      <property name="inTransitRetry" scope="instance" type="Number"/>
      <property name="dataUrl" scope="instance" type="Object"/>
      <property name="sendMethod" scope="instance" type="String"/>
      <property name="maxRequestSize" scope="instance" type=""/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="schedulePusher" scope="prototype">
        <summary>Schedule the data pushing routines to happen in interval ms</summary>
        <parameters>
          <parameter name="interval" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="addData" scope="prototype">
        <summary>add data to the queue. Will be pusshed to the server on the next
	data push</summary>
        <parameters>
          <parameter name="dataType" type="" usage="required"/>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="checkData" scope="prototype">
        <summary>TODOC?</summary>
      </method>
      <method name="onPushComplete" scope="prototype">
        <summary>If our data push was successfully, remove the _inTransit data and schedule the next
	parser run.</summary>
        <parameters>
          <parameter name="results" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.analytics.Urchin" type="Function" classlike="true">
    <summary>A Google-analytics helper, for post-onLoad inclusion of the tracker, and
	dynamic tracking during long-lived page cycles.</summary>
    <description>A small class object will allows for lazy-loading the Google Analytics API
	at any point during a page lifecycle. Most commonly, Google-Analytics is loaded
	via a synchronous script tag in the body, which causes `dojo.addOnLoad` to
	stall until the external API has been completely loaded. The Urchin helper
	will load the API on the fly, and provide a convenient API to use, wrapping
	Analytics for Ajaxy or single page applications.
	The class can be instantiated two ways: Programatically, by passing an
	`acct:` parameter, or via Markup / dojoType and defining a djConfig
	parameter `urchin:`
	IMPORTANT:
	This module will not work simultaneously with the core dojox.analytics
	package. If you need the ability to run Google Analytics AND your own local
	analytics system, you MUST include dojox.analytics._base BEFORE dojox.analytics.Urchin</description>
    <examples>
      <example>	// create the tracker programatically:
		var tracker = new dojox.analytics.Urchin({ acct:"UA-123456-7" });</example>
      <example>	// define the urchin djConfig option:
		var djConfig = { urchin: "UA-123456-7" };
		// and in markup:
		&lt;div dojoType="dojox.analytics.Urchin"&gt;&lt;/div&gt;
		// or code:
		new dojox.analytics.Urchin();</example>
      <example>	// create and define all analytics with one tag.
		&lt;div dojoType="dojox.analytics.Urchin" acct="UA-12345-67"&gt;&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="acct" scope="instance-prototype" type="String">
        <summary>your GA urchin tracker account number. Overrides &lt;code&gt;djConfig.urchin&lt;/code&gt;</summary>
      </property>
      <property name="tracker" scope="instance-prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize this Urchin instance. Immediately starts the load
	sequence, so defer construction until (ideally) after onLoad and
	potentially widget parsing.</summary>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_gotGA" scope="prototype">
        <summary>initialize the tracker</summary>
      </method>
      <method name="GAonLoad" scope="prototype">
        <summary>Stub function to fire when urchin is complete</summary>
        <description>This function is executed when the tracker variable is
	complete and initialized. The initial trackPageView (with
	no arguments) is called here as well, so remeber to call
	manually if overloading this method.</description>
        <examples>
          <example>Create an Urchin tracker that will track a specific page on init
	after page load (or parsing, if parseOnLoad is true)
		dojo.addOnLoad(function(){
			new dojox.ananlytics.Urchin({
				acct:"UA-12345-67",
				GAonLoad: function(){
					this.trackPageView("/custom-page");
				}
			});
		});</example>
        </examples>
      </method>
      <method name="trackPageView" scope="prototype">
        <summary>A public API attached to this widget instance, allowing you
	Ajax-like notification of updates.</summary>
        <examples>
          <example>Track clicks from a container of anchors and populate a `ContentPane`
		// 'tracker' is our `Urchin` instance, pane is the `ContentPane` ref.
		dojo.connect(container, "onclick", function(e){
			var ref = dojo.attr(e.target, "href");
			tracker.trackPageView(ref);
			pane.attr("href", ref);
		});</example>
        </examples>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <summary>String A location to tell the tracker to track, eg: &amp;quot;/my-ajaxy-endpoint&amp;quot;</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.analytics.pushData" type="Function" classlike="true">
    <summary>pushes data to the server if any exists.  If a push is done, return
	the deferred after hooking up completion callbacks.  If there is no data
	to be pushed, return false;</summary>
    <properties>
      <property name="_inTransit" scope="instance" type=""/>
      <property name="_data" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.analytics.getQueryPacket" type="Function" classlike="true">
    <summary>TODOC</summary>
    <properties>
      <property name="_split" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.analytics.plugins">
    <properties>
      <property name="consoleMessages" scope="normal" type="Object"/>
      <property name="dojo" scope="normal" type="Object"/>
      <property name="idle" scope="normal" type="Object"/>
      <property name="mouseClick" scope="normal" type="Object"/>
      <property name="mouseOver" scope="normal" type="Object"/>
      <property name="window" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dependencies">
    <properties>
      <property name="layers" scope="normal" type="Array"/>
      <property name="prefixes" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.atom.io"/>
  <object location="dojox.atom.io.Connection" type="Function" classlike="true">
    <summary>This object implements a transport layer for working with ATOM feeds and ATOM publishing protocols.</summary>
    <description>This object implements a transport layer for working with ATOM feeds and ATOM publishing protocols.
	Specifically, it provides a mechanism by which feeds can be fetched and entries can be fetched, created
	deleted, and modified.  It also provides access to the introspection data.</description>
    <properties>
      <property name="preventCache" scope="instance-prototype" type="bool"/>
      <property name="alertsEnabled" scope="prototype" type="bool"/>
      <property name="sync" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="sync" type="Boolean" usage="required"/>
          <parameter name="preventCache" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>initializer</summary>
        <parameters>
          <parameter name="sync" type="Boolean" usage="required"/>
          <parameter name="preventCache" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getFeed" scope="prototype">
        <summary>Function to obtain a s specific ATOM feed from a given ATOM Feed url.</summary>
        <description>This function takes the URL for a specific ATOM feed and returns
	the data from that feed to the caller through the use of a callback
	handler.</description>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <summary>The URL of the ATOM feed to fetch.</summary>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <summary>A function reference that will handle the feed when it has been retrieved.
	The callback should accept two parameters:  The feed object and the original complete DOM object.</summary>
          </parameter>
          <parameter name="errorCallback" type="Function" usage="required"/>
          <parameter name="scope" type="Object" usage="required">
            <summary>The scope to use for all callbacks.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getService" scope="prototype">
        <summary>Function to retrieve an introspection document from the given URL.</summary>
        <description>This function takes the URL for an ATOM item and feed and returns
	the introspection document.</description>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <summary>The URL of the ATOM document to obtain the introspection document of.</summary>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <summary>A function reference that will handle the introspection document when it has been retrieved.
	The callback should accept two parameters:  The introspection document object and the original complete DOM object.</summary>
          </parameter>
          <parameter name="errorCallback" type="" usage="required"/>
          <parameter name="scope" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getEntry" scope="prototype">
        <summary>Function to retrieve a single entry from an ATOM feed from the given URL.</summary>
        <description>This function takes the URL for an ATOM entry and returns the constructed dojox.atom.io.model.Entry object through
	the specified callback.</description>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <summary>The URL of the ATOM Entry document to parse.</summary>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <summary>A function reference that will handle the Entry object obtained.
	The callback should accept two parameters, the dojox.atom.io.model.Entry object and the original dom.</summary>
          </parameter>
          <parameter name="errorCallback" type="" usage="required"/>
          <parameter name="scope" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getXmlDoc" scope="prototype">
        <summary>Internal Function to retrieve an XML document and pass the results to a callback.</summary>
        <description>This internal function takes the URL for an XML document and and passes the
	parsed contents to a specified callback.</description>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <summary>The URL of the XML document to retrieve</summary>
          </parameter>
          <parameter name="nodeName" type="" usage="required"/>
          <parameter name="newNode" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
          <parameter name="callback" type="Function" usage="required">
            <summary>A function reference that will handle the retrieved XML data.
	The callback should accept one parameter, the DOM of the parsed XML document.</summary>
          </parameter>
          <parameter name="errorCallback" type="" usage="required"/>
          <parameter name="scope" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateEntry" scope="prototype">
        <summary>Function to update a specific ATOM entry by putting the new changes via APP.</summary>
        <description>This function takes a specific dojox.atom.io.model.Entry object and pushes the
	changes back to the provider of the Entry.
	The entry MUST have a link tag with rel="edit" for this to work.</description>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
        <parameters>
          <parameter name="entry" type="Object" usage="required">
            <summary>The dojox.atom.io.model.Entry object to update.</summary>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <summary>A function reference that will handle the results from the entry update.
	The callback should accept two parameters:  The first is an Entry object, and the second is the URL of that Entry
	Either can be null, depending on the value of retrieveUpdated.</summary>
          </parameter>
          <parameter name="errorCallback" type="" usage="required"/>
          <parameter name="retrieveUpdated" type="boolean" usage="required">
            <summary>A boolean flag denoting if the entry that was updated should then be
	retrieved and returned to the caller via the callback.</summary>
          </parameter>
          <parameter name="xmethod" type="boolean" usage="required">
            <summary>Whether to use POST for PUT/DELETE items and send the X-Method-Override header.</summary>
          </parameter>
          <parameter name="scope" type="Object" usage="required">
            <summary>The scope to use for all callbacks.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addEntry" scope="prototype">
        <summary>Function to add a new ATOM entry by posting the new entry via APP.</summary>
        <description>This function takes a specific dojox.atom.io.model.Entry object and pushes the
	changes back to the provider of the Entry.</description>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
        <parameters>
          <parameter name="entry" type="Object" usage="required">
            <summary>The dojox.atom.io.model.Entry object to publish.</summary>
          </parameter>
          <parameter name="url" type="" usage="required"/>
          <parameter name="callback" type="Function" usage="required">
            <summary>A function reference that will handle the results from the entry publish.
	The callback should accept two parameters:   The first is an dojox.atom.io.model.Entry object, and the second is the location of the entry
	Either can be null, depending on the value of retrieveUpdated.</summary>
          </parameter>
          <parameter name="errorCallback" type="" usage="required"/>
          <parameter name="retrieveEntry" type="boolean" usage="required">
            <summary>A boolean flag denoting if the entry that was created should then be
	retrieved and returned to the caller via the callback.</summary>
          </parameter>
          <parameter name="scope" type="Object" usage="required">
            <summary>The scope to use for all callbacks.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="deleteEntry" scope="prototype">
        <summary>Function to delete a specific ATOM entry via APP.</summary>
        <description>This function takes a specific dojox.atom.io.model.Entry object and calls for a delete on the
	service housing the ATOM Entry database.
	The entry MUST have a link tag with rel="edit" for this to work.</description>
        <return-description>Nothing. The return is handled through the callback handler.</return-description>
        <parameters>
          <parameter name="entry" type="Object" usage="required">
            <summary>The dojox.atom.io.model.Entry object to delete.</summary>
          </parameter>
          <parameter name="callback" type="Function" usage="required">
            <summary>A function reference that will handle the results from the entry delete.
	The callback is called only if the delete is successful.</summary>
          </parameter>
          <parameter name="errorCallback" type="" usage="required"/>
          <parameter name="xmethod" type="" usage="required"/>
          <parameter name="scope" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom">
    <summary>Implements the Atom Syndication Format and Atom Publishing Protocol</summary>
  </object>
  <object location="dojox.atom.io.model"/>
  <object location="dojox.atom.io.model.Node" type="Function" classlike="true">
    <properties>
      <property name="name_space" scope="instance-prototype" type=""/>
      <property name="shortNs" scope="instance-prototype" type=""/>
      <property name="name" scope="instance-prototype" type="Object"/>
      <property name="textContent" scope="instance-prototype" type="Object"/>
      <property name="attributes" scope="instance-prototype" type="Array"/>
      <property name="content" scope="instance" type="Array"/>
      <property name="rawNodes" scope="instance" type="Array"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="name_space" type="" usage="required"/>
          <parameter name="name" type="" usage="required"/>
          <parameter name="attributes" type="" usage="required"/>
          <parameter name="content" type="" usage="required"/>
          <parameter name="shortNs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="name_space" type="" usage="required"/>
          <parameter name="name" type="" usage="required"/>
          <parameter name="attributes" type="" usage="required"/>
          <parameter name="content" type="" usage="required"/>
          <parameter name="shortNs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_saveAttributes" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addAttribute" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAttribute" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype"/>
      <method name="addContent" scope="prototype">
        <parameters>
          <parameter name="content" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.AtomItem" type="Function" classlike="true" superclass="dojox.atom.io.model.Node">
    <summary>Class container for generic Atom items.</summary>
    <description>Class container for generic Atom items.
	child objects can override this if they want to be called after a Dom build</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.Node"/>
    </mixins>
    <properties>
      <property name="_accepts" scope="prototype" type="Object"/>
      <property name="extensions" scope="instance-prototype" type="Object"/>
      <property name="authors" scope="instance-prototype" type="Object"/>
      <property name="contributors" scope="instance-prototype" type="Object"/>
      <property name="links" scope="instance-prototype" type="Object"/>
      <property name="categories" scope="instance-prototype" type="Object"/>
      <property name="icon" scope="instance-prototype" type="Object"/>
      <property name="id" scope="instance-prototype" type="Object"/>
      <property name="logo" scope="instance-prototype" type="Object"/>
      <property name="xmlBase" scope="instance-prototype" type="Object"/>
      <property name="rights" scope="instance-prototype" type="Object"/>
      <property name="subtitle" scope="instance-prototype" type="Object"/>
      <property name="updated" scope="instance-prototype" type="Object"/>
      <property name="published" scope="instance-prototype" type="Object"/>
      <property name="issued" scope="instance-prototype" type="Object"/>
      <property name="modified" scope="instance-prototype" type="Object"/>
      <property name="content" scope="instance-prototype" type="Object"/>
      <property name="entries" scope="instance-prototype" type="Object"/>
      <property name="ATOM_URI" scope="instance" type=""/>
      <property name="name_spaces" scope="instance" type="Object"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="prototype"/>
      <method name="accept" scope="prototype">
        <parameters>
          <parameter name="tag" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="prototype"/>
      <method name="buildFromDom" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addNamespace" scope="prototype">
        <parameters>
          <parameter name="fullName" type="" usage="required"/>
          <parameter name="shortName" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addAuthor" scope="prototype">
        <summary>Function to add in an author to the list of authors.</summary>
        <description>Function to add in an author to the list of authors.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <summary>The author's name.</summary>
          </parameter>
          <parameter name="email" type="String" usage="required">
            <summary>The author's e-mail address.</summary>
          </parameter>
          <parameter name="uri" type="String" usage="required">
            <summary>A URI associated with the author.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addContributor" scope="prototype">
        <summary>Function to add in an author to the list of authors.</summary>
        <description>Function to add in an author to the list of authors.</description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <summary>The author's name.</summary>
          </parameter>
          <parameter name="email" type="String" usage="required">
            <summary>The author's e-mail address.</summary>
          </parameter>
          <parameter name="uri" type="String" usage="required">
            <summary>A URI associated with the author.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addLink" scope="prototype">
        <summary>Function to add in a link to the list of links.</summary>
        <description>Function to add in a link to the list of links.</description>
        <parameters>
          <parameter name="href" type="String" usage="required">
            <summary>The href.</summary>
          </parameter>
          <parameter name="rel" type="String" usage="required"/>
          <parameter name="hrefLang" type="String" usage="required"/>
          <parameter name="title" type="String" usage="required">
            <summary>A title to associate with the link.</summary>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <summary>The type of link is is.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeLink" scope="prototype">
        <summary>Function to remove a link from the list of links.</summary>
        <description>Function to remove a link from the list of links.</description>
        <parameters>
          <parameter name="href" type="String" usage="required">
            <summary>The href.</summary>
          </parameter>
          <parameter name="rel" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeBasicLinks" scope="prototype">
        <summary>Function to remove all basic links from the list of links.</summary>
        <description>Function to remove all basic link from the list of links.</description>
      </method>
      <method name="addCategory" scope="prototype">
        <summary>Function to add in a category to the list of categories.</summary>
        <description>Function to add in a category to the list of categories.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getCategories" scope="prototype">
        <summary>Function to get all categories that match a particular scheme.</summary>
        <description>Function to get all categories that match a particular scheme.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required">
            <summary>The scheme to filter on.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeCategories" scope="prototype">
        <summary>Function to remove all categories that match a particular scheme and term.</summary>
        <description>Function to remove all categories that match a particular scheme and term.</description>
        <parameters>
          <parameter name="scheme" type="String" usage="required">
            <summary>The scheme to filter on.</summary>
          </parameter>
          <parameter name="term" type="String" usage="required">
            <summary>The term to filter on.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setTitle" scope="prototype">
        <summary>Function to set the title of the item.</summary>
        <description>Function to set the title of the item.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <summary>The title to set.</summary>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <summary>The type of title format, text, xml, xhtml, etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addExtension" scope="prototype">
        <summary>Function to add in an extension namespace into the item.</summary>
        <description>Function to add in an extension namespace into the item.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required">
            <summary>The namespace of the extension.</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>The name of the extension</summary>
          </parameter>
          <parameter name="attributes" type="Array" usage="required">
            <summary>The attributes associated with the extension.</summary>
          </parameter>
          <parameter name="content" type="String" usage="required">
            <summary>The content of the extension.</summary>
          </parameter>
          <parameter name="shortNS" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getExtensions" scope="prototype">
        <summary>Function to get extensions that match a namespace and name.</summary>
        <description>Function to get extensions that match a namespace and name.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required">
            <summary>The namespace of the extension.</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>The name of the extension</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeExtensions" scope="prototype">
        <summary>Function to remove extensions that match a namespace and name.</summary>
        <description>Function to remove extensions that match a namespace and name.</description>
        <parameters>
          <parameter name="name_space" type="String" usage="required">
            <summary>The namespace of the extension.</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>The name of the extension</summary>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.atom.io.model.AtomItem.title">
    <properties>
      <property name="value" scope="prototype" type=""/>
      <property name="type" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.io.model.Category" type="Function" classlike="true" superclass="dojox.atom.io.model.Node">
    <summary>Class container for 'Category' types.</summary>
    <description>Class container for 'Category' types.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.Node"/>
    </mixins>
    <properties>
      <property name="label" scope="instance-prototype" type=""/>
      <property name="scheme" scope="instance-prototype" type=""/>
      <property name="term" scope="instance-prototype" type=""/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="scheme" type="String" usage="required"/>
          <parameter name="term" type="String" usage="required"/>
          <parameter name="label" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="prototype"/>
      <method name="_getAttributeNames" scope="prototype"/>
      <method name="toString" scope="prototype">
        <summary>Function to construct string form of the category tag, which is an XML structure.</summary>
        <description>Function to construct string form of the category tag, which is an XML structure.</description>
      </method>
      <method name="buildFromDom" scope="prototype">
        <summary>Function to do construction of the Category data from the DOM node containing it.</summary>
        <description>Function to do construction of the Category data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <summary>The DOM node to process for content.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.Content" type="Function" classlike="true" superclass="dojox.atom.io.model.Node">
    <summary>Class container for 'Content' types. Such as summary, content, username, and so on types of data.</summary>
    <description>Class container for 'Content' types. Such as summary, content, username, and so on types of data.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.Node"/>
    </mixins>
    <properties>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="type" scope="instance-prototype" type="String"/>
      <property name="scheme" scope="prototype" type=""/>
      <property name="term" scope="prototype" type=""/>
      <property name="tagName" scope="instance" type=""/>
      <property name="src" scope="instance" type=""/>
      <property name="xmlLang" scope="instance" type=""/>
      <property name="HTML" scope="instance" type="String"/>
      <property name="TEXT" scope="instance" type="String"/>
      <property name="XHTML" scope="instance" type="String"/>
      <property name="XML" scope="instance" type="String"/>
      <property name="_useTextContent" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="tagName" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
          <parameter name="src" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
          <parameter name="xmlLang" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="tagName" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
          <parameter name="src" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
          <parameter name="xmlLang" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="prototype"/>
      <method name="_postBuild" scope="prototype"/>
      <method name="buildFromDom" scope="prototype">
        <summary>Function to do construction of the Content data from the DOM node containing it.</summary>
        <description>Function to do construction of the Content data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <summary>The DOM node to process for content.
	Handle checking for XML content as the content type</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <summary>Function to construct string form of the content tag, which is an XML structure.</summary>
        <description>Function to construct string form of the content tag, which is an XML structure.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.Link" type="Function" classlike="true" superclass="dojox.atom.io.model.Node">
    <summary>Class container for 'link' types.</summary>
    <description>Class container for 'link' types.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.Node"/>
    </mixins>
    <properties>
      <property name="href" scope="instance-prototype" type=""/>
      <property name="hrefLang" scope="instance-prototype" type=""/>
      <property name="rel" scope="instance-prototype" type=""/>
      <property name="title" scope="instance-prototype" type=""/>
      <property name="type" scope="instance-prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="href" type="" usage="required"/>
          <parameter name="rel" type="" usage="required"/>
          <parameter name="hrefLang" type="" usage="required"/>
          <parameter name="title" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="href" type="" usage="required"/>
          <parameter name="rel" type="" usage="required"/>
          <parameter name="hrefLang" type="" usage="required"/>
          <parameter name="title" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="prototype"/>
      <method name="_postBuild" scope="prototype"/>
      <method name="buildFromDom" scope="prototype">
        <summary>Function to do construction of the link data from the DOM node containing it.</summary>
        <description>Function to do construction of the link data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>DOM node to process for link data.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <summary>Function to construct string form of the link tag, which is an XML structure.</summary>
        <description>Function to construct string form of the link tag, which is an XML structure.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.Person" type="Function" classlike="true" superclass="dojox.atom.io.model.Node">
    <summary>Class container for 'person' types, such as Author, controbutors, and so on.</summary>
    <description>Class container for 'person' types, such as Author, controbutors, and so on.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.Node"/>
    </mixins>
    <properties>
      <property name="extensions" scope="prototype" type="Array"/>
      <property name="author" scope="instance" type="String"/>
      <property name="contributor" scope="instance" type="String"/>
      <property name="personType" scope="instance" type=""/>
      <property name="name" scope="instance" type="String"/>
      <property name="email" scope="instance" type="String"/>
      <property name="uri" scope="instance" type="String"/>
      <property name="_objName" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="personType" type="" usage="required"/>
          <parameter name="name" type="" usage="required"/>
          <parameter name="email" type="" usage="required"/>
          <parameter name="uri" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="personType" type="" usage="required"/>
          <parameter name="name" type="" usage="required"/>
          <parameter name="email" type="" usage="required"/>
          <parameter name="uri" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="prototype"/>
      <method name="_postBuild" scope="prototype"/>
      <method name="accept" scope="prototype">
        <parameters>
          <parameter name="tag" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="prototype">
        <summary>Function to do construction of the person data from the DOM node containing it.</summary>
        <description>Function to do construction of the person data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>DOM node to process for person data.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <summary>Function to construct string form of the Person tag, which is an XML structure.</summary>
        <description>Function to construct string form of the Person tag, which is an XML structure.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.Person._accepts" private="true">
    <properties>
      <property name="name" scope="normal" type="Object"/>
      <property name="uri" scope="normal" type="Object"/>
      <property name="email" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.atom.io.model.Generator" type="Function" classlike="true" superclass="dojox.atom.io.model.Node">
    <summary>Class container for 'Generator' types.</summary>
    <description>Class container for 'Generator' types.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.Node"/>
    </mixins>
    <properties>
      <property name="value" scope="instance-prototype" type="Object"/>
      <property name="uri" scope="instance-prototype" type=""/>
      <property name="version" scope="instance-prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="version" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="uri" type="String" usage="required"/>
          <parameter name="version" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_postBuild" scope="prototype"/>
      <method name="buildFromDom" scope="prototype">
        <summary>Function to do construction of the generator data from the DOM node containing it.</summary>
        <description>Function to do construction of the generator data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>DOM node to process for link data.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <summary>Function to construct string form of the Generator tag, which is an XML structure.</summary>
        <description>Function to construct string form of the Generator tag, which is an XML structure.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.Entry" type="Function" classlike="true" superclass="dojox.atom.io.model.AtomItem">
    <summary>Class container for 'Entry' types.</summary>
    <description>Class container for 'Entry' types.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.AtomItem"/>
    </mixins>
    <properties>
      <property name="published" scope="prototype" type=""/>
      <property name="updated" scope="prototype" type=""/>
      <property name="links" scope="prototype" type="Array"/>
      <property name="id" scope="instance" type=""/>
      <property name="_objName" scope="instance" type="String"/>
      <property name="feedUrl" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getAttributeNames" scope="prototype"/>
      <method name="toString" scope="prototype">
        <summary>Function to construct string form of the entry tag, which is an XML structure.</summary>
        <description>Function to construct string form of the entry tag, which is an XML structure.</description>
        <parameters>
          <parameter name="amPrimary" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getEditHref" scope="prototype">
        <summary>Function to get the href that allows editing of this feed entry.</summary>
        <description>Function to get the href that allows editing of this feed entry.</description>
        <return-description>The href that specifies edit capability.</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="setEditHref" scope="prototype">
        <parameters>
          <parameter name="url" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.Entry._accepts" private="true">
    <properties>
      <property name="author" scope="normal" type="Object"/>
      <property name="content" scope="normal" type="Object"/>
      <property name="category" scope="normal" type="Object"/>
      <property name="contributor" scope="normal" type="Object"/>
      <property name="created" scope="normal" type="Object"/>
      <property name="id" scope="normal" type="Object"/>
      <property name="link" scope="normal" type="Object"/>
      <property name="published" scope="normal" type="Object"/>
      <property name="rights" scope="normal" type="Object"/>
      <property name="summary" scope="normal" type="Object"/>
      <property name="title" scope="normal" type="Object"/>
      <property name="updated" scope="normal" type="Object"/>
      <property name="xmlbase" scope="normal" type="Object"/>
      <property name="issued" scope="normal" type="Object"/>
      <property name="modified" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.atom.io.model.Feed" type="Function" classlike="true" superclass="dojox.atom.io.model.AtomItem">
    <summary>Class container for 'Feed' types.</summary>
    <description>Class container for 'Feed' types.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.AtomItem"/>
    </mixins>
    <properties>
      <property name="entries" scope="prototype" type="Array"/>
      <property name="rights" scope="prototype" type=""/>
      <property name="updated" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="addEntry" scope="prototype">
        <summary>Function to add an entry to this feed.</summary>
        <description>Function to add an entry to this feed.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>The entry object to add.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFirstEntry" scope="prototype">
        <summary>Function to get the first entry of the feed.</summary>
        <description>Function to get the first entry of the feed.</description>
        <return-description>The first entry in the feed.</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getEntry" scope="prototype">
        <summary>Function to get an entry by its id.</summary>
        <description>Function to get an entry by its id.</description>
        <return-description>The entry desired, or null if none.</return-description>
        <parameters>
          <parameter name="entryId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="removeEntry" scope="prototype">
        <summary>Function to remove an entry from the list of links.</summary>
        <description>Function to remove an entry from the list of links.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>The entry.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setEntries" scope="prototype">
        <summary>Function to add a set of entries to the feed.</summary>
        <description>Function to get an entry by its id.</description>
        <parameters>
          <parameter name="arrayOfEntry" type="array" usage="required">
            <summary>An array of entry objects to add to the feed.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <summary>Function to construct string form of the feed tag, which is an XML structure.</summary>
        <description>Function to construct string form of the feed tag, which is an XML structure.</description>
      </method>
      <method name="createEntry" scope="prototype">
        <summary>Function to Create a new entry object in the feed.</summary>
        <description>Function to Create a new entry object in the feed.</description>
        <return-description>An empty entry object in the feed.</return-description>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getSelfHref" scope="prototype">
        <summary>Function to get the href that refers to this feed.</summary>
        <description>Function to get the href that refers to this feed.</description>
        <return-description>The href that refers to this feed or null if none.</return-description>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.Feed._accepts" private="true">
    <properties>
      <property name="author" scope="normal" type="Object"/>
      <property name="content" scope="normal" type="Object"/>
      <property name="category" scope="normal" type="Object"/>
      <property name="contributor" scope="normal" type="Object"/>
      <property name="created" scope="normal" type="Object"/>
      <property name="id" scope="normal" type="Object"/>
      <property name="link" scope="normal" type="Object"/>
      <property name="published" scope="normal" type="Object"/>
      <property name="rights" scope="normal" type="Object"/>
      <property name="summary" scope="normal" type="Object"/>
      <property name="title" scope="normal" type="Object"/>
      <property name="updated" scope="normal" type="Object"/>
      <property name="xmlbase" scope="normal" type="Object"/>
      <property name="entry" scope="normal" type="Object"/>
      <property name="logo" scope="normal" type="Object"/>
      <property name="issued" scope="normal" type="Object"/>
      <property name="modified" scope="normal" type="Object"/>
      <property name="icon" scope="normal" type="Object"/>
      <property name="subtitle" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.atom.io.model.Service" type="Function" classlike="true" superclass="dojox.atom.io.model.AtomItem">
    <summary>Class container for 'Feed' types.</summary>
    <description>Class container for 'Feed' types.
	builds a Service document.  each element of this, except for the namespace, is the href of
	a service that the server supports.  Some of the common services are:
	"create-entry" , "user-prefs" , "search-entries" , "edit-template" , "categories"</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.AtomItem"/>
    </mixins>
    <properties>
      <property name="workspaces" scope="prototype" type="Array"/>
      <property name="name_space" scope="prototype" type=""/>
      <property name="href" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="href" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="href" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="prototype">
        <summary>Function to do construction of the Service data from the DOM node containing it.</summary>
        <description>Function to do construction of the Service data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <summary>The DOM node to process for content.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getCollection" scope="prototype">
        <summary>Function to collections that match a specific url.</summary>
        <description>Function to collections that match a specific url.</description>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <summary>e URL to match collections against.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.Workspace" type="Function" classlike="true" superclass="dojox.atom.io.model.AtomItem">
    <summary>Class container for 'Workspace' types.</summary>
    <description>Class container for 'Workspace' types.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.AtomItem"/>
    </mixins>
    <properties>
      <property name="title" scope="instance-prototype" type="Object"/>
      <property name="collections" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="title" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="title" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="prototype">
        <summary>Function to do construction of the Workspace data from the DOM node containing it.</summary>
        <description>Function to do construction of the Workspace data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <summary>The DOM node to process for content.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.Collection" type="Function" classlike="true" superclass="dojox.atom.io.model.AtomItem">
    <summary>Class container for 'Collection' types.</summary>
    <description>Class container for 'Collection' types.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.io.model.AtomItem"/>
    </mixins>
    <properties>
      <property name="href" scope="instance-prototype" type="Object"/>
      <property name="memberType" scope="instance-prototype" type="Object"/>
      <property name="id" scope="instance-prototype" type="Object"/>
      <property name="title" scope="instance-prototype" type="Object"/>
      <property name="attributes" scope="instance" type="Array"/>
      <property name="features" scope="instance" type="Array"/>
      <property name="children" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="href" type="" usage="required"/>
          <parameter name="title" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="href" type="" usage="required"/>
          <parameter name="title" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildFromDom" scope="prototype">
        <summary>Function to do construction of the Collection data from the DOM node containing it.</summary>
        <description>Function to do construction of the Collection data from the DOM node containing it.</description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <summary>The DOM node to process for content.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model._Constants" private="true">
    <summary>Container for general constants.</summary>
    <description>Container for general constants.</description>
    <properties>
      <property name="ATOM_URI" scope="normal" type="String"/>
      <property name="ATOM_NS" scope="normal" type="String"/>
      <property name="PURL_NS" scope="normal" type="String"/>
      <property name="APP_NS" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.atom.io.model._actions" private="true">
    <summary>Container for tag handling functions.</summary>
    <description>Container for tag handling functions.  Each child of this container is
	a handler function for the given type of node. Each accepts two parameters:
	obj:  Object.
	The object to insert data into.
	node: DOM Node.
	The dom node containing the data
	Google news
	Google news</description>
    <methods>
      <method name="link" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="author" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="contributor" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="category" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="icon" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="id" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="rights" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="subtitle" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="title" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updated" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="issued" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="modified" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="published" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="entry" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="content" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="summary" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="name" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="email" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="uri" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="generator" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.io.model.util">
    <methods>
      <method name="createDate" scope="normal">
        <summary>Utility function to create a date from a DOM node's text content.</summary>
        <description>Utility function to create a date from a DOM node's text content.</description>
        <return-description>Date object from a DOM Node containing a ISO-8610 string.</return-description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <summary>The DOM node to inspect.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="escapeHtml" scope="normal">
        <summary>Utility function to escape XML special characters in an HTML string.</summary>
        <description>Utility function to escape XML special characters in an HTML string.</description>
        <return-description>HTML String with special characters (&lt;,&gt;,&amp;, ", etc,) escaped.</return-description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <summary>The string to escape</summary>
          </parameter>
        </parameters>
      </method>
      <method name="unEscapeHtml" scope="normal">
        <summary>Utility function to un-escape XML special characters in an HTML string.</summary>
        <description>Utility function to un-escape XML special characters in an HTML string.</description>
        <return-description>HTML String converted back to the normal text (unescaped) characters (&lt;,&gt;,&amp;, ", etc,).</return-description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <summary>The string to un-escape.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getNodename" scope="normal">
        <summary>Utility function to get a node name and deal with IE's bad handling of namespaces
	on tag names.</summary>
        <description>Utility function to get a node name and deal with IE's bad handling of namespaces
	on tag names.</description>
        <return-description>String
	The name without namespace prefixes.</return-description>
        <parameters>
          <parameter name="node" type="DOM" usage="required">
            <summary>The DOM node whose name to retrieve.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.widget"/>
  <object location="dojox.atom.widget.FeedEntryEditor" type="Function" classlike="true" superclass="dojox.atom.widget.FeedEntryViewer">
    <summary>An ATOM feed entry editor that allows viewing of the individual attributes of an entry.</summary>
    <description>An ATOM feed entry editor that allows viewing of the individual attributes of an entry.
	Flag denoting if the current entry is editable or not.</description>
    <mixins>
      <mixin scope="instance" location="dojox.atom.widget.FeedEntryViewer"/>
    </mixins>
    <properties>
      <property name="_contentEditor" scope="prototype" type="Object"/>
      <property name="_oldContent" scope="prototype" type="Object"/>
      <property name="_setObject" scope="prototype" type="Object"/>
      <property name="enableEdit" scope="prototype" type="bool"/>
      <property name="_contentEditorCreator" scope="prototype" type="Object"/>
      <property name="entryNewButton" scope="prototype" type="Object"/>
      <property name="_editable" scope="prototype" type="bool"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_subscriptions" scope="prototype" type="Array"/>
      <property name="_editMode" scope="prototype" type="bool"/>
      <property name="_toLoad" scope="prototype" type="Object"/>
      <property name="entryContentNode" scope="prototype" type="Object"/>
      <property name="_new" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="setEntry" scope="prototype">
        <summary>Function to set the current entry that is being edited.</summary>
        <description>Function to set the current entry that is being edited.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>Instance of dojox.atom.io.model.Entry to display for reading/editing.</summary>
          </parameter>
          <parameter name="feed" type="object" usage="required"/>
          <parameter name="leaveMenuState" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleEdit" scope="prototype">
        <summary>Internal function for toggling/enabling the display of edit mode</summary>
        <description>Internal function for toggling/enabling the display of edit mode</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_handleEvent" scope="prototype">
        <summary>Internal function for listening to a topic that will handle entry notification.</summary>
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required">
            <summary>The topic message containing the entry that was selected for view.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_isEditable" scope="prototype">
        <summary>Internal function for determining of a particular entry is editable.</summary>
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <return-description>Boolean denoting if the entry seems editable or not..</return-description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>The dojox.atom.io.model.Entry object to examine</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setTitle" scope="prototype">
        <summary>Function to set the contents of the title node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the title node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="titleAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the title data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setAuthors" scope="prototype">
        <summary>Function to set the contents of the author node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the author node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="authorsAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the author data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setContributors" scope="prototype">
        <summary>Function to set the contents of the contributor node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the contributor node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the contributor data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setId" scope="prototype">
        <summary>Function to set the contents of the ID  node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="idAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the ID data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setUpdated" scope="prototype">
        <summary>Function to set the contents of the updated  node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the updated node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the udpated data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setSummary" scope="prototype">
        <summary>Function to set the contents of the summary  node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the summary data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setContent" scope="prototype">
        <summary>Function to set the contents of the content node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	summaryAnchorNode:
	The DOM node to attach the content data to.</description>
        <parameters>
          <parameter name="contentAnchorNode" type="DOM" usage="required">
            <summary>node</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_createEditor" scope="prototype">
        <summary>Function to create an appropriate text editor widget based on the given parameters.</summary>
        <description>Function to create an appropriate text editor widget based on the given parameters.</description>
        <return-description>Either a widget (for textarea or textbox widgets) or an anonymous object to be used to create a
	rich text area widget.</return-description>
        <parameters>
          <parameter name="anchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the editor widget to.</summary>
          </parameter>
          <parameter name="node" type="DOM" usage="required">
            <summary>An object containing the value to be put into the editor.  This ranges from an anonymous object
	with a value parameter to a dojox.atom.io.model.Content object.</summary>
          </parameter>
          <parameter name="multiline" type="boolean" usage="required">
            <summary>A boolean indicating whether the content should be multiline (such as a textarea) instead of a
	single line (such as a textbox).</summary>
          </parameter>
          <parameter name="rte" type="object" usage="required">
            <summary>A boolean indicating whether the content should be a rich text editor widget.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_switchEditor" scope="prototype">
        <summary>Function to switch between editor types.</summary>
        <description>Function to switch between a rich text editor and a textarea widget.  Used for title, summary,
	And content when switching between text and html/xhtml content.</description>
        <parameters>
          <parameter name="event" type="object" usage="required">
            <summary>The event generated by the change in the select box on the page.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_createPeopleEditor" scope="prototype">
        <summary>Creates a People Editor widget and returns it.</summary>
        <description>Creates a People Editor widget, sets its value, and returns it.</description>
        <return-description>A new People Editor object.</return-description>
        <parameters>
          <parameter name="anchorNode" type="DOM" usage="required">
            <summary>The node to attach the editor to.</summary>
          </parameter>
          <parameter name="node" type="DOM" usage="required">
            <summary>An object containing the value to be put into the editor. Typically, this is an
	dojox.atom.io.model.Person object.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="saveEdits" scope="prototype">
        <summary>Saves edits submitted when the 'save' button is pressed.</summary>
        <description>Saves edits submitted when the 'save' button is pressed.  Distinguishes between new and existing
	entries and saves appropriately.  Fetches the values of the editors, and, if existing, compares them to
	the existing values and submits the updates, otherwise creates a new entry and posts it as a new entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_handleSave" scope="prototype">
        <summary>Function for handling the save of an entry, cleaning up the display after the edit is completed.</summary>
        <description>Function for handling the save of an entry, cleaning up the display after the edit is completed.</description>
        <return-description>Nothing.
	Close the editor and revert out.</return-description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>dojox.atom.io.model.Entry object
	The entry that was saved.
	Location: String
	A URL to be used, not used here, but part of the call back from the AtomIO</summary>
          </parameter>
          <parameter name="location" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="cancelEdits" scope="prototype">
        <summary>Cancels edits and reverts the editor to its previous state (display mode)</summary>
        <description>Cancels edits and reverts the editor to its previous state (display mode)</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="clear" scope="prototype">
        <summary>Clears the editor, destorys all editors, leaving the editor completely clear</summary>
        <description>Clears the editor, destorys all editors, leaving the editor completely clear</description>
      </method>
      <method name="clearEditors" scope="prototype"/>
      <method name="_enforceXhtml" scope="prototype">
        <summary>Function for cleaning up/enforcing the XHTML standard in HTML returned from the editor2 widget.</summary>
        <description>Function for cleaning up/enforcing the XHTML standard in HTML returned from the editor2 widget.</description>
        <return-description>string of cleaned up HTML.</return-description>
        <parameters>
          <parameter name="html" type="string" usage="required">
            <summary>HTML string to be enforced as xhtml.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_closeTag" scope="prototype">
        <summary>Function for closing tags in a text of HTML/XHTML</summary>
        <description>Function for closing tags in a text of HTML/XHTML</description>
        <return-description>string of cleaned up HTML.
	NOTE:  Probably should redo this function in a more efficient way.  This could get expensive.</return-description>
        <parameters>
          <parameter name="xhtml" type="string" usage="required">
            <summary>String XHTML string which needs the closing tag.</summary>
          </parameter>
          <parameter name="tag" type="string" usage="required">
            <summary>The tag to close.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_toggleNew" scope="prototype">
        <summary>Function to put the editor into a state to create a new entry.</summary>
        <description>Function to put the editor into a state to create a new entry.</description>
      </method>
      <method name="_displaySections" scope="prototype">
        <summary>Function to display the appropriate sections based on validity.</summary>
        <description>Function to display the appropriate sections based on validity.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.displayOptions" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelTitle" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelAuthors" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelContributors" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelId" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.close" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelUpdated" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelSummary" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.feedEntryCheckBoxLabelContent" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.doNew" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.edit" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.save" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.cancel" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.entryTitleSelect" type="">
    <properties>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor._editors" private="true">
    <properties>
      <property name="authors" scope="prototype" type="Object"/>
      <property name="contributors" scope="prototype" type="Object"/>
      <property name="id" scope="prototype" type="Object"/>
      <property name="updated" scope="prototype" type="Object"/>
      <property name="title" scope="prototype" type="Object"/>
      <property name="summary" scope="prototype" type="Object"/>
      <property name="content" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.entrySummarySelect" type="">
    <properties>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryEditor.entryContentSelect" type="">
    <properties>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.atom.widget.PeopleEditor" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>An editor for dojox.atom.io.model.Person objects.</summary>
    <description>An editor for dojox.atom.io.model.Person objects.  Displays multiple rows for the respective arrays
	of people.  Can add/remove rows on the fly.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_rows" scope="prototype" type="Array"/>
      <property name="_editors" scope="prototype" type="Array"/>
      <property name="_index" scope="prototype" type="Number"/>
      <property name="_numRows" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="_createEditors" scope="prototype">
        <summary>creates editor boxes (textbox widgets) for the individual values of a Person.</summary>
        <description>creates editor boxes (textbox widgets) for the individual values of a Person.</description>
        <parameters>
          <parameter name="name" type="string" usage="required">
            <summary>The name of this Person.</summary>
          </parameter>
          <parameter name="email" type="string" usage="required">
            <summary>The email of this Person.</summary>
          </parameter>
          <parameter name="uri" type="string" usage="required">
            <summary>The Person's URI.</summary>
          </parameter>
          <parameter name="index" type="int" usage="required">
            <summary>The row index to use for this Person.</summary>
          </parameter>
          <parameter name="widgetName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="_createEditor" scope="prototype">
        <summary>Creates an individual editor widget (textbox) for a value.</summary>
        <description>Creates an individual editor widget (textbox) for a value.</description>
        <return-description>Editor widget.</return-description>
        <parameters>
          <parameter name="value" type="string" usage="required">
            <summary>The initial value of the textbox</summary>
          </parameter>
          <parameter name="id" type="string" usage="required">
            <summary>The id the textbox should have.</summary>
          </parameter>
          <parameter name="name" type="string" usage="required">
            <summary>The text to put in the label element for this textbox.</summary>
          </parameter>
          <parameter name="labelNode" type="DOM" usage="required">
            <summary>The node to attach the label to.</summary>
          </parameter>
          <parameter name="node" type="DOM" usage="required">
            <summary>The node to attach the editor rows to.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_removeEditor" scope="prototype">
        <summary>Removes a Person from our list of editors.</summary>
        <description>Removes a Person from our list of editors by removing the block of editors that
	make up that Person.</description>
        <parameters>
          <parameter name="event" type="object" usage="required">
            <summary>The event generated when the remove button is pressed on the page.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_add" scope="prototype">
        <summary>Adds a new block of blank editors to represent a Person.</summary>
        <description>Adds a new block of blank editors to represent a Person.</description>
      </method>
      <method name="getValues" scope="prototype">
        <summary>Gets the values of this editor in an array.</summary>
        <description>Gets the values of this editor in an array, with each Person as an object within the array.</description>
        <return-description>An array of anonymous objects representing dojox.atom.io.model.Persons.</return-description>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>An ATOM feed entry editor for publishing updated ATOM entries, or viewing non-editable entries.</summary>
    <description>An ATOM feed entry editor for publishing updated ATOM entries, or viewing non-editable entries.
	The topic to listen on for entries to edit.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="entrySelectionTopic" scope="prototype" type="String"/>
      <property name="_validEntryFields" scope="prototype" type="Object"/>
      <property name="displayEntrySections" scope="prototype" type="String"/>
      <property name="_displayEntrySections" scope="prototype" type="Array"/>
      <property name="enableMenu" scope="prototype" type="bool"/>
      <property name="enableMenuFade" scope="prototype" type="bool"/>
      <property name="_optionButtonDisplayed" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_entry" scope="prototype" type="Object"/>
      <property name="_feed" scope="prototype" type="Object"/>
      <property name="_editMode" scope="prototype" type="bool"/>
      <property name="_subscriptions" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="clear" scope="prototype">
        <summary>Function to clear the state of the widget.</summary>
        <description>Function to clear the state of the widget.</description>
      </method>
      <method name="clearNodes" scope="prototype">
        <summary>Function to clear all the display nodes for the ATOM entry from the viewer.</summary>
        <description>Function to clear all the display nodes for the ATOM entry from the viewer.</description>
      </method>
      <method name="setEntry" scope="prototype">
        <summary>Function to set the current entry that is being edited.</summary>
        <description>Function to set the current entry that is being edited.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>Instance of dojox.atom.io.model.Entry to display for reading/editing.</summary>
          </parameter>
          <parameter name="feed" type="object" usage="required"/>
          <parameter name="leaveMenuState" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setTitleHeader" scope="prototype">
        <summary>Function to set the contents of the title header node in the template to some value.</summary>
        <description>Function to set the contents of the title header node in the template to some value.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	titleAchorNode:
	The DOM node to attach the title data to.
	editMode:
	Boolean to indicate if the display should be in edit mode or not.</description>
        <parameters>
          <parameter name="titleHeaderNode" type="DOM" usage="required">
            <summary>node</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setTitle" scope="prototype">
        <summary>Function to set the contents of the title node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the title node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	titleAchorNode:
	The DOM node to attach the title data to.</description>
        <parameters>
          <parameter name="titleAnchorNode" type="" usage="required"/>
          <parameter name="editMode" type="Boolean" usage="required">
            <summary>to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="The" usage="required">
            <summary>Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setAuthorsHeader" scope="prototype">
        <summary>Function to set the title format for the authors section of the author row in the template to some value from the entry.</summary>
        <description>Function to set the title format for the authors section of the author row in the template to some value from the entry.
	This exists specifically so users can over-ride how the author data is filled out from an entry.</description>
        <parameters>
          <parameter name="authorHeaderNode" type="DOM" usage="required">
            <summary>The DOM node to attach the author section header data to.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setAuthors" scope="prototype">
        <summary>Function to set the contents of the author node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the author node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	authorsAchorNode:
	The DOM node to attach the author data to.</description>
        <parameters>
          <parameter name="authorsAnchorNode" type="DOM" usage="required">
            <summary>node</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setContributorsHeader" scope="prototype">
        <summary>Function to set the contents of the contributor header node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the contributor header node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsHeaderNode" type="DOM" usage="required">
            <summary>The DOM node to attach the contributor title to.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setContributors" scope="prototype">
        <summary>Function to set the contents of the contributor node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the contributor node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contributorsAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the contributor data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setIdHeader" scope="prototype">
        <summary>Function to set the contents of the ID  node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.
	idAnchorNode:
	The DOM node to attach the ID data to.</description>
        <parameters>
          <parameter name="idHeaderNode" type="DOM" usage="required">
            <summary>node</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setId" scope="prototype">
        <summary>Function to set the contents of the ID  node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the ID node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="idAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the ID data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setUpdatedHeader" scope="prototype">
        <summary>Function to set the contents of the updated header node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the updated header node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedHeaderNode" type="DOM" usage="required">
            <summary>The DOM node to attach the updated header data to.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setUpdated" scope="prototype">
        <summary>Function to set the contents of the updated  node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the updated node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="updatedAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the udpated data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setSummaryHeader" scope="prototype">
        <summary>Function to set the contents of the summary  node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryHeaderNode" type="DOM" usage="required">
            <summary>The DOM node to attach the summary title to.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setSummary" scope="prototype">
        <summary>Function to set the contents of the summary  node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the summary node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="summaryAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the summary data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setContentHeader" scope="prototype">
        <summary>Function to set the contents of the content node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contentHeaderNode" type="DOM" usage="required">
            <summary>The DOM node to attach the content data to.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setContent" scope="prototype">
        <summary>Function to set the contents of the content node in the template to some value from the entry.</summary>
        <description>Function to set the contents of the content node in the template to some value from the entry.
	This exists specifically so users can over-ride how the title data is filled out from an entry.</description>
        <parameters>
          <parameter name="contentAnchorNode" type="DOM" usage="required">
            <summary>The DOM node to attach the content data to.</summary>
          </parameter>
          <parameter name="editMode" type="boolean" usage="required">
            <summary>Boolean to indicate if the display should be in edit mode or not.</summary>
          </parameter>
          <parameter name="entry" type="object" usage="required">
            <summary>The Feed Entry to work with.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_displaySections" scope="prototype">
        <summary>Internal function for determining which sections of the view to actually display.</summary>
        <description>Internal function for determining which sections of the view to actually display.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setDisplaySections" scope="prototype">
        <summary>Function for setting which sections of the entry should be displayed.</summary>
        <description>Function for setting which sections of the entry should be displayed.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="sectionsArray" type="array" usage="required">
            <summary>Array of string names that indicate which sections to display.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setDisplaySectionsCheckboxes" scope="prototype">
        <summary>Internal function for setting which checkboxes on the display are selected.</summary>
        <description>Internal function for setting which checkboxes on the display are selected.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_readDisplaySections" scope="prototype">
        <summary>Internal function for reading what is currently checked for display and generating the display list from it.</summary>
        <description>Internal function for reading what is currently checked for display and generating the display list from it.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_toggleCheckbox" scope="prototype">
        <summary>Internal function for determining of a particular entry is editable.</summary>
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <return-description>Nothing</return-description>
        <parameters>
          <parameter name="checkBox" type="object" usage="required">
            <summary>The checkbox object to toggle the selection on.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_toggleOptions" scope="prototype">
        <summary>Internal function for determining of a particular entry is editable.</summary>
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <return-description>Nothing</return-description>
        <parameters>
          <parameter name="checkBox" type="object" usage="required">
            <summary>The checkbox object to toggle the selection on.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_handleEvent" scope="prototype">
        <summary>Internal function for listening to a topic that will handle entry notification.</summary>
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required">
            <summary>The topic message containing the entry that was selected for view.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setFieldValidity" scope="prototype">
        <summary>Function to set whether a field in the view is valid and displayable.</summary>
        <description>Function to set whether a field in the view is valid and displayable.
	This is needed for over-riding of the set* functions and customization of how data is displayed in the attach point.
	So if custom implementations use their own display logic, they can still enable the field.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="field" type="string" usage="required">
            <summary>The field name to set the valid parameter on.  Such as 'content', 'id', etc.</summary>
          </parameter>
          <parameter name="isValid" type="boolean" usage="required">
            <summary>Flag denoting if the field is valid or not.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isFieldValid" scope="prototype">
        <summary>Function to return if a displayable field is valid or not</summary>
        <description>Function to return if a displayable field is valid or not</description>
        <return-description>boolean denoting if the field is valid and set.</return-description>
        <parameters>
          <parameter name="field" type="string" usage="required">
            <summary>The field name to get the valid parameter of.  Such as 'content', 'id', etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getEntry" scope="prototype"/>
      <method name="getFeed" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer.displayOptions" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelTitle" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelAuthors" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelContributors" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelId" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer.close" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelUpdated" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelSummary" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedEntryViewer.feedEntryCheckBoxLabelContent" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.EntryHeader" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Widget representing a header in a FeedEntryViewer/Editor</summary>
    <description>Widget representing a header in a FeedEntryViewer/Editor</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="title" scope="prototype" type="String"/>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="setListHeader" scope="prototype">
        <parameters>
          <parameter name="title" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.atom.widget.FeedViewer" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>An ATOM feed viewer that allows for viewing a feed, deleting entries, and editing entries.</summary>
    <description>An ATOM feed viewer that allows for viewing a feed, deleting entries, and editing entries.
	The body of the feed viewer table so we can access it and populate it.  Will be assigned via template.
	The overal table container which contains the feed viewer table.  Will be assigned via template.
	The topic to broadcast when any entry is clicked so that a listener can pick up it and display it.
	The URL to which to connect to initially on creation.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="feedViewerTableBody" scope="prototype" type="Object"/>
      <property name="feedViewerTable" scope="prototype" type="Object"/>
      <property name="entrySelectionTopic" scope="prototype" type="String"/>
      <property name="url" scope="prototype" type="String"/>
      <property name="xmethod" scope="prototype" type="bool"/>
      <property name="localSaveOnly" scope="prototype" type="bool"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_feed" scope="prototype" type="Object"/>
      <property name="_currentSelection" scope="prototype" type="Object"/>
      <property name="_includeFilters" scope="prototype" type="Array"/>
      <property name="alertsEnabled" scope="prototype" type="bool"/>
      <property name="_subscriptions" scope="prototype" type="Array"/>
      <property name="atomIO" scope="prototype" type="Object"/>
      <property name="childWidgets" scope="prototype" type="Array"/>
      <property name="containerNode" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>The postCreate function.</summary>
        <description>The postCreate function.  Creates our AtomIO object for future interactions and subscribes to the
	event given in markup/creation.</description>
      </method>
      <method name="startup" scope="prototype">
        <summary>The startup function.</summary>
        <description>The startup function.  Parses the filters and sets the feed based on the given url.</description>
      </method>
      <method name="clear" scope="prototype">
        <summary>Function clearing all current entries in the feed view.</summary>
        <description>Function clearing all current entries in the feed view.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="setFeedFromUrl" scope="prototype">
        <summary>Function setting the feed from a URL which to get the feed.</summary>
        <description>Function setting the dojox.atom.io.model.Feed data into the view.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <summary>The URL to the feed to load.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setFeed" scope="prototype">
        <summary>Function setting the dojox.atom.io.model.Feed data into the view.</summary>
        <description>Function setting the dojox.atom.io.model.Feed data into the view.
	entry:
	The dojox.atom.io.model.Feed object to process</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="feed" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_displayDateForEntry" scope="prototype">
        <summary>Internal function for determining the appropriate date to display.</summary>
        <description>Internal function for determining of a particular entry is editable.</description>
        <return-description>An appropriate date for the feed viewer display.</return-description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>The dojox.atom.io.model.Entry object to examine.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="appendGrouping" scope="prototype">
        <summary>Function for appending a new grouping of entries to the feed view.</summary>
        <description>Function for appending a grouping of entries to the feed view.
	entry:
	The title of the new grouping to create on the view.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="titleText" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="appendEntry" scope="prototype">
        <summary>Function for appending an entry to the feed view.</summary>
        <description>Function for appending an entry to the feed view.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>The dojox.atom.io.model.Entry object to append</summary>
          </parameter>
        </parameters>
      </method>
      <method name="deleteEntry" scope="prototype">
        <summary>Function for deleting a row from the view</summary>
        <description>Function for deleting a row from the view</description>
        <parameters>
          <parameter name="entryRow" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_removeEntry" scope="prototype">
        <summary>callback for when an entry is deleted from a feed.</summary>
        <description>callback for when an entry is deleted from a feed.</description>
        <parameters>
          <parameter name="entry" type="FeedViewerEntry" usage="required"/>
          <parameter name="success" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_rowSelected" scope="prototype">
        <summary>Internal function for handling the selection of feed entries.</summary>
        <description>Internal function for handling the selection of feed entries.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="evt" type="object" usage="required">
            <summary>The click event that triggered a selection.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_deselectCurrentSelection" scope="prototype">
        <summary>Internal function for unselecting the current selection.</summary>
        <description>Internal function for unselecting the current selection.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="_isEditable" scope="prototype">
        <summary>Internal function for determining of a particular entry is editable.</summary>
        <description>Internal function for determining of a particular entry is editable.
	This is used for determining if the delete action should be displayed or not.</description>
        <return-description>Boolean denoting if the entry seems editable or not..</return-description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>The dojox.atom.io.model.Entry object to examine</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onEntrySelected" scope="prototype">
        <summary>Function intended for over-riding/replacement as an attachpoint to for other items to recieve
	selection notification.</summary>
        <description>Function intended for over0-riding/replacement as an attachpoint to for other items to recieve
	selection notification.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="entry" type="object" usage="required">
            <summary>The dojox.atom.io.model.Entry object selected.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_isRelativeURL" scope="prototype">
        <summary>Method to determine if the URL is relative or absolute.</summary>
        <description>Method to determine if the URL is relative or absolute.  Basic assumption is if it doesn't start
	with http:// or file://, it's relative to the current document.</description>
        <return-description>boolean indicating whether it's a relative url or not.</return-description>
        <parameters>
          <parameter name="url" type="string" usage="required">
            <summary>The URL to inspect.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_calculateBaseURL" scope="prototype">
        <summary>Internal function to calculate a baseline URL from the provided full URL.</summary>
        <description>Internal function to calculate a baseline URL from the provided full URL.</description>
        <return-description>String of the baseline URL</return-description>
        <parameters>
          <parameter name="fullURL" type="string" usage="required">
            <summary>The full URL as a string.</summary>
          </parameter>
          <parameter name="currentPageRelative" type="boolean" usage="required">
            <summary>Flag to denote of the base URL should be calculated as just the server base, or relative to the current page/location in the URL.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_isFilterAccepted" scope="prototype">
        <summary>Internal function to do matching of category filters to widgets.</summary>
        <description>Internal function to do matching of category filters to widgets.</description>
        <return-description>boolean denoting if this entry matched one of the accept filters.</return-description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="addCategoryIncludeFilter" scope="prototype">
        <summary>Function to add a filter for entry inclusion in the feed view.</summary>
        <description>Function to add a filter for entry inclusion in the feed view.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="filter" type="object" usage="required">
            <summary>The basic items to filter on and the values.
	Should be of format: {scheme: &amp;lt;some text or null&amp;gt;, term: &amp;lt;some text or null&amp;gt;, label: &amp;lt;some text or null&amp;gt;}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeCategoryIncludeFilter" scope="prototype">
        <summary>Function to remove a filter for entry inclusion in the feed view.</summary>
        <description>Function to remove a filter for entry inclusion in the feed view.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="filter" type="object" usage="required">
            <summary>The basic items to identify the filter that is present.
	Should be of format: {scheme: &amp;lt;some text or null&amp;gt;, term: &amp;lt;some text or null&amp;gt;, label: &amp;lt;some text or null&amp;gt;}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_handleEvent" scope="prototype">
        <summary>Internal function for listening to a topic that will handle entry notification.</summary>
        <description>Internal function for listening to a topic that will handle entry notification.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="entrySelectionEvent" type="object" usage="required">
            <summary>The topic message containing the entry that was selected for view.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addEntry" scope="prototype">
        <summary>callback function used when adding an entry to the feed.</summary>
        <description>callback function used when adding an entry to the feed.  After the entry has been posted to the feed,
	we add it to our feed representation (to show it on the page) and publish an event to update any entry viewers.</description>
        <parameters>
          <parameter name="entry" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroys this widget, including all descendants and subscriptions.</summary>
        <description>Destroys this widget, including all descendants and subscriptions.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.widget.FeedViewerEntry" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Widget for handling the display of an entry and specific events associated with it.</summary>
    <description>Widget for handling the display of an entry and specific events associated with it.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="entryNode" scope="prototype" type="Object"/>
      <property name="timeNode" scope="prototype" type="Object"/>
      <property name="entry" scope="prototype" type="Object"/>
      <property name="feed" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="setTitle" scope="prototype">
        <summary>Function to set the title of the entry.</summary>
        <description>Function to set the title of the entry.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="text" type="string" usage="required">
            <summary>The title.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setTime" scope="prototype">
        <summary>Function to set the time of the entry.</summary>
        <description>Function to set the time of the entry.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="timeText" type="string" usage="required">
            <summary>The string form of the date.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="enableDelete" scope="prototype">
        <summary>Function to enable the delete action on this entry.</summary>
        <description>Function to enable the delete action on this entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="disableDelete" scope="prototype">
        <summary>Function to disable the delete action on this entry.</summary>
        <description>Function to disable the delete action on this entry.</description>
        <return-description>Nothing.</return-description>
      </method>
      <method name="deleteEntry" scope="prototype">
        <summary>Function to handle the delete event and delete the entry.</summary>
        <description>Function to handle the delete event and delete the entry.</description>
        <return-description>Nothing.</return-description>
        <parameters>
          <parameter name="event" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Attach point for when a row is clicked on.</summary>
        <description>Attach point for when a row is clicked on.</description>
        <parameters>
          <parameter name="e" type="object" usage="required">
            <summary>The event generated by the click.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.widget.FeedViewerEntry.deleteButton">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedViewerEntry.deleteButton.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.atom.widget.FeedViewerGrouping" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Grouping of feed entries.</summary>
    <description>Grouping of feed entries.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="groupingNode" scope="prototype" type="Object"/>
      <property name="titleNode" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setText" scope="prototype">
        <summary>Sets the text to be shown above this grouping.</summary>
        <description>Sets the text to be shown above this grouping.</description>
        <parameters>
          <parameter name="text" type="The" usage="required">
            <summary>text to show.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.atom.widget.AtomEntryCategoryFilter" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A filter to be applied to the list of entries.</summary>
    <description>A filter to be applied to the list of entries.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="scheme" scope="prototype" type="String"/>
      <property name="term" scope="prototype" type="String"/>
      <property name="label" scope="prototype" type="String"/>
      <property name="isFilter" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.atom.widget.FeedViewer.CategoryIncludeFilter" type="Function" classlike="true">
    <summary>The initializer function.</summary>
    <description>The initializer function.</description>
    <properties>
      <property name="scheme" scope="instance" type=""/>
      <property name="term" scope="instance" type=""/>
      <property name="label" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="scheme" type="" usage="required"/>
          <parameter name="term" type="" usage="required"/>
          <parameter name="label" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>The initializer function.</summary>
        <description>The initializer function.</description>
        <parameters>
          <parameter name="scheme" type="" usage="required"/>
          <parameter name="term" type="" usage="required"/>
          <parameter name="label" type="" usage="required"/>
        </parameters>
      </method>
      <method name="match" scope="prototype">
        <summary>Function to determine if this category filter matches against a category on an atom entry</summary>
        <description>Function to determine if this category filter matches against a category on an atom entry</description>
        <return-description>boolean denoting if this category filter matched to this entry.</return-description>
        <parameters>
          <parameter name="entry" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.av">
    <summary>Provides Audio/Video capabilities</summary>
  </object>
  <object location="dojox.av.FLAudio" type="Function" classlike="true">
    <summary>Play MP3 files through the Flash SWF built in the
	DEFT project.</summary>
    <description>This class is brand new, so there is a lot of
	functionality not yet available. The initial
	purpose is for playing "event" sounds like button
	clicks, and for loading and controlling multiple
	sounds at once. As of yet, streaming is not supported
	and polling the sounds for events during playback
	may still be missing information. Markup is not
	supported, as it may not be needed.
	TODO:
	Streaming, playback events, crossdomain, CDN support,
	(alternate SWF location), global volume, ID3 tag,
	factor out doLater, onLoadStatus needs work,
	play(position) / seek()</description>
    <examples>
      <example>	new dojox.av.FLAudio({
			initialVolume:.7,
			initialPan:0,
			autoPlay:false
		});</example>
    </examples>
    <properties>
      <property name="id" scope="instance-prototype" type="String">
        <summary>The id of this widget and the id of the SWF movie.</summary>
      </property>
      <property name="initialVolume" scope="prototype" type="Number">
        <summary>From 0-1
	Sets volume for all files unless changed with doPlay
	or setVolume</summary>
      </property>
      <property name="initialPan" scope="prototype" type="Number">
        <summary>From -1 to 1 (-1 is left, 1 is right, 0 is middle)
	Sets pan for all files unless changed with play
	or setPan
	autoPlay: Boolean
	If true, all files will play upon load. If false,
	they load and wait for doPlay() command.</summary>
      </property>
      <property name="isDebug" scope="prototype" type="Boolean">
        <summary>Setting to true tells the SWF to output log messages to Firebug.</summary>
      </property>
      <property name="statusInterval" scope="prototype" type="Number">
        <summary>How often in milliseconds that the status of the
	player is checked - both load and play</summary>
      </property>
      <property name="_swfPath" scope="prototype" type="Uri">
        <summary>The path to the video player SWF resource</summary>
      </property>
      <property name="_subs" scope="prototype" type="Array"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="prototype">
        <summary>Initialize the media.</summary>
      </method>
      <method name="load" scope="prototype">
        <summary>Adds a media object to the playlist
	***This can be called repeatedly to add multiple items.</summary>
        <return-description>The normalized url, which can be used to identify the
	audio.</return-description>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <summary>url: String
	(required) path to MP3 media
	url must be absolute or relative to SWF,
	not dojo or the html. An effort will be made
	to fix incorrect paths.
	id: String
	(optional) an identifier to later determine
	which media to control.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="doPlay" scope="prototype">
        <summary>Tell media to play, based on
	the options passed.</summary>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <summary>volume: Number
	Sets the volume
	pan: Number
	Sets left/right pan
	index:Number OR id:String OR url:String
	Choose one of the above to indentify
	the media you wish to control. id is
	set by you. index is the order in which
	media was added (zero based)
	NOTE: lack of an identifier will default
	to first (or only) item.
	NOTE: Can't name this method &amp;quot;play()&amp;quot; as it causes
	an IE error.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="pause" scope="prototype">
        <summary>Tell media to pause, based on identifier in
	the options passed.</summary>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <summary>index:Number OR id:String OR url:String
	See doPlay()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="stop" scope="prototype">
        <summary>Tell media to stop, based on identifier in
	the options passed.</summary>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <summary>index:Number OR id:String OR url:String
	See doPlay()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setVolume" scope="prototype">
        <summary>Set media volume, based on identifier in
	the options passed.</summary>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <summary>volume: Number
	0 to 1
	index:Number OR id:String OR url:String
	See doPlay()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setPan" scope="prototype">
        <summary>Set media pan, based on identifier in
	the options passed.</summary>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <summary>pan:Number -1 to 1
	index:Number OR id:String OR url:String
	See doPlay()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getVolume" scope="prototype">
        <summary>Get media volume, based on identifier in
	the options passed.</summary>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <summary>index:Number OR id:String OR url:String
	See doPlay()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getPan" scope="prototype">
        <summary>Set media pan, based on identifier in
	the options passed.</summary>
        <parameters>
          <parameter name="options" type="Object" usage="required">
            <summary>index:Number OR id:String OR url:String
	See doPlay()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <summary>stub fired when an error occurs</summary>
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onLoadStatus" scope="prototype">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onAllLoaded" scope="prototype">
        <summary>stub fired</summary>
      </method>
      <method name="onPlayStatus" scope="prototype">
        <parameters>
          <parameter name="events" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="prototype">
        <summary>stub fired when SWF is ready</summary>
      </method>
      <method name="onID3" scope="prototype">
        <summary>Fired when the ID3 data is received.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>destroys flash</summary>
      </method>
      <method name="_sub" scope="prototype">
        <summary>helper for subscribing to topics</summary>
        <parameters>
          <parameter name="topic" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeVolume" scope="prototype">
        <summary>Ensures volume is less than one</summary>
        <parameters>
          <parameter name="vol" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeUrl" scope="prototype">
        <summary>Checks that path is relative to HTML file or
	convertes it to an absolute path.</summary>
        <parameters>
          <parameter name="_url" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.av.FLAudio._flashObject" private="true">
    <properties>
      <property name="onLoad" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method name="onError" scope="prototype">
        <parameters>
          <parameter name="err" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.av.FLVideo" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Inserts a Flash FLV video into the HTML page and provides methods
	and events for controlling the video. Also plays the H264/M4V codec
	with a little trickery: change the '.M4V' extension to '.flv'.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.av._Media.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dojox.av._Media"/>
    </mixins>
    <examples>
      <example>markup:
		&lt;div id="vid" initialVolume=".7",
			mediaUrl="../resources/Grog.flv"
			dojoType="dojox.av.FLVideo"&gt;&lt;/div&gt;
	programmatic:
		new dojox.av.FLVideo({
			initialVolume:.7,
			mediaUrl:"../resources/Grog.flv"
		}, "vid");
	mediaUrl: String
	REQUIRED: The Url of the video file that will be played.
	NOTE: Must be either an absolute URL or relative to the HTML file.
	Relative paths will be converted to abslute paths</example>
    </examples>
    <properties>
      <property name="_swfPath" scope="prototype" type="Uri">
        <summary>The path to the video player SWF resource</summary>
      </property>
      <property name="_subs" scope="prototype" type="Array"/>
      <property name="_cons" scope="prototype" type="Array"/>
      <property name="mediaUrl" scope="prototype" type="Object"/>
      <property name="initialVolume" scope="prototype" type="Object"/>
      <property name="isPlaying" scope="prototype" type="bool"/>
      <property name="isStopped" scope="prototype" type="bool"/>
      <property name="isBuffering" scope="prototype" type=""/>
      <property name="percentDownloaded" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Initialize the media.</summary>
      </method>
      <method name="play" scope="prototype">
        <summary>Plays the video. If an url is passed in, plays the new link.</summary>
        <parameters>
          <parameter name="newUrl" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="pause" scope="prototype">
        <summary>Pauses the video</summary>
      </method>
      <method name="seek" scope="prototype">
        <summary>Goes to the time passed in the argument</summary>
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="volume" scope="prototype">
        <summary>Sets the volume of the video to the time in the
	argument - between 0 - 1.</summary>
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="onLoad" scope="prototype">
        <summary>Fired when the SWF player has loaded
	NOT when the video has loaded</summary>
        <parameters>
          <parameter name="mov" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloaded" scope="prototype">
        <summary>Fires the amount of that the media has been
	downloaded. Number, 0-100</summary>
        <parameters>
          <parameter name="percent" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Fires when the player is clicked
	Could be used to toggle play/pause, or
	do an external activity, like opening a new
	window.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSwfSized" scope="prototype">
        <summary>Fired on SWF resize, or when its
	toggled between fullscreen.</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="prototype">
        <summary>The video properties. Width, height, duration, etc.
	NOTE: 	if data is empty, this is an older FLV with no meta data.
	Duration cannot be determined. In original FLVs, duration
	could only be obtained with Flash Media Server.
	NOTE: 	Older FLVs can still return width and height
	and will do so on a second event call</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="prototype">
        <summary>The position of the playhead in seconds</summary>
        <parameters>
          <parameter name="time" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="prototype">
        <summary>Fires when video starts
	Good for setting the play button to pause
	during an autoPlay for example</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="prototype">
        <summary>Fires when video starts and resumes</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onPause" scope="prototype">
        <summary>Fires when the pause button is clicked</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="prototype">
        <summary>Fires when video ends
	Could be used to change pause button to play
	or show a post video graphic, like YouTube</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="prototype">
        <summary>Fire when the Stop button is clicked
	TODO: 	This is not hooked up yet and shouldn't
	fire.</summary>
      </method>
      <method name="onBuffer" scope="prototype">
        <summary>Fires a boolean to tell if media
	is paused for buffering or if buffering
	has finished</summary>
        <parameters>
          <parameter name="isBuffering" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <summary>Fired when the player encounters an error</summary>
        <examples>
          <example> console.warn("ERROR-"+data.type.toUpperCase()+":",
			data.info.code, " - URL:", url);</example>
        </examples>
        <parameters>
          <parameter name="data" type="" usage="required"/>
          <parameter name="url" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onStatus" scope="prototype">
        <summary>Simple status</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onPlayerStatus" scope="prototype">
        <summary>The status of the video from the SWF
	playing, stopped, bufering, etc.</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="prototype">
        <summary>Fired on page resize</summary>
      </method>
      <method name="_checkBuffer" scope="prototype">
        <summary>Checks that there is a proper buffer time between
	current playhead time and the amount of data loaded.
	Works only on FLVs with a duration (not older). Pauses
	the video while continuing download.</summary>
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
          <parameter name="bufferLength" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="prototype">
        <summary>Helper function to fire onPosition, check download progress,
	and check buffer.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.av.FLVideo._flashObject" private="true">
    <properties>
      <property name="onLoad" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method name="onError" scope="prototype">
        <parameters>
          <parameter name="err" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.av._Media" type="Function" classlike="true">
    <summary>Used as a mixin for dojox and AIR media</summary>
    <description>Calculates the current status of the playing media and fires
	the appropriate events.</description>
    <properties>
      <property name="mediaUrl" scope="prototype" type="String"/>
      <property name="initialVolume" scope="prototype" type="Float">
        <summary>The initial volume setting of the player. Acccepts between 0 and 1.</summary>
      </property>
      <property name="autoPlay" scope="prototype" type="Boolean">
        <summary>Whether the video automatically plays on load or not.</summary>
      </property>
      <property name="bufferTime" scope="prototype" type="Number">
        <summary>Time in milliseconds that the video should be loaded before it will
	play. May pause and resume to build up buffer. Prevents stuttering.
	Note:
	Older FLVs, without a duration, cannot be buffered.</summary>
      </property>
      <property name="minBufferTime" scope="prototype" type="Number">
        <summary>Time in milliseconds bwteen the playhead time and loaded time that
	will trigger the buffer. When buffer is triggered, video will pause
	until the bufferTime amount is buffered.
	Note: Should be a small number, greater than zero.</summary>
      </property>
      <property name="updateTime" scope="prototype" type="Number">
        <summary>How often, in milliseconds to get an update of the video position.</summary>
      </property>
      <property name="id" scope="prototype" type="String">
        <summary>The id of this widget and the id of the SWF movie.</summary>
      </property>
      <property name="isDebug" scope="prototype" type="Boolean">
        <summary>Setting to true tells the SWF to output log messages to Firebug.</summary>
      </property>
      <property name="percentDownloaded" scope="prototype" type="read-only-Number">
        <summary>The percentage the media has downloaded; from 0-100</summary>
      </property>
      <property name="_flashObject" scope="prototype" type="read-only-Object">
        <summary>The dojox.embed object</summary>
      </property>
      <property name="flashMedia" scope="prototype" type="read-only-SWF">
        <summary>The SWF object. Methods are passed to this.</summary>
      </property>
      <property name="status" scope="prototype" type="String"/>
      <property name="duration" scope="prototype" type=""/>
      <property name="isBuffering" scope="prototype" type=""/>
      <property name="_prevPos" scope="prototype" type=""/>
      <property name="_prevStatus" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initStatus" scope="prototype">
        <summary>Connect mediaStatus to the media.</summary>
      </method>
      <method name="getTime" scope="prototype">
        <summary>Returns the current time of the video
	Note:
	Consider the onPosition event, which returns
	the time at a set interval. Too many trips to
	the SWF could impact performance.</summary>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="onLoad" scope="prototype">
        <summary>Fired when the SWF player has loaded
	NOT when the video has loaded</summary>
        <parameters>
          <parameter name="mov" type="SWF" usage="required"/>
        </parameters>
      </method>
      <method name="onDownloaded" scope="prototype">
        <summary>Fires the amount of that the media has been
	downloaded. Number, 0-100</summary>
        <parameters>
          <parameter name="percent" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>TODO: Return x/y of click
	Fires when the player is clicked
	Could be used to toggle play/pause, or
	do an external activity, like opening a new
	window.</summary>
        <parameters>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onSwfSized" scope="prototype">
        <summary>Fired on SWF resize, or when its
	toggled between fullscreen.</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="prototype">
        <summary>The video properties. Width, height, duration, etc.
	NOTE: 	if data is empty, this is an older FLV with no meta data.
	Duration cannot be determined. In original FLVs, duration
	could only be obtained with Flash Media Server.
	NOTE: 	Older FLVs can still return width and height
	and will do so on a second event call</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="evt" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="prototype">
        <summary>The position of the playhead in seconds</summary>
        <parameters>
          <parameter name="time" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="prototype">
        <summary>Fires when video starts
	Good for setting the play button to pause
	during an autoPlay for example</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlay" scope="prototype">
        <summary>Fires when video starts and resumes</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPause" scope="prototype">
        <summary>Fires when the pause button is clicked</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onEnd" scope="prototype">
        <summary>Fires when video ends
	Could be used to change pause button to play
	or show a post video graphic, like YouTube</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onStop" scope="prototype">
        <summary>Fire when the Stop button is clicked
	TODO: 	This is not hooked up yet and shouldn't
	fire.</summary>
      </method>
      <method name="onBuffer" scope="prototype">
        <summary>Fires a boolean to tell if media
	is paused for buffering or if buffering
	has finished</summary>
        <parameters>
          <parameter name="isBuffering" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <summary>Fired when the player encounters an error</summary>
        <examples>
          <example> console.warn("ERROR-"+data.type.toUpperCase()+":",
			data.info.code, " - URL:", url);</example>
        </examples>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onStatus" scope="prototype">
        <summary>Simple status</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlayerStatus" scope="prototype">
        <summary>The status of the video from the SWF
	playing, stopped, bufering, etc.</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="prototype"/>
      <method name="_figureStatus" scope="prototype">
        <summary>Calculate media status, based on playhead movement, and
	onStop and onStart events
	TODO:
	Figure in real status from the media for more accurate results.</summary>
      </method>
      <method name="_eventFactory" scope="prototype">
        <summary>Creates a generic event object.</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_sub" scope="prototype">
        <summary>helper for subscribing to topics</summary>
        <parameters>
          <parameter name="topic" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeVolume" scope="prototype">
        <summary>Ensures volume is less than one</summary>
        <parameters>
          <parameter name="vol" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeUrl" scope="prototype">
        <summary>Checks that path is relative to HTML file or
	convertes it to an absolute path.</summary>
        <parameters>
          <parameter name="_url" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>destroys flash</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.av.widget"/>
  <object location="dojox.av.widget.PlayButton" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A Play/Pause button widget to use with dojox.av.widget.Player</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="media" scope="prototype" type=""/>
      <property name="_mode" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Intialize button.</summary>
      </method>
      <method name="setMedia" scope="prototype">
        <summary>A common method to set the media in all Player widgets.
	May do connections and initializations.</summary>
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Fired on play or pause click.</summary>
      </method>
      <method name="onPlay" scope="prototype">
        <summary>Fired on play click.</summary>
      </method>
      <method name="onPause" scope="prototype">
        <summary>Fired on pause click.</summary>
      </method>
      <method name="showPlay" scope="prototype">
        <summary>Toggles the pause button invisible and the play
	button visible..</summary>
      </method>
      <method name="showPause" scope="prototype">
        <summary>Toggles the play button invisible and the pause
	button visible.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.av.widget.Player" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A Media Player UI widget for all types of dojox.av and AIR media.</summary>
    <description>Currently for markup only. All controls should reside as child
	nodes within the Player node. 'controlType' is used to determine
	the placement of the control. If no type or an unrecoginized type
	is used, it will be left-aligned in the same row as the volume.
	Note:
	Be sure to use 'controlType' as a node attribute. It is not a
	property of the widget.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dojox.av.widget.Player" playerWidth="100%"&gt;
	 		&lt;div controlType="video" initialVolume=".1"
	 			mediaUrl="video/Grog.flv" autoPlay="true"
				isDebug="false" dojoType="dojox.av.FLVideo"&gt;&lt;/div&gt;
			 	&lt;div controlType="play" dojoType="dojox.av.widget.PlayButton"&gt;&lt;/div&gt;
			 	&lt;div controlType="volume" dojoType="dojox.av.widget.VolumeButton"&gt;&lt;/div&gt;
			 	&lt;div controlType="progress" dojoType="dojox.av.widget.ProgressSlider"&gt;&lt;/div&gt;
			 	&lt;div controlType="status" dojoType="dojox.av.widget.Status"&gt;&lt;/div&gt;
	 &lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="playerWidth" scope="prototype" type="Number">
        <summary>or String
	Sets the width of the player (not the video size)
	Number will be converted to pixels
	String will be used literally. EX: &amp;quot;320px&amp;quot; or &amp;quot;100%&amp;quot;
	TODO:
	playerHeight
	videoWidth: 320,
	videoHeight: 240,</summary>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="items" scope="prototype" type="Array"/>
      <property name="children" scope="prototype" type="Array"/>
      <property name="media" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_fillContent" scope="prototype"/>
      <method name="postCreate" scope="prototype">
        <summary>Do player styling, and place child widgets in the proper location.</summary>
      </method>
      <method name="startup" scope="prototype">
        <summary>Fired when all children are ready. Set the media in
	all children with setMedia()</summary>
      </method>
      <method name="onResize" scope="prototype">
        <summary>If a player size is a percentage, this will fire an onResize
	event for all children, passing the size of the player.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.av.widget.ProgressSlider" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A custom slider widget to use with dojox.av.widget.Player.</summary>
    <description>Displays the current playhead position of the media. Has two
	progress bars: one for playhead position, and one for download
	progress.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="seeking" scope="prototype" type="bool"/>
      <property name="handleWidth" scope="prototype" type=""/>
      <property name="finalWidth" scope="prototype" type=""/>
      <property name="width" scope="prototype" type="Number"/>
      <property name="x" scope="prototype" type=""/>
      <property name="playerWidget" scope="prototype" type=""/>
      <property name="media" scope="prototype" type=""/>
      <property name="cmove" scope="prototype" type="Object"/>
      <property name="cup" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Initialize slider.</summary>
      </method>
      <method name="setMedia" scope="prototype">
        <summary>A common method to set the media in all Player widgets.
	May do connections and initializations.</summary>
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
          <parameter name="playerWidget" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onDrag" scope="prototype">
        <summary>Fired when the mouse is moved. Sets the slider.</summary>
        <parameters>
          <parameter name="evt" type="HTMLEvent" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="prototype">
        <summary>Fired onmousedown of the slider handle.</summary>
      </method>
      <method name="endDrag" scope="prototype">
        <summary>Fired on document.onmouseup.</summary>
      </method>
      <method name="setHandle" scope="prototype">
        <summary>Sets the slider handle (when it is not being dragged)</summary>
        <parameters>
          <parameter name="time" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setLoadedPosition" scope="prototype">
        <summary>Sets the download progress bar to the percentage of how much
	the media has been downloaded.</summary>
        <parameters>
          <parameter name="decimal" type="" usage="required"/>
        </parameters>
      </method>
      <method name="handleOver" scope="prototype">
        <summary>Highlights the slider handle on mouseover, and
	stays highlighted during drag.</summary>
      </method>
      <method name="handleOut" scope="prototype">
        <summary>Unhighlights handle onmouseover, or on endDrag.</summary>
      </method>
      <method name="onResize" scope="prototype">
        <summary>Handles player resize. Need to recalculate the width of
	position an download bars.</summary>
        <parameters>
          <parameter name="playerDimensions" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.av.widget.Status" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A Status widget to use with dojox.av.widget.Player</summary>
    <description>Displays the name of the media file, and it's current status
	(playing, paused, buffering, etc.) in the middle. Displays
	the playhead time on the left and the duration on the right.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="timeNode" scope="prototype" type="Object"/>
      <property name="media" scope="prototype" type=""/>
      <property name="duration" scope="prototype" type=""/>
      <property name="title" scope="prototype" type=""/>
      <property name="isBuffering" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="setMedia" scope="prototype">
        <summary>A common method to set the media in all Player widgets.
	May do connections and initializations.</summary>
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMetaData" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onBuffer" scope="prototype">
        <parameters>
          <parameter name="isBuffering" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onPosition" scope="prototype">
        <parameters>
          <parameter name="time" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onStart" scope="prototype"/>
      <method name="onPlay" scope="prototype"/>
      <method name="onPause" scope="prototype"/>
      <method name="onStop" scope="prototype"/>
      <method name="onEnd" scope="prototype"/>
      <method name="onError" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="prototype"/>
      <method name="setStatus" scope="prototype">
        <parameters>
          <parameter name="str" type="" usage="required"/>
          <parameter name="isError" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toSeconds" scope="prototype">
        <parameters>
          <parameter name="time" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.av.widget.Status.durNode">
    <properties>
      <property name="innerHTML" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.av.widget.Status.titleNode">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.av.widget.VolumeButton" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A volume widget to use with dojox.av.widget.Player</summary>
    <description>Controls and displays the volume of the media. This widget
	opens a slider on click that is used to adjust the volume.
	The icon changes according to the volume level.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="handleWidth" scope="prototype" type=""/>
      <property name="width" scope="prototype" type=""/>
      <property name="slotWidth" scope="prototype" type="Number"/>
      <property name="volumeSlider" scope="prototype" type="Object"/>
      <property name="media" scope="prototype" type=""/>
      <property name="showing" scope="prototype" type="bool"/>
      <property name="x" scope="prototype" type="Number"/>
      <property name="clickOff" scope="prototype" type="Object"/>
      <property name="isDragging" scope="prototype" type="bool"/>
      <property name="cmove" scope="prototype" type="Object"/>
      <property name="cup" scope="prototype" type="Object"/>
      <property name="_domCoords" scope="prototype" type="Object"/>
      <property name="_handleCoords" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Initialize the widget.</summary>
      </method>
      <method name="setMedia" scope="prototype">
        <summary>A common method to set the media in all Player widgets.
	May do connections and initializations.</summary>
        <parameters>
          <parameter name="med" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="updateIcon" scope="prototype">
        <summary>Changes the icon on the button according to volume level.</summary>
        <parameters>
          <parameter name="vol" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="onShowVolume" scope="prototype">
        <summary>Shows the volume slider.</summary>
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onDocClick" scope="prototype">
        <summary>Fired on document.onmousedown. Checks if clicked inside
	of this widget or not.</summary>
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="onHideVolume" scope="prototype">
        <summary>Hides volume slider.</summary>
      </method>
      <method name="onDrag" scope="prototype">
        <summary>Fired on mousemove. Updates volume and position of
	slider handle.</summary>
        <parameters>
          <parameter name="evt" type="DOMEvent" usage="required"/>
        </parameters>
      </method>
      <method name="startDrag" scope="prototype">
        <summary>Fired on mousedown of the slider handle.</summary>
      </method>
      <method name="endDrag" scope="prototype">
        <summary>Fired on mouseup of the slider handle.</summary>
      </method>
      <method name="handleOver" scope="prototype">
        <summary>Highlights the slider handle on mouseover, and
	stays highlighted during drag.</summary>
      </method>
      <method name="handleOut" scope="prototype">
        <summary>Unhighlights handle onmouseover, or on endDrag.</summary>
      </method>
      <method name="_getVolumeDim" scope="prototype">
        <summary>Gets dimensions of slider background node.
	Only uses dojo.coords once, unless the page
	or player is resized.</summary>
      </method>
      <method name="_getHandleDim" scope="prototype">
        <summary>Gets dimensions of slider handle.
	Only uses dojo.marginBox once.</summary>
      </method>
      <method name="onResize" scope="prototype">
        <summary>Fired on player resize. Zeros dimensions
	so that it can be calculated again.</summary>
        <parameters>
          <parameter name="playerDimensions" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting">
    <summary>Vector graphic, data-driven graphs and charts</summary>
  </object>
  <object location="dojox.charting.Chart2D" type="Function" classlike="true">
    <properties>
      <property name="coords" scope="instance-prototype" type="Object"/>
      <property name="theme" scope="instance-prototype" type="Object"/>
      <property name="dirty" scope="instance-prototype" type="Object"/>
      <property name="dim" scope="prototype" type="Object"/>
      <property name="offsets" scope="prototype" type="Object"/>
      <property name="plotArea" scope="prototype" type="Object"/>
      <property name="margins" scope="instance" type="Object"/>
      <property name="stroke" scope="instance" type=""/>
      <property name="fill" scope="instance" type=""/>
      <property name="axes" scope="instance" type="Object"/>
      <property name="stack" scope="instance" type="Array"/>
      <property name="plots" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="runs" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="getCoords" scope="prototype"/>
      <method name="setTheme" scope="prototype">
        <parameters>
          <parameter name="theme" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addAxis" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAxis" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeAxis" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="addPlot" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removePlot" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="addSeries" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="data" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeSeries" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="updateSeries" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="width" type="" usage="required"/>
          <parameter name="height" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getGeometry" scope="prototype"/>
      <method name="setAxisWindow" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="scale" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setWindow" scope="prototype">
        <parameters>
          <parameter name="sx" type="" usage="required"/>
          <parameter name="sy" type="" usage="required"/>
          <parameter name="dx" type="" usage="required"/>
          <parameter name="dy" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateGeometry" scope="prototype"/>
      <method name="fullGeometry" scope="prototype"/>
      <method name="render" scope="prototype"/>
      <method name="fullRender" scope="prototype"/>
      <method name="connectToPlot" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="object" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_makeClean" scope="prototype"/>
      <method name="_makeDirty" scope="prototype"/>
      <method name="_invalidateDependentPlots" scope="prototype">
        <parameters>
          <parameter name="plotName" type="" usage="required"/>
          <parameter name="verticalAxis" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.lang">
    <summary>Language specific extensions</summary>
    <properties>
      <property name="lettableWin" scope="normal" type=""/>
      <property name="ReadOnlyProxy" scope="normal" type="Object"/>
      <property name="typed" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="observable" scope="normal">
        <summary>Creates a wrapper object, which can be observed. The wrapper object
	is a proxy to the wrapped object. If you will be making multiple wrapper
	objects with the same set of listeners, it is recommended that you
	use makeObservable, as it is more memory efficient.</summary>
        <parameters>
          <parameter name="wrapped" type="Object" usage="required">
            <summary>The object to be wrapped and monitored for property access and modification</summary>
          </parameter>
          <parameter name="onRead" type="function" usage="required">
            <summary>See dojox.lang.makeObservable.onRead</summary>
          </parameter>
          <parameter name="onWrite" type="function" usage="required">
            <summary>See dojox.lang.makeObservable.onWrite</summary>
          </parameter>
          <parameter name="onInvoke" type="function" usage="required">
            <summary>See dojox.lang.makeObservable.onInvoke</summary>
          </parameter>
        </parameters>
      </method>
      <method name="makeObservable" scope="normal">
        <summary>Creates and returns an observable creator function. All the objects that
	are created with the returned constructor will use the provided onRead and
	onWrite listeners.
	The created constructor should be called with a single argument,
	the object that will be wrapped to be observed. The constructor will
	return the wrapper object.</summary>
        <examples>
          <example>The following could be used to create a wrapper that would
	prevent functions from being accessed on an object:
		function onRead(obj,prop){
			return typeof obj[prop] == 'function' ? null : obj[prop];
		}
		var observable = dojox.lang.makeObservable(onRead,onWrite);
		var obj = {foo:1,bar:function(){}};
		obj = observable(obj);
		obj.foo -&gt; 1
		obj.bar -&gt; null</example>
        </examples>
        <parameters>
          <parameter name="onRead" type="function" usage="required">
            <summary>This is called whenever one of the wrapper objects created
	from the constructor has a property that is accessed. onRead
	will be called with two arguments, the first being the wrapped object,
	and the second is the name of property that is being accessed.
	The value that onRead returns will be used as the value returned
	by the property access</summary>
          </parameter>
          <parameter name="onWrite" type="function" usage="required">
            <summary>This is called whenever one of the wrapper objects created
	from the constructor has a property that is modified. onWrite
	will be called with three arguments, the first being the wrapped object,
	the second is the name of property that is being modified, and the
	third is the value that is being set on the property.</summary>
          </parameter>
          <parameter name="onInvoke" type="function" usage="required">
            <summary>This is called when a method on the object is invoked. The first
	argument is the wrapper object, the second is the original wrapped object,
	the third is the method name, and the fourth is the arguments.</summary>
          </parameter>
          <parameter name="hiddenFunctions" type="Object" usage="required">
            <summary>allows you to define functions that should be delegated
	but may not be enumerable on the wrapped objects, so they must be
	explicitly included</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="do it with getters and setters"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.Chart3D" type="Function" classlike="true">
    <properties>
      <property name="node" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="view" scope="instance" type="Object"/>
      <property name="theme" scope="instance" type=""/>
      <property name="walls" scope="instance" type="Array"/>
      <property name="plots" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="lights" type="" usage="required"/>
          <parameter name="camera" type="" usage="required"/>
          <parameter name="theme" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="lights" type="" usage="required"/>
          <parameter name="camera" type="" usage="required"/>
          <parameter name="theme" type="" usage="required"/>
        </parameters>
      </method>
      <method name="generate" scope="prototype"/>
      <method name="invalidate" scope="prototype"/>
      <method name="render" scope="prototype"/>
      <method name="addPlot" scope="prototype">
        <parameters>
          <parameter name="plot" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removePlot" scope="prototype">
        <parameters>
          <parameter name="plot" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addWall" scope="prototype">
        <parameters>
          <parameter name="wall" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeWall" scope="prototype">
        <parameters>
          <parameter name="wall" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_add" scope="prototype">
        <parameters>
          <parameter name="array" type="" usage="required"/>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="prototype">
        <parameters>
          <parameter name="array" type="" usage="required"/>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_generateWalls" scope="prototype"/>
      <method name="_generatePlots" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d">
    <summary>A 3d API for dojox.gfx</summary>
    <properties>
      <property name="_base" scope="normal" type="Object"/>
      <property name="Matrix3D" scope="normal" type=""/>
      <property name="object" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="gradient" scope="normal">
        <summary>calculate a cylindrical gradient</summary>
        <parameters>
          <parameter name="model" type="dojox.gfx3d.lighting.Model:" usage="required">
            <summary>color model</summary>
          </parameter>
          <parameter name="material" type="Object:" usage="required">
            <summary>defines visual properties</summary>
          </parameter>
          <parameter name="center" type="Object:" usage="required">
            <summary>center of the cylinder's bottom</summary>
          </parameter>
          <parameter name="radius" type="Number:" usage="required">
            <summary>radius of the cylinder</summary>
          </parameter>
          <parameter name="from" type="Number:" usage="required">
            <summary>from position in radians</summary>
          </parameter>
          <parameter name="to" type="Number:" usage="required">
            <summary>from position in radians</summary>
          </parameter>
          <parameter name="matrix" type="dojox.gfx3d.Matrix3D:" usage="required">
            <summary>the cumulative transformation matrix
	tolerance: Number: tolerable diffirence in colors between gradient steps</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx">
    <summary>Cross-browser vector graphics API</summary>
    <description>dojox.gfx is an advanced API providing normalized vector drawing
	in a variety of browsers. It has individual renderers for SVG, VML,
	Canvas, and Silverlight.</description>
    <properties>
      <property name="_vectorFontCache" scope="normal" type="Object"/>
      <property name="_svgFontCache" scope="normal" type="Object"/>
      <property name="VectorText" scope="normal" type="Object"/>
      <property name="getDefault" scope="normal" type="Object"/>
      <property name="cm_in_pt" scope="normal" type="Number"/>
      <property name="mm_in_pt" scope="normal" type="Number"/>
      <property name="pathVmlRegExp" scope="normal" type="RegExp"/>
      <property name="pathSvgRegExp" scope="normal" type="RegExp"/>
      <property name="canvas" scope="normal" type="Object"/>
      <property name="Matrix2D" scope="normal" type=""/>
      <property name="move" scope="normal" type="Object"/>
      <property name="renderer" scope="normal" type="String"/>
    </properties>
    <methods>
      <method name="normalizedLength" scope="normal">
        <summary>converts any length value to pixels</summary>
        <parameters>
          <parameter name="len" type="String:" usage="required">
            <summary>a length, e.g., &amp;quot;12pc&amp;quot;</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="getVectorFont" scope="normal">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeColor" scope="normal">
        <summary>converts any legal color representation to normalized
	dojo.Color object</summary>
        <parameters>
          <parameter name="color" type="Color" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Color"/>
        </return-types>
      </method>
      <method name="normalizeParameters" scope="normal">
        <summary>updates an existing object with properties from an &amp;quot;update&amp;quot;
	object</summary>
        <parameters>
          <parameter name="existed" type="Object" usage="required">
            <summary>the &amp;quot;target&amp;quot; object to be updated</summary>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <summary>the &amp;quot;update&amp;quot; object, whose properties will be used to update
	the existed object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="makeParameters" scope="normal">
        <summary>copies the original object, and all copied properties from the
	&amp;quot;update&amp;quot; object</summary>
        <parameters>
          <parameter name="defaults" type="Object" usage="required">
            <summary>the object to be cloned before updating</summary>
          </parameter>
          <parameter name="update" type="Object" usage="required">
            <summary>the object, which properties are to be cloned during updating</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="formatNumber" scope="normal">
        <summary>converts a number to a string using a fixed notation</summary>
        <parameters>
          <parameter name="x" type="Number:" usage="required">
            <summary>number to be converted</summary>
          </parameter>
          <parameter name="addSpace" type="Boolean:" usage="optional">
            <summary>if it is true, add a space before a positive number</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="makeFontString" scope="normal">
        <summary>converts a font object to a CSS font string</summary>
        <parameters>
          <parameter name="font" type="Object:" usage="required">
            <summary>font object (see dojox.gfx.defaultFont)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="splitFontString" scope="normal">
        <summary>converts a CSS font string to a font object</summary>
        <description>Converts a CSS font string to a gfx font object. The CSS font
	string components should follow the W3C specified order
	(see http://www.w3.org/TR/CSS2/fonts.html#font-shorthand):
	style, variant, weight, size, optional line height (will be
	ignored), and family.</description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <summary>a CSS font string</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="px_in_pt" scope="normal">
        <summary>returns a number of pixels per point</summary>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pt2px" scope="normal">
        <summary>converts points to pixels</summary>
        <parameters>
          <parameter name="len" type="Number:" usage="required">
            <summary>a value in points</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="px2pt" scope="normal">
        <summary>converts pixels to points</summary>
        <parameters>
          <parameter name="len" type="Number:" usage="required">
            <summary>a value in pixels</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="equalSources" scope="normal">
        <summary>compares event sources, returns true if they are equal</summary>
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_hasClass" scope="normal">
        <summary>Returns whether or not the specified classes are a portion of the
	class list currently applied to the node.
	return (new RegExp('(^|\\s+)'+classStr+'(\\s+|$)')).test(node.className)	// Boolean</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_addClass" scope="normal">
        <summary>Adds the specified classes to the end of the class list on the
	passed node.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_removeClass" scope="normal">
        <summary>Removes classes from node.</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="classStr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="createSurface" scope="normal">
        <summary>creates a surface (VML)</summary>
        <parameters>
          <parameter name="parentNode" type="Node:" usage="required">
            <summary>a parent node</summary>
          </parameter>
          <parameter name="width" type="String:" usage="required">
            <summary>width of surface, e.g., &amp;quot;100px&amp;quot;</summary>
          </parameter>
          <parameter name="height" type="String:" usage="required">
            <summary>height of surface, e.g., &amp;quot;100px&amp;quot;</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
      <method name="attachNode" scope="normal">
        <summary>creates a shape from a Node</summary>
        <parameters>
          <parameter name="node" type="Node:" usage="required">
            <summary>an VML node</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="for now"/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="decompose" scope="normal">
        <summary>decompose a 2D matrix into translation, scaling, and rotation components</summary>
        <description>this function decompose a matrix into four logical components:
	translation, rotation, scaling, and one more rotation using SVD.
	The components should be applied in following order:
	 [translate, rotate(angle2), scale, rotate(angle1)]</description>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required">
            <summary>a 2D matrix-like object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="attachSurface" scope="normal">
        <summary>creates a surface from a Node</summary>
        <parameters>
          <parameter name="node" type="Node:" usage="required">
            <summary>an VML node</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Surface"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.DataChart" type="Function" classlike="true" superclass="dojox.charting.Chart2D">
    <summary>DataChart
	Extension to the 2D chart that connects to a data store in
	a simple manner. Convenience methods have been added for
	connecting store item labels to the chart labels.</summary>
    <description>This code should be considered very experimental and the APIs subject
	to change. This is currently an alpha version and will need some testing
	and review.
	The main reason for this extension is to create animated charts, generally
	available with scroll=true, and a property field that gets continually updated.
	The previous property settings are kept in memory and displayed until scrolled
	off the chart.
	Although great effort was made to maintain the integrity of the current
	charting APIs, some things have been added or modified in order to get
	the store to connect and also to get the data to scroll/animate.
	"displayRange" in particular is used to force the xaxis to a specific
	size and keep the chart from stretching or squashing to fit the data.
	Currently, plot lines can only be set at initialization. Setting
	a new store query will have no effect (although using setStore
	may work but its untested).</description>
    <mixins>
      <mixin scope="instance" location="dojox.charting.Chart2D"/>
    </mixins>
    <examples>
      <example>	var chart = new dojox.charting.DataChart("myNode", {
			displayRange:8,
			store:dataStore,
			query:{symbol:"*"},
			fieldName:"price"
			type: dojox.charting.plot2d.Columns
		});
	properties:</example>
    </examples>
    <properties>
      <property name="scroll" scope="prototype" type="Boolean">
        <summary>Whether live data updates and changes display, like columns moving
	up and down, or whether it scrolls to the left as data is added</summary>
      </property>
      <property name="comparative" scope="prototype" type="Boolean">
        <summary>If false, all items are each their own series.
	If true, the items are combined into one series
	so that their charted properties can be compared.</summary>
      </property>
      <property name="query" scope="prototype" type="String">
        <summary>Used for fetching items. Will vary depending upon store.</summary>
      </property>
      <property name="queryOptions" scope="prototype" type="String">
        <summary>Option used for fetching items</summary>
      </property>
      <property name="fieldName" scope="prototype" type="String">
        <summary>The field in the store item that is getting charted</summary>
      </property>
      <property name="chartTheme" scope="normal" type="dojox.charting.themes.*">
        <summary>The theme to style the chart. Defaults to PlotKit.blue.</summary>
      </property>
      <property name="displayRange" scope="prototype" type="Number">
        <summary>The number of major ticks to show on the xaxis</summary>
      </property>
      <property name="stretchToFit" scope="instance-prototype" type="Boolean">
        <summary>If true, chart is sized to data. If false, chart is a
	fixed size. Note, is overridden by displayRange.
	TODO: Stretch for the y-axis?</summary>
      </property>
      <property name="minWidth" scope="prototype" type="Number">
        <summary>The the smallest the chart width can be</summary>
      </property>
      <property name="minHeight" scope="prototype" type="Number">
        <summary>The the smallest the chart height can be</summary>
      </property>
      <property name="showing" scope="prototype" type="Boolean">
        <summary>Whether the chart is showing (default) on
	initialization or hidden.</summary>
      </property>
      <property name="label" scope="prototype" type="String">
        <summary>The name field of the store item
	DO NOT SET: Set from store.labelAttribute</summary>
      </property>
      <property name="firstRun" scope="instance-prototype" type="Object"/>
      <property name="store" scope="prototype" type="Object"/>
      <property name="onSetInterval" scope="instance-prototype" type="Number"/>
      <property name="items" scope="prototype" type=""/>
      <property name="dataOffset" scope="instance-prototype" type="Number"/>
      <property name="dataLength" scope="instance-prototype" type="Number"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="onSetItems" scope="instance" type="Object"/>
      <property name="seriesData" scope="instance" type="Object"/>
      <property name="seriesDataBk" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>The node to attach the chart to.</summary>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Set up properties and initialize chart build.
	arguments:</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>The node to attach the chart to.</summary>
          </parameter>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setStore" scope="prototype">
        <summary>Sets the chart store and query
	then does the first fetch and
	connects to subsequent changes.
	TODO: Not handling resetting store</summary>
        <parameters>
          <parameter name="store" type="Object" usage="required"/>
          <parameter name="query" type="?" usage="required">
            <summary>String</summary>
          </parameter>
          <parameter name="fieldName" type="?" usage="required">
            <summary>String</summary>
          </parameter>
          <parameter name="queryOptions" type="?" usage="required">
            <summary>Object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <summary>If chart is hidden, show it</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>If chart is showing, hide it
	Prevents rendering while hidden</summary>
      </method>
      <method name="onSet" scope="prototype">
        <summary>Fired when a store item changes.
	Collects the item calls and when
	done (after 200ms), sends item
	array to onData().
	FIXME: Using labels instead of IDs for item
	identifiers here and in the chart series. This
	is obviously short sighted, but currently used
	for seriesLabels. Workaround for potential bugs
	is to assign a label for which all items are unique.</summary>
        <parameters>
          <parameter name="item" type="storeObject" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <parameters>
          <parameter name="err" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onDataReceived" scope="prototype">
        <summary>stub. Fires after data is received but
	before data is parsed and rendered</summary>
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getProperty" scope="prototype">
        <summary>The main use of this function is to determine
	between a single value and an array of values.
	Other property types included for convenience.</summary>
        <parameters>
          <parameter name="item" type="storeObject" usage="required"/>
          <parameter name="prop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onData" scope="prototype">
        <summary>Called after a completed fetch
	or when store items change.
	On first run, sets the chart data,
	then updates chart and legends.
	console.log(&amp;quot;Store:&amp;quot;, store);console.log(&amp;quot;items: (&amp;quot;, items.length+&amp;quot;)&amp;quot;, items);console.log(&amp;quot;Chart:&amp;quot;, this);</summary>
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <summary>Fetches initial data. Subsequent changes
	are received via onSet in data store.</summary>
      </method>
      <method name="convertLabels" scope="prototype">
        <summary>Convenience method to convert a label array of strings
	into an array of objects</summary>
        <parameters>
          <parameter name="axis" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="seriesLabels" scope="prototype">
        <summary>Convenience method that sets series labels based on item labels.</summary>
        <parameters>
          <parameter name="val" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="resizeChart" scope="prototype">
        <summary>Call this function to change the chart size.
	Can be connected to a layout widget that calls
	resize.</summary>
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.DataChart.xaxis">
    <summary>First query for store
	grid: Object
	Options for the grid plot
	chartPlot: Object
	Options for chart elements (lines, bars, etc)</summary>
    <properties>
      <property name="labelFunc" scope="instance" type="Object"/>
      <property name="to" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.DataChart.yaxis">
    <summary>optional parameters for yaxis (see above)
	store: Object
	dojo.data store (currently nly supports Persevere)</summary>
    <properties>
      <property name="labelFunc" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.DataChart.chartTheme.plotarea" type="">
    <properties>
      <property name="stroke" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.Element" type="Function" classlike="true">
    <properties>
      <property name="group" scope="instance-prototype" type="Object"/>
      <property name="dirty" scope="instance-prototype" type="Object"/>
      <property name="htmlElements" scope="instance-prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createGroup" scope="prototype">
        <parameters>
          <parameter name="creator" type="" usage="required"/>
        </parameters>
      </method>
      <method name="purgeGroup" scope="prototype"/>
      <method name="cleanGroup" scope="prototype">
        <parameters>
          <parameter name="creator" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroyHtmlElements" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.Element.chart" type="">
    <properties>
      <property name="surface" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.Series" type="Function" classlike="true" superclass="dojox.charting.Element">
    <mixins>
      <mixin scope="instance" location="dojox.charting.Element"/>
    </mixins>
    <properties>
      <property name="dyn" scope="prototype" type="Object"/>
      <property name="plot" scope="instance" type="String"/>
      <property name="data" scope="instance" type=""/>
      <property name="dirty" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="data" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="data" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.Theme" type="Function" classlike="true">
    <properties>
      <property name="markers" scope="instance" type="Object"/>
      <property name="colors" scope="instance" type="Array"/>
      <property name="antiAlias" scope="instance" type=""/>
      <property name="assignColors" scope="instance" type=""/>
      <property name="assignMarkers" scope="instance" type=""/>
      <property name="_current" scope="instance" type="Object"/>
      <property name="_markers" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_clone" scope="prototype">
        <summary>Return a clone of this theme, with the position vars reset to 0.</summary>
      </method>
      <method name="addMarker" scope="prototype">
        <summary>Add a custom marker to this theme.</summary>
        <examples>
          <example>	myTheme.addMarker("Ellipse", foo);</example>
        </examples>
        <parameters>
          <parameter name="name" type="String" usage="required"/>
          <parameter name="segment" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="next" scope="prototype">
        <summary>get either the next color or the next marker, depending on
	what was passed. If type is not passed, it assumes color.</summary>
        <examples>
          <example>	var color = myTheme.next();
		var color = myTheme.next("color");
		var marker = myTheme.next("marker");</example>
        </examples>
        <parameters>
          <parameter name="type" type="String" usage="optional">
            <summary>Optional. One of either &amp;quot;color&amp;quot; or &amp;quot;marker&amp;quot;. Defaults to
	&amp;quot;color&amp;quot;.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.Theme.defineColors" type="Function" classlike="true">
    <summary>Generate a set of colors for the theme based on keyword
	arguments</summary>
    <properties>
      <property name="colors" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.Theme._buildMarkerArray" type="Function" classlike="true" private="true">
    <properties>
      <property name="_markers" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.charting.Theme._buildMarkerArray._current" type="">
    <properties>
      <property name="marker" scope="instance" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme.setMarkers" type="Function" classlike="true">
    <summary>Set all the markers of this theme at once.  obj should be a
	dictionary of keys and path segments.</summary>
    <examples>
      <example>	myTheme.setMarkers({ "CIRCLE": foo });</example>
    </examples>
    <properties>
      <property name="markers" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.Theme.clear" type="Function" classlike="true">
    <summary>resets both marker and color counters back to the start.
	Subsequent calls to &lt;code&gt;next&lt;/code&gt; will retrievie the first value
	of each depending on the passed type.</summary>
    <properties>
      <property name="_current" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.charting.Theme.Markers">
    <properties>
      <property name="CIRCLE" scope="normal" type="String"/>
      <property name="SQUARE" scope="normal" type="String"/>
      <property name="DIAMOND" scope="normal" type="String"/>
      <property name="CROSS" scope="normal" type="String"/>
      <property name="X" scope="normal" type="String"/>
      <property name="TRIANGLE" scope="normal" type="String"/>
      <property name="TRIANGLE_INVERTED" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def" private="true">
    <properties>
      <property name="colors" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.chart">
    <properties>
      <property name="stroke" scope="normal" type="Object"/>
      <property name="fill" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.plotarea">
    <properties>
      <property name="stroke" scope="normal" type="Object"/>
      <property name="fill" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.axis">
    <properties>
      <property name="font" scope="normal" type="String"/>
      <property name="fontColor" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.axis.stroke">
    <properties>
      <property name="color" scope="normal" type="String"/>
      <property name="width" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.axis.majorTick">
    <properties>
      <property name="color" scope="normal" type="String"/>
      <property name="width" scope="normal" type="Number"/>
      <property name="length" scope="normal" type="Number"/>
      <property name="position" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.axis.minorTick">
    <properties>
      <property name="color" scope="normal" type="String"/>
      <property name="width" scope="normal" type="Number"/>
      <property name="length" scope="normal" type="Number"/>
      <property name="position" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.axis.microTick">
    <properties>
      <property name="color" scope="normal" type="String"/>
      <property name="width" scope="normal" type="Number"/>
      <property name="length" scope="normal" type="Number"/>
      <property name="position" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.series">
    <properties>
      <property name="fill" scope="normal" type="String"/>
      <property name="font" scope="normal" type="String"/>
      <property name="fontColor" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.series.outline">
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.series.stroke">
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.marker">
    <properties>
      <property name="fill" scope="normal" type="String"/>
      <property name="font" scope="normal" type="String"/>
      <property name="fontColor" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.Theme._def.marker.stroke">
    <properties>
      <property name="width" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.action2d"/>
  <object location="dojox.charting.action2d.Base" type="Function" classlike="true">
    <properties>
      <property name="handle" scope="prototype" type="Object"/>
      <property name="anim" scope="instance-prototype" type="Object"/>
      <property name="chart" scope="instance" type=""/>
      <property name="plot" scope="instance" type=""/>
      <property name="duration" scope="instance" type=""/>
      <property name="easing" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwargs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwargs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="prototype"/>
      <method name="disconnect" scope="prototype"/>
      <method name="reset" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.action2d.Base.overOutEvents">
    <properties>
      <property name="onmouseover" scope="normal" type="Number"/>
      <property name="onmouseout" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.action2d.Highlight" type="Function" classlike="true" superclass="dojox.charting.action2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.action2d.Base"/>
    </mixins>
    <properties>
      <property name="colorFun" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.action2d.Highlight.defaultParams">
    <properties>
      <property name="duration" scope="normal" type="Number"/>
      <property name="easing" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.action2d.Highlight.optionalParams">
    <properties>
      <property name="highlight" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.action2d.Magnify" type="Function" classlike="true" superclass="dojox.charting.action2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.action2d.Base"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="scale" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.action2d.Magnify.defaultParams">
    <properties>
      <property name="duration" scope="normal" type="Number"/>
      <property name="easing" scope="normal" type=""/>
      <property name="scale" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.action2d.MoveSlice" type="Function" classlike="true" superclass="dojox.charting.action2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.action2d.Base"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="angles" scope="prototype" type="Object"/>
      <property name="shift" scope="instance-prototype" type="Number"/>
      <property name="scale" scope="instance-prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.action2d.MoveSlice.defaultParams">
    <properties>
      <property name="duration" scope="normal" type="Number"/>
      <property name="easing" scope="normal" type=""/>
      <property name="scale" scope="normal" type=""/>
      <property name="shift" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.action2d.Shake" type="Function" classlike="true" superclass="dojox.charting.action2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.action2d.Base"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="shiftX" scope="instance" type=""/>
      <property name="shiftY" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.action2d.Shake.defaultParams">
    <properties>
      <property name="duration" scope="normal" type="Number"/>
      <property name="easing" scope="normal" type=""/>
      <property name="shiftX" scope="normal" type=""/>
      <property name="shiftY" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.action2d.Tooltip" type="Function" classlike="true" superclass="dojox.charting.action2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.action2d.Base"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="aroundRect" scope="prototype" type="Object"/>
      <property name="angles" scope="prototype" type="Object"/>
      <property name="text" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="plot" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.action2d.Tooltip.defaultParams">
    <properties>
      <property name="text" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.axis2d"/>
  <object location="dojox.charting.axis2d.Base" type="Function" classlike="true" superclass="dojox.charting.Element">
    <mixins>
      <mixin scope="instance" location="dojox.charting.Element"/>
    </mixins>
    <properties>
      <property name="vertical" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
      <method name="initialized" scope="prototype"/>
      <method name="calculate" scope="prototype">
        <parameters>
          <parameter name="min" type="" usage="required"/>
          <parameter name="max" type="" usage="required"/>
          <parameter name="span" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getScaler" scope="prototype"/>
      <method name="getTicks" scope="prototype"/>
      <method name="getOffsets" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.axis2d.Default" type="Function" classlike="true" superclass="dojox.charting.axis2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.axis2d.Base"/>
    </mixins>
    <properties>
      <property name="dirty" scope="prototype" type="bool"/>
      <property name="scale" scope="prototype" type=""/>
      <property name="offset" scope="prototype" type="Number"/>
      <property name="labels" scope="prototype" type=""/>
      <property name="ticks" scope="prototype" type="Object"/>
      <property name="_cachedLabelWidth" scope="prototype" type=""/>
      <property name="group" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dependOnData" scope="prototype"/>
      <method name="clear" scope="prototype"/>
      <method name="initialized" scope="prototype"/>
      <method name="setWindow" scope="prototype">
        <parameters>
          <parameter name="scale" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getWindowScale" scope="prototype"/>
      <method name="getWindowOffset" scope="prototype"/>
      <method name="_groupLabelWidth" scope="prototype">
        <parameters>
          <parameter name="labels" type="" usage="required"/>
          <parameter name="font" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculate" scope="prototype">
        <parameters>
          <parameter name="min" type="" usage="required"/>
          <parameter name="max" type="" usage="required"/>
          <parameter name="span" type="" usage="required"/>
          <parameter name="labels" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getScaler" scope="prototype"/>
      <method name="getTicks" scope="prototype"/>
      <method name="getOffsets" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.axis2d.Default.defaultParams">
    <properties>
      <property name="vertical" scope="normal" type="bool"/>
      <property name="fixUpper" scope="normal" type="String"/>
      <property name="fixLower" scope="normal" type="String"/>
      <property name="natural" scope="normal" type="bool"/>
      <property name="leftBottom" scope="normal" type="Object"/>
      <property name="includeZero" scope="normal" type="bool"/>
      <property name="fixed" scope="normal" type="Object"/>
      <property name="majorLabels" scope="normal" type="Object"/>
      <property name="minorTicks" scope="normal" type="Object"/>
      <property name="minorLabels" scope="normal" type="Object"/>
      <property name="microTicks" scope="normal" type="bool"/>
      <property name="htmlLabels" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.axis2d.Default.optionalParams">
    <properties>
      <property name="min" scope="normal" type="Number"/>
      <property name="max" scope="normal" type="Number"/>
      <property name="from" scope="normal" type="Number"/>
      <property name="to" scope="normal" type="Number"/>
      <property name="majorTickStep" scope="normal" type="Number"/>
      <property name="minorTickStep" scope="normal" type="Number"/>
      <property name="microTickStep" scope="normal" type="Number"/>
      <property name="labels" scope="normal" type="Array"/>
      <property name="labelFunc" scope="normal" type="Object"/>
      <property name="maxLabelSize" scope="normal" type="Number"/>
      <property name="stroke" scope="normal" type="Object"/>
      <property name="majorTick" scope="normal" type="Object"/>
      <property name="minorTick" scope="normal" type="Object"/>
      <property name="microTick" scope="normal" type="Object"/>
      <property name="font" scope="normal" type="String"/>
      <property name="fontColor" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.axis2d.Default.scaler">
    <properties>
      <property name="bounds" scope="prototype" type=""/>
      <property name="minMinorStep" scope="prototype" type=""/>
      <property name="major" scope="prototype" type=""/>
      <property name="minor" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.axis2d.Default.opt">
    <properties>
      <property name="from" scope="prototype" type="String"/>
      <property name="to" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.axis2d.Default.chart.theme" type="">
    <properties>
      <property name="axis" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.scaler"/>
  <object location="dojox.charting.axis2d.common"/>
  <object location="dojox.charting.axis2d.common.createText">
    <methods>
      <method name="gfx" scope="normal">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="creator" type="" usage="required"/>
          <parameter name="x" type="" usage="required"/>
          <parameter name="y" type="" usage="required"/>
          <parameter name="align" type="" usage="required"/>
          <parameter name="text" type="" usage="required"/>
          <parameter name="font" type="" usage="required"/>
          <parameter name="fontColor" type="" usage="required"/>
        </parameters>
      </method>
      <method name="html" scope="normal">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="creator" type="" usage="required"/>
          <parameter name="x" type="" usage="required"/>
          <parameter name="y" type="" usage="required"/>
          <parameter name="align" type="" usage="required"/>
          <parameter name="text" type="" usage="required"/>
          <parameter name="font" type="" usage="required"/>
          <parameter name="fontColor" type="" usage="required"/>
          <parameter name="labelWidth" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d"/>
  <object location="dojox.charting.plot2d.Areas" type="Function" classlike="true" superclass="dojox.charting.plot2d.Default">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Default"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Areas.opt" type="">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Bars" type="Function" classlike="true" superclass="dojox.charting.plot2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Base"/>
    </mixins>
    <properties>
      <property name="dirty" scope="prototype" type="bool"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type=""/>
      <property name="vAxis" scope="instance" type=""/>
      <property name="animate" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_animateBar" scope="prototype">
        <parameters>
          <parameter name="shape" type="" usage="required"/>
          <parameter name="hoffset" type="" usage="required"/>
          <parameter name="hsize" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Bars.defaultParams">
    <properties>
      <property name="hAxis" scope="normal" type="String"/>
      <property name="vAxis" scope="normal" type="String"/>
      <property name="gap" scope="normal" type="Number"/>
      <property name="shadows" scope="normal" type="Object"/>
      <property name="animate" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Bars.optionalParams">
    <properties>
      <property name="minBarSize" scope="normal" type="Number"/>
      <property name="maxBarSize" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Bars.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Base" type="Function" classlike="true" superclass="dojox.charting.Element">
    <mixins>
      <mixin scope="instance" location="dojox.charting.Element"/>
    </mixins>
    <properties>
      <property name="series" scope="prototype" type="Array"/>
      <property name="_hAxis" scope="prototype" type="Object"/>
      <property name="_vAxis" scope="prototype" type="Object"/>
      <property name="dirty" scope="prototype" type="Object"/>
      <property name="_hScaler" scope="prototype" type="Object"/>
      <property name="_vScaler" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="destroy" scope="prototype"/>
      <method name="clear" scope="prototype"/>
      <method name="setAxis" scope="prototype">
        <parameters>
          <parameter name="axis" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addSeries" scope="prototype">
        <parameters>
          <parameter name="run" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getRequiredColors" scope="prototype"/>
      <method name="plotEvent" scope="prototype">
        <parameters>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="prototype">
        <parameters>
          <parameter name="object" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
        </parameters>
      </method>
      <method name="events" scope="prototype"/>
      <method name="resetEvents" scope="prototype"/>
      <method name="_calc" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="stats" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_connectEvents" scope="prototype">
        <parameters>
          <parameter name="shape" type="" usage="required"/>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Bubble" type="Function" classlike="true" superclass="dojox.charting.plot2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Base"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="dirty" scope="prototype" type="bool"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type=""/>
      <property name="vAxis" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Bubble.defaultParams">
    <properties>
      <property name="hAxis" scope="normal" type="String"/>
      <property name="vAxis" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Bubble.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Bubble.opt">
    <properties>
      <property name="shadows" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Candlesticks" type="Function" classlike="true" superclass="dojox.charting.plot2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Base"/>
    </mixins>
    <properties>
      <property name="dirty" scope="prototype" type="bool"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type=""/>
      <property name="vAxis" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="collectStats" scope="prototype">
        <parameters>
          <parameter name="series" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Candlesticks.defaultParams">
    <properties>
      <property name="hAxis" scope="normal" type="String"/>
      <property name="vAxis" scope="normal" type="String"/>
      <property name="gap" scope="normal" type="Number"/>
      <property name="shadows" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Candlesticks.optionalParams">
    <properties>
      <property name="minBarSize" scope="normal" type="Number"/>
      <property name="maxBarSize" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Candlesticks.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.ClusteredBars" type="Function" classlike="true" superclass="dojox.charting.plot2d.Bars">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Bars"/>
    </mixins>
    <properties>
      <property name="dirty" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.ClusteredBars.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.ClusteredColumns" type="Function" classlike="true" superclass="dojox.charting.plot2d.Columns">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Columns"/>
    </mixins>
    <properties>
      <property name="dirty" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.ClusteredColumns.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Columns" type="Function" classlike="true" superclass="dojox.charting.plot2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Base"/>
    </mixins>
    <properties>
      <property name="dirty" scope="prototype" type="bool"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type=""/>
      <property name="vAxis" scope="instance" type=""/>
      <property name="animate" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_animateColumn" scope="prototype">
        <parameters>
          <parameter name="shape" type="" usage="required"/>
          <parameter name="voffset" type="" usage="required"/>
          <parameter name="vsize" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Columns.defaultParams">
    <properties>
      <property name="hAxis" scope="normal" type="String"/>
      <property name="vAxis" scope="normal" type="String"/>
      <property name="gap" scope="normal" type="Number"/>
      <property name="shadows" scope="normal" type="Object"/>
      <property name="animate" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Columns.optionalParams">
    <properties>
      <property name="minBarSize" scope="normal" type="Number"/>
      <property name="maxBarSize" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Columns.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Default" type="Function" classlike="true" superclass="dojox.charting.plot2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Base"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="dirty" scope="prototype" type="bool"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type=""/>
      <property name="vAxis" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Default.defaultParams">
    <properties>
      <property name="hAxis" scope="normal" type="String"/>
      <property name="vAxis" scope="normal" type="String"/>
      <property name="lines" scope="normal" type="Object"/>
      <property name="areas" scope="normal" type="bool"/>
      <property name="markers" scope="normal" type="bool"/>
      <property name="shadows" scope="normal" type="Number"/>
      <property name="tension" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Default.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Default.opt">
    <properties>
      <property name="shadows" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Grid" type="Function" classlike="true" superclass="dojox.charting.Element">
    <mixins>
      <mixin scope="instance" location="dojox.charting.Element"/>
    </mixins>
    <properties>
      <property name="optionalParams" scope="prototype" type="Object"/>
      <property name="_hAxis" scope="prototype" type="Object"/>
      <property name="_vAxis" scope="prototype" type="Object"/>
      <property name="dirty" scope="instance-prototype" type="Object"/>
      <property name="group" scope="prototype" type=""/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="hAxis" scope="instance" type=""/>
      <property name="vAxis" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
      <method name="setAxis" scope="prototype">
        <parameters>
          <parameter name="axis" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addSeries" scope="prototype">
        <parameters>
          <parameter name="run" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="prototype"/>
      <method name="getRequiredColors" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Grid.defaultParams">
    <properties>
      <property name="hAxis" scope="normal" type="String"/>
      <property name="vAxis" scope="normal" type="String"/>
      <property name="hMajorLines" scope="normal" type="Object"/>
      <property name="hMinorLines" scope="normal" type="bool"/>
      <property name="vMajorLines" scope="normal" type="Object"/>
      <property name="vMinorLines" scope="normal" type="bool"/>
      <property name="hStripes" scope="normal" type="String"/>
      <property name="vStripes" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Grid.chart.theme" type="">
    <properties>
      <property name="axis" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Lines" type="Function" classlike="true" superclass="dojox.charting.plot2d.Default">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Default"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Lines.opt" type="">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Markers" type="Function" classlike="true" superclass="dojox.charting.plot2d.Default">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Default"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Markers.opt" type="">
    <properties>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.MarkersOnly" type="Function" classlike="true" superclass="dojox.charting.plot2d.Default">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Default"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.MarkersOnly.opt" type="">
    <properties>
      <property name="lines" scope="instance" type="bool"/>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.OHLC" type="Function" classlike="true" superclass="dojox.charting.plot2d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Base"/>
    </mixins>
    <properties>
      <property name="dirty" scope="prototype" type="bool"/>
      <property name="opt" scope="instance" type="Object"/>
      <property name="series" scope="instance" type="Array"/>
      <property name="hAxis" scope="instance" type=""/>
      <property name="vAxis" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="collectStats" scope="prototype">
        <parameters>
          <parameter name="series" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.OHLC.defaultParams">
    <properties>
      <property name="hAxis" scope="normal" type="String"/>
      <property name="vAxis" scope="normal" type="String"/>
      <property name="gap" scope="normal" type="Number"/>
      <property name="shadows" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.OHLC.optionalParams">
    <properties>
      <property name="minBarSize" scope="normal" type="Number"/>
      <property name="maxBarSize" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.OHLC.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Pie" type="Function" classlike="true" superclass="dojox.charting.Element">
    <mixins>
      <mixin scope="instance" location="dojox.charting.Element"/>
    </mixins>
    <properties>
      <property name="dirty" scope="prototype" type="bool"/>
      <property name="dyn" scope="instance-prototype" type="Array"/>
      <property name="group" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="clear" scope="prototype"/>
      <method name="setAxis" scope="prototype">
        <parameters>
          <parameter name="axis" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addSeries" scope="prototype">
        <parameters>
          <parameter name="run" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getRequiredColors" scope="prototype"/>
      <method name="plotEvent" scope="prototype">
        <parameters>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="prototype">
        <parameters>
          <parameter name="object" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
        </parameters>
      </method>
      <method name="events" scope="prototype"/>
      <method name="resetEvents" scope="prototype"/>
      <method name="_connectEvents" scope="prototype">
        <parameters>
          <parameter name="shape" type="" usage="required"/>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="continue"/>
          <return-type type="stop iteration"/>
        </return-types>
      </method>
      <method name="_getLabel" scope="prototype">
        <parameters>
          <parameter name="number" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Pie.defaultParams">
    <properties>
      <property name="labels" scope="normal" type="Object"/>
      <property name="ticks" scope="normal" type="bool"/>
      <property name="fixed" scope="normal" type="Object"/>
      <property name="precision" scope="normal" type="Number"/>
      <property name="labelOffset" scope="normal" type="Number"/>
      <property name="labelStyle" scope="normal" type="String"/>
      <property name="htmlLabels" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Pie.optionalParams">
    <properties>
      <property name="font" scope="normal" type="String"/>
      <property name="fontColor" scope="normal" type="String"/>
      <property name="radius" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Pie.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Pie.opt">
    <properties>
      <property name="radius" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Pie.run">
    <properties>
      <property name="data" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Scatter" type="Function" classlike="true" superclass="dojox.charting.plot2d.Default">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Default"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Scatter.opt" type="">
    <properties>
      <property name="lines" scope="instance" type="bool"/>
      <property name="markers" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Stacked" type="Function" classlike="true" superclass="dojox.charting.plot2d.Default">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Default"/>
    </mixins>
    <properties>
      <property name="_maxRunLength" scope="prototype" type=""/>
      <property name="dirty" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.Stacked.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.Stacked.opt" type="">
    <properties>
      <property name="shadows" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.StackedAreas" type="Function" classlike="true" superclass="dojox.charting.plot2d.Stacked">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Stacked"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.StackedAreas.opt" type="">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
      <property name="areas" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.StackedBars" type="Function" classlike="true" superclass="dojox.charting.plot2d.Bars">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Bars"/>
    </mixins>
    <properties>
      <property name="_maxRunLength" scope="prototype" type=""/>
      <property name="dirty" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.StackedBars.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.StackedColumns" type="Function" classlike="true" superclass="dojox.charting.plot2d.Columns">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Columns"/>
    </mixins>
    <properties>
      <property name="_maxRunLength" scope="prototype" type=""/>
      <property name="dirty" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="calculateAxes" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
          <parameter name="offsets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.StackedColumns.chart" type="">
    <properties>
      <property name="theme" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.StackedLines" type="Function" classlike="true" superclass="dojox.charting.plot2d.Stacked">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot2d.Stacked"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.StackedLines.opt" type="">
    <properties>
      <property name="lines" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.plot2d.common" type="">
    <methods>
      <method name="makeStroke" scope="normal">
        <parameters>
          <parameter name="stroke" type="" usage="required"/>
        </parameters>
      </method>
      <method name="augmentColor" scope="normal">
        <parameters>
          <parameter name="target" type="" usage="required"/>
          <parameter name="color" type="" usage="required"/>
        </parameters>
      </method>
      <method name="augmentStroke" scope="normal">
        <parameters>
          <parameter name="stroke" type="" usage="required"/>
          <parameter name="color" type="" usage="required"/>
        </parameters>
      </method>
      <method name="augmentFill" scope="normal">
        <parameters>
          <parameter name="fill" type="" usage="required"/>
          <parameter name="color" type="" usage="required"/>
        </parameters>
      </method>
      <method name="collectSimpleStats" scope="normal">
        <parameters>
          <parameter name="series" type="" usage="required"/>
        </parameters>
      </method>
      <method name="calculateBarSize" scope="normal">
        <parameters>
          <parameter name="availableSize" type="Number" usage="required"/>
          <parameter name="opt" type="Object" usage="required"/>
          <parameter name="clusterSize" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="collectStackedStats" scope="normal">
        <parameters>
          <parameter name="series" type="" usage="required"/>
        </parameters>
      </method>
      <method name="curve" scope="normal">
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
          <parameter name="tension" type="Number|String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot2d.common.defaultStats">
    <properties>
      <property name="hmin" scope="normal" type=""/>
      <property name="hmax" scope="normal" type=""/>
      <property name="vmin" scope="normal" type=""/>
      <property name="vmax" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot3d"/>
  <object location="dojox.charting.plot3d.Bars" type="Function" classlike="true" superclass="dojox.charting.plot3d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot3d.Base"/>
    </mixins>
    <properties>
      <property name="depth" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="data" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="width" type="" usage="required"/>
          <parameter name="height" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="width" type="" usage="required"/>
          <parameter name="height" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="prototype"/>
      <method name="generate" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="creator" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot3d.Bars.material">
    <properties>
      <property name="color" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.plot3d.Base" type="Function" classlike="true">
    <properties>
      <property name="data" scope="prototype" type="Array"/>
      <property name="width" scope="instance" type=""/>
      <property name="height" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="width" type="" usage="required"/>
          <parameter name="height" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="width" type="" usage="required"/>
          <parameter name="height" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setData" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="prototype"/>
      <method name="generate" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="creator" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot3d.Cylinders" type="Function" classlike="true" superclass="dojox.charting.plot3d.Base">
    <mixins>
      <mixin scope="instance" location="dojox.charting.plot3d.Base"/>
    </mixins>
    <properties>
      <property name="depth" scope="instance" type="String"/>
      <property name="gap" scope="instance" type="Number"/>
      <property name="data" scope="instance" type="Array"/>
      <property name="outline" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="width" type="" usage="required"/>
          <parameter name="height" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="width" type="" usage="required"/>
          <parameter name="height" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getDepth" scope="prototype"/>
      <method name="generate" scope="prototype">
        <parameters>
          <parameter name="chart" type="" usage="required"/>
          <parameter name="creator" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.plot3d.Cylinders.material">
    <properties>
      <property name="color" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.scaler.common">
    <methods>
      <method name="findString" scope="normal">
        <parameters>
          <parameter name="val" type="String" usage="required"/>
          <parameter name="text" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="getNumericLabel" scope="normal">
        <parameters>
          <parameter name="number" type="Number" usage="required"/>
          <parameter name="precision" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.scaler.linear">
    <methods>
      <method name="buildScaler" scope="normal">
        <parameters>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
          <parameter name="span" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="buildTicks" scope="normal">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransformerFromModel" scope="normal">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="getTransformerFromPlot" scope="normal">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.scaler.primitive">
    <methods>
      <method name="buildScaler" scope="normal">
        <parameters>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
          <parameter name="span" type="Number" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="buildTicks" scope="normal">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransformerFromModel" scope="normal">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="getTransformerFromPlot" scope="normal">
        <parameters>
          <parameter name="scaler" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.themes">
    <properties>
      <property name="Adobebricks" scope="normal" type="Object"/>
      <property name="Algae" scope="normal" type="Object"/>
      <property name="Bahamation" scope="normal" type="Object"/>
      <property name="BlueDusk" scope="normal" type="Object"/>
      <property name="CubanShirts" scope="normal" type="Object"/>
      <property name="Desert" scope="normal" type="Object"/>
      <property name="Distinctive" scope="normal" type="Object"/>
      <property name="Dollar" scope="normal" type="Object"/>
      <property name="Grasshopper" scope="normal" type="Object"/>
      <property name="Grasslands" scope="normal" type="Object"/>
      <property name="GreySkies" scope="normal" type="Object"/>
      <property name="Harmony" scope="normal" type="Object"/>
      <property name="IndigoNation" scope="normal" type="Object"/>
      <property name="Ireland" scope="normal" type="Object"/>
      <property name="MiamiNice" scope="normal" type="Object"/>
      <property name="Midwest" scope="normal" type="Object"/>
      <property name="Minty" scope="normal" type="Object"/>
      <property name="PurpleRain" scope="normal" type="Object"/>
      <property name="RoyalPurples" scope="normal" type="Object"/>
      <property name="SageToLime" scope="normal" type="Object"/>
      <property name="Shrooms" scope="normal" type="Object"/>
      <property name="Tufte" scope="normal" type="Object"/>
      <property name="WatersEdge" scope="normal" type="Object"/>
      <property name="Wetland" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.themes.ET">
    <properties>
      <property name="greys" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.themes.PlotKit">
    <properties>
      <property name="blue" scope="normal" type="Object"/>
      <property name="cyan" scope="normal" type="Object"/>
      <property name="green" scope="normal" type="Object"/>
      <property name="orange" scope="normal" type="Object"/>
      <property name="purple" scope="normal" type="Object"/>
      <property name="red" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.charting.widget"/>
  <object location="dojox.charting.widget.Chart2D" type="Function" classlike="true" superclass="dijit._Widget">
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="theme" scope="prototype" type="Object"/>
      <property name="margins" scope="prototype" type="Object"/>
      <property name="stroke" scope="prototype" type="Object"/>
      <property name="fill" scope="prototype" type="Object"/>
      <property name="domNode" scope="prototype" type=""/>
      <property name="chart" scope="prototype" type="Object"/>
      <property name="actions" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="destroy" scope="prototype">
        <summary>properly destroy the widget</summary>
      </method>
      <method name="resize" scope="prototype">
        <summary>resize the widget</summary>
        <parameters>
          <parameter name="box" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.widget.Legend" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A legend for a chart. A legend contains summary labels for
	each series of data contained in the chart.
	Set the boolean horizontal attribute to false to layout legend labels vertically.
	(Line or Scatter charts (colored lines with shape symbols) )
	-o- Series1		-X- Series2		-v- Series3
	(Area/Bar/Pie charts (letters represent colors))
	[a] Series1		[b] Series2		[c] Series3</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="chartRef" scope="prototype" type="String"/>
      <property name="horizontal" scope="prototype" type="Object"/>
      <property name="swatchSize" scope="prototype" type="Number"/>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="legendNode" scope="prototype" type="Object"/>
      <property name="legendBody" scope="prototype" type="Object"/>
      <property name="chart" scope="prototype" type="Object"/>
      <property name="series" scope="prototype" type=""/>
      <property name="_surfaces" scope="prototype" type="Array"/>
      <property name="_tr" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="refresh" scope="prototype">
        <summary>regenerates the legend to reflect changes to the chart</summary>
      </method>
      <method name="_addLabel" scope="prototype">
        <parameters>
          <parameter name="dyn" type="" usage="required"/>
          <parameter name="label" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_makeIcon" scope="prototype">
        <parameters>
          <parameter name="div" type="" usage="required"/>
          <parameter name="dyn" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.charting.widget.Legend.series.0.chart.stack" type="">
    <properties>
      <property name="0" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.charting.widget.Sparkline" type="Function" classlike="true" superclass="dojox.charting.widget.Chart2D">
    <mixins>
      <mixin scope="instance" location="dojox.charting.widget.Chart2D"/>
    </mixins>
    <properties>
      <property name="theme" scope="normal" type=""/>
      <property name="type" scope="prototype" type="String"/>
      <property name="valueFn" scope="prototype" type="String"/>
      <property name="store" scope="prototype" type="String"/>
      <property name="field" scope="prototype" type="String"/>
      <property name="query" scope="prototype" type="String"/>
      <property name="queryOptions" scope="prototype" type="String"/>
      <property name="start" scope="prototype" type="String"/>
      <property name="count" scope="prototype" type="String"/>
      <property name="sort" scope="prototype" type="String"/>
      <property name="data" scope="prototype" type="String"/>
      <property name="name" scope="prototype" type="String"/>
      <property name="srcNodeRef" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.charting.widget.Sparkline.margins">
    <properties>
      <property name="l" scope="normal" type="Number"/>
      <property name="r" scope="normal" type="Number"/>
      <property name="t" scope="normal" type="Number"/>
      <property name="b" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.collections">
    <summary>A set of lists and hashes for easy use within your applications.</summary>
    <properties>
      <property name="Set" scope="normal" type="Object"/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.collections.ArrayList" type="Function" classlike="true">
    <properties>
      <property name="count" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="arr" type="array" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.ArrayList"/>
          <return-type type="bool"/>
          <return-type type="dojox.collections.Iterator"/>
          <return-type type="int"/>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="addRange" scope="instance">
        <parameters>
          <parameter name="a" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.ArrayList"/>
        </return-types>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="indexOf" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="insert" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="reverse" scope="instance"/>
      <method name="sort" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="optional"/>
        </parameters>
      </method>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toArray" scope="instance"/>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="delim" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.collections.BinaryTree" type="Function" classlike="true">
    <properties>
      <property name="count" scope="instance" type="Number"/>
      <property name="root" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance"/>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deleteData" scope="instance">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance"/>
      <method name="search" scope="instance">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="instance">
        <parameters>
          <parameter name="order" type="" usage="required"/>
          <parameter name="sep" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.collections.BinaryTree.TraversalMethods">
    <properties>
      <property name="Preorder" scope="normal" type="Number"/>
      <property name="Inorder" scope="normal" type="Number"/>
      <property name="Postorder" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.collections.Dictionary" type="Function" classlike="true">
    <properties>
      <property name="count" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="dictionary" type="dojox.collections.Dictionary" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.Dictionary"/>
          <return-type type="bool"/>
          <return-type type="dojox.collections.DictionaryEntry"/>
          <return-type type="object"/>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Dictionary"/>
        </return-types>
      </method>
      <method name="contains" scope="instance"/>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getKeyList" scope="instance"/>
      <method name="getValueList" scope="instance"/>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.collections.Queue" type="Function" classlike="true">
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="arr" type="array" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.Queue"/>
          <return-type type="bool"/>
          <return-type type="object"/>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Queue"/>
        </return-types>
      </method>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="dequeue" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="enqueue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="peek" scope="instance"/>
      <method name="toArray" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.collections.SortedList" type="Function" classlike="true">
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="dictionary" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.SortedList"/>
          <return-type type="bool"/>
          <return-type type="dojox.collections.DictionaryEntry"/>
          <return-type type="object"/>
          <return-type type="dojox.collections.DictionaryIterator"/>
          <return-type type="array"/>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance">
        <return-types>
          <return-type type="dojox.collections.SortedList"/>
        </return-types>
      </method>
      <method name="contains" scope="instance"/>
      <method name="containsKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="containsValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="entry" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.collections.DictionaryEntry"/>
        </return-types>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.DictionaryIterator"/>
        </return-types>
      </method>
      <method name="getKey" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="getKeyList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getValueList" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="indexOfKey" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="indexOfValue" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="item" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="removeAt" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="replace" scope="instance">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="setByIndex" scope="instance">
        <parameters>
          <parameter name="i" type="int" usage="required"/>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.collections.Stack" type="Function" classlike="true">
    <properties>
      <property name="count" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="arr" type="array" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
          <return-type type="dojox.collections.Iterator"/>
          <return-type type="object"/>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="clear" scope="instance"/>
      <method name="clone" scope="instance"/>
      <method name="contains" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="copyTo" scope="instance">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
          <parameter name="i" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="forEach" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="getIterator" scope="instance">
        <return-types>
          <return-type type="dojox.collections.Iterator"/>
        </return-types>
      </method>
      <method name="peek" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="pop" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="push" scope="instance">
        <parameters>
          <parameter name="o" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="toArray" scope="instance">
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.collections.DictionaryEntry" type="Function" classlike="true">
    <properties>
      <property name="key" scope="instance" type=""/>
      <property name="value" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="k" type="string" usage="required"/>
          <parameter name="v" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="valueOf" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.collections.Iterator" type="Function" classlike="true">
    <properties>
      <property name="element" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="arr" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.collections.DictionaryIterator" type="Function" classlike="true">
    <properties>
      <property name="element" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="bool"/>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="atEnd" scope="instance">
        <return-types>
          <return-type type="bool"/>
        </return-types>
      </method>
      <method name="get" scope="instance">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="map" scope="instance">
        <parameters>
          <parameter name="fn" type="function" usage="required"/>
          <parameter name="scope" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.color">
    <summary>Advanced color methods, including HSV, HSL, and CMYK conversion, a color generator and advanced colorspace calculations.</summary>
    <properties>
      <property name="Colorspace" scope="normal" type="Object"/>
      <property name="blend" scope="normal" type=""/>
      <property name="fromRgb" scope="normal" type=""/>
      <property name="fromHex" scope="normal" type=""/>
      <property name="fromArray" scope="normal" type=""/>
      <property name="fromString" scope="normal" type=""/>
      <property name="greyscale" scope="normal" type=""/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="fromXYZ" scope="normal">
        <parameters>
          <parameter name="xyz" type="Object" usage="required"/>
          <parameter name="kwArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="fromCmy" scope="normal">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromCmyk" scope="normal">
        <parameters>
          <parameter name="cyan" type="Object|Array|int" usage="required"/>
          <parameter name="magenta" type="int" usage="required"/>
          <parameter name="yellow" type="int" usage="required"/>
          <parameter name="black" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromHsl" scope="normal">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="luminosity" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
      <method name="fromHsv" scope="normal">
        <parameters>
          <parameter name="hue" type="Object|Array|int" usage="required"/>
          <parameter name="saturation" type="int" usage="required"/>
          <parameter name="value" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Color"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.color.Color" type="Function" classlike="true">
    <methods>
      <method constructor="constructor"/>
      <method name="toXYZ" scope="prototype">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmy" scope="prototype">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toCmyk" scope="prototype">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toHsl" scope="prototype">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toHsv" scope="prototype">
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.math">
    <summary>A collection of various advanced math functions.</summary>
    <properties>
      <property name="BigInteger-ext" scope="normal" type="Object"/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="toRadians" scope="normal">
        <summary>Convert the passed number to radians.</summary>
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="toDegrees" scope="normal">
        <summary>Convert the passed number to degrees.</summary>
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="degreesToRadians" scope="normal">
        <summary>Deprecated.  Use dojox.math.toRadians.</summary>
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="radiansToDegrees" scope="normal">
        <summary>Deprecated.  Use dojox.math.toDegrees.</summary>
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="_gamma" scope="normal">
        <summary>Compute the gamma function for the passed number.
	Approximately 14 dijits of precision with non-integers.</summary>
        <parameters>
          <parameter name="z" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="normal integer quick return"/>
          <return-type type="undefined at nonpositive integers since sin() below will return 0"/>
          <return-type type="popular gamma(1/2)"/>
          <return-type type="reflection"/>
        </return-types>
      </method>
      <method name="factorial" scope="normal">
        <summary>Return the factorial of n</summary>
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="permutations" scope="normal">
        <summary>TODO</summary>
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="k" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="combinations" scope="normal">
        <summary>TODO</summary>
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="r" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="bernstein" scope="normal">
        <summary>TODO</summary>
        <parameters>
          <parameter name="t" type="Number" usage="required"/>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="i" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="gaussian" scope="normal">
        <summary>Return a random number based on the Gaussian algo.</summary>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="range" scope="normal">
        <summary>Create a range of numbers based on the parameters.</summary>
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="optional"/>
          <parameter name="step" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="distance" scope="normal">
        <summary>Calculate the distance between point A and point B</summary>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="midpoint" scope="normal">
        <summary>Calculate the midpoint between points A and B.  A and B may be multidimensional.</summary>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="round" scope="normal">
        <summary>Similar to dojo.number.round, but compensates for binary floating point artifacts</summary>
        <description>Rounds to the nearest value with the given number of decimal places, away from zero if equal,
	similar to Number.toFixed().  Rounding can be done by fractional increments also.
	Makes minor adjustments to accommodate for precision errors due to binary floating point representation
	of Javascript Numbers.  See http://speleotrove.com/decimal/decifaq.html for more information.
	Because of this adjustment, the rounding may not be mathematically correct for full precision
	floating point values.  The calculations assume 14 significant figures, so the accuracy will
	be limited to a certain number of decimal places preserved will vary with the magnitude of
	the input.  This is not a substitute for decimal arithmetic.</description>
        <examples>
          <example>&gt;&gt;&gt; 4.8-(1.1+2.2)
	1.4999999999999996
	&gt;&gt;&gt; Math.round(4.8-(1.1+2.2))
	1
	&gt;&gt;&gt; dojox.math.round(4.8-(1.1+2.2))
	2
	&gt;&gt;&gt; ((4.8-(1.1+2.2))/100)
	0.014999999999999996
	&gt;&gt;&gt; ((4.8-(1.1+2.2))/100).toFixed(2)
	"0.01"
	&gt;&gt;&gt; dojox.math.round((4.8-(1.1+2.2))/100,2)
	0.02
	&gt;&gt;&gt; dojox.math.round(10.71, 0, 2.5)
	10.75
	&gt;&gt;&gt; dojo.number.round(162.295, 2)
	162.29
	&gt;&gt;&gt; dojox.math.round(162.295, 2)
	162.3</example>
        </examples>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <summary>The number to round</summary>
          </parameter>
          <parameter name="places" type="Number" usage="optional">
            <summary>The number of decimal places where rounding takes place.  Defaults to 0 for whole rounding.
	Must be non-negative.</summary>
          </parameter>
          <parameter name="increment" type="Number" usage="optional">
            <summary>Rounds next place to nearest value of increment/10.  10 by default.</summary>
          </parameter>
          <parameter name="v" type="" usage="required"/>
          <parameter name="p" type="" usage="required"/>
          <parameter name="m" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.color.Palette" type="Function" classlike="true">
    <properties>
      <property name="colors" scope="instance" type="dojox.color.Color[]">
        <summary>The actual color references in this palette.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="base" type="String|Array|dojox.color.Color|dojox.color.Palette" usage="required"/>
        </parameters>
      </method>
      <method name="generate" scope="normal">
        <parameters>
          <parameter name="base" type="String|dojox.color.Color" usage="required"/>
          <parameter name="type" type="Function|String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="transform" scope="prototype">
        <parameters>
          <parameter name="kwArgs" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
      <method name="clone" scope="prototype">
        <return-types>
          <return-type type="dojox.color.Palette"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.color.Palette.generators">
    <methods>
      <method name="analogous" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="monochromatic" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="triadic" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="complementary" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="splitComplementary" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="compound" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shades" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.cometd">
    <summary>A cometd client written in Dojo</summary>
    <properties>
      <property name="HttpChannels" scope="normal" type=""/>
      <property name="connectionTypes" scope="normal" type="Object"/>
      <property name="_base" scope="normal" type="Object"/>
      <property name="ackEnabled" scope="normal" type="Object"/>
      <property name="ack" scope="normal" type="Object"/>
      <property name="longPollTransport" scope="normal" type="Object"/>
      <property name="timestamp" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.cometd.RestChannels" type="Function" classlike="true">
    <summary>Initiates the REST Channels protocol</summary>
    <properties>
      <property name="acceptType" scope="prototype" type="String"/>
      <property name="subscriptions" scope="prototype" type="Object"/>
      <property name="subCallbacks" scope="prototype" type="Object"/>
      <property name="autoReconnectTime" scope="prototype" type="Number"/>
      <property name="reloadDataOnReconnect" scope="prototype" type="Object"/>
      <property name="sendAsJson" scope="prototype" type="bool"/>
      <property name="url" scope="prototype" type="String"/>
      <property name="autoSubscribeRoot" scope="prototype" type="String"/>
      <property name="started" scope="prototype" type="bool"/>
      <property name="connectionId" scope="prototype" type=""/>
      <property name="createdClientId" scope="prototype" type="Object"/>
      <property name="lastIndex" scope="prototype" type="Number"/>
      <property name="connected" scope="prototype" type="bool"/>
      <property name="defaultInstance" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <summary>arguments:
	The *autoSubscribeRoot* parameter:
	When this is set, all REST service requests that have this
	prefix will be auto-subscribed. The default is '/' (all REST requests).
	The *url* parameter:
	This is the url to connect to for server-sent messages. The default
	is &amp;quot;/channels&amp;quot;.
	The *autoReconnectTime* parameter:
	This is amount time to wait to reconnect with a connection is broken
	The *reloadDataOnReconnect* parameter:
	This indicates whether RestChannels should re-download data when a connection
	is restored (value of true), or if it should re-subscribe with retroactive subscriptions
	(Subscribe-Since header) using HEAD requests (value of false). The
	default is true.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initiates the REST Channels protocol</summary>
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <summary>arguments:
	The *autoSubscribeRoot* parameter:
	When this is set, all REST service requests that have this
	prefix will be auto-subscribed. The default is '/' (all REST requests).
	The *url* parameter:
	This is the url to connect to for server-sent messages. The default
	is &amp;quot;/channels&amp;quot;.
	The *autoReconnectTime* parameter:
	This is amount time to wait to reconnect with a connection is broken
	The *reloadDataOnReconnect* parameter:
	This indicates whether RestChannels should re-download data when a connection
	is restored (value of true), or if it should re-subscribe with retroactive subscriptions
	(Subscribe-Since header) using HEAD requests (value of false). The
	default is true.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="absoluteUrl" scope="prototype">
        <parameters>
          <parameter name="baseUrl" type="" usage="required"/>
          <parameter name="relativeUrl" type="" usage="required"/>
        </parameters>
      </method>
      <method name="open" scope="prototype">
        <summary>Startup the transport (connect to the &amp;quot;channels&amp;quot; resource to receive updates from the server).</summary>
        <description>Note that if there is no connection open, this is automatically called when you do a subscription,
	it is often not necessary to call this</description>
        <return-types>
          <return-type type="this can be called after dojo is unloaded, just do nothing in that case"/>
        </return-types>
      </method>
      <method name="_send" scope="prototype">
        <parameters>
          <parameter name="method" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="prototype">
        <summary>Subscribes to a channel/uri, and returns a dojo.Deferred object for the response from
	the subscription request</summary>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <summary>the uri for the resource you want to monitor</summary>
          </parameter>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional">
            <summary>See dojo.xhr
	headers:
	These are the headers to be applied to the channel subscription request
	callback:
	This will be called when a event occurs for the channel
	The callback will be called with a single argument:
		callback(message)
	where message is an object that follows the XHR API:
	status : Http status
	statusText : Http status text
	getAllResponseHeaders() : The response headers
	getResponseHeaders(headerName) : Retrieve a header by name
	responseText : The response body as text
	with the following additional Bayeux properties
	data : The response body as JSON
	channel : The channel/url of the response</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="don't process the response, the response will be received in the main channels response"/>
        </return-types>
      </method>
      <method name="publish" scope="prototype">
        <summary>Publish an event.</summary>
        <description>This does a simple POST operation to the provided URL,
	POST is the semantic equivalent of publishing a message within REST/Channels</description>
        <parameters>
          <parameter name="channel" type="Channel/resource" usage="required">
            <summary>path to publish to</summary>
          </parameter>
          <parameter name="data" type="data" usage="required">
            <summary>to publish</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_processMessage" scope="prototype">
        <parameters>
          <parameter name="message" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="indicate an error"/>
        </return-types>
      </method>
      <method name="onprogress" scope="prototype">
        <parameters>
          <parameter name="xhr" type="" usage="required"/>
          <parameter name="data" type="" usage="required"/>
          <parameter name="contentType" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <summary>GET the initial value of the resource and subscribe to it
	See subscribe for parameter values</summary>
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="receive" scope="prototype">
        <summary>Called when a message is received from the server</summary>
        <parameters>
          <parameter name="message" type="A" usage="required">
            <summary>cometd/XHR message</summary>
          </parameter>
        </parameters>
      </method>
      <method name="disconnected" scope="prototype">
        <summary>called when our channel gets disconnected</summary>
      </method>
      <method name="unsubscribe" scope="prototype">
        <summary>unsubscribes from the resource
	See subscribe for parameter values</summary>
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="args" type="dojo.__XhrArgs" usage="optional"/>
        </parameters>
      </method>
      <method name="disconnect" scope="prototype">
        <summary>disconnect from the server</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.cometd.Connection" type="Function" classlike="true">
    <properties>
      <property name="url" scope="instance" type="Object"/>
      <property name="_isXD" scope="instance" type="bool"/>
      <property name="_props" scope="instance" type=""/>
      <property name="_messageQ" scope="instance" type="Array"/>
      <property name="_subscriptions" scope="instance" type="Array"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="_status" scope="instance" type="String"/>
      <property name="batch" scope="instance" type="Number"/>
      <property name="_deferredSubscribes" scope="instance" type=""/>
      <property name="_handshook" scope="instance" type="Object"/>
      <property name="_backoffInterval" scope="instance" type="Number"/>
      <property name="handshakeReturn" scope="instance" type=""/>
      <property name="clientId" scope="instance" type=""/>
      <property name="lastMessage" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="prefix" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="state" scope="instance"/>
      <method name="init" scope="instance">
        <summary>Initialize the cometd implementation of the Bayeux protocol</summary>
        <description>Initialize the cometd implementation of the Bayeux protocol by
	sending a handshake message. The cometd state will be changed to CONNECTING
	until a handshake response is received and the first successful connect message
	has returned.
	The protocol state changes may be monitored
	by subscribing to the dojo topic "/prefix/meta" (typically "/cometd/meta") where
	events are published in the form
	{cometd:this,action:"handshake",successful:true,state:this.state()}</description>
        <examples>
          <example>	dojox.cometd.init("/cometd");
		dojox.cometd.init("http://xdHost/cometd",{ext:{user:"fred",pwd:"secret"}});</example>
        </examples>
        <parameters>
          <parameter name="root" type="String" usage="required">
            <summary>The URL of the cometd server. If the root is absolute, the host
	is examined to determine if xd transport is needed. Otherwise the
	same domain is assumed.</summary>
          </parameter>
          <parameter name="props" type="Object" usage="optional">
            <summary>An optional object that is used as the basis of the handshake message</summary>
          </parameter>
          <parameter name="bargs" type="Object" usage="optional">
            <summary>An optional object of bind args mixed in with the send of the handshake</summary>
          </parameter>
        </parameters>
      </method>
      <method name="publish" scope="instance">
        <summary>publishes the passed message to the cometd server for delivery
	on the specified topic</summary>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <summary>the destination channel for the message</summary>
          </parameter>
          <parameter name="data" type="Object" usage="required">
            <summary>a JSON object containing the message &amp;quot;payload&amp;quot;
	properties:
	Optional. Other meta-data to be mixed into the top-level of the
	message</summary>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="subscribe" scope="instance">
        <summary>inform the server of this client's interest in channel</summary>
        <description>`dojox.cometd.subscribe()` handles all the hard work of telling
	the server that we want to be notified when events are
	published on a particular topic. `subscribe` accepts a function
	to handle messages and returns a `dojo.Deferred` object which
	has an extra property added to it which makes it suitable for
	passing to `dojox.cometd.unsubscribe()` as a "subscription
	handle" (much like the handle object that `dojo.connect()`
	produces and which `dojo.disconnect()` expects).
	Note that of a subscription is registered before a connection
	with the server is established, events sent before the
	connection is established will not be delivered to this client.
	The deferred object which `subscribe` returns will callback
	when the server successfuly acknolwedges receipt of our
	"subscribe" request.</description>
        <examples>
          <example>Simple subscribe use-case
		dojox.cometd.init("http://myserver.com:8080/cometd");
		// log out all incoming messages on /foo/bar
		dojox.cometd.subscribe("/foo/bar", console, "debug");</example>
          <example>Subscribe before connection is initialized
		dojox.cometd.subscribe("/foo/bar", console, "debug");
		dojox.cometd.init("http://myserver.com:8080/cometd");</example>
          <example>Subscribe an unsubscribe
		dojox.cometd.init("http://myserver.com:8080/cometd");
		var h = dojox.cometd.subscribe("/foo/bar", console, "debug");
		dojox.cometd.unsubscribe(h);</example>
          <example>Listen for successful subscription:
		dojox.cometd.init("http://myserver.com:8080/cometd");
		var h = dojox.cometd.subscribe("/foo/bar", console, "debug");
		h.addCallback(function(){
			console.debug("subscription to /foo/bar established");
		});</example>
        </examples>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <summary>name of the cometd channel to subscribe to</summary>
          </parameter>
          <parameter name="objOrFunc" type="Object" usage="required">
            <summary>an object scope for funcName or the name or reference to a
	function to be called when messages are delivered to the
	channel</summary>
          </parameter>
          <parameter name="funcName" type="String" usage="required">
            <summary>the second half of the objOrFunc/funcName pair for identifying
	a callback function to notifiy upon channel message delivery</summary>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="unsubscribe" scope="instance">
        <summary>inform the server of this client's disinterest in channel</summary>
        <parameters>
          <parameter name="channel" type="String" usage="required">
            <summary>name of the cometd channel to unsubscribe from</summary>
          </parameter>
          <parameter name="objOrFunc" type="Object" usage="optional">
            <summary>an object scope for funcName or the name or reference to a
	function to be called when messages are delivered to the
	channel. If null then all subscribers to the channel are unsubscribed.</summary>
          </parameter>
          <parameter name="funcName" type="String" usage="optional">
            <summary>the second half of the objOrFunc/funcName pair for identifying
	a callback function to notifiy upon channel message delivery</summary>
          </parameter>
          <parameter name="props" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="disconnect" scope="instance">
        <summary>Disconnect from the server.</summary>
        <description>Disconnect from the server by sending a disconnect message</description>
        <examples>
          <example>	dojox.cometd.disconnect();</example>
        </examples>
      </method>
      <method name="subscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribed" scope="instance">
        <parameters>
          <parameter name="channel" type="String" usage="required"/>
          <parameter name="message" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance">
        <parameters>
          <parameter name="childLocation" type="" usage="required"/>
          <parameter name="childDomain" type="" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_backoff" scope="instance"/>
      <method name="_backon" scope="instance"/>
      <method name="_interval" scope="instance"/>
      <method name="_publishMeta" scope="instance">
        <parameters>
          <parameter name="action" type="" usage="required"/>
          <parameter name="successful" type="" usage="required"/>
          <parameter name="props" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_finishInit" scope="instance">
        <summary>Handle the handshake return from the server and initialize
	connection if all is OK</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_extendIn" scope="instance">
        <summary>Handle extensions for inbound messages</summary>
        <parameters>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_extendOut" scope="instance">
        <summary>Handle extensions for inbound messages</summary>
        <parameters>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="messages" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_deliver" scope="instance">
        <parameters>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_sendMessage" scope="instance">
        <parameters>
          <parameter name="message" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="startBatch" scope="instance"/>
      <method name="endBatch" scope="instance"/>
      <method name="_onUnload" scope="instance"/>
      <method name="_connectTimeout" scope="instance">
        <summary>Return the connect timeout in ms, calculated as the minimum of the advised timeout
	and the configured timeout. Else 0 to indicate no client side timeout</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.cometd.Connection._advice" private="true">
    <properties>
      <property name="interval" scope="instance" type="Number"/>
      <property name="reconnect" scope="instance" type="String"/>
    </properties>
  </object>
  <object location="dojox.cometd.Connection.currentTransport">
    <properties>
      <property name="_cometd" scope="instance" type="Object"/>
      <property name="version" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.cometd._ack" type="Function" classlike="true" private="true">
    <methods>
      <method constructor="constructor"/>
      <method name="_in" scope="instance">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_out" scope="instance">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.cometd.callbackPollTransport" type="Function" classlike="true">
    <properties>
      <property name="_connectionType" scope="instance" type="String"/>
      <property name="tunnelCollapse" scope="instance" type=""/>
      <property name="_connect" scope="instance" type=""/>
      <property name="deliver" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="" usage="required"/>
          <parameter name="version" type="" usage="required"/>
          <parameter name="xdomain" type="" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="" usage="required"/>
          <parameter name="url" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.cometd.callbackPollTransport._cometd" private="true">
    <properties>
      <property name="_polling" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.cometd.longPollTransportFormEncoded" type="Function" classlike="true">
    <properties>
      <property name="_connectionType" scope="instance" type="String"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="_poll" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="" usage="required"/>
          <parameter name="version" type="" usage="required"/>
          <parameter name="xdomain" type="" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_connect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="content" type="" usage="required"/>
          <parameter name="url" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.cometd.longPollTransportFormEncoded._cometd" private="true">
    <properties>
      <property name="_status" scope="instance" type="String"/>
      <property name="_polling" scope="instance" type="bool"/>
    </properties>
  </object>
  <object location="dojox.cometd.longPollTransportJsonEncoded" type="Function" classlike="true">
    <properties>
      <property name="_connectionType" scope="instance" type="String"/>
      <property name="_initialized" scope="instance" type="bool"/>
      <property name="_poll" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="check" scope="instance">
        <parameters>
          <parameter name="types" type="" usage="required"/>
          <parameter name="version" type="" usage="required"/>
          <parameter name="xdomain" type="" usage="required"/>
        </parameters>
      </method>
      <method name="tunnelInit" scope="instance"/>
      <method name="tunnelCollapse" scope="instance"/>
      <method name="_connect" scope="instance"/>
      <method name="deliver" scope="instance">
        <parameters>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="openTunnelWith" scope="instance">
        <parameters>
          <parameter name="messages" type="" usage="required"/>
          <parameter name="url" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessages" scope="instance">
        <parameters>
          <parameter name="messages" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="instance">
        <parameters>
          <parameter name="handshakeData" type="" usage="required"/>
        </parameters>
      </method>
      <method name="disconnect" scope="instance"/>
      <method name="cancelConnect" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.cometd.longPollTransportJsonEncoded._cometd" private="true">
    <properties>
      <property name="_status" scope="instance" type="String"/>
      <property name="_polling" scope="instance" type="bool"/>
    </properties>
  </object>
  <object location="dojox.cometd.timesync" type="Function" classlike="true">
    <properties>
      <property name="_window" scope="instance" type="Number"/>
      <property name="_lags" scope="instance" type="Array"/>
      <property name="_offsets" scope="instance" type="Array"/>
      <property name="lag" scope="instance" type="Object"/>
      <property name="offset" scope="instance" type="Object"/>
      <property name="samples" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getServerTime" scope="instance"/>
      <method name="getServerDate" scope="instance"/>
      <method name="setTimeout" scope="instance">
        <parameters>
          <parameter name="call" type="function" usage="required">
            <summary>the function to call when the timeout occurs
	atTimeOrTime:
	a long timestamp or a Date representing the server time at
	which the timeout should occur.</summary>
          </parameter>
          <parameter name="atTimeOrDate" type="long|Date" usage="required"/>
        </parameters>
      </method>
      <method name="_in" scope="instance">
        <description>Look for ext:{timesync:{}} field and calculate offset if present.</description>
        <parameters>
          <parameter name="msg" type="Object" usage="required">
            <summary>The incoming bayeux message</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_out" scope="instance">
        <description>Look for handshake and connect messages and add the ext:{timesync:{}} fields</description>
        <parameters>
          <parameter name="msg" type="The" usage="required">
            <summary>outgoing bayeux message</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data">
    <summary>Additional dojo.data data stores and demos</summary>
    <properties>
      <property name="ASYNC_MODE" scope="normal" type="Number"/>
      <property name="SYNC_MODE" scope="normal" type="Number"/>
    </properties>
    <methods>
      <method name="_getStoreForItem" scope="normal">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="restListener" scope="normal">
        <summary>this function can be used to receive REST notifications, from Comet or from another frame</summary>
        <description>Example:
		dojo.connect(window,"onMessage",null,function(event) {
			var data = dojo.fromJson(event.data);
			dojox.restListener(data);
		});</description>
        <parameters>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.AndOrReadStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>AndOrReadStore uses ItemFileReadStore as a base, modifying only the query (_fetchItems) section.
	Supports queries of the form: query:&amp;quot;id:1* OR dept:'Sales Department' || (id:2* &amp;amp;&amp;amp; NOT dept:S*)&amp;quot;
	Includes legacy/widget support via:
	query:{complexQuery:&amp;quot;id:1* OR dept:'Sales Department' || (id:2* &amp;amp;&amp;amp; NOT dept:S*)&amp;quot;}
	The ItemFileReadStore implements the dojo.data.api.Read API and reads
	data from JSON files that have contents in this format --
	{ items: [
	{ name:'Kermit', color:'green', age:12, friends:['Gonzo', {_reference:{name:'Fozzie Bear'}}]},
	{ name:'Fozzie Bear', wears:['hat', 'tie']},
	{ name:'Miss Piggy', pets:'Foo-Foo'}
	]}
	Note that it can also contain an 'identifer' property that specified which attribute on the items
	in the array of items that acts as the unique identifier for that item.
	use &amp;quot;&amp;quot; rather than undefined for the benefit of the parser (#3539)</summary>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="_ccUrl" scope="instance-prototype" type="String"/>
      <property name="data" scope="instance-prototype" type="Object"/>
      <property name="typeMap" scope="prototype" type="Object"/>
      <property name="clearOnClose" scope="instance-prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="hierarchical" scope="instance-prototype" type="Object"/>
      <property name="_jsonFileUrl" scope="instance-prototype" type=""/>
      <property name="_jsonData" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfTopLevelItems" scope="instance-prototype" type="Array"/>
      <property name="_itemsByIdentity" scope="instance-prototype" type="Object"/>
      <property name="_labelAttr" scope="prototype" type=""/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_storeRefPropName" scope="instance" type="String"/>
      <property name="_itemNumPropName" scope="instance" type="String"/>
      <property name="_rootItemPropName" scope="instance" type="String"/>
      <property name="_reverseRefMap" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>constructor</summary>
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="mixed"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <summary>Internal function for looking at the values contained by the item.</summary>
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The data item to examine for attribute values.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to inspect.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match.</summary>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <summary>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>See dojo.data.util.simpleFetch.fetch()
	filter modified to permit complex queries where
	logical operators are case insensitive:
	, NOT AND OR ( ) ! &amp;amp;&amp;amp; ||
	Note:  &amp;quot;,&amp;quot; included for quoted/string legacy queries.</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <summary>Internal function to execute delayed request in the store.
	Execute any deferred fetches now.</summary>
      </method>
      <method name="_getItemsArray" scope="prototype">
        <summary>Internal function to determine which list of items to search over.</summary>
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <summary>The query options parameter, if any.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getItemsFromLoadedData" scope="prototype">
        <summary>Function to parse the loaded data into item format and build the internal items array.</summary>
        <description>Function to parse the loaded data into item format and build the internal items array.</description>
        <return-description>array
	Array of items in store item format.</return-description>
        <parameters>
          <parameter name="dataObject" type="Object" usage="required">
            <summary>The JS data object containing the raw data to convery into item format.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addReferenceToMap" scope="prototype">
        <summary>Method to add an reference map entry for an item and attribute.</summary>
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <summary>The item that is referenced.</summary>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <summary>The item that holds the new reference to refItem.</summary>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <summary>The attribute on parentItem that contains the new reference.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
          <return-type type="Object"/>
          <return-type type=""/>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemByIdentity" scope="prototype">
        <summary>Internal function to look an item up by its identity map.</summary>
        <parameters>
          <parameter name="identity" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentifierAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_forceLoad" scope="prototype">
        <summary>Internal function to force a load of the store if it hasn't occurred yet.  This is required
	for specific functions to work properly.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.data.AndOrReadStore._features.dojo.data.api" type="">
    <properties>
      <property name="Identity" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.data.AndOrReadStore._datatypeMap" private="true">
    <properties>
      <property name="Date" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.data.AndOrWriteStore" type="Function" classlike="true" superclass="dojox.data.AndOrReadStore">
    <mixins>
      <mixin scope="instance" location="dojox.data.AndOrReadStore"/>
    </mixins>
    <properties>
      <property name="referenceIntegrity" scope="instance-prototype" type="bool"/>
      <property name="_saveInProgress" scope="instance-prototype" type="bool"/>
      <property name="_pending" scope="instance-prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <summary>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="keywordParameters" type="object" usage="required">
            <summary>typeMap: object)
	The structure of the typeMap object is as follows:
	{
	type0: function || object,
	type1: function || object,
	...
	typeN: function || object
	}
	Where if it is a function, it is assumed to be an object constructor that takes the
	value of _value as the initialization parameters.  It is serialized assuming object.toString()
	serialization.  If it is an object, then it is assumed
	to be an object of general form:
	{
	type: function, //constructor.
	deserialize:	function(value) //The function that parses the value and constructs the object defined by type appropriately.
	serialize:	function(object) //The function that converts the object back into the proper file format form.
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assert" scope="prototype">
        <parameters>
          <parameter name="condition" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getIdentifierAttribute" scope="prototype"/>
      <method name="newItem" scope="prototype">
        <summary>See dojo.data.api.Write.newItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
          <parameter name="parentInfo" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="item"/>
        </return-types>
      </method>
      <method name="_removeArrayElement" scope="prototype">
        <parameters>
          <parameter name="array" type="Array" usage="required"/>
          <parameter name="element" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="prototype">
        <summary>See dojo.data.api.Write.deleteItem()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>See dojo.data.api.Write.set()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <summary>anything</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="prototype">
        <summary>See dojo.data.api.Write.setValues()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <summary>See dojo.data.api.Write.unsetAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueOrValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="newValueOrValues" type="anything" usage="required"/>
          <parameter name="callOnSet" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_addReferenceToMap" scope="prototype">
        <summary>Method to add an reference map entry for an item and attribute.</summary>
        <description>Method to add an reference map entry for an item and attribute. 		 //</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <summary>The item that is referenced.</summary>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <summary>The item that holds the new reference to refItem.</summary>
          </parameter>
          <parameter name="attribute" type="string" usage="required">
            <summary>The attribute on parentItem that contains the new reference.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_removeReferenceFromMap" scope="prototype">
        <summary>Method to remove an reference map entry for an item and attribute.</summary>
        <description>Method to remove an reference map entry for an item and attribute.  This will
	also perform cleanup on the map such that if there are no more references at all to
	the item, its reference object and entry are removed.</description>
        <parameters>
          <parameter name="refItem" type="item" usage="required">
            <summary>The item that is referenced.</summary>
          </parameter>
          <parameter name="parentItem" type="item" usage="required">
            <summary>The item holding a reference to refItem.</summary>
          </parameter>
          <parameter name="attribute" type="strin" usage="required">
            <summary>The attribute on parentItem that contains the reference.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_dumpReferenceMap" scope="prototype">
        <summary>Function to dump the reverse reference map of all items in the store for debug purposes.</summary>
        <description>Function to dump the reverse reference map of all items in the store for debug purposes.</description>
      </method>
      <method name="_getValueOrValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="_flatten" scope="prototype">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewFileContentString" scope="prototype">
        <summary>Generate a string that can be saved to a file.
	The result should look similar to:
	http://trac.dojotoolkit.org/browser/dojo/trunk/tests/data/countries.json</summary>
      </method>
      <method name="_isEmpty" scope="prototype">
        <summary>Function to determine if an array or object has no properties or values.</summary>
        <parameters>
          <parameter name="something" type="The" usage="required">
            <summary>array or object to examine.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <summary>See dojo.data.api.Write.save()</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="prototype">
        <summary>See dojo.data.api.Write.revert()</summary>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="prototype">
        <summary>See dojo.data.api.Write.isDirty()</summary>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onSet" scope="prototype">
        <summary>See dojo.data.api.Notification.onSet()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <summary>| array</summary>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <summary>| array</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onNew" scope="prototype">
        <summary>See dojo.data.api.Notification.onNew()</summary>
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="onDelete" scope="prototype">
        <summary>See dojo.data.api.Notification.onDelete()</summary>
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>Over-ride of base close function of ItemFileReadStore to add in check for store state.</summary>
        <description>Over-ride of base close function of ItemFileReadStore to add in check for store state.
	If the store is still dirty (unsaved changes), then an error will be thrown instead of
	clearing the internal state for reload from the url.</description>
        <parameters>
          <parameter name="request" type="object" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.AndOrWriteStore._features.dojo.data.api" type="">
    <properties>
      <property name="Write" scope="instance" type="Object"/>
      <property name="Notification" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.data.AndOrWriteStore._datatypeMap.Date" type="">
    <methods>
      <method name="serialize" scope="instance">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.AppStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>The APP data store.</summary>
    <description>The APP Store is instantiated either in markup or programmatically by supplying a
	url of the Collection to be used.</description>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <summary>string So the parser can instantiate the store via markup.</summary>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="Whether">
        <summary>boolean Whether or not to pass the preventCache parameter to the connection</summary>
      </property>
      <property name="xmethod" scope="prototype" type="boolean">
        <summary>Whether to use X-Method-Override for PUT/DELETE.</summary>
      </property>
      <property name="_atomIO" scope="prototype" type="Object"/>
      <property name="_feed" scope="prototype" type="Object"/>
      <property name="_requests" scope="prototype" type="Array"/>
      <property name="_processing" scope="prototype" type="Object"/>
      <property name="_updates" scope="prototype" type="Object"/>
      <property name="_adds" scope="prototype" type="Object"/>
      <property name="_deletes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>An anonymous object to initialize properties.  It expects the following values:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>The APP data store.</summary>
        <description>The APP Store is instantiated either in markup or programmatically by supplying a
	url of the Collection to be used.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>An anonymous object to initialize properties.  It expects the following values:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setFeed" scope="prototype">
        <summary>Sets the internal feed using a dojox.atom.io.model.Feed object.</summary>
        <description>Sets the internal feed using a dojox.atom.io.model.Feed object.  Also adds
	a property to the entries to track that they belong to this store. It
	also parses stored requests (since we were waiting on a callback) and
	executes those as well.</description>
        <parameters>
          <parameter name="feed" type="dojox.atom.io.model.Feed" usage="required">
            <summary>object
	The Feed to use for this data store.</summary>
          </parameter>
          <parameter name="data" type="unused" usage="required">
            <summary>Signature for this function is defined by AtomIO.getFeed, since this is a callback.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getAllItems" scope="prototype">
        <summary>Function to return all entries in the Feed as an array of items.</summary>
        <description>Function to return all entries in the Feed as an array of items.</description>
        <return-description>Array of all entries in the feed.</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item is an item.</summary>
        <description>This function tests whether the item passed in is indeed an item
	in the store.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item is an attribute.</summary>
        <description>This function tests whether the item passed in is indeed a valid
	'attribute' like type for the store.</description>
        <return-description>Returns a boolean indicating whether this is a valid attribute.</return-description>
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addUpdate" scope="prototype">
        <summary>Internal function to add an updated entry to our updates array</summary>
        <description>Internal function to add an updated entry to our updates array</description>
        <parameters>
          <parameter name="update" type="Object" usage="required">
            <summary>dojox.atom.io.model.Entry object
	The updated Entry we've changed.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type=""/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <summary>Internal function for looking at the values contained by the item.</summary>
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The data item to examine for attribute values.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to inspect.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match.</summary>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <summary>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</summary>
          </parameter>
          <parameter name="trim" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>Fetch items (Atom entries) that match to a query</summary>
        <description>Fetch items (Atom entries) that match to a query</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <summary>function to call for fetched items</summary>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <summary>function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_finishFetchItems" scope="prototype">
        <summary>Internal function for finishing a fetch request.</summary>
        <description>Internal function for finishing a fetch request.  Needed since the feed
	might not have been loaded, so we finish the fetch in a callback.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <summary>function to call for fetched items</summary>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <summary>function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()
	nothing to do here!</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentityAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <summary>See dojo.data.api.Write.newItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="prototype">
        <summary>See dojo.data.api.Write.deleteItem()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>See dojo.data.api.Write.setValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <summary>anything</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setValues" scope="prototype">
        <summary>See dojo.data.api.Write.setValues()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <summary>See dojo.data.api.Write.unsetAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <summary>See dojo.data.api.Write.save()</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <summary>{ onComplete: function
	onError: function
	scope: object
	}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="revert" scope="prototype">
        <summary>See dojo.data.api.Write.revert()</summary>
      </method>
      <method name="isDirty" scope="prototype">
        <summary>See dojo.data.api.Write.isDirty()</summary>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.data.AtomReadStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>A read only data store for Atom XML based services or documents</summary>
    <description>A data store for Atom XML based services or documents.	This store is still under development
	and doesn't support wildcard filtering yet.	Attribute filtering is limited to category or id.</description>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <summary>url to a service or an XML document that represents the store</summary>
      </property>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="sendQuery" scope="instance-prototype" type="A">
        <summary>boolean indicate to add a query string to the service URL</summary>
      </property>
      <property name="unescapeHTML" scope="instance-prototype" type="A">
        <summary>boolean to specify whether or not to unescape HTML text</summary>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="_feedMetaData" scope="prototype" type="Object"/>
      <property name="_items" scope="prototype" type=""/>
      <property name="rewriteUrl" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <summary>An anonymous object to initialize properties.	It expects the following values:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Constructor for the AtomRead store.</summary>
        <parameters>
          <parameter name="args" type="object" usage="required">
            <summary>An anonymous object to initialize properties.	It expects the following values:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>Return an attribute value</summary>
        <description>'item' must be an instance of an object created by the AtomReadStore instance.
	Accepted attributes are id, subtitle, title, summary, content, author, updated,
	published, category, link and alternate</description>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An item returned by a call to the 'fetch' method.</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A attribute of the Atom Entry</summary>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <summary>A default value</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>Return an attribute value</summary>
        <description>'item' must be an instance of an object created by the AtomReadStore instance.
	Accepted attributes are id, subtitle, title, summary, content, author, updated,
	published, category, link and alternate</description>
        <return-description>An array of values for the attribute value found, otherwise 'defaultValue'</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An item returned by a call to the 'fetch' method.</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A attribute of the Atom Entry</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>Return an array of attribute names</summary>
        <description>'item' must be have been created by the AtomReadStore instance.
	tag names of child elements and XML attribute names of attributes
	specified to the element are returned along with special attribute
	names applicable to the element including "tagName", "childNodes"
	if the element has child elements, "text()" if the element has
	child text nodes, and attribute names in '_attributeMap' that match
	the tag name of the element.</description>
        <return-description>An array of attributes found</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An XML element</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>Check whether an element has the attribute</summary>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>'item' must be created by the AtomReadStore instance.</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>An attribute of an Atom Entry item.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>Check whether the attribute values contain the value</summary>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>'item' must be an instance of a dojox.data.XmlItem from the store instance.</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A tag name of a child element, An XML attribute name or one of
	special names</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>Check whether the object is an item (XML element)
	item:
	An object to check</summary>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>Check whether the object is an item (XML element) and loaded
	item:
	An object to check</summary>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>Load an item (XML element)</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <summary>containing the args for loadItem.	See dojo.data.api.Read.loadItem()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>Return supported data APIs</summary>
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getFeedValue" scope="prototype">
        <summary>Non-API method for retrieving values regarding the Atom feed,
	rather than the Atom entries.</summary>
        <parameters>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFeedValues" scope="prototype">
        <summary>Non-API method for retrieving values regarding the Atom feed,
	rather than the Atom entries.</summary>
        <parameters>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_initItem" scope="prototype">
        <summary>Initializes an item before it can be parsed.</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>Retrieves the items from the Atom XML document.</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
          <parameter name="fetchHandler" type="" usage="required"/>
          <parameter name="errorHandler" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getFetchUrl" scope="prototype">
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="prototype">
        <summary>Parses the document in a first pass</summary>
        <parameters>
          <parameter name="document" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getItem" scope="prototype">
        <parameters>
          <parameter name="element" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_parseItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHTML" scope="prototype">
        <parameters>
          <parameter name="text" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.CdfStore" type="Function" classlike="true">
    <summary>IMPORTANT: The CDF Store is designed to work with Tibco GI, and references Tibco's
	JSX3 JavaScript library and will not work without it.
	The CDF Store implements dojo.data.Read, Write, and Identity api's.  It is a local
	(in memory) store that handles XML documents formatted according to the
	Common Data Format (CDF) spec:
	http://www.tibco.com/devnet/resources/gi/3_1/tips_and_techniques/CommonDataFormatCDF.pdf
	The purpose of this store is to provide a glue between a jsx3 CDF file and a Dijit.
	While a CDF document is an XML file, other than the initial input, all data returned
	from and written to this store should be in object format.</summary>
    <examples>
      <example>	'&lt;data jsxid="jsxroot"&gt;&lt;record jsxtext="A"/&gt;&lt;record jsxtext="B" jsxid="2" jsxid="2"/&gt;&lt;/data&gt;'</example>
    </examples>
    <properties>
      <property name="identity" scope="instance-prototype" type="String">
        <summary>The unique identifier for each item. Defaults to &amp;quot;jsxid&amp;quot; which is standard for a CDF
	document. Should not be changed.
	url : String
	The location from which to fetch the XML (CDF) document.</summary>
      </property>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="xmlStr" scope="instance-prototype" type="String">
        <summary>A string that can be parsed into an XML document and should be formatted according
	to the CDF spec.</summary>
      </property>
      <property name="data" scope="prototype" type="Object">
        <summary>A object that will be converted into the xmlStr property, and then parsed into a CDF.</summary>
      </property>
      <property name="label" scope="instance-prototype" type="String">
        <summary>The property within each item used to define the item.
	mode [const]: dojox.data.ASYNC_MODE | dojox.data.SYNC_MODE
	This store supports syncronous fetches if this property is set to dojox.data.SYNC_MODE.</summary>
      </property>
      <property name="mode" scope="instance-prototype" type=""/>
      <property name="cdfDoc" scope="prototype" type="Object"/>
      <property name="_modifiedItems" scope="instance-prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Constructor for the CDF store. Instantiate a new CdfStore.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>Return an property value of an item</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>Return an array of values
	TODO!!! Can't find an example of an array in any CDF files</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>Return an array of property names</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>Check whether an item has a property</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasProperty" scope="prototype">
        <summary>Alias for hasAttribute</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>Check whether an item contains a value</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>Check whether the object is an item (jsx3.xml.Entity)</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>Check whether the object is a jsx3.xml.Entity object and loaded</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>Load an item</summary>
        <description>The store always loads all items, so if it's an item, then it's loaded.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>Return supported data APIs</summary>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>returns an array of what properties of the item that were used
	to generate its label
	See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetch" scope="prototype">
        <summary>Returns an Array of items based on the request arguments.</summary>
        <description>Returns an Array of items based on the request arguments.
	If the store is in ASYNC mode, the items should be expected in an onComplete
	method passed in the request object. If store is in SYNC mode, the items will
	be return directly as well as within the onComplete method.
	note:
	The mode can be set on store initialization or during a fetch as one of the
	parameters.
	query: String
	The items in the store are treated as objects, but this is reading an XML
	document. Further, the actual querying of the items takes place in Tibco GI's
	jsx3.xml.Entity. Therefore, we are using their syntax which is xpath.
	Note:
	As conforming to a CDF document, most, if not all nodes are considered "records"
	and their tagNames are as such. The root node is named "data".
	examples:
	All items:
		store.fetch({query:"*"});
	Item with a jsxid attribute equal to "1" (note you could use byId for this)
		store.fetch({query:"//record[@jsxid='1']"});
	All items with any jsxid attribute:
		"//record[@jsxid='*']"
	The items with a jsxid of '1' or '4':
		"//record[@jsxid='4' or @jsxid='1']"
	All children within a "group" node (could be multiple group nodes):
	"//group/record"
	All children within a specific group node:
	"//group[@name='mySecondGroup']/record"
	Any record, anywhere in the document:
		"//record"
	Only the records beneath the root (data) node:
		"//data/record"
	See:
	http://www.tibco.com/devnet/resources/gi/3_7/api/html/jsx3/xml/Entity.html#method:selectNodes
	http://www.w3.org/TR/xpath
	http://msdn.microsoft.com/en-us/library/ms256086.aspx
	See dojo.data.Read.fetch():
	onBegin
	onComplete
	onItem
	onError
	scope
	start
	count
	sort</description>
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_loadCDF" scope="prototype">
        <summary>Internal method.
	If a cdfDoc exists, return it. Otherwise, get one from JSX3,
	load the data or url, and return the doc or a deferred.</summary>
        <return-types>
          <return-type type="jsx3.xml.CDF"/>
          <return-type type="dojo.Deferred"/>
          <return-type type="Error"/>
        </return-types>
      </method>
      <method name="_getItems" scope="prototype">
        <summary>Internal method.
	Requests the items from jsx3.xml.Entity with an xpath query.</summary>
        <parameters>
          <parameter name="cdfDoc" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <summary>Creates a jsx3.xml.Entity item and inserts it either inside the
	parent or appends it to the root</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="optional"/>
          <parameter name="parentInfo" type="object" usage="optional">
            <summary>|| String?</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="jsx3.xml.Entity"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="prototype">
        <summary>Delete an jsx3.xml.Entity (wrapper to a XML element).</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="prototype">
        <summary>Set an property value</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="value" type="almost" usage="required">
            <summary>anything</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="prototype">
        <summary>Set property values
	TODO: Needs to be fully implemented.</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <summary>Remove an property</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="revert" scope="prototype">
        <summary>Invalidate changes (new and/or modified elements)
	Resets data by simply deleting the reference to the cdfDoc.
	Subsequent fetches will load the new data.
	Note:
	Any items outside the store will no longer be valid and may cause errors.</summary>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="prototype">
        <summary>Check whether an item is new, modified or deleted.
	If no item is passed, checks if anything in the store has changed.</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required">
            <summary>?</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_makeDirty" scope="prototype">
        <summary>Internal method.
	Marks items as modified, deleted or new.</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_makeXmlString" scope="prototype">
        <summary>Internal method.
	Converts an object into an XML string.</summary>
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>Returns the identifier for an item.</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>Returns the property used for the identity.</summary>
        <parameters>
          <parameter name="item" type="jsx3.xml.Entity" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity(keywordArgs)
	Note:
	This method can be synchronous if mode is set.
	Also, there is a more finger friendly alias of this method, byId();</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>|| String</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
          <return-type type=""/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="byId" scope="instance-prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>|| String</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.ClientFilter" type="Function" classlike="true">
    <summary>This is an abstract class that data stores can extend to add updateable result set functionality
	as well as client side querying capabilities. This enables
	widgets to be aware of how active results change in response to the modifications/notifications.</summary>
    <description>To a update a result set after a notification (onNew, onSet, and onDelete),
	widgets can call the updateResultSet method. Widgets can use the updated
	result sets to determine how to react to notifications, and how to update their displayed results
	based on changes.
	This module will use the best available information to update result sets, using query attribute
	objects to determine if items are in a result set, and using the sort arrays to maintain sort
	information. However, queries can be opaque strings, and this module can not update
	results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
	and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
	isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
	definition of isUpdateable and matchesQuery
	isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
	matchesQuery(item,request) - item is the item to test, and request is the value arguments object
	for the fetch function.
	You can define a property on this object instance "cacheByDefault" to a value of true that will
	cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
	This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.</description>
    <examples>
      <example>to make a updated-result-set data store from an existing data store:
		dojo.declare("dojox.data.MyLiveDataStore",
			dojox.data.MyDataStore,dojox.data.ClientFilter], // subclass LiveResultSets if available
			{}
		);</example>
    </examples>
    <properties>
      <property name="cacheByDefault" scope="prototype" type="bool"/>
      <property name="_fetchCache" scope="instance-prototype" type="Array"/>
      <property name="serverVersion" scope="prototype" type="Number"/>
      <property name="onSet" scope="instance" type="Object"/>
      <property name="onNew" scope="instance" type="Object"/>
      <property name="onDelete" scope="instance" type="Object"/>
      <property name="_updates" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>This is an abstract class that data stores can extend to add updateable result set functionality
	as well as client side querying capabilities. This enables
	widgets to be aware of how active results change in response to the modifications/notifications.</summary>
        <description>To a update a result set after a notification (onNew, onSet, and onDelete),
	widgets can call the updateResultSet method. Widgets can use the updated
	result sets to determine how to react to notifications, and how to update their displayed results
	based on changes.
	This module will use the best available information to update result sets, using query attribute
	objects to determine if items are in a result set, and using the sort arrays to maintain sort
	information. However, queries can be opaque strings, and this module can not update
	results by itself in this case. In this situations, data stores can provide a isUpdateable(request) function
	and matchesQuery(item,request) function. If a data store can handle a query, it can return true from
	isUpdateable and if an item matches a query, it can return true from matchesQuery. Here is
	definition of isUpdateable and matchesQuery
	isUpdateable(request)  - request is the keywords arguments as is passed to the fetch function.
	matchesQuery(item,request) - item is the item to test, and request is the value arguments object
	for the fetch function.
	You can define a property on this object instance "cacheByDefault" to a value of true that will
	cause all queries to be cached by default unless the cache queryOption is explicitly set to false.
	This can be defined in the constructor options for ServiceStore/JsonRestStore and subtypes.</description>
        <examples>
          <example>to make a updated-result-set data store from an existing data store:
		dojo.declare("dojox.data.MyLiveDataStore",
			dojox.data.MyDataStore,dojox.data.ClientFilter], // subclass LiveResultSets if available
			{}
		);</example>
        </examples>
      </method>
      <method name="clearCache" scope="prototype">
        <summary>Clears the cache of client side queries</summary>
      </method>
      <method name="updateResultSet" scope="prototype">
        <summary>Attempts to update the given result set based on previous notifications</summary>
        <description>This will attempt to update the provide result based on previous notification, adding new items
	from onNew calls, removing deleted items, and updating modified items, and properly removing
	and adding items as required by the query and sort parameters. This function will return:
	0: Indicates it could not successfully update the result set
	1: Indicates it could successfully handle all the notifications, but no changes were made to the result set
	2: Indicates it successfully handled all the notifications and result set has been updated.</description>
        <parameters>
          <parameter name="resultSet" type="Array" usage="required">
            <summary>The result set array that should be updated</summary>
          </parameter>
          <parameter name="request" type="Object" usage="required">
            <summary>This object follows the same meaning as the keywordArgs passed to a dojo.data.api.Read.fetch.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="querySuperSet" scope="prototype">
        <summary>Determines whether the provided arguments are super/sub sets of each other</summary>
        <parameters>
          <parameter name="argsSuper" type="Dojo" usage="required">
            <summary>Data Fetch arguments</summary>
          </parameter>
          <parameter name="argsSub" type="Dojo" usage="required">
            <summary>Data Fetch arguments</summary>
          </parameter>
        </parameters>
      </method>
      <method name="cachingFetch" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isUpdateable" scope="prototype">
        <summary>Returns whether the provide fetch arguments can be used to update an existing list</summary>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <summary>See dojo.data.api.Read.fetch request</summary>
          </parameter>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="prototype">
        <summary>Performs a query on the client side and returns the results as an array</summary>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <summary>See dojo.data.api.Read.fetch request</summary>
          </parameter>
          <parameter name="baseResults" type="Array" usage="required">
            <summary>This provides the result set to start with for client side querying</summary>
          </parameter>
        </parameters>
      </method>
      <method name="clientSidePaging" scope="prototype">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="matchesQuery" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="makeComparator" scope="prototype">
        <summary>returns a comparator function for the given sort order array</summary>
        <parameters>
          <parameter name="sort" type="See" usage="required">
            <summary>dojox.data.api.Read.fetch</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="keep the order unchanged"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.data.CouchDBRestStore" type="Function" classlike="true" superclass="dojox.data.JsonRestStore">
    <mixins>
      <mixin scope="instance" location="dojox.data.JsonRestStore"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="save" scope="prototype">
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <summary>This only differs from JsonRestStore in that it, will put the query string the query part of the URL and it handles start and count</summary>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getStores" scope="normal">
        <parameters>
          <parameter name="couchServerUrl" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.CouchDBRestStore.service" type="">
    <properties>
      <property name="servicePath" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.data.CssClassStore" type="Function" classlike="true" superclass="dojox.data.CssRuleStore">
    <summary>Basic store to display CSS information.</summary>
    <description>The CssClassStore allows users to get information about active Css classes in the page running the CssClassStore.
	It can also filter out classes from specific stylesheets.  The attributes it exposes on classes are as follows:
	class:		The classname, including the '.'.
	classSans:	The classname without the '.'.</description>
    <mixins>
      <mixin scope="instance" location="dojox.data.CssRuleStore"/>
    </mixins>
    <properties>
      <property name="_labelAttribute" scope="prototype" type="String"/>
      <property name="_idAttribute" scope="prototype" type="String"/>
      <property name="_cName" scope="prototype" type="String"/>
      <property name="_pending" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_handleRule" scope="prototype">
        <summary>Handles the creation of an item based on the passed rule.  In this store, this implies
	parsing out all available class names.</summary>
        <parameters>
          <parameter name="rule" type="" usage="required"/>
          <parameter name="styleSheet" type="" usage="required"/>
          <parameter name="href" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="prototype">
        <summary>Handles the return from a fetching action.  Delegates requests to act on the resulting
	item set to eitehr the _handleFetchReturn or _handleFetchByIdentityReturn depending on
	where the request originated.</summary>
      </method>
      <method name="_handleFetchByIdentityReturn" scope="prototype">
        <summary>Handles a fetchByIdentity request by finding the correct item.</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentityAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="request" type="request" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.CssRuleStore" type="Function" classlike="true">
    <summary>Basic store to display CSS information.</summary>
    <description>The CssRuleStore allows users to get information about active CSS rules in the page running the CssRuleStore.
	It can also filter out rules from specific stylesheets.  The attributes it exposes on rules are as follows:
	selector:				The selector text.
	classes:				An array of classes present in this selector.
	rule:					The actual DOM Rule object.
	style:					The actual DOM CSSStyleDeclaration object.
	cssText:				The cssText string provided on the rule object.
	styleSheet:				The originating DOM Stylesheet object.
	parentStyleSheet: 		The parent stylesheet to the sheet this rule originates from.
	parentStyleSheetHref: 	The href of the parent stylesheet.
	AND every style attribute denoted as style.*, such as style.textAlign or style.backgroundColor</description>
    <properties>
      <property name="_storeRef" scope="prototype" type="String"/>
      <property name="_labelAttribute" scope="prototype" type="String"/>
      <property name="_cache" scope="instance-prototype" type="Object"/>
      <property name="_browserMap" scope="prototype" type="Object"/>
      <property name="_cName" scope="prototype" type="String"/>
      <property name="context" scope="prototype" type="Object"/>
      <property name="_pending" scope="prototype" type="Array"/>
      <property name="_allItems" scope="instance-prototype" type="Object"/>
      <property name="_waiting" scope="instance" type="Array"/>
      <property name="gatherHandle" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setContext" scope="prototype">
        <parameters>
          <parameter name="context" type="Array" usage="required">
            <summary>- Array of CSS string paths to execute queries within</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <summary>See dojo.data.api.Read.fetch()</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="prototype">
        <summary>Populates the _allItems object with unique class names</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_handleRule" scope="prototype">
        <summary>Handles the creation of an item based on the passed rule.  In this store, this implies
	parsing out all available class names.</summary>
        <parameters>
          <parameter name="rule" type="" usage="required"/>
          <parameter name="styleSheet" type="" usage="required"/>
          <parameter name="href" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_handleReturn" scope="prototype">
        <summary>Handles the return from a fetching action.  Delegates requests to act on the resulting
	item set to eitehr the _handleFetchReturn or _handleFetchByIdentityReturn depending on
	where the request originated.</summary>
      </method>
      <method name="_handleFetchReturn" scope="prototype">
        <summary>Handles a fetchByIdentity request by finding the correct items.</summary>
        <parameters>
          <parameter name="request" type="Request" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()
	Clears out the cache and allItems objects, meaning all future fetches will requery
	the stylesheets.</summary>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_containsValue" scope="prototype">
        <summary>Internal function for looking at the values contained by the item.</summary>
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The data item to examine for attribute values.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to inspect.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match.</summary>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <summary>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.data.CsvStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>The CsvStore implements the dojo.data.api.Read API and reads
	data from files in CSV (Comma Separated Values) format.
	All values are simple string values. References to other items
	are not supported as attribute values in this datastore.
	Example data file:
	name, color, age, tagline
	Kermit, green, 12, &amp;quot;Hi, I'm Kermit the Frog.&amp;quot;
	Fozzie Bear, orange, 10, &amp;quot;Wakka Wakka Wakka!&amp;quot;
	Miss Piggy, pink, 11, &amp;quot;Kermie!&amp;quot;
	Note that values containing a comma must be enclosed with quotes (&amp;quot;&amp;quot;)
	Also note that values containing quotes must be escaped with two consecutive quotes (&amp;quot;&amp;quot;quoted&amp;quot;&amp;quot;)
	examples:
	var csvStore = new dojox.data.CsvStore({url:&amp;quot;movies.csv&amp;quot;);
	var csvStore = new dojox.data.CsvStore({url:&amp;quot;http://example.com/movies.csv&amp;quot;);</summary>
    <properties>
      <property name="url" scope="instance-prototype" type="string">
        <summary>Declarative hook for setting Csv source url.</summary>
      </property>
      <property name="label" scope="instance-prototype" type="string">
        <summary>Declarative hook for setting the label attribute.</summary>
      </property>
      <property name="identifier" scope="instance-prototype" type="string">
        <summary>Declarative hook for setting the identifier.</summary>
      </property>
      <property name="separator" scope="instance-prototype" type="string">
        <summary>Parameter to allow specifying if preventCache should be passed to
	the xhrGet call or not when loading data from a url.
	Note this does not mean the store calls the server on each fetch,
	only that the data load has preventCache set as an option.</summary>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="bool"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_csvData" scope="instance-prototype" type="Object"/>
      <property name="_getArrayOfArraysFromCsvFileContents" scope="normal" type=""/>
      <property name="_attributes" scope="instance-prototype" type="Array"/>
      <property name="_dataArray" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance-prototype" type="Array"/>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_attributeIndexes" scope="instance" type="Object"/>
      <property name="_storeProp" scope="instance" type="String"/>
      <property name="_idProp" scope="instance" type="String"/>
      <property name="_features" scope="instance" type="Object"/>
      <property name="_idMap" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>identifier: String} The column label for the column to use for the identity.  Optional.  If not set, the identity is the row number.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>initializer</summary>
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>identifier: String} The column label for the column to use for the identity.  Optional.  If not set, the identity is the row number.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getIndex" scope="prototype">
        <summary>Internal function to get the internal index to the item data from the item handle</summary>
        <parameters>
          <parameter name="item" type="The" usage="required">
            <summary>idem handle to get the index for.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()
	Note that for the CsvStore, an empty string value is the same as no value,
	so the defaultValue would be returned instead of an empty string.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>|| attribute-name-string</summary>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()
	CSV syntax does not support multi-valued attributes, so this is just a
	wrapper function for getValue().</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>|| attribute-name-string</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()
	The hasAttribute test is true if attribute has an index number within the item's array length
	AND if the item has a value for that attribute. Note that for the CsvStore, an
	empty string value is the same as no value.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>|| attribute-name-string</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <summary>Internal function for looking at the values contained by the item.</summary>
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The data item to examine for attribute values.</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>The attribute to inspect.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match.</summary>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <summary>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()
	The CsvStore always loads all items, so if it's an item, then it's loaded.</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <description>The CsvStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>See dojo.data.util.simpleFetch.fetch()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_splitLines" scope="prototype">
        <summary>Function to split the CSV file contents into separate lines.
	Since line breaks can occur inside quotes, a Regexp didn't
	work as well.  A quick passover parse should be just as efficient.</summary>
        <parameters>
          <parameter name="csvContent" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processData" scope="prototype">
        <summary>Function for processing the string data from the server.</summary>
        <parameters>
          <parameter name="data" type="String" usage="required">
            <summary>The CSV data.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_createItemFromIdentity" scope="prototype">
        <summary>Function for creating a new item from its identifier.</summary>
        <parameters>
          <parameter name="identity" type="String" usage="required">
            <summary>The identity</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentifierAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <summary>Internal function to execute delayed request in the store.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.data.FileStore" type="Function" classlike="true">
    <summary>A simple store that provides a datastore interface to a filesystem.</summary>
    <description>A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
	for initialization:</description>
    <examples>
      <example>options="expand,dirsOnly,showHiddenFiles"</example>
    </examples>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <summary>string The URL to the file path service.</summary>
      </property>
      <property name="_storeRef" scope="prototype" type="string">
        <summary>Internal variable used to denote an item came from this store instance.</summary>
      </property>
      <property name="label" scope="instance-prototype" type="The">
        <summary>string Default attribute to use to represent the item as a user-readable
	string.  Public, so users can change it.</summary>
      </property>
      <property name="_identifier" scope="prototype" type="string">
        <summary>Default attribute to use to represent the item's identifier.
	Path should always be unique in the store instance.</summary>
      </property>
      <property name="_attributes" scope="prototype" type="string">
        <summary>Internal variable of attributes all file items should have.</summary>
      </property>
      <property name="pathSeparator" scope="prototype" type="string">
        <summary>The path separator to use when chaining requests for children
	Can be overriden by the server on initial load</summary>
      </property>
      <property name="options" scope="instance-prototype" type="array">
        <summary>Array of options to always send when doing requests.
	Back end service controls this, like 'dirsOnly', 'showHiddenFiles', 'expandChildren', etc.</summary>
      </property>
      <property name="failOk" scope="prototype" type="boolean">
        <summary>Flag to pass on to xhr functions to check if we are OK to fail the call silently</summary>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="string">
        <summary>Flag to dennote if preventCache should be passed to xhrGet.
	Function to switch between REST style URL lookups and passing the path to specific items as a query param: 'path'.</summary>
      </property>
      <property name="pathAsQueryParam" scope="instance-prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>A simple store that provides a datastore interface to a filesystem.</summary>
        <description>A simple store that provides a datastore interface to a filesystem.  It takes a few parameters
	for initialization:</description>
        <examples>
          <example>options="expand,dirsOnly,showHiddenFiles"</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <summary>Fetch  items that match to a query</summary>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processResult" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemArray" scope="prototype">
        <summary>Internal function for processing an array of items for return.</summary>
        <parameters>
          <parameter name="itemArray" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="prototype">
        <summary>Internal function for processing an item returned from the store.
	It sets up the store ref as well as sets up the attributes necessary
	to invoke a lazy load on a child, if there are any.</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.FlickrRestStore" type="Function" classlike="true" superclass="dojox.data.FlickrStore">
    <summary>Initializer for the FlickrRestStore store.</summary>
    <description>The FlickrRestStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
    <mixins>
      <mixin scope="instance" location="dojox.data.FlickrStore"/>
    </mixins>
    <properties>
      <property name="_id" scope="instance-prototype" type="Integer">
        <summary>A unique identifier for this store.</summary>
      </property>
      <property name="_requestCount" scope="prototype" type="Integer">
        <summary>A counter for the number of requests made. This is used to define
	the callback function that Flickr will use.</summary>
      </property>
      <property name="_flickrRestUrl" scope="prototype" type="String">
        <summary>The URL to the Flickr REST services.</summary>
      </property>
      <property name="_apikey" scope="instance-prototype" type="String">
        <summary>The users API key to be used when accessing Flickr REST services.</summary>
      </property>
      <property name="_storeRef" scope="prototype" type="String">
        <summary>A key used to mark an data store item as belonging to this store.</summary>
      </property>
      <property name="_cache" scope="instance-prototype" type="Array">
        <summary>An Array of all previously downloaded picture info.</summary>
      </property>
      <property name="_prevRequests" scope="instance-prototype" type="Object">
        <summary>A HashMap used to record the signature of a request to prevent duplicate
	request being made.</summary>
      </property>
      <property name="_handlers" scope="instance-prototype" type="Object">
        <summary>A HashMap used to record the handlers registered for a single remote request.  Multiple
	requests may be made for the same information before the first request has finished.
	Each element of this Object is an array of handlers to call back when the request finishes.
	This prevents multiple requests being made for the same information.</summary>
      </property>
      <property name="label" scope="instance" type=""/>
      <property name="_prevRequestRanges" scope="instance" type="Array"/>
      <property name="_maxPhotosPerUser" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initializer for the FlickrRestStore store.</summary>
        <description>The FlickrRestStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>Fetch flickr items that match to a query</summary>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <summary>A request object</summary>
          </parameter>
          <parameter name="fetchHandler" type="Function" usage="required">
            <summary>A function to call for fetched items</summary>
          </parameter>
          <parameter name="errorHandler" type="Function" usage="required">
            <summary>A function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_processFlickrData" scope="prototype">
        <summary>Processes the raw data from Flickr and updates the internal cache.</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <summary>Data returned from Flickr</summary>
          </parameter>
          <parameter name="request" type="Object" usage="required">
            <summary>The original dojo.data.Request object passed in by the user.</summary>
          </parameter>
          <parameter name="cacheKey" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_checkPrevRanges" scope="prototype">
        <parameters>
          <parameter name="primaryKey" type="" usage="required"/>
          <parameter name="start" type="" usage="required"/>
          <parameter name="count" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.FlickrRestStore._sortAttributes" private="true">
    <summary>A quick lookup of valid attribute names in a sort query.</summary>
    <properties>
      <property name="date-posted" scope="normal" type="Object"/>
      <property name="date-taken" scope="normal" type="Object"/>
      <property name="interestingness" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.data.FlickrStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>Initializer for the FlickrStore store.</summary>
    <description>The FlickrStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
    <properties>
      <property name="_storeRef" scope="prototype" type="String"/>
      <property name="label" scope="instance-prototype" type="String"/>
      <property name="urlPreventCache" scope="instance-prototype" type="Object"/>
      <property name="urlRegistry" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initializer for the FlickrStore store.</summary>
        <description>The FlickrStore is a Datastore interface to one of the basic services
	of the Flickr service, the public photo feed.  This does not provide
	access to all the services of Flickr.
	This store cannot do * and ? filtering as the flickr service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>Fetch flickr items that match to a query</summary>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <summary>function to call for fetched items</summary>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <summary>function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_processFlickrData" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="prototype">
        <summary>Utility function to un-escape XML special characters in an
	HTML string.</summary>
        <return-description>HTML String converted back to the normal text (unescaped)
	characters (&lt;,&gt;,&amp;, ", etc,).</return-description>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <summary>String. The string to un-escape</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.GoogleFeedStore" type="Function" classlike="true" superclass="dojox.data.GoogleSearchStore">
    <summary>A data store for retrieving RSS and Atom feeds from Google. The
	feeds can come from any source, which is specified in the &amp;quot;url&amp;quot;
	parameter of the query passed to the &amp;quot;fetch&amp;quot; function.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The feed entry title.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;link - The URL for the HTML version of the feed entry.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - The full content of the blog post, in HTML format&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;summary - A snippet of information about the feed entry, in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;published - The string date on which the entry was published.
	You can parse the date with new Date(store.getValue(item, &amp;quot;published&amp;quot;)&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;categories - An array of string tags for the entry&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: url - The URL of the feed to retrieve</summary>
    <mixins>
      <mixin scope="instance" location="dojox.data.GoogleSearchStore"/>
    </mixins>
    <properties>
      <property name="_type" scope="prototype" type="String"/>
      <property name="_googleUrl" scope="prototype" type="String"/>
      <property name="_attributes" scope="prototype" type="Array"/>
      <property name="_feedMetaData" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getFeedValue" scope="prototype">
        <summary>Non-API method for retrieving values regarding the Atom feed,
	rather than the Atom entries.</summary>
        <parameters>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFeedValues" scope="prototype">
        <summary>Non-API method for retrieving values regarding the Atom feed,
	rather than the Atom entries.</summary>
        <parameters>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_createContent" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.GoogleFeedStore._queryAttrs" private="true">
    <properties>
      <property name="url" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.data.GoogleSearchStore" type="Function" classlike="true">
    <summary>A data store for retrieving search results from Google.
	This data store acts as a base class for Google searches,
	and has a number of child data stores that implement different
	searches. This store defaults to searching the web, and is functionally
	identical to the dojox.data.GoogleWebSearchStore object.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;unescapedUrl - The URL for the item, with URL escaping. This is often more readable&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;visibleUrl - The URL with no protocol specified.
	&amp;lt;li&amp;gt;cacheUrl - The URL to the copy of the document cached by Google
	&amp;lt;li&amp;gt;title - The page title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The page title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the page&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</summary>
    <description>The GoogleSearchStore is a Datastore interface to
	the Google search service. The constructor accepts the following arguments:
	&lt;ul&gt;
	&lt;li&gt;label - the label attribute to use. Defaults to titleNoFormatting&lt;/li&gt;
	&lt;li&gt;key - The API key to use. This is optional&lt;/li&gt;
	&lt;li&gt;lang - The language locale to use. Defaults to the browser locale&lt;/li&gt;
	&lt;/ul&gt;</description>
    <properties>
      <property name="_id" scope="instance-prototype" type="Integer">
        <summary>A unique identifier for this store.</summary>
      </property>
      <property name="_requestCount" scope="prototype" type="Integer">
        <summary>A counter for the number of requests made. This is used to define
	the callback function that GoogleSearchStore will use.</summary>
      </property>
      <property name="_googleUrl" scope="prototype" type="String">
        <summary>The URL to Googles search web service.</summary>
      </property>
      <property name="_storeRef" scope="prototype" type="String">
        <summary>The internal reference added to each item pointing at the store which owns it.</summary>
      </property>
      <property name="_attributes" scope="prototype" type="Array">
        <summary>The list of attributes that this store supports</summary>
      </property>
      <property name="label" scope="instance-prototype" type="String">
        <summary>The default attribute which acts as a label for each item.</summary>
      </property>
      <property name="_type" scope="prototype" type="String"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <summary>Sets whether or not to pass preventCache to dojo.io.script.</summary>
      </property>
      <property name="_key" scope="instance" type=""/>
      <property name="_lang" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initializer for the GoogleSearchStore store.</summary>
        <description>The GoogleSearchStore is a Datastore interface to
	the Google search service. The constructor accepts the following arguments:
	&lt;ul&gt;
	&lt;li&gt;label - the label attribute to use. Defaults to titleNoFormatting&lt;/li&gt;
	&lt;li&gt;key - The API key to use. This is optional&lt;/li&gt;
	&lt;li&gt;lang - The language locale to use. Defaults to the browser locale&lt;/li&gt;
	&lt;/ul&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_format" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="name" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="base implementation does not format any items"/>
        </return-types>
      </method>
      <method name="fetch" scope="prototype">
        <summary>Fetch Google search items that match to a query</summary>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object
	fetchHandler:
	A function to call for fetched items
	errorHandler:
	A function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getSort" scope="prototype"/>
      <method name="_processItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getItems" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_createContent" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.GoogleSearchStore._aggregatedAttributes" private="true">
    <properties>
      <property name="estimatedResultCount" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.data.GoogleSearchStore._queryAttrs" type="Hash" private="true">
    <summary>Maps query hash keys to Google query parameters.</summary>
    <properties>
      <property name="text" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.data.GoogleWebSearchStore" type="Function" classlike="true" superclass="dojox.data.GoogleSearchStore">
    <mixins>
      <mixin scope="instance" location="dojox.data.GoogleSearchStore"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.data.GoogleBlogSearchStore" type="Function" classlike="true" superclass="dojox.data.GoogleSearchStore">
    <mixins>
      <mixin scope="instance" location="dojox.data.GoogleSearchStore"/>
    </mixins>
    <properties>
      <property name="_type" scope="prototype" type="String"/>
      <property name="_attributes" scope="prototype" type="Array"/>
      <property name="_aggregatedAttributes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.data.GoogleLocalSearchStore" type="Function" classlike="true" superclass="dojox.data.GoogleSearchStore">
    <summary>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The blog post title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The  blog post title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the blog post&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;lat - The latitude.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;lng - The longtitude.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;streetAddress - The street address&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;city - The city&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;region - The region&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;country - The country&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;phoneNumbers - Phone numbers associated with this address. Can be one or more.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;ddUrl - A URL that can be used to provide driving directions from the center of the search results to this search results&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;ddUrlToHere - A URL that can be used to provide driving directions from this search result to a user specified location&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;staticMapUrl - The published date, in RFC-822 format&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;viewport - Recommended viewport for the query results (same for all results in a query)
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;center - contains lat, lng properties&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;span - lat, lng properties for the viewport span&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;ne, sw - lat, lng properties for the viewport corners&amp;lt;li&amp;gt;
	&amp;lt;/ul&amp;gt;
	&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts the following parameters:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;text - The string to search for&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;centerLatLong - Comma-separated lat &amp;amp; long for the center of the search (e.g. &amp;quot;48.8565,2.3509&amp;quot;)&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;searchSpan - Comma-separated lat &amp;amp; long degrees indicating the size of the desired search area (e.g. &amp;quot;0.065165,0.194149&amp;quot;)&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;</summary>
    <mixins>
      <mixin scope="instance" location="dojox.data.GoogleSearchStore"/>
    </mixins>
    <properties>
      <property name="_type" scope="prototype" type="String"/>
      <property name="_attributes" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.data.GoogleLocalSearchStore._aggregatedAttributes" private="true">
    <properties>
      <property name="viewport" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.data.GoogleLocalSearchStore._queryAttrs" private="true">
    <properties>
      <property name="text" scope="normal" type="String"/>
      <property name="centerLatLong" scope="normal" type="String"/>
      <property name="searchSpan" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.data.GoogleVideoSearchStore" type="Function" classlike="true" superclass="dojox.data.GoogleSearchStore">
    <summary>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The blog post title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The  blog post title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the blog post&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;published - The published date, in RFC-822 format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;publisher - The name of the publisher.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;duration - The approximate duration, in seconds, of the video.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbWidth - The width in pixels of the video.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbHeight - The height in pixels of the video&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbUrl - The URL to a thumbnail representation of the video.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;playUrl - If present, supplies the url of the flash version of the video that can be played inline on your page. To play this video simply create and &amp;lt;embed&amp;gt; element on your page using this value as the src attribute and using application/x-shockwave-flash as the type attribute. If you want the video to play right away, make sure to append &amp;amp;autoPlay=true to the url..&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</summary>
    <mixins>
      <mixin scope="instance" location="dojox.data.GoogleSearchStore"/>
    </mixins>
    <properties>
      <property name="_type" scope="prototype" type="String"/>
      <property name="_attributes" scope="prototype" type="Array"/>
      <property name="_aggregatedAttributes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.data.GoogleNewsSearchStore" type="Function" classlike="true" superclass="dojox.data.GoogleSearchStore">
    <summary>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The news story title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The news story title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the news story&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;unescapedUrl - The URL for the item, with URL escaping. This is often more readable&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;publisher - The name of the publisher&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;clusterUrl - A URL pointing to a page listing related storied.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;location - The location of the news story.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;publishedDate - The date of publication, in RFC-822 format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;relatedStories - An optional array of objects specifying related stories.
	Each object has the following subset of properties:
	&amp;quot;title&amp;quot;, &amp;quot;titleNoFormatting&amp;quot;, &amp;quot;url&amp;quot;, &amp;quot;unescapedUrl&amp;quot;, &amp;quot;publisher&amp;quot;, &amp;quot;location&amp;quot;, &amp;quot;publishedDate&amp;quot;.
	&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</summary>
    <mixins>
      <mixin scope="instance" location="dojox.data.GoogleSearchStore"/>
    </mixins>
    <properties>
      <property name="_type" scope="prototype" type="String"/>
      <property name="_attributes" scope="prototype" type="Array"/>
      <property name="_aggregatedAttributes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.data.GoogleBookSearchStore" type="Function" classlike="true" superclass="dojox.data.GoogleSearchStore">
    <summary>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The book title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The book title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;authors - An array of authors&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the item&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;unescapedUrl - The URL for the item, with URL escaping. This is often more readable&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;bookId - An identifier for the book, usually an ISBN.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;pageCount - The number of pages in the book.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;publishedYear - The year of publication.&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</summary>
    <mixins>
      <mixin scope="instance" location="dojox.data.GoogleSearchStore"/>
    </mixins>
    <properties>
      <property name="_type" scope="prototype" type="String"/>
      <property name="_attributes" scope="prototype" type="Array"/>
      <property name="_aggregatedAttributes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.data.GoogleImageSearchStore" type="Function" classlike="true" superclass="dojox.data.GoogleSearchStore">
    <summary>A data store for retrieving search results from Google.
	The following attributes are supported on each item:
	&amp;lt;ul&amp;gt;
	&amp;lt;li&amp;gt;title - The image title in HTML format.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;titleNoFormatting - The image title in plain text&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;url - The URL for the image&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;unescapedUrl - The URL for the image, with URL escaping. This is often more readable&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbUrl - The URL for the image thumbnail&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;visibleUrl - A shortened version of the URL associated with the result, stripped of a protocol and path&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;originalContextUrl - The URL of the page containing the image.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;width - The width of the image in pixels.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;height - The height of the image in pixels.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbWidth - The width of the image thumbnail in pixels.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;tbHeight - The height of the image thumbnail in pixels.&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;content - A snippet of information about the image, in HTML format&amp;lt;/li&amp;gt;
	&amp;lt;li&amp;gt;contentNoFormatting - A snippet of information about the image, in plain text&amp;lt;/li&amp;gt;
	&amp;lt;/ul&amp;gt;
	The query accepts one parameter: text - The string to search for</summary>
    <mixins>
      <mixin scope="instance" location="dojox.data.GoogleSearchStore"/>
    </mixins>
    <properties>
      <property name="_type" scope="prototype" type="String"/>
      <property name="_attributes" scope="prototype" type="Array"/>
      <property name="_aggregatedAttributes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.data.HtmlStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>Initializer for the HTML table store.</summary>
    <description>The HtmlStore can be created in one of two ways: a) by parsing an existing
	table or list DOM node on the current page or b) by referencing an external url and giving
	the id of the table or list in that page.  The remote url will be parsed as an html page.
	The HTML table or list should be of the following form:
		&lt;table id="myTable"&gt;
			&lt;thead&gt;
				&lt;tr&gt;
					&lt;th&gt;Attribute1&lt;/th&gt;
					&lt;th&gt;Attribute2&lt;/th&gt;
				&lt;/tr&gt;
			&lt;/thead&gt;
			&lt;tbody&gt;
				&lt;tr&gt;
					&lt;td&gt;Value1.1&lt;/td&gt;
					&lt;td&gt;Value1.2&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;Value2.1&lt;/td&gt;
					&lt;td&gt;Value2.2&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/tbody&gt;
		&lt;/table&gt;
	-or-
		&lt;ul id="myUnorderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ul&gt;
	-or-
		&lt;ol id="myOrderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ol&gt;</description>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <summary>string The URL from which to load an HTML document for data loading</summary>
      </property>
      <property name="dataId" scope="instance-prototype" type="The">
        <summary>string The id in the document for an element from which to get the data.</summary>
      </property>
      <property name="trimWhitespace" scope="instance-prototype" type="Trim">
        <summary>off any surrounding whitespace from the headers (attribute
	names) and text content of the items in question.  Default is false for
	backwards compatibility.</summary>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <summary>Flag to denote if peventCache should be used on xhrGet calls.</summary>
      </property>
      <property name="_rootNode" scope="instance-prototype" type="Object"/>
      <property name="_headings" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>An anonymous object to initialize properties.  It expects the following values:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initializer for the HTML table store.</summary>
        <description>The HtmlStore can be created in one of two ways: a) by parsing an existing
	table or list DOM node on the current page or b) by referencing an external url and giving
	the id of the table or list in that page.  The remote url will be parsed as an html page.
	The HTML table or list should be of the following form:
		&lt;table id="myTable"&gt;
			&lt;thead&gt;
				&lt;tr&gt;
					&lt;th&gt;Attribute1&lt;/th&gt;
					&lt;th&gt;Attribute2&lt;/th&gt;
				&lt;/tr&gt;
			&lt;/thead&gt;
			&lt;tbody&gt;
				&lt;tr&gt;
					&lt;td&gt;Value1.1&lt;/td&gt;
					&lt;td&gt;Value1.2&lt;/td&gt;
				&lt;/tr&gt;
				&lt;tr&gt;
					&lt;td&gt;Value2.1&lt;/td&gt;
					&lt;td&gt;Value2.2&lt;/td&gt;
				&lt;/tr&gt;
			&lt;/tbody&gt;
		&lt;/table&gt;
	-or-
		&lt;ul id="myUnorderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ul&gt;
	-or-
		&lt;ol id="myOrderedList"&gt;
			&lt;li&gt;Value.1&lt;/li&gt;
			&lt;li&gt;Value.2&lt;/li&gt;
		&lt;/ol&gt;</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>An anonymous object to initialize properties.  It expects the following values:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_indexItems" scope="prototype">
        <summary>Function to index items found under the id.</summary>
      </method>
      <method name="_getHeadings" scope="prototype">
        <summary>Function to load the attribute names from the table header so that the
	attributes (cells in a row), can have a reasonable name.
	For list items, returns single implicit heading, [&amp;quot;name&amp;quot;]</summary>
      </method>
      <method name="_getAllItems" scope="prototype">
        <summary>Function to return all rows in the table as an array of items.</summary>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type=""/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <summary>Internal function for looking at the values contained by the item.</summary>
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The data item to examine for attribute values.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to inspect.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match.</summary>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <summary>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>Fetch items (XML elements) that match to a query</summary>
        <description>If '_fetchUrl' is specified, it is used to load an XML document
	with a query string.
	Otherwise and if 'url' is specified, the XML document is
	loaded and list XML elements that match to a query (set of element
	names and their text attribute values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If '_rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <summary>function to call for fetched items</summary>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <summary>function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_finishFetchItems" scope="prototype">
        <summary>Internal function for processing the passed in request and locating the requested items.</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
          <parameter name="fetchHandler" type="" usage="required"/>
          <parameter name="errorHandler" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()
	nothing to do here!</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentityAttributes()
	Identity isn't taken from a public attribute.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.HtmlTableStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <properties>
      <property name="url" scope="instance-prototype" type="string">
        <summary>The URL from which to load an HTML document for data loading</summary>
      </property>
      <property name="tableId" scope="instance-prototype" type="string">
        <summary>The id of the table to load as store contents.</summary>
      </property>
      <property name="_headings" scope="prototype" type="Array"/>
      <property name="_rootNode" scope="instance-prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getHeadings" scope="prototype">
        <summary>Function to load the attribute names from the table header so that the
	attributes (cells in a row), can have a reasonable name.</summary>
      </method>
      <method name="_getAllItems" scope="prototype">
        <summary>Function to return all rows in the table as an array of items.</summary>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <return-description>Returns the index (column) that the attribute resides in the row.</return-description>
        <parameters>
          <parameter name="attribute" type="String" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type=""/>
          <return-type type="int"/>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <summary>Internal function for looking at the values contained by the item.</summary>
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The data item to examine for attribute values.</summary>
          </parameter>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to inspect.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match.</summary>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <summary>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>Fetch items (XML elements) that match to a query</summary>
        <description>If '_fetchUrl' is specified, it is used to load an XML document
	with a query string.
	Otherwise and if 'url' is specified, the XML document is
	loaded and list XML elements that match to a query (set of element
	names and their text attribute values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If '_rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <summary>function to call for fetched items</summary>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <summary>function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_finishFetchItems" scope="prototype">
        <summary>Internal function for processing the passed in request and locating the requested items.</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
          <parameter name="fetchHandler" type="" usage="required"/>
          <parameter name="errorHandler" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()
	nothing to do here!</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentityAttributes()
	Identity isn't taken from a public attribute.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.ItemExplorer" type="Function" classlike="true" superclass="dijit.Tree">
    <mixins>
      <mixin scope="instance" location="dijit.Tree"/>
    </mixins>
    <properties>
      <property name="useSelect" scope="prototype" type="bool"/>
      <property name="refSelectSearchAttr" scope="prototype" type="Object"/>
      <property name="store" scope="prototype" type="Object"/>
      <property name="_modelNodeIdMap" scope="instance-prototype" type="Object"/>
      <property name="_modelNodePropMap" scope="instance-prototype" type="Object"/>
      <property name="_editDialog" scope="prototype" type="Object"/>
      <property name="model" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="setStore" scope="prototype">
        <parameters>
          <parameter name="store" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="refreshItem" scope="prototype"/>
      <method name="_createEditDialog" scope="prototype">
        <return-types>
          <return-type type="isFocused"/>
          <return-type type=""/>
          <return-type type="this.store.getItemByIdentity(this._editDialog.attr(&quot;value&quot;)._reference);"/>
        </return-types>
      </method>
      <method name="_enableFields" scope="prototype">
        <parameters>
          <parameter name="selection" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateItem" scope="prototype">
        <parameters>
          <parameter name="vals" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_editProperty" scope="prototype"/>
      <method name="_destroyProperty" scope="prototype"/>
      <method name="_addProperty" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.data.ItemExplorer.rootModelNode">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.data.JsonQueryRestStore" type="Function" classlike="true" superclass="dojox.data.JsonRestStore">
    <mixins>
      <mixin scope="prototype" location="dojox.data.util.JsonQuery.prototype"/>
      <mixin scope="instance" location="dojox.data.JsonRestStore"/>
      <mixin scope="instance" location="dojox.data.util.JsonQuery"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="matchesQuery" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.JsonRestStore" type="Function" classlike="true" superclass="dojox.data.ServiceStore">
    <summary>Allow no trailing slash on target paths. This is generally discouraged since
	it creates prevents simple scalar values from being used a relative URLs.
	Disabled by default.
	Write API Support
	Notifcation Support</summary>
    <description>The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
	When using a Rest store on a public network, it is important to implement proper security measures to
	control access to resources.
	On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
	GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
	query (like /table/?name=foo).
	PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
	provide the modified object
	POST - This should create a new object. The URL will correspond to the target store (like /table/)
	and the body should be the properties of the new object. The server's response should include a
	Location header that indicates the id of the newly created object. This id will be used for subsequent
	PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
	the temporary randomly generated id used by client, and this location is used for subsequent
	PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
	to receiving a response from the server.
	DELETE - This should delete an object by id.
	These articles include more detailed information on using the JsonRestStore:
	http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
	http://blog.medryx.org/2008/07/24/jsonreststore-overview/</description>
    <mixins>
      <mixin scope="instance" location="dojox.data.ServiceStore"/>
    </mixins>
    <examples>
      <example>A JsonRestStore takes a REST service or a URL and uses it the remote communication for a
	read/write dojo.data implementation. A JsonRestStore can be created with a simple URL like:
		new JsonRestStore({target:"/MyData/"});</example>
      <example>To use a JsonRestStore with a service, you should create a
	service with a REST transport. This can be configured with an SMD:
		{
			services: {
				jsonRestStore: {
					transport: "REST",
					envelope: "URL",
					target: "store.php",
					contentType:"application/json",
					parameters: [
						{name: "location", type: "string", optional: true}
					]
				}
			}
		}
	The SMD can then be used to create service, and the service can be passed to a JsonRestStore. For example:
		var myServices = new dojox.rpc.Service(dojo.moduleUrl("dojox.rpc.tests.resources", "test.smd"));
		var jsonStore = new dojox.data.JsonRestStore({service:myServices.jsonRestStore});</example>
      <example>The JsonRestStore also supports lazy loading. References can be made to objects that have not been loaded.
	For example if a service returned:
		{"name":"Example","lazyLoadedObject":{"$ref":"obj2"}}
	And this object has accessed using the dojo.data API:
		var obj = jsonStore.getValue(myObject,"lazyLoadedObject");
	The object would automatically be requested from the server (with an object id of "obj2").</example>
    </examples>
    <properties>
      <property name="loadReferencedSchema" scope="prototype" type="Object"/>
      <property name="idAsRef" scope="prototype" type="bool"/>
      <property name="referenceIntegrity" scope="prototype" type="Object"/>
      <property name="target" scope="instance-prototype" type="String"/>
      <property name="allowNoTrailingSlash" scope="prototype" type="bool"/>
      <property name="serverVersion" scope="prototype" type=""/>
      <property name="idAttribute" scope="instance" type="String"/>
      <property name="_index" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <summary>arguments
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	The function should also have the following methods:
	put(id,value) - puts the value at the given id
	post(id,value) - posts (appends) the value at the given id
	delete(id) - deletes the value corresponding to the given id
	Note that it is critical that the service parses responses as JSON.
	If you are using dojox.rpc.Service, the easiest way to make sure this
	happens is to make the responses have a content type of
	application/json. If you are creating your own service, make sure you
	use handleAs: &amp;quot;json&amp;quot; with your XHR requests.
	The *target* parameter
	This is the target URL for this Service store. This may be used in place
	of a service parameter to connect directly to RESTful URL without
	using a dojox.rpc.Service object.
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>JsonRestStore is a Dojo Data store interface to JSON HTTP/REST web
	storage services that support read and write through GET, PUT, POST, and DELETE.</summary>
        <description>The JsonRestStore will cause all saved modifications to be sent to the server using Rest commands (PUT, POST, or DELETE).
	When using a Rest store on a public network, it is important to implement proper security measures to
	control access to resources.
	On the server side implementing a REST interface means providing GET, PUT, POST, and DELETE handlers.
	GET - Retrieve an object or array/result set, this can be by id (like /table/1) or with a
	query (like /table/?name=foo).
	PUT - This should modify a object, the URL will correspond to the id (like /table/1), and the body will
	provide the modified object
	POST - This should create a new object. The URL will correspond to the target store (like /table/)
	and the body should be the properties of the new object. The server's response should include a
	Location header that indicates the id of the newly created object. This id will be used for subsequent
	PUT and DELETE requests. JsonRestStore also includes a Content-Location header that indicates
	the temporary randomly generated id used by client, and this location is used for subsequent
	PUT/DELETEs if no Location header is provided by the server or if a modification is sent prior
	to receiving a response from the server.
	DELETE - This should delete an object by id.
	These articles include more detailed information on using the JsonRestStore:
	http://www.sitepen.com/blog/2008/06/13/restful-json-dojo-data/
	http://blog.medryx.org/2008/07/24/jsonreststore-overview/</description>
        <examples>
          <example>A JsonRestStore takes a REST service or a URL and uses it the remote communication for a
	read/write dojo.data implementation. A JsonRestStore can be created with a simple URL like:
		new JsonRestStore({target:"/MyData/"});</example>
          <example>To use a JsonRestStore with a service, you should create a
	service with a REST transport. This can be configured with an SMD:
		{
			services: {
				jsonRestStore: {
					transport: "REST",
					envelope: "URL",
					target: "store.php",
					contentType:"application/json",
					parameters: [
						{name: "location", type: "string", optional: true}
					]
				}
			}
		}
	The SMD can then be used to create service, and the service can be passed to a JsonRestStore. For example:
		var myServices = new dojox.rpc.Service(dojo.moduleUrl("dojox.rpc.tests.resources", "test.smd"));
		var jsonStore = new dojox.data.JsonRestStore({service:myServices.jsonRestStore});</example>
          <example>The JsonRestStore also supports lazy loading. References can be made to objects that have not been loaded.
	For example if a service returned:
		{"name":"Example","lazyLoadedObject":{"$ref":"obj2"}}
	And this object has accessed using the dojo.data API:
		var obj = jsonStore.getValue(myObject,"lazyLoadedObject");
	The object would automatically be requested from the server (with an object id of "obj2").</example>
        </examples>
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <summary>arguments
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	The function should also have the following methods:
	put(id,value) - puts the value at the given id
	post(id,value) - posts (appends) the value at the given id
	delete(id) - deletes the value corresponding to the given id
	Note that it is critical that the service parses responses as JSON.
	If you are using dojox.rpc.Service, the easiest way to make sure this
	happens is to make the responses have a content type of
	application/json. If you are creating your own service, make sure you
	use handleAs: &amp;quot;json&amp;quot; with your XHR requests.
	The *target* parameter
	This is the target URL for this Service store. This may be used in place
	of a service parameter to connect directly to RESTful URL without
	using a dojox.rpc.Service object.
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary</summary>
          </parameter>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <summary>adds a new item to the store at the specified point.
	Takes two parameters, data, and options.</summary>
        <parameters>
          <parameter name="data" type="object" usage="required">
            <summary>The data to be added in as an item.</summary>
          </parameter>
          <parameter name="parentInfo" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deleteItem" scope="prototype">
        <summary>deletes item and any references to that item from the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>to delete</summary>
          </parameter>
        </parameters>
      </method>
      <method name="changing" scope="prototype">
        <summary>adds an item to the list of dirty items.	This item
	contains a reference to the item itself as well as a
	cloned and trimmed version of old item for use with
	revert.</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="_deleting" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>sets 'attribute' on 'item' to 'value'</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setValues" scope="prototype">
        <summary>sets 'attribute' on 'item' to 'value' value
	must be an array.</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="values" type="" usage="required"/>
        </parameters>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <summary>unsets 'attribute' on 'item'</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="save" scope="prototype">
        <summary>Saves the dirty data using REST Ajax methods. See dojo.data.api.Write for API.
	kwArgs.global:
	This will cause the save to commit the dirty data for all
	JsonRestStores as a single transaction.
	kwArgs.revertOnError
	This will cause the changes to be reverted if there is an
	error on the save. By default a revert is executed unless
	a value of false is provide for this parameter.
	kwArgs.incrementalUpdates
	For items that have been updated, if this is enabled, the server will be sent a POST request
	with a JSON object containing the changed properties. By default this is
	not enabled, and a PUT is used to deliver an update, and will include a full
	serialization of all the properties of the item/object.
	If this is true, the POST request body will consist of a JSON object with
	only the changed properties. The incrementalUpdates parameter may also
	be a function, in which case it will be called with the updated and previous objects
	and an object update representation can be returned.
	kwArgs.alwaysPostNewItems
	If this is true, new items will always be sent with a POST request. By default
	this is not enabled, and the JsonRestStore will send a POST request if
	the item does not include its identifier (expecting server assigned location/
	identifier), and will send a PUT request if the item does include its identifier
	(the PUT will be sent to the URI corresponding to the provided identifier).</summary>
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="revert" scope="prototype">
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <summary>Checks to see if a passed 'item'
	really belongs to this JsonRestStore.</summary>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <summary>The value to test for being an item</summary>
          </parameter>
          <parameter name="anyStore" type="boolean" usage="required">
            <summary>If true, this will return true if the value is an item for any JsonRestStore,
	not just this instance</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_doQuery" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="don't change anything, and deal with the stupid post-commit lint complaints"/>
        </return-types>
      </method>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="" usage="required"/>
          <parameter name="deferred" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getConstructor" scope="prototype">
        <summary>Gets the constructor for objects from this store</summary>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="prototype"/>
      <method name="onNew" scope="prototype"/>
      <method name="onDelete" scope="prototype"/>
      <method name="getFeatures" scope="prototype">
        <summary>return the store feature set</summary>
      </method>
      <method name="getParent" scope="prototype">
        <summary>Returns the parent item (or query) for the given item</summary>
        <parameters>
          <parameter name="item" type="The" usage="required">
            <summary>item to find the parent of</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_constructor" scope="instance">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getStore" scope="normal">
        <summary>Will retrieve or create a store using the given options (the same options
	that are passed to JsonRestStore constructor. Returns a JsonRestStore instance</summary>
        <parameters>
          <parameter name="options" type="See" usage="required">
            <summary>the JsonRestStore constructor</summary>
          </parameter>
          <parameter name="Class" type="Constructor" usage="required">
            <summary>to use (for creating stores from JsonRestStore subclasses).
	This is optional and defaults to JsonRestStore.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.JsonRestStore.service">
    <properties>
      <property name="_schema" scope="instance" type="Object"/>
      <property name="_store" scope="instance" type="Object"/>
      <property name="idAsRef" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.data.JsonRestStore.schema">
    <properties>
      <property name="_idAttr" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.json.ref">
    <summary>Adds advanced JSON {de}serialization capabilities to the base json library.
	This enhances the capabilities of dojo.toJson and dojo.fromJson,
	adding referencing support, date handling, and other extra format handling.
	On parsing, references are resolved. When references are made to
	ids/objects that have been loaded yet, the loader function will be set to
	_loadObject to denote a lazy loading (not loaded yet) object.</summary>
    <properties>
      <property name="_useRefs" scope="normal" type="bool"/>
      <property name="serializeFunctions" scope="normal" type="bool"/>
      <property name="refAttribute" scope="normal" type="String">
        <summary>This indicates what property is the reference property. This acts like the idAttribute
	except that this is used to indicate the current object is a reference or only partially
	loaded. This defaults to &amp;quot;$ref&amp;quot;.</summary>
      </property>
    </properties>
    <methods>
      <method name="fromJson" scope="normal">
        <summary>evaluates the passed string-form of a JSON object.</summary>
        <parameters>
          <parameter name="str" type="String" usage="required">
            <summary>a string literal of a JSON item, for instance:
	'{ &amp;quot;foo&amp;quot;: [ &amp;quot;bar&amp;quot;, 1, { &amp;quot;baz&amp;quot;: &amp;quot;thud&amp;quot; } ] }'</summary>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <summary>See resolveJson
	return:
	An object, the result of the evaluation</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addProp" scope="normal">
        <parameters>
          <parameter name="id" type="" usage="required"/>
          <parameter name="prop" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.KeyValueStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>This is a dojo.data store implementation.  It can take in either a Javascript
	array, JSON string, or URL as the data source.  Data is expected to be in the
	following format:
	[
	{ &amp;quot;key1&amp;quot;: &amp;quot;value1&amp;quot; },
	{ &amp;quot;key2&amp;quot;: &amp;quot;value2&amp;quot; }
	]
	This is to mimic the Java Properties file format.  Each 'item' from this store
	is a JS object representing a key-value pair.  If an item in the above array has
	more than one key/value pair, only the first will be used/accessed.</summary>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="data" scope="prototype" type="String"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <summary>Controls if urlPreventCache should be used with underlying xhrGet.</summary>
      </property>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_keyValueString" scope="instance-prototype" type="Object"/>
      <property name="_keyValueVar" scope="instance-prototype" type="Object"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfAllItems" scope="prototype" type="Array"/>
      <property name="_loadFinished" scope="prototype" type="Object"/>
      <property name="_keyAttribute" scope="instance" type="String"/>
      <property name="_valueAttribute" scope="instance" type="String"/>
      <property name="_storeProp" scope="instance" type="String"/>
      <property name="_features" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>dataVar: jsonObject}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>constructor</summary>
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>dataVar: jsonObject}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="String" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()
	Key/Value syntax does not support multi-valued attributes, so this is just a
	wrapper function for getValue().</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <summary>Internal function for looking at the values contained by the item.</summary>
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The data item to examine for attribute values.</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>The attribute to inspect.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match.</summary>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <summary>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()
	The KeyValueStore always loads all items, so if it's an item, then it's loaded.</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <description>The KeyValueStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke
	the callback handlers.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>See dojo.data.util.simpleFetch.fetch()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <summary>Internal function to execute delayed request in the store.
	Execute any deferred fetches now.</summary>
      </method>
      <method name="_processData" scope="prototype">
        <parameters>
          <parameter name="data" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_createItem" scope="prototype">
        <parameters>
          <parameter name="something" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentifierAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_finishFetchItemByIdentity" scope="prototype">
        <parameters>
          <parameter name="items" type="Array" usage="required"/>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.OpenSearchStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>Initializer for the OpenSearchStore store.</summary>
    <description>The OpenSearchStore is a Datastore interface to any search
	engine that implements the open search specifications.</description>
    <properties>
      <property name="url" scope="instance-prototype" type="String"/>
      <property name="itemPath" scope="instance-prototype" type="String"/>
      <property name="_storeRef" scope="prototype" type="String"/>
      <property name="iframeElement" scope="prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <summary>Flag denoting if xhrGet calls should use the preventCache option.</summary>
      </property>
      <property name="ATOM_CONTENT_TYPE" scope="prototype" type="Number"/>
      <property name="ATOM_CONTENT_TYPE_STRING" scope="prototype" type="String"/>
      <property name="RSS_CONTENT_TYPE" scope="prototype" type="Number"/>
      <property name="RSS_CONTENT_TYPE_STRING" scope="prototype" type="String"/>
      <property name="XML_CONTENT_TYPE" scope="prototype" type="Number"/>
      <property name="XML_CONTENT_TYPE_STRING" scope="prototype" type="String"/>
      <property name="contentType" scope="prototype" type=""/>
      <property name="label" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initializer for the OpenSearchStore store.</summary>
        <description>The OpenSearchStore is a Datastore interface to any search
	engine that implements the open search specifications.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="process" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="processItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_createSearchUrl" scope="prototype">
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>Fetch OpenSearch items that match to a query</summary>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <summary>function to call for fetched items</summary>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <summary>function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_processOSDxml" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemxml" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDatom" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processItematom" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDrss" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemrss" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processOSDfeed" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processItemfeed" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getNodeXml" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="skipFirst" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processOsdd" scope="prototype">
        <parameters>
          <parameter name="doc" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.OpenSearchStore.urlElement">
    <properties>
      <property name="attributes" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.data.OpmlStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>*   The OpmlStore implements the dojo.data.api.Read API.</summary>
    <properties>
      <property name="label" scope="instance-prototype" type="string">
        <summary>The attribute of the Opml item to act as a label.</summary>
      </property>
      <property name="url" scope="instance-prototype" type="string">
        <summary>The location from which to fetch the Opml document.</summary>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <summary>Flag to denote if the underlying xhrGet call should set preventCache.</summary>
      </property>
      <property name="_loadFinished" scope="instance-prototype" type="bool"/>
      <property name="_xmlData" scope="instance-prototype" type="Object"/>
      <property name="_metadataNodes" scope="instance-prototype" type="Object"/>
      <property name="_loadInProgress" scope="instance-prototype" type="bool"/>
      <property name="_opmlData" scope="instance-prototype" type="Object"/>
      <property name="_queuedFetches" scope="instance-prototype" type="Array"/>
      <property name="_arrayOfTopLevelItems" scope="instance" type="Array"/>
      <property name="_arrayOfAllItems" scope="instance" type="Array"/>
      <property name="_identityMap" scope="instance" type="Object"/>
      <property name="_identCount" scope="instance" type="Number"/>
      <property name="_idProp" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>url: String, label: String}  Where label is optional and configures what should be used as the return from getLabel()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>constructor</summary>
        <parameters>
          <parameter name="keywordParameters" type="Object" usage="required">
            <summary>url: String, label: String}  Where label is optional and configures what should be used as the return from getLabel()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="item" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_removeChildNodesThatAreNotElementNodes" scope="prototype">
        <parameters>
          <parameter name="node" type="node" usage="required"/>
          <parameter name="recursive" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_processRawXmlTree" scope="prototype">
        <parameters>
          <parameter name="rawXmlTree" type="xmlDoc" usage="required"/>
        </parameters>
      </method>
      <method name="_checkChildNodes" scope="prototype">
        <summary>Internal function to recurse over all child nodes from the store and add them
	As non-toplevel items</summary>
        <description>Internal function to recurse over all child nodes from the store and add them
	As non-toplevel items</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>The child node to walk.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getItemsArray" scope="prototype">
        <summary>Internal function to determine which list of items to search over.</summary>
        <parameters>
          <parameter name="queryOptions" type="object" usage="optional">
            <summary>The query options parameter, if any.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>|| attribute-name-string</summary>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValues()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>|| attribute-name-string</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>|| attribute-name-string</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>|| attribute-name-string</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean."/>
        </return-types>
      </method>
      <method name="_containsValue" scope="prototype">
        <summary>Internal function for looking at the values contained by the item.</summary>
        <description>Internal function for looking at the values contained by the item.  This
	function allows for denoting if the comparison should be case sensitive for
	strings or not (for handling filtering cases where string case should not matter)</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The data item to examine for attribute values.</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>The attribute to inspect.</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>The value to match.</summary>
          </parameter>
          <parameter name="regexp" type="RegExp" usage="optional">
            <summary>Optional regular expression generated off value if value was of string type to handle wildcarding.
	If present and attribute values are string, then it can be used for comparison instead of 'value'</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <description>Four things are verified to ensure that "something" is an item:
	something can not be null, the nodeType must be an XML Element,
	the tagName must be "outline", and the node must be a member of
	XML document for this datastore.</description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()
	OpmlStore loads every item, so if it's an item, then it's loaded.</summary>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <description>The OpmlStore always loads all items, so if it's an item, then it's loaded.
	From the dojo.data.api.Read.loadItem docs:
	If a call to isItemLoaded() returns true before loadItem() is even called,
	then loadItem() need not do any work at all and will not even invoke the callback handlers.</description>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>See dojo.data.util.simpleFetch.fetch()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
          <parameter name="findCallback" type="Function" usage="required"/>
          <parameter name="errorCallback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentifierAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_handleQueuedFetches" scope="prototype">
        <summary>Internal function to execute delayed request in the store.
	Execute any deferred fetches now.</summary>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.PersevereStore" type="Function" classlike="true" superclass="dojox.data.JsonQueryRestStore">
    <mixins>
      <mixin scope="instance" location="dojox.data.JsonQueryRestStore"/>
    </mixins>
    <properties>
      <property name="useFullIdInQueries" scope="prototype" type="Object"/>
      <property name="jsonQueryPagination" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getStores" scope="normal">
        <summary>Creates Dojo data stores for all the table/classes on a Persevere server</summary>
        <parameters>
          <parameter name="path" type="String" usage="optional">
            <summary>URL of the Persevere server's root, this normally just &amp;quot;/&amp;quot;
	which is the default value if the target is not provided</summary>
          </parameter>
          <parameter name="sync" type="Boolean" usage="optional">
            <summary>Indicates that the operation should happen synchronously.
	return:
	A map/object of datastores will be returned if it is performed asynchronously,
	otherwise it will return a Deferred object that will provide the map/object.
	The name of each property is a the name of a store,
	and the value is the actual data store object.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addProxy" scope="normal">
        <summary>Invokes the XHR proxy plugin. Call this if you will be using x-site data.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.rpc">
    <summary>TODOC</summary>
    <properties>
      <property name="_sync" scope="normal" type=""/>
      <property name="JsonRPC" scope="normal" type="Object"/>
      <property name="ProxiedPath" scope="normal" type="Object"/>
      <property name="transportRegistry" scope="normal" type="Object"/>
      <property name="envelopeRegistry" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="getTarget" scope="normal">
        <parameters>
          <parameter name="smd" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toOrdered" scope="normal">
        <parameters>
          <parameter name="parameters" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.PicasaStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>Initializer for the PicasaStore store.</summary>
    <description>The PicasaStore is a Datastore interface to one of the basic services
	of the Picasa service, the public photo feed.  This does not provide
	access to all the services of Picasa.
	This store cannot do * and ? filtering as the picasa service
	provides no interface for wildcards.</description>
    <properties>
      <property name="_picasaUrl" scope="prototype" type="String"/>
      <property name="_storeRef" scope="prototype" type="String"/>
      <property name="label" scope="instance-prototype" type="string">
        <summary>The attribute to use from the picasa item as its label.</summary>
      </property>
      <property name="urlPreventCache" scope="instance-prototype" type="boolean">
        <summary>Flag denoting if preventCache should be passed to dojo.io.script.</summary>
      </property>
      <property name="maxResults" scope="instance-prototype" type="Define">
        <summary>out how many results to return for a fetch.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initializer for the PicasaStore store.</summary>
        <description>The PicasaStore is a Datastore interface to one of the basic services
	of the Picasa service, the public photo feed.  This does not provide
	access to all the services of Picasa.
	This store cannot do * and ? filtering as the picasa service
	provides no interface for wildcards.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>Fetch picasa items that match to a query</summary>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <summary>function to call for fetched items</summary>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <summary>function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_processPicasaData" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_unescapeHtml" scope="prototype">
        <summary>Utility function to un-escape XML special characters in an HTML string.</summary>
        <description>Utility function to un-escape XML special characters in an HTML string.</description>
        <return-description>HTML String converted back to the normal text (unescaped) characters (&lt;,&gt;,&amp;, ", etc,).
	TODO: Check to see if theres already compatible escape() in dojo.string or dojo.html</return-description>
        <parameters>
          <parameter name="str" type="String." usage="required">
            <summary>The string to un-escape</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.QueryReadStore" type="Function" classlike="true">
    <summary>By default all the sorting is done serverside before the data is returned
	which is the proper place to be doing it for really large datasets.</summary>
    <examples>
      <example>	// The parameter "query" contains the data that are sent to the server.
		var store = new dojox.data.QueryReadStore({url:'/search.php'});
		store.fetch({query:{name:'a'}, queryOptions:{ignoreCase:false}});
		// Since "serverQuery" is given, it overrules and those data are
		// sent to the server.
		var store = new dojox.data.QueryReadStore({url:'/search.php'});
		store.fetch({serverQuery:{name:'a'}, queryOptions:{ignoreCase:false}});
		&lt;div dojoType="dojox.data.QueryReadStore"
			jsId="store2"
			url="../tests/stores/QueryReadStore.php"
			requestMethod="post"&gt;&lt;/div&gt;
		&lt;div dojoType="dojox.grid.data.DojoData"
			jsId="model2"
			store="store2"
			sortFields="[{attribute: 'name', descending: true}]"
			rowsPerPage="30"&gt;&lt;/div&gt;
		&lt;div dojoType="dojox.Grid" id="grid2"
			model="model2"
			structure="gridLayout"
			style="height:300px; width:800px;"&gt;&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="url" scope="prototype" type="String"/>
      <property name="requestMethod" scope="prototype" type="String"/>
      <property name="_className" scope="prototype" type="String"/>
      <property name="_items" scope="prototype" type="Array"/>
      <property name="_lastServerQuery" scope="prototype" type="Object"/>
      <property name="_numRows" scope="prototype" type="Number"/>
      <property name="lastRequestHash" scope="prototype" type="String"/>
      <property name="doClientPaging" scope="prototype" type="bool"/>
      <property name="doClientSorting" scope="prototype" type="bool"/>
      <property name="_itemsByIdentity" scope="prototype" type="Object"/>
      <property name="_identifier" scope="prototype" type="Object"/>
      <property name="_features" scope="prototype" type="Object"/>
      <property name="_labelAttr" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="defaultValue" type="value" usage="optional"/>
        </parameters>
      </method>
      <method name="getValues" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttribute()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <parameters>
          <parameter name="args" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <summary>See dojo.data.util.simpleFetch.fetch() this is just a copy and I adjusted
	only the paging, since it happens on the server if doClientPaging is
	false, thx to http://trac.dojotoolkit.org/ticket/4761 reporting this.
	Would be nice to be able to use simpleFetch() to reduce copied code,
	but i dont know how yet. Ideas please!</summary>
        <parameters>
          <parameter name="request" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="prototype"/>
      <method name="close" scope="prototype">
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_xhrFetchHandler" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
          <parameter name="fetchHandler" type="" usage="required"/>
          <parameter name="errorHandler" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>The request contains the data as defined in the Read-API.
	Additionally there is following keyword &amp;quot;serverQuery&amp;quot;.
	The *serverQuery* parameter, optional.
	This parameter contains the data that will be sent to the server.
	If this parameter is not given the parameter &amp;quot;query&amp;quot;'s
	data are sent to the server. This is done for some reasons:
	- to specify explicitly which data are sent to the server, they
	might also be a mix of what is contained in &amp;quot;query&amp;quot;, &amp;quot;queryOptions&amp;quot;
	and the paging parameters &amp;quot;start&amp;quot; and &amp;quot;count&amp;quot; or may be even
	completely different things.
	- don't modify the request.query data, so the interface using this
	store can rely on unmodified data, as the combobox dijit currently
	does it, it compares if the query has changed
	- request.query is required by the Read-API
	I.e. the following examples might be sent via GET:
	fetch({query:{name:&amp;quot;abc&amp;quot;}, queryOptions:{ignoreCase:true}})
	the URL will become:   /url.php?name=abc
	fetch({serverQuery:{q:&amp;quot;abc&amp;quot;, c:true}, query:{name:&amp;quot;abc&amp;quot;}, queryOptions:{ignoreCase:true}})
	the URL will become:   /url.php?q=abc&amp;amp;c=true
	// The serverQuery-parameter has overruled the query-parameter
	// but the query parameter stays untouched, but is not sent to the server!
	// The serverQuery contains more data than the query, so they might differ!</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
          <parameter name="fetchHandler" type="" usage="required"/>
          <parameter name="errorHandler" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_filterResponse" scope="prototype">
        <summary>If the data from servers needs to be processed before it can be processed by this
	store, then this function should be re-implemented in subclass. This default
	implementation just return the data unchanged.</summary>
        <parameters>
          <parameter name="data" type="The" usage="required">
            <summary>data received from server</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>It throws an error if item is not valid, so you can call it in every method that needs to
	throw an error when item is invalid.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity()</summary>
        <parameters>
          <parameter name="keywordArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentity()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>See dojo.data.api.Identity.getIdentityAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.QueryReadStore._features.dojo.data.api" type="">
    <properties>
      <property name="Read" scope="normal" type="Object"/>
      <property name="Identity" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.data.RailsStore" type="Function" classlike="true" superclass="dojox.data.JsonRestStore">
    <summary>RailsStore is a data store for interacting with RESTful Rails controllers</summary>
    <mixins>
      <mixin scope="instance" location="dojox.data.JsonRestStore"/>
    </mixins>
    <properties>
      <property name="rootAttribute" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>RailsStore is a data store for interacting with RESTful Rails controllers</summary>
      </method>
      <method constructor="preamble" name="preamble" scope="prototype">
        <summary>RailsStore is a data store for interacting with RESTful Rails controllers</summary>
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="" usage="required"/>
          <parameter name="deferred" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.S3Store" type="Function" classlike="true" superclass="dojox.data.JsonRestStore">
    <mixins>
      <mixin scope="instance" location="dojox.data.JsonRestStore"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.ServiceStore" type="Function" classlike="true" superclass="dojox.data.ClientFilter">
    <summary>ServiceStore constructor, instantiate a new ServiceStore
	A ServiceStore can be configured from a JSON Schema. Queries are just
	passed through to the underlying services</summary>
    <description>ServiceStore can do client side caching and result set updating if
	dojox.data.ClientFilter is loaded. Do this add:
		dojo.require("dojox.data.ClientFilter")
	prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
	To utilize client side filtering with a subclass, you can break queries into
	client side and server side components by putting client side actions in
	clientFilter property in fetch calls. For example you could override fetch:
		fetch: function(args){
			// do the sorting and paging on the client side
			args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			// args.query will be passed to the service object for the server side handling
			return this.inherited(arguments);
		}
	When extending this class, if you would like to create lazy objects, you can follow
	the example from dojox.data.tests.stores.ServiceStore:
		var lazyItem = {
			_loadObject: function(callback){
				this.name="loaded";
				delete this._loadObject;
				callback(this);
			}
		};
	setup a byId alias to the api call</description>
    <mixins>
      <mixin scope="instance" location="dojox.data.ClientFilter"/>
    </mixins>
    <properties>
      <property name="service" scope="prototype" type="Object"/>
      <property name="schema" scope="prototype" type="Object"/>
      <property name="idAttribute" scope="instance-prototype" type="Object"/>
      <property name="syncMode" scope="prototype" type="bool"/>
      <property name="estimateCountFactor" scope="prototype" type="Number"/>
      <property name="loadLazyValues" scope="prototype" type="Object"/>
      <property name="_currentId" scope="prototype" type="Number"/>
      <property name="byId" scope="instance" type=""/>
      <property name="_index" scope="instance" type="Object"/>
      <property name="labelAttribute" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <summary>arguments
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	The *estimateCountFactor* parameter
	This parameter is used by the ServiceStore to estimate the total count. When
	paging is indicated in a fetch and the response includes the full number of items
	requested by the fetch's count parameter, then the total count will be estimated
	to be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server
	does not support paging, and the response is the full set of items, where the
	total count is equal to the numer of items returned. If the server does support
	paging, an estimateCountFactor of 2 is a good value for estimating the total count
	It is also possible to override _processResults if the server can provide an exact
	total count.
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary. This will only work with a synchronous capable service.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>ServiceStore constructor, instantiate a new ServiceStore
	A ServiceStore can be configured from a JSON Schema. Queries are just
	passed through to the underlying services</summary>
        <description>ServiceStore can do client side caching and result set updating if
	dojox.data.ClientFilter is loaded. Do this add:
		dojo.require("dojox.data.ClientFilter")
	prior to loading the ServiceStore (ClientFilter must be loaded before ServiceStore).
	To utilize client side filtering with a subclass, you can break queries into
	client side and server side components by putting client side actions in
	clientFilter property in fetch calls. For example you could override fetch:
		fetch: function(args){
			// do the sorting and paging on the client side
			args.clientFilter = {start:args.start, count: args.count, sort: args.sort};
			// args.query will be passed to the service object for the server side handling
			return this.inherited(arguments);
		}
	When extending this class, if you would like to create lazy objects, you can follow
	the example from dojox.data.tests.stores.ServiceStore:
		var lazyItem = {
			_loadObject: function(callback){
				this.name="loaded";
				delete this._loadObject;
				callback(this);
			}
		};
	setup a byId alias to the api call</description>
        <parameters>
          <parameter name="options" type="Keyword" usage="required">
            <summary>arguments
	The *schema* parameter
	This is a schema object for this store. This should be JSON Schema format.
	The *service* parameter
	This is the service object that is used to retrieve lazy data and save results
	The function should be directly callable with a single parameter of an object id to be loaded
	The *idAttribute* parameter
	Defaults to 'id'. The name of the attribute that holds an objects id.
	This can be a preexisting id provided by the server.
	If an ID isn't already provided when an object
	is fetched or added to the store, the autoIdentity system
	will generate an id for it and add it to the index.
	The *estimateCountFactor* parameter
	This parameter is used by the ServiceStore to estimate the total count. When
	paging is indicated in a fetch and the response includes the full number of items
	requested by the fetch's count parameter, then the total count will be estimated
	to be estimateCountFactor multiplied by the provided count. If this is 1, then it is assumed that the server
	does not support paging, and the response is the full set of items, where the
	total count is equal to the numer of items returned. If the server does support
	paging, an estimateCountFactor of 2 is a good value for estimating the total count
	It is also possible to override _processResults if the server can provide an exact
	total count.
	The *syncMode* parameter
	Setting this to true will set the store to using synchronous calls by default.
	Sync calls return their data immediately from the calling function, so
	callbacks are unnecessary. This will only work with a synchronous capable service.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getSchema" scope="prototype"/>
      <method name="getValue" scope="prototype">
        <summary>Gets the value of an item's 'property'</summary>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <summary>The item to get the value from</summary>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <summary>property to look up value for</summary>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <summary>the default value</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="return the plain value since it was found;"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>Gets the value of an item's 'property' and returns
	it.	If this value is an array it is just returned,
	if not, the value is added to an array and that is returned.</summary>
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="property" type="string" usage="required">
            <summary>property to look up value for</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>Gets the available attributes of an item's 'property' and returns
	it as an array.</summary>
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>Checks to see if item has attribute</summary>
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>Checks to see if 'item' has 'value' at 'attribute'</summary>
        <parameters>
          <parameter name="item" type="object" usage="required"/>
          <parameter name="attribute" type="string" usage="required"/>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="isItem" scope="prototype">
        <summary>Checks to see if the argument is an item</summary>
        <parameters>
          <parameter name="item" type="object" usage="required">
            <summary>attribute: /* string</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>Checks to see if the item is loaded.</summary>
        <parameters>
          <parameter name="item" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>Loads an item and calls the callback handler. Note, that this will call the callback
	handler even if the item is loaded. Consequently, you can use loadItem to ensure
	that an item is loaded is situations when the item may or may not be loaded yet.
	If you access a value directly through property access, you can use this to load
	a lazy value as well (doesn't need to be an item).</summary>
        <examples>
          <example>store.loadItem({
	item: item, // this item may or may not be loaded
	onItem: function(item){
	// do something with the item
	}
	});</example>
        </examples>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="" usage="required"/>
          <parameter name="deferred" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <summary>See dojo.data.api.Read.fetch
	The *queryOptions.cache* parameter
	If true, indicates that the query result should be cached for future use. This is only available
	if dojox.data.ClientFilter has been loaded before the ServiceStore
	The *syncMode* parameter
	Indicates that the call should be fetch synchronously if possible (this is not always possible)
	The *clientFetch* parameter
	This is a fetch keyword argument for explicitly doing client side filtering, querying, and paging</summary>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>return the store feature set</summary>
      </method>
      <method name="getLabel" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>returns an array of attributes that are used to create the label of an item</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentity" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>returns the attributes which are used to make up the
	identity of an item.	Basically returns this.idAttribute</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>fetch an item by its identity, by looking in our index of what we have loaded</summary>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.SnapLogicStore" type="Function" classlike="true">
    <summary>Initialize a SnapLogicStore object.</summary>
    <properties>
      <property name="url" scope="instance-prototype" type="A">
        <summary>URL to the SnapLogic pipeline's output routed through PipeToHttp. Typically, this
	will look like &amp;quot;http://&amp;lt;server-host&amp;gt;:&amp;lt;port&amp;gt;/pipe/&amp;lt;pipeline-url&amp;gt;/&amp;lt;pipeline-output-view&amp;gt;&amp;quot;.
	parameters:
	An object whose properties define parameters to the pipeline. The values of these
	properties will be sent to the pipeline as parameters when it run.</summary>
      </property>
      <property name="_parameters" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>An object that contains properties for initializing the new data store object. The
	following properties are understood:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize a SnapLogicStore object.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>An object that contains properties for initializing the new data store object. The
	following properties are understood:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsItem" scope="prototype">
        <summary>This function tests whether the item passed in is indeed an item in the store.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_assertIsAttribute" scope="prototype">
        <summary>This function tests whether the item passed in is indeed a valid 'attribute' like type for the store.</summary>
        <parameters>
          <parameter name="attribute" type="attribute-name-string" usage="required">
            <summary>The attribute to test for being contained by the store.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>See dojo.data.api.Read.getFeatures()</summary>
      </method>
      <method name="getValue" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="defaultValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>See dojo.data.api.Read.hasAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>See dojo.data.api.Read.isItemLoaded()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>See dojo.data.api.Read.loadItem()</summary>
        <parameters>
          <parameter name="keywordArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>See dojo.data.api.Read.containsValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>See dojo.data.api.Read.getValue()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>See dojo.data.api.Read.isItem()</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fetchHandler" scope="prototype">
        <summary>Process data retrieved via fetch and send it back to requester.
	response:
	The data returend from the I/O transport. In the normal case, it will be an array of result rows
	from the pipeline. In the special case for record count optimization, response will be an array
	with a single element containing the total pipeline result row count. See fetch() for details
	on this optimization.</summary>
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_partHandler" scope="prototype">
        <summary>Handle the individual replies for both data and length requests.</summary>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <summary>The request/handle object used with the original fetch() call.</summary>
          </parameter>
          <parameter name="part" type="String" usage="required">
            <summary>A value indicating which request this handler call is for (this.Parts).</summary>
          </parameter>
          <parameter name="response" type="Object" usage="required">
            <summary>Response received from the underlying IO transport.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <summary>See dojo.data.api.Read.close() for generic interface.
	In addition to the standard Read API fetch support, this store supports an optimization for
	for retrieving the total count of records in the Pipeline without retrieving the data. To
	use this optimization, simply provide an onBegin handler without an onItem or onComplete handler.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.data.SnapLogicStore.Parts">
    <properties>
      <property name="DATA" scope="normal" type="String"/>
      <property name="COUNT" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.data.StoreExplorer" type="Function" classlike="true" superclass="dijit.layout.BorderContainer">
    <mixins>
      <mixin scope="instance" location="dijit.layout.BorderContainer"/>
    </mixins>
    <properties>
      <property name="store" scope="prototype" type="Object"/>
      <property name="stringQueries" scope="prototype" type="bool"/>
      <property name="tree" scope="prototype" type="Object"/>
      <property name="gridOnFetchComplete" scope="prototype" type=""/>
      <property name="queryOptions" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="setItemName" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setQuery" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_formatCell" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setStore" scope="prototype">
        <parameters>
          <parameter name="store" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createNew" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.data.StoreExplorer.grid._pending_requests" type="">
    <properties>
      <property name="0" scope="prototype" type="bool"/>
    </properties>
  </object>
  <object location="dojox.data.StoreExplorer.grid">
    <methods>
      <method name="_onFetchComplete" scope="prototype">
        <parameters>
          <parameter name="items" type="" usage="required"/>
          <parameter name="req" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.WikipediaStore" type="Function" classlike="true" superclass="dojox.data.ServiceStore">
    <summary>Initializer for the Wikipedia data store interface.</summary>
    <description>The WikipediaStore is a data store interface to Wikipedia, using the
	Wikipedia SMD spec from dojox.rpc. It currently is useful only for
	finding articles that contain some particular text or grabbing single
	articles by full name; no wildcards or other filtering are supported.</description>
    <mixins>
      <mixin scope="instance" location="dojox.data.ServiceStore"/>
    </mixins>
    <examples>
      <example>	var store = new dojox.data.WikipediaStore();
		store.fetch({
			query: {title:"Dojo Toolkit"},
			onItem: function(item){
				dojo.byId("somediv").innerHTML = item.text["*"];
			}
		});</example>
    </examples>
    <properties>
      <property name="service" scope="instance" type=""/>
      <property name="idAttribute" scope="instance" type="String"/>
      <property name="labelAttribute" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <summary>Fetch a page or some partially-loaded search results from
	Wikipedia. Note that there isn't a way to sort data coming
	in from the API, so we just ignore the *sort* parameter.</summary>
        <examples>
          <example>Loading a page:
		store.fetch({
			query: {title:"Dojo Toolkit"},
			// define your handlers here
		});</example>
          <example>Searching for pages containing "dojo":
		store.fetch({
			query: {
				action: "query",
				text: "dojo"
			},
			// define your handlers here
		});</example>
          <example>Searching for the next 50 pages containing "dojo":
		store.fetch({
			query: {
				action: "query",
				text: "dojo",
				start: 10,
				count: 50 // max 500; will be capped if necessary
			},
			// define your handlers here
		});</example>
        </examples>
        <parameters>
          <parameter name="request" type="object" usage="required"/>
        </parameters>
      </method>
      <method name="_processResults" scope="prototype">
        <parameters>
          <parameter name="results" type="" usage="required"/>
          <parameter name="def" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.XmlStore" type="Function" classlike="true" superclass="dojo.data.util.simpleFetch">
    <summary>A data store for XML based services or documents</summary>
    <description>A data store for XML based services or documents</description>
    <properties>
      <property name="url" scope="instance-prototype" type="The">
        <summary>url to a service or an XML document that represents the store</summary>
      </property>
      <property name="rootItem" scope="instance-prototype" type="A">
        <summary>tag name for root items</summary>
      </property>
      <property name="keyAttribute" scope="instance-prototype" type="An">
        <summary>attribute name for a key or an identity (unique identifier)
	Required for serverside fetchByIdentity, etc.  Not required for
	client side fetchItemBIdentity, as it will use an XPath-like
	structure if keyAttribute was not specified.  Recommended to always
	set this, though, for consistent identity behavior.
	attributeMap:   An anonymous object contains properties for attribute mapping,
	{&amp;quot;tag_name.item_attribute_name&amp;quot;: &amp;quot;@xml_attribute_name&amp;quot;, ...}</summary>
      </property>
      <property name="label" scope="instance-prototype" type="Object"/>
      <property name="sendQuery" scope="instance-prototype" type="A">
        <summary>boolean indicate to add a query string to the service URL.
	Default is false.</summary>
      </property>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="urlPreventCache" scope="instance-prototype" type="Parameter">
        <summary>to indicate whether or not URL calls should apply
	the preventCache option to the xhr request.</summary>
      </property>
      <property name="_newItems" scope="instance-prototype" type="Array"/>
      <property name="_deletedItems" scope="instance-prototype" type="Array"/>
      <property name="_modifiedItems" scope="instance-prototype" type="Array"/>
      <property name="_attributeMap" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="object" usage="required">
            <summary>An anonymous object to initialize properties.  It expects the following values:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Constructor for the XML store.</summary>
        <parameters>
          <parameter name="args" type="object" usage="required">
            <summary>An anonymous object to initialize properties.  It expects the following values:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>Return an attribute value</summary>
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", the tag name of the element is
	returned.
	If 'attribute' specifies "childNodes", the first element child is
	returned.
	If 'attribute' specifies "text()", the value of the first text
	child is returned.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value of the XML
	attribute is returned.
	Otherwise, the first child element of the tag name specified with
	'attribute' is returned.</description>
        <return-description>An attribute value found, otherwise 'defaultValue'</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An XML element that holds the attribute</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A tag name of a child element, An XML attribute name or one of
	special names</summary>
          </parameter>
          <parameter name="defaultValue" type="value" usage="optional">
            <summary>A default value</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="object"/>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getValues" scope="prototype">
        <summary>Return an array of attribute values</summary>
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", the tag name of the element is
	returned.
	If 'attribute' specifies "childNodes", child elements are returned.
	If 'attribute' specifies "text()", the values of child text nodes
	are returned.
	For generic attributes, if 'attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value of the XML
	attribute is returned.
	Otherwise, child elements of the tag name specified with
	'attribute' are returned.</description>
        <return-description>An array of attribute values found, otherwise an empty array</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An XML element that holds the attribute</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A tag name of child elements, An XML attribute name or one of
	special names</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getAttributes" scope="prototype">
        <summary>Return an array of attribute names</summary>
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	tag names of child elements and XML attribute names of attributes
	specified to the element are returned along with special attribute
	names applicable to the element including "tagName", "childNodes"
	if the element has child elements, "text()" if the element has
	child text nodes, and attribute names in '_attributeMap' that match
	the tag name of the element.</description>
        <return-description>An array of attributes found</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An XML element</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="hasAttribute" scope="prototype">
        <summary>Check whether an element has the attribute</summary>
        <return-description>True if the element has the attribute, otherwise false</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>'item' must be an instance of a dojox.data.XmlItem from the store instance.</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A tag name of a child element, An XML attribute name or one of
	special names</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="containsValue" scope="prototype">
        <summary>Check whether the attribute values contain the value</summary>
        <return-description>True if the attribute values contain the value, otherwise false</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>'item' must be an instance of a dojox.data.XmlItem from the store instance.</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A tag name of a child element, An XML attribute name or one of
	special names</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isItem" scope="prototype">
        <summary>Check whether the object is an item (XML element)
	item:
	An object to check</summary>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="boolran"/>
        </return-types>
      </method>
      <method name="isItemLoaded" scope="prototype">
        <summary>Check whether the object is an item (XML element) and loaded
	item:
	An object to check</summary>
        <return-description>True if the object is an XML element, otherwise false</return-description>
        <parameters>
          <parameter name="something" type="anything" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="loadItem" scope="prototype">
        <summary>Load an item (XML element)</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <summary>containing the args for loadItem.  See dojo.data.api.Read.loadItem()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>Return supported data APIs</summary>
        <return-description>"dojo.data.api.Read" and "dojo.data.api.Write"</return-description>
        <return-types>
          <return-type type="array"/>
        </return-types>
      </method>
      <method name="getLabel" scope="prototype">
        <summary>See dojo.data.api.Read.getLabel()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="getLabelAttributes" scope="prototype">
        <summary>See dojo.data.api.Read.getLabelAttributes()</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_fetchItems" scope="prototype">
        <summary>Fetch items (XML elements) that match to a query</summary>
        <description>If 'sendQuery' is true, an XML document is loaded from
	'url' with a query string.
	Otherwise, an XML document is loaded and list XML elements that
	match to a query (set of element names and their text attribute
	values that the items to contain).
	A wildcard, "*" can be used to query values to match all
	occurrences.
	If 'rootItem' is specified, it is used to fetch items.</description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
          <parameter name="fetchHandler" type="A" usage="required">
            <summary>function to call for fetched items</summary>
          </parameter>
          <parameter name="errorHandler" type="A" usage="required">
            <summary>function to call on error</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getFetchUrl" scope="prototype">
        <summary>Generate a URL for fetch</summary>
        <description>This default implementation generates a query string in the form of
	"?name1=value1&amp;name2=value2..." off properties of 'query' object
	specified in 'request' and appends it to 'url', if 'sendQuery'
	is set to false.
	Otherwise, 'url' is returned as is.
	Sub-classes may override this method for the custom URL generation.</description>
        <return-description>A fetch URL</return-description>
        <parameters>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getItems" scope="prototype">
        <summary>Fetch items (XML elements) in an XML document based on a request</summary>
        <description>This default implementation walks through child elements of
	the document element to see if all properties of 'query' object
	match corresponding attributes of the element (item).
	If 'request' is not specified, all child elements are returned.
	Sub-classes may override this method for the custom search in
	an XML document.</description>
        <return-description>An array of items</return-description>
        <parameters>
          <parameter name="document" type="An" usage="required">
            <summary>XML document</summary>
          </parameter>
          <parameter name="request" type="A" usage="required">
            <summary>request object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_flattenNodes" scope="prototype">
        <parameters>
          <parameter name="nodes" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>See dojo.data.api.Read.close()</summary>
        <parameters>
          <parameter name="request" type="dojo.data.api.Request" usage="required">
            <summary>|| keywordArgs || null</summary>
          </parameter>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <summary>Return a new dojox.data.XmlItem</summary>
        <description>At least, 'keywordArgs' must contain "tagName" to be used for
	the new	element.
	Other attributes in 'keywordArgs' are set to the new element,
	including "text()", but excluding "childNodes".</description>
        <return-description>An XML element</return-description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="optional">
            <summary>An object containing initial attributes</summary>
          </parameter>
          <parameter name="parentInfo" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="prototype">
        <summary>Delete an dojox.data.XmlItem (wrapper to a XML element).</summary>
        <return-description>True</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An XML element to delete</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValue" scope="prototype">
        <summary>Set an attribute value</summary>
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", nothing is set and false is
	returned.
	If 'attribute' specifies "childNodes", the value (XML element) is
	added to the element.
	If 'attribute' specifies "text()", a text node is created with
	the value and set it to the element as a child.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the value is set to the XML
	attribute.
	Otherwise, a text node is created with the value and set it to
	the first child element of the tag name specified with 'attribute'.
	If the child element does not exist, it is created.</description>
        <return-description>False for "tagName", otherwise true</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An XML element that holds the attribute</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A tag name of a child element, An XML attribute name or one of
	special names</summary>
          </parameter>
          <parameter name="value" type="almost" usage="required">
            <summary>A attribute value to set</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="setValues" scope="prototype">
        <summary>Set attribute values</summary>
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	If 'attribute' specifies "tagName", nothing is set and false is
	returned.
	If 'attribute' specifies "childNodes", the value (array of XML
	elements) is set to the element's childNodes.
	If 'attribute' specifies "text()", a text node is created with
	the values and set it to the element as a child.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the first value is set to
	the XML attribute.
	Otherwise, child elements of the tag name specified with
	'attribute' are replaced with new child elements and their
	child text nodes of values.</description>
        <return-description>False for "tagName", otherwise true</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An XML element that holds the attribute</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A tag name of child elements, an XML attribute name or one of
	special names
	value:
	A attribute value to set
	notify:
	A non-API optional argument, used to indicate if notification API should be called
	or not.</summary>
          </parameter>
          <parameter name="values" type="array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="unsetAttribute" scope="prototype">
        <summary>Remove an attribute</summary>
        <description>'item' must be an instance of a dojox.data.XmlItem from the store instance.
	'attribute' can be an XML attribute name of the element or one of
	special names described below.
	If 'attribute' specifies "tagName", nothing is removed and false is
	returned.
	If 'attribute' specifies "childNodes" or "text()", all child nodes
	are removed.
	For generic attributes, if '_attributeMap' is specified,
	an actual attribute name is looked up with the tag name of
	the element and 'attribute' (concatenated with '.').
	Then, if 'attribute' starts with "@", the XML attribute is removed.
	Otherwise, child elements of the tag name specified with
	'attribute' are removed.</description>
        <return-description>False for "tagName", otherwise true</return-description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>An XML element that holds the attribute</summary>
          </parameter>
          <parameter name="attribute" type="attribute" usage="required">
            <summary>A tag name of child elements, an XML attribute name or one of
	special names</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <summary>Save new and/or modified items (XML elements)</summary>
        <description>'url' is used to save XML documents for new, modified and/or
	deleted XML elements.</description>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required">
            <summary>An object for callbacks</summary>
          </parameter>
        </parameters>
      </method>
      <method name="revert" scope="prototype">
        <summary>Invalidate changes (new and/or modified elements)</summary>
        <return-description>True</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isDirty" scope="prototype">
        <summary>Check whether an item is new, modified or deleted</summary>
        <description>If 'item' is specified, true is returned if the item is new,
	modified or deleted.
	Otherwise, true is returned if there are any new, modified
	or deleted items.</description>
        <return-description>True if an item or items are new, modified or deleted, otherwise
	false</return-description>
        <parameters>
          <parameter name="item" type="item" usage="optional">
            <summary>An item (XML element) to check</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_saveItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="keywordArgs" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getPostUrl" scope="prototype">
        <summary>Generate a URL for post</summary>
        <description>This default implementation just returns 'url'.
	Sub-classes may override this method for the custom URL.</description>
        <return-description>A post URL</return-description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <summary>item to save</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPutUrl" scope="prototype">
        <summary>Generate a URL for put</summary>
        <description>This default implementation just returns 'url'.
	Sub-classes may override this method for the custom URL.</description>
        <return-description>A put URL</return-description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <summary>item to save</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getDeleteUrl" scope="prototype">
        <summary>Generate a URL for delete</summary>
        <description>This default implementation returns 'url' with 'keyAttribute'
	as a query string.
	Sub-classes may override this method for the custom URL based on
	changes (new, deleted, or modified).</description>
        <return-description>A delete URL</return-description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <summary>item to delete</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="_getPostContent" scope="prototype">
        <summary>Generate a content to post</summary>
        <description>This default implementation generates an XML document for one
	(the first only) new or modified element.
	Sub-classes may override this method for the custom post content
	generation.</description>
        <return-description>A post content</return-description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <summary>item to save</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="XML string"/>
        </return-types>
      </method>
      <method name="_getPutContent" scope="prototype">
        <summary>Generate a content to put</summary>
        <description>This default implementation generates an XML document for one
	(the first only) new or modified element.
	Sub-classes may override this method for the custom put content
	generation.</description>
        <return-description>A post content</return-description>
        <parameters>
          <parameter name="item" type="An" usage="required">
            <summary>item to save</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="XML string"/>
        </return-types>
      </method>
      <method name="_getAttribute" scope="prototype">
        <parameters>
          <parameter name="tagName" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getItem" scope="prototype">
        <parameters>
          <parameter name="element" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getItemIndex" scope="prototype">
        <parameters>
          <parameter name="items" type="" usage="required"/>
          <parameter name="element" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="_backupItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="new or already modified"/>
        </return-types>
      </method>
      <method name="_restoreItems" scope="prototype">
        <parameters>
          <parameter name="items" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_forgetItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getDocument" scope="prototype">
        <parameters>
          <parameter name="element" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getRootElement" scope="prototype">
        <parameters>
          <parameter name="element" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DOMElement"/>
        </return-types>
      </method>
      <method name="_getXPath" scope="prototype">
        <summary>A function to compute the xpath of a node in a DOM document.</summary>
        <description>A function to compute the xpath of a node in a DOM document.  Used for
	Client side query handling and identity.</description>
        <parameters>
          <parameter name="element" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="getIdentity" scope="prototype">
        <summary>Returns a unique identifier for an item.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The XML Item from the store from which to obtain its identifier.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String."/>
        </return-types>
      </method>
      <method name="getIdentityAttributes" scope="prototype">
        <summary>Returns an array of attribute names that are used to generate the identity.</summary>
        <description>For XmlStore, if sendQuery is false and no keyAttribute was set, then this function
	returns null, as xpath is used for the identity, which is not a public attribute of
	the item.  If sendQuery is true and keyAttribute is set, then this function
	returns an array of one attribute name: keyAttribute.   This means the server side
	implementation must apply a keyAttribute to a returned node that always allows
	it to be looked up again.</description>
        <parameters>
          <parameter name="item" type="item" usage="required">
            <summary>The item from the store from which to obtain the array of public attributes that
	compose the identifier, if any.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="array"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="fetchItemByIdentity" scope="prototype">
        <summary>See dojo.data.api.Identity.fetchItemByIdentity(keywordArgs)</summary>
        <parameters>
          <parameter name="keywordArgs" type="object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.XmlItem" type="Function" classlike="true">
    <summary>A data item of 'XmlStore'</summary>
    <description>This class represents an item of 'XmlStore' holding an XML element.
	'element'
	element:
	An XML element</description>
    <properties>
      <property name="element" scope="instance" type="An">
        <summary>XML element</summary>
      </property>
      <property name="store" scope="instance" type="The">
        <summary>containing store, if any.
	query:
	The query to use to look up a specific element.
	Usually an XPath or dojo.query statement.</summary>
      </property>
      <property name="q" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="element" type="An" usage="required">
            <summary>XML element</summary>
          </parameter>
          <parameter name="store" type="The" usage="required">
            <summary>containing store, if any.</summary>
          </parameter>
          <parameter name="query" type="The" usage="required">
            <summary>query to use to look up a specific element.
	Usually an XPath or dojo.query statement.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize with an XML element</summary>
        <parameters>
          <parameter name="element" type="An" usage="required">
            <summary>XML element</summary>
          </parameter>
          <parameter name="store" type="The" usage="required">
            <summary>containing store, if any.</summary>
          </parameter>
          <parameter name="query" type="The" usage="required">
            <summary>query to use to look up a specific element.
	Usually an XPath or dojo.query statement.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <summary>Return a value of the first text child of the element</summary>
        <return-description>a value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.data.css.rules">
    <methods>
      <method name="forEach" scope="normal">
        <parameters>
          <parameter name="fn" type="" usage="required"/>
          <parameter name="ctx" type="" usage="required"/>
          <parameter name="context" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.css">
    <methods>
      <method name="findStyleSheets" scope="normal">
        <parameters>
          <parameter name="sheets" type="" usage="required"/>
        </parameters>
      </method>
      <method name="findStyleSheet" scope="normal">
        <parameters>
          <parameter name="sheet" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="IE stylesheet has imports[] containing @import'ed rules"/>
        </return-types>
      </method>
      <method name="determineContext" scope="normal">
        <parameters>
          <parameter name="initialStylesheets" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.dom">
    <methods>
      <method name="createDocument" scope="normal">
        <summary>cross-browser implementation of creating an XML document object.</summary>
        <parameters>
          <parameter name="str" type="string" usage="optional">
            <summary>Optional text to create the document from.  If not provided, an empty XML document will be created.
	If str is empty string &amp;quot;&amp;quot;, then a new empty document will be created.</summary>
          </parameter>
          <parameter name="mimetype" type="string" usage="optional">
            <summary>Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMDocument."/>
        </return-types>
      </method>
      <method name="textContent" scope="normal">
        <summary>Implementation of the DOM Level 3 attribute; scan node for text</summary>
        <description>Implementation of the DOM Level 3 attribute; scan node for text
	This function can also update the text of a node by replacing all child
	content of the node.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>The node to get the text off of or set the text on.</summary>
          </parameter>
          <parameter name="text" type="string" usage="optional">
            <summary>Optional argument of the text to apply to the node.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="replaceChildren" scope="normal">
        <summary>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</summary>
        <description>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</description>
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <summary>The node to modify the children on</summary>
          </parameter>
          <parameter name="newChildren" type="Node" usage="required">
            <summary>The children to add to the node.  It can either be a single Node or an
	array of Nodes.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeChildren" scope="normal">
        <summary>removes all children from node and returns the count of children removed.
	The children nodes are not destroyed. Be sure to call dojo._destroyElement on them
	after they are not used anymore.</summary>
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <summary>The node to remove all the children from.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="innerXML" scope="normal">
        <summary>Implementation of MS's innerXML function.</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>The node from which to generate the XML text representation.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="string"/>
          <return-type type=""/>
          <return-type type="null"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.rpc.Rest" type="Function">
    <summary>Creates a REST service using the provided path.</summary>
    <properties>
      <property name="_index" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="_get" scope="normal">
        <parameters>
          <parameter name="service" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="server error, let the error propagate"/>
        </return-types>
      </method>
      <method name="_change" scope="normal">
        <parameters>
          <parameter name="method" type="" usage="required"/>
          <parameter name="service" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
          <parameter name="serializedContent" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.data.util"/>
  <object location="dojox.data.util.JsonQuery" type="Function" classlike="true">
    <summary>Indicates that simplified queries should be generated. Simplified queries are of the form:
	?name='value'  (instead of [?(@.name='value')])</summary>
    <properties>
      <property name="useFullIdInQueries" scope="prototype" type="bool"/>
      <property name="simplifiedQuery" scope="prototype" type="bool"/>
      <property name="jsonQueryPagination" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_toJsonQuery" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
          <parameter name="jsonQueryPagination" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isUpdateable" scope="prototype"/>
      <method name="matchesQuery" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="request" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clientSideFetch" scope="prototype">
        <parameters>
          <parameter name="request" type="Object" usage="required"/>
          <parameter name="baseResults" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="querySuperSet" scope="prototype">
        <parameters>
          <parameter name="argsSuper" type="" usage="required"/>
          <parameter name="argsSub" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.date.buddhist">
    <methods>
      <method name="getDaysInMonth" scope="normal">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
        </parameters>
      </method>
      <method name="isLeapYear" scope="normal">
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="normal">
        <summary>Compare two buddhist date objects by date, time, or both.</summary>
        <parameters>
          <parameter name="date1" type="buddhist.Date" usage="required"/>
          <parameter name="date2" type="buddhist.Date" usage="required"/>
          <parameter name="portion" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="FIXME"/>
        </return-types>
      </method>
      <method name="add" scope="normal">
        <summary>Add to a Date in intervals of different size, from milliseconds to years</summary>
        <parameters>
          <parameter name="date" type="dojox.date.buddhist.Date" usage="required">
            <summary>buddhist.Date Date object to start with</summary>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <summary>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</summary>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <summary>How much to add to the date.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.date.buddhist.Date"/>
        </return-types>
      </method>
      <method name="difference" scope="normal">
        <summary>date1 - date2
	date2 is hebrew.Date object.  If not specified, the current hebrew.Date is used.</summary>
        <parameters>
          <parameter name="date1" type="dojox.date.buddhist.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.buddhist.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional">
            <summary>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;,  &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number (integer)"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.date.buddhist.Date" type="Function" classlike="true">
    <summary>This is the constructor</summary>
    <description>This fucntion initialize the date object values</description>
    <examples>
      <example>		var date1 = new dojox.date.buddhist.Date();
			var date2 = new dojox.date.buddhist.Date(date1);
			var date3 = new dojox.date.buddhist.Date(2552,2,12);</example>
    </examples>
    <properties>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Number"/>
      <property name="_year" scope="instance-prototype" type="Number"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>This is the constructor</summary>
        <description>This fucntion initialize the date object values</description>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			var date2 = new dojox.date.buddhist.Date(date1);
			var date3 = new dojox.date.buddhist.Date(2552,2,12);</example>
        </examples>
      </method>
      <method name="getDate" scope="prototype">
        <summary>This function returns the date value (0 - 30)</summary>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			console.log(date1.getDate());</example>
        </examples>
        <parameters>
          <parameter name="isNumber" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="getMonth" scope="prototype">
        <summary>This function return the month value ( 0 - 11 )</summary>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			console.log(date1.getMonth()+1);</example>
        </examples>
      </method>
      <method name="getFullYear" scope="prototype">
        <summary>This function return the Year value</summary>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			console.log(date1.getFullYear());</example>
        </examples>
      </method>
      <method name="getHours" scope="prototype">
        <summary>returns the Hour value</summary>
      </method>
      <method name="getMinutes" scope="prototype">
        <summary>returns the Minuites value</summary>
      </method>
      <method name="getSeconds" scope="prototype">
        <summary>returns the seconde value</summary>
      </method>
      <method name="getMilliseconds" scope="prototype">
        <summary>returns the Milliseconds value</summary>
      </method>
      <method name="setDate" scope="prototype">
        <summary>This function sets the Date</summary>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			date1.setDate(2);</example>
        </examples>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setFullYear" scope="prototype">
        <summary>This function set Year</summary>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			date1.setFullYear(2552);
			date1.setFullYear(2552, 1, 1);</example>
        </examples>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
          <parameter name="month" type="number" usage="optional"/>
          <parameter name="date" type="number" usage="optional"/>
        </parameters>
      </method>
      <method name="setMonth" scope="prototype">
        <summary>This function set Month</summary>
        <examples>
          <example>		var date1 = new dojox.date.buddhist.Date();
			date1.setMonth(0); //first month</example>
        </examples>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="prototype">
        <summary>set the Hours  0-23</summary>
      </method>
      <method name="setMinutes" scope="prototype">
        <summary>set the Minutes  frm 0-59</summary>
        <parameters>
          <parameter name="minutes" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="prototype">
        <summary>set the Seconds  from 0-59</summary>
        <parameters>
          <parameter name="seconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="prototype">
        <summary>set the milliseconds</summary>
        <parameters>
          <parameter name="milliseconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <summary>This returns a string representation of the date in &amp;quot;dd, MM, YYYY HH:MM:SS&amp;quot; format</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getDaysInMonth" scope="prototype">
        <parameters>
          <parameter name="month" type="number" usage="required"/>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="fromGregorian" scope="prototype">
        <summary>This function sets this Date to the Hebrew Date corresponding to the Gregorian Date</summary>
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="toGregorian" scope="prototype">
        <summary>This returns the equivalent Gregorian date value as a Date object</summary>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getDay" scope="prototype">
        <summary>This function return Week Day value ( 0 - 6 )</summary>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="valueOf" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.date">
    <summary>Additional date manipulation functions</summary>
    <properties>
      <property name="timezone" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.date.buddhist.locale">
    <methods>
      <method name="format" scope="normal">
        <summary>Format a Date object as a String, using  settings.</summary>
        <parameters>
          <parameter name="dateObject" type="buddhist.Date" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="normal">
        <summary>Builds the regular needed to parse a buddhist.Date</summary>
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="normal">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="normal">
        <summary>This function parse string date value according to options</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="addCustomFormats" scope="normal">
        <summary>Add a reference to a bundle containing localized custom formats to be
	used by date/time formatting and parsing routines.</summary>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getBuddhistBundle" scope="normal">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="normal">
        <summary>Used to get localized strings from dojo.cldr for day or month names.</summary>
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="date" type="buddhist" usage="required">
            <summary>Date Object?</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.date.hebrew">
    <methods>
      <method name="getDaysInMonth" scope="normal">
        <parameters>
          <parameter name="month" type="hebrew.Date" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="normal">
        <summary>Compare two hebrew date objects by date, time, or both.</summary>
        <description>Returns 0 if equal, positive if a &gt; b, else negative.
	date1:
	hebrew.Date object
	date2:
	hebrew.Date object.  If not specified, the current hebrew.Date is used.</description>
        <parameters>
          <parameter name="dateheb1" type="hebrew.Date" usage="required"/>
          <parameter name="dateheb2" type="hebrew.Date" usage="required"/>
          <parameter name="portion" type="String" usage="optional">
            <summary>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="normal">
        <summary>Add to a Date in intervals of different size, from milliseconds to years</summary>
        <parameters>
          <parameter name="date" type="dojox.date.hebrew.Date" usage="required">
            <summary>hebrew.Date Date object to start with</summary>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <summary>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</summary>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <summary>How much to add to the date.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.date.hebrew.Date"/>
        </return-types>
      </method>
      <method name="difference" scope="normal">
        <summary>date1 - date2
	date2 is hebrew.Date object.  If not specified, the current hebrew.Date is used.</summary>
        <parameters>
          <parameter name="date1" type="dojox.date.hebrew.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.hebrew.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional">
            <summary>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;,  &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number (integer)"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.date.hebrew.Date" type="Function" classlike="true">
    <summary>A Date-like object which implements the Hebrew calendar</summary>
    <description>A Date-like object which implements the Hebrew Calendar.  Because this object
	implements many of the same methods as the native JavaScript Date object, which
	implements the Gregorian calendar, it can often be used its place.  Note that
	this object does not extend Date or use its prototype.</description>
    <examples>
      <example>	dojo.require("dojox.date.hebrew.Date");
		var date = new dojox.date.hebrew.Date();
		console.log(date.getFullYear()+'\'+date.getMonth()+'\'+date.getDate());</example>
    </examples>
    <properties>
      <property name="_MONTH_LENGTH" scope="prototype" type="Array"/>
      <property name="_MONTH_START" scope="prototype" type="Array"/>
      <property name="_LEAP_MONTH_START" scope="prototype" type="Array"/>
      <property name="_GREGORIAN_MONTH_COUNT" scope="prototype" type="Array"/>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Number"/>
      <property name="_year" scope="instance-prototype" type="String"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>initialize the date object value</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			var date2 = new dojox.date.hebrew.Date(date1);
			var date3 = new dojox.date.hebrew.Date(5768,2,12);</example>
        </examples>
      </method>
      <method name="getDate" scope="prototype">
        <summary>returns the date value (1 - 30)</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			console.log(date1.getDate());</example>
        </examples>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getDateLocalized" scope="prototype">
        <summary>returns the date value as hebrew numerals for the Hebrew locale,
	a number for all others.</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			console.log(date1.getDate());</example>
        </examples>
        <parameters>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getMonth" scope="prototype">
        <summary>returns the month value (0 - 12)</summary>
        <description>the result is the index in the month array:
	0. Tishri
	1. Heshvan
	2. Kislev
	3. Tevet
	4. Shevat
	5. Adar I (leap years only)
	6. Adar
	7. Nisan
	8. Iyar
	9. Sivan
	10. Tammuz
	11.	Av
	12. Elul - 12
	For non leap years, for months after Shevat, the actual position of
	the month in the year (used for short format) is less than
	the "absolute" index by 1.</description>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			console.log(date1.getMonth()+1);
			&gt;&gt; 7</example>
        </examples>
      </method>
      <method name="getFullYear" scope="prototype">
        <summary>returns the Year value</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			console.log(date1.getFullYear());
			&gt;&gt; 5769</example>
        </examples>
      </method>
      <method name="getHours" scope="prototype">
        <summary>returns the hour value</summary>
      </method>
      <method name="getMinutes" scope="prototype">
        <summary>returns the minutes value</summary>
      </method>
      <method name="getSeconds" scope="prototype">
        <summary>returns the seconds value</summary>
      </method>
      <method name="getMilliseconds" scope="prototype">
        <summary>returns the milliseconds value</summary>
      </method>
      <method name="setDate" scope="prototype">
        <summary>sets the date number for a given month</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			date1.setDate(2);</example>
        </examples>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setFullYear" scope="prototype">
        <summary>set the year</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setFullYear(5768);
			date1.setFullYear(5768, 1, 1);</example>
        </examples>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
          <parameter name="month" type="number" usage="optional"/>
          <parameter name="date" type="number" usage="optional"/>
        </parameters>
      </method>
      <method name="setMonth" scope="prototype">
        <summary>sets the month.  You should use &amp;quot;absolute&amp;quot; index in the month array:
	0. Tishri
	1. Heshvan
	2. Kislev
	3. Tevet
	4. Shevat
	5. Adar I (leap years only)
	6. Adar
	7. Nisan
	8. Iyar
	9. Sivan
	10. Tammuz
	11.	Av
	12. Elul - 12
	For non leap years, for months after Shevat, the actual position of
	the month in the year (used for short format) is less than
	the &amp;quot;absolute&amp;quot; index by 1.</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setMonth(0); //first month</example>
        </examples>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="prototype">
        <summary>sets the hour</summary>
        <description>Sets the hour and optionally minutes, seconds, milliseconds also.</description>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setHours(12, 30, 0, 0);</example>
        </examples>
      </method>
      <method name="setMinutes" scope="prototype">
        <summary>sets the minutes (0-59)</summary>
        <parameters>
          <parameter name="minutes" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="prototype">
        <summary>sets the seconds (0-59)</summary>
        <parameters>
          <parameter name="seconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="prototype">
        <summary>sets the milliseconds</summary>
        <parameters>
          <parameter name="milliseconds" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setDay" scope="prototype"/>
      <method name="toString" scope="prototype">
        <summary>returns a string representation of the date in &amp;quot;dd, MM, yyyy HH:mm:ss&amp;quot; format</summary>
        <description>returns a string representation of the date in "dd, MM, yyyy HH:mm:ss" format (all numeric)
	For user presentation, use dojox.date.hebrew.locale.format which will present in the appropriate language
	and format.  toString() language- and culturally-specific conventions to keep this module free of
	dependencies on dojox.date.locale and dojo.cldr.</description>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date(5769, 6, 1);
			console.log(date1.toString());
			&gt;&gt;&gt; "1, 6, 5769 0:0:0"</example>
        </examples>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getDaysInHebrewMonth" scope="prototype">
        <summary>returns the number of days in the given month and year</summary>
        <parameters>
          <parameter name="month" type="Number" usage="required"/>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_yearType" scope="prototype">
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_handleGetYearLength" scope="prototype">
        <parameters>
          <parameter name="eyear" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="_startOfYear" scope="prototype">
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="isLeapYear" scope="prototype">
        <summary>Determines if the year (argument) is a leap year</summary>
        <description>The Leap year contains additional month adar sheni
	return (year * 12 + 17) % 19 &gt;= 12;</description>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="fromGregorian" scope="prototype">
        <summary>This function sets this Date to the Hebrew Date corresponding to the Gregorian Date</summary>
        <examples>
          <example>		var dateHebrew = new dojox.date.hebrew.Date();
			var dateGregorian = new Date(2008,10,12);
			dateHebrew.fromGregorian(dateGregorian);</example>
        </examples>
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_computeHebrewFields" scope="prototype">
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="toGregorian" scope="prototype">
        <summary>returns the equivalent Grogorian date value as a native Date object</summary>
        <examples>
          <example>		var dateHebrew = new dojox.date.hebrew.Date(5768,11,20);
			var dateGregorian = dateHebrew.toGregorian();</example>
        </examples>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="_floorDivide" scope="prototype">
        <parameters>
          <parameter name="numerator" type="" usage="required"/>
          <parameter name="denominator" type="" usage="required"/>
          <parameter name="remainder" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getDay" scope="prototype">
        <summary>returns weekday value (0 - 6)</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			console.log(date1.getDay());</example>
        </examples>
      </method>
      <method name="_getJulianDayFromGregorianDate" scope="prototype">
        <summary>returns the Julian day of a Gregorian date</summary>
        <parameters>
          <parameter name="gdate" type="" usage="required"/>
        </parameters>
      </method>
      <method name="valueOf" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.date.hebrew.locale">
    <methods>
      <method name="format" scope="normal">
        <summary>Format a Date object as a String, using  settings.</summary>
        <description>Create a string from a hebrew.Date object using a known pattern.
	By default, this method formats both date and time from dateObject.
	Default formatting lengths is 'short'</description>
        <parameters>
          <parameter name="dateObject" type="hebrew.Date" usage="required">
            <summary>the date and/or time to be formatted.  If a time only is formatted,
	the values in the year, month, and day fields are irrelevant.  The
	opposite is true when formatting only dates.</summary>
          </parameter>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="normal">
        <summary>Builds the regular needed to parse a hebrew.Date</summary>
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="normal">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="normal">
        <summary>This function parse string date value according to options</summary>
        <examples>
          <example>		var dateHebrew = dojox.date.hebrew.locale.parse('11/10/5740', {datePattern:'dd/MM/yy', selector:'date'});
			in Hebrew locale string for parsing contains Hebrew Numerals
		options = {datePattern:'dd MMMM yy', selector:'date'};
		 y - year
		 M, MM  - short month
		MMM, MMMM - long month
		d - date
		a - am, pm
		 E, EE, EEE, EEEE  - week day
			h, H, k, K, m, s, S,  -  time format</example>
        </examples>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="hebrew.Date"/>
        </return-types>
      </method>
      <method name="addCustomFormats" scope="normal">
        <summary>Add a reference to a bundle containing localized custom formats to be
	used by date/time formatting and parsing routines.</summary>
        <description>The user may add custom localized formats where the bundle has properties following the
	same naming convention used by dojo.cldr: `dateFormat-xxxx` / `timeFormat-xxxx`
	The pattern string should match the format used by the CLDR.
	See dojo.date.locale.format() for details.
	The resources must be loaded by dojo.requireLocalization() prior to use</description>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getHebrewBundle" scope="normal">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="normal">
        <summary>Used to get localized strings from dojo.cldr for day or month names.</summary>
        <parameters>
          <parameter name="item" type="String" usage="required">
            <summary>'months' || 'days'</summary>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <summary>'wide' || 'narrow' || 'abbr' (e.g. &amp;quot;Monday&amp;quot;, &amp;quot;Mon&amp;quot;, or &amp;quot;M&amp;quot; respectively, in English)
	use:
	'standAlone' || 'format' (default)</summary>
          </parameter>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional">
            <summary>override locale used to find the names
	using  var monthNames = dojox.date.hebrew.locale.getNames('months', 'wide', 'format', 'he');</summary>
          </parameter>
          <parameter name="date" type="hebrew" usage="required">
            <summary>Date Object?</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.date.hebrew.numerals">
    <methods>
      <method name="getYearHebrewLetters" scope="normal">
        <summary>This function return year written in Hebrew numbers-letters,</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			document.writeln(dojox.date.hebrew.numerals.getYearHebrewLetters(date1.getFullYear());</example>
        </examples>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parseYearHebrewLetters" scope="normal">
        <summary>This function return year in format number from  the year written in Hebrew numbers-letters</summary>
        <examples>
          <example>		var date = new dojox.date.hebrew.Date();
						date.setFullYear(dojox.date.hebrew.numerals.parseYearHebrewLetters('"'));</example>
        </examples>
        <parameters>
          <parameter name="year" type="String" usage="required">
            <summary>hebrew year</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getDayHebrewLetters" scope="normal">
        <summary>This function return date written in Hebrew numbers-letter,  can be in format &amp;times; or &amp;times;' (with geresh)</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			document.writeln(dojox.date.hebrew.numerals.getDayHebrewLetters(date1.getDay());</example>
        </examples>
        <parameters>
          <parameter name="day" type="" usage="required"/>
          <parameter name="nogrsh" type="boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parseDayHebrewLetters" scope="normal">
        <summary>This function return date in format number from  the date written in Hebrew numbers-letter</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			date1.setDate(dojox.date.hebrew.numerals.parseDayHebrewLetters(''));</example>
        </examples>
        <parameters>
          <parameter name="day" type="String" usage="required">
            <summary>hebrew</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="getMonthHebrewLetters" scope="normal">
        <summary>This function return month written in Hebrew numerals</summary>
        <examples>
          <example>		var date1 = new dojox.date.hebrew.Date();
			document.writeln(dojox.date.hebrew.numerals.getMonthHebrewLetters(date1.getMonth());</example>
        </examples>
        <parameters>
          <parameter name="month" type="int" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="parseMonthHebrewLetters" scope="normal">
        <summary>This function return month in format number from  the month written in Hebrew  word  or numbers-letters
	the return number is index in month name array, to use it for setMont, do correction for leap year</summary>
        <examples>
          <example>		var date = new dojox.date.hebrew.Date();
							var number = dojox.date.hebrew.numerals.parseMonthHebrewLetters("");
			date.setMonth(number);</example>
        </examples>
        <parameters>
          <parameter name="monthStr" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.date.islamic">
    <methods>
      <method name="getDaysInMonth" scope="normal">
        <parameters>
          <parameter name="month" type="islamic.Date" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="normal">
        <summary>Compare two islamic date objects by date, time, or both.</summary>
        <description>Returns 0 if equal, positive if a &gt; b, else negative.</description>
        <parameters>
          <parameter name="date1" type="islamic.Date" usage="required">
            <summary>object</summary>
          </parameter>
          <parameter name="date2" type="islamic.Date" usage="required">
            <summary>object.  If not specified, the current islamic.Date is used.</summary>
          </parameter>
          <parameter name="portion" type="String" usage="optional">
            <summary>A string indicating the &amp;quot;date&amp;quot; or &amp;quot;time&amp;quot; portion of a Date object.
	Compares both &amp;quot;date&amp;quot; and &amp;quot;time&amp;quot; by default.  One of the following:
	&amp;quot;date&amp;quot;, &amp;quot;time&amp;quot;, &amp;quot;datetime&amp;quot;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="add" scope="normal">
        <summary>Add to a Date in intervals of different size, from milliseconds to years</summary>
        <parameters>
          <parameter name="date" type="dojox.date.islamic.Date" usage="required">
            <summary>islamic.Date Date object to start with</summary>
          </parameter>
          <parameter name="interval" type="String" usage="required">
            <summary>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;, &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;</summary>
          </parameter>
          <parameter name="amount" type="int" usage="required">
            <summary>How much to add to the date.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.date.islamic.Date"/>
        </return-types>
      </method>
      <method name="difference" scope="normal">
        <summary>date1 - date2
	date2 is islamic.Date object.  If not specified, the current islamic.Date is used.</summary>
        <parameters>
          <parameter name="date1" type="dojox.date.islamic.Date" usage="required"/>
          <parameter name="date2" type="dojox.date.islamic.Date" usage="optional"/>
          <parameter name="interval" type="String" usage="optional">
            <summary>A string representing the interval.  One of the following:
	&amp;quot;year&amp;quot;, &amp;quot;month&amp;quot;, &amp;quot;day&amp;quot;, &amp;quot;hour&amp;quot;, &amp;quot;minute&amp;quot;, &amp;quot;second&amp;quot;,
	&amp;quot;millisecond&amp;quot;,  &amp;quot;week&amp;quot;, &amp;quot;weekday&amp;quot;
	Defaults to &amp;quot;day&amp;quot;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number (integer)"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.date.islamic.Date" type="Function" classlike="true">
    <summary>The component defines the Islamic (Hijri) Calendar Object</summary>
    <description>This module is similar to the Date() object provided by JavaScript</description>
    <examples>
      <example>	dojo.require("dojox.date.islamic.Date");
		var date = new dojox.date.islamic.Date();
		document.writeln(date.getFullYear()+'\'+date.getMonth()+'\'+date.getDate());</example>
    </examples>
    <properties>
      <property name="_date" scope="instance-prototype" type="Object"/>
      <property name="_month" scope="instance-prototype" type="Object"/>
      <property name="_year" scope="instance-prototype" type="String"/>
      <property name="_hours" scope="instance-prototype" type="Object"/>
      <property name="_minutes" scope="instance-prototype" type="Object"/>
      <property name="_seconds" scope="instance-prototype" type="Object"/>
      <property name="_milliseconds" scope="instance-prototype" type="Object"/>
      <property name="_day" scope="prototype" type="Object"/>
      <property name="_GREGORIAN_EPOCH" scope="prototype" type="Number"/>
      <property name="_ISLAMIC_EPOCH" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>This is the constructor</summary>
        <description>This function initialize the date object values</description>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			var date2 = new dojox.date.islamic.Date("12\2\1429");
			var date3 = new dojox.date.islamic.Date(date2);
			var date4 = new dojox.date.islamic.Date(1429,2,12);</example>
        </examples>
      </method>
      <method name="getDate" scope="prototype">
        <summary>This function returns the date value (1 - 30)</summary>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.getDate);</example>
        </examples>
      </method>
      <method name="getMonth" scope="prototype">
        <summary>This function return the month value ( 0 - 11 )</summary>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.getMonth()+1);</example>
        </examples>
      </method>
      <method name="getFullYear" scope="prototype">
        <summary>This function return the Year value</summary>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.getFullYear());</example>
        </examples>
      </method>
      <method name="getDay" scope="prototype">
        <summary>This function return Week Day value ( 0 - 6 )</summary>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.getDay());</example>
        </examples>
      </method>
      <method name="getHours" scope="prototype">
        <summary>returns the Hour value</summary>
      </method>
      <method name="getMinutes" scope="prototype">
        <summary>returns the Minuites value</summary>
      </method>
      <method name="getSeconds" scope="prototype">
        <summary>returns the seconde value</summary>
      </method>
      <method name="getMilliseconds" scope="prototype">
        <summary>returns the Milliseconds value</summary>
      </method>
      <method name="setDate" scope="prototype">
        <summary>This function sets the Date</summary>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			date1.setDate(2);</example>
        </examples>
        <parameters>
          <parameter name="date" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setFullYear" scope="prototype">
        <summary>This function set Year</summary>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			date1.setYear(1429);</example>
        </examples>
        <parameters>
          <parameter name="year" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMonth" scope="prototype">
        <summary>This function set Month</summary>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			date1.setMonth(2);</example>
        </examples>
        <parameters>
          <parameter name="month" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setHours" scope="prototype">
        <summary>set the Hours</summary>
      </method>
      <method name="setMinutes" scope="prototype">
        <summary>set the Minutes</summary>
        <parameters>
          <parameter name="minutes" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setSeconds" scope="prototype">
        <summary>set Seconds</summary>
        <parameters>
          <parameter name="seconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="setMilliseconds" scope="prototype">
        <summary>set the Millisconds</summary>
        <parameters>
          <parameter name="milliseconds" type="number" usage="required"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype">
        <summary>This returns a string representation of the date in &amp;quot;DDDD MMMM DD YYYY HH:MM:SS&amp;quot; format</summary>
        <examples>
          <example>		var date1 = new dojox.date.islamic.Date();
			document.writeln(date1.toString());</example>
        </examples>
      </method>
      <method name="toGregorian" scope="prototype">
        <summary>This returns the equevalent Grogorian date value in Date object</summary>
        <examples>
          <example>		var dateIslamic = new dojox.date.islamic.Date(1429,11,20);
			var dateGregorian = dateIslamic.toGregorian();</example>
        </examples>
      </method>
      <method name="fromGregorian" scope="prototype">
        <summary>This function returns the equivalent Islamic Date value for the Gregorian Date</summary>
        <examples>
          <example>		var dateIslamic = new dojox.date.islamic.Date();
			var dateGregorian = new Date(2008,10,12);
			dateIslamic.fromGregorian(dateGregorian);</example>
        </examples>
        <parameters>
          <parameter name="gdate" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="valueOf" scope="prototype">
        <summary>This function returns The stored time value in milliseconds
	since midnight, January 1, 1970 UTC</summary>
      </method>
      <method name="_yearStart" scope="prototype">
        <summary>return start of Islamic year</summary>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_monthStart" scope="prototype">
        <summary>return the start of Islamic Month</summary>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
          <parameter name="month" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_civilLeapYear" scope="prototype">
        <summary>return Boolean value if Islamic leap year</summary>
        <parameters>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="getDaysInIslamicMonth" scope="prototype">
        <summary>returns the number of days in the given Islamic Month</summary>
        <parameters>
          <parameter name="month" type="Number" usage="required">
            <summary>dojox.date.islamic.Date</summary>
          </parameter>
          <parameter name="year" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.date.islamic.Date"/>
        </return-types>
      </method>
      <method name="_mod" scope="prototype">
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.date.islamic.locale">
    <properties>
      <property name="weekDays" scope="normal" type="Object"/>
      <property name="months" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="format" scope="normal">
        <summary>Format a Date object as a String, using  settings.</summary>
        <parameters>
          <parameter name="dateObject" type="islamic.Date" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="regexp" scope="normal">
        <summary>Builds the regular needed to parse a islamic.Date</summary>
        <parameters>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parseInfo" scope="normal">
        <parameters>
          <parameter name="options" type="oblect" usage="optional"/>
        </parameters>
      </method>
      <method name="parse" scope="normal">
        <summary>This function parse string date value according to options</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="options" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="addCustomFormats" scope="normal">
        <summary>Add a reference to a bundle containing localized custom formats to be
	used by date/time formatting and parsing routines.</summary>
        <parameters>
          <parameter name="packageName" type="String" usage="required"/>
          <parameter name="bundleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getIslamicBundle" scope="normal">
        <parameters>
          <parameter name="locale" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getNames" scope="normal">
        <summary>Used to get localized strings from dojo.cldr for day or month names.</summary>
        <parameters>
          <parameter name="item" type="String" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="context" type="String" usage="optional"/>
          <parameter name="locale" type="String" usage="optional"/>
          <parameter name="date" type="islamic" usage="required">
            <summary>Date Object?</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.date.php">
    <methods>
      <method name="format" scope="normal">
        <summary>Get a formatted string for a given date object</summary>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.date.php.DateFormat" type="Function" classlike="true">
    <summary>Format the internal date object</summary>
    <properties>
      <property name="weekdays" scope="prototype" type="Array"/>
      <property name="weekdays_3" scope="prototype" type="Array"/>
      <property name="months" scope="prototype" type="Array"/>
      <property name="months_3" scope="prototype" type="Array"/>
      <property name="monthdays" scope="prototype" type="Array"/>
      <property name="tokens" scope="instance" type="Object"/>
      <property name="replacements" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="d" scope="prototype">
        <summary>Day of the month, 2 digits with leading zeros</summary>
      </method>
      <method name="D" scope="prototype">
        <summary>A textual representation of a day, three letters</summary>
      </method>
      <method name="j" scope="prototype">
        <summary>Day of the month without leading zeros</summary>
      </method>
      <method name="l" scope="prototype">
        <summary>A full textual representation of the day of the week</summary>
      </method>
      <method name="N" scope="prototype">
        <summary>ISO-8601 numeric representation of the day of the week (added in PHP 5.1.0)</summary>
      </method>
      <method name="S" scope="prototype">
        <summary>English ordinal suffix for the day of the month, 2 characters</summary>
      </method>
      <method name="w" scope="prototype">
        <summary>Numeric representation of the day of the week</summary>
      </method>
      <method name="z" scope="prototype">
        <summary>The day of the year (starting from 0)</summary>
      </method>
      <method name="W" scope="prototype">
        <summary>ISO-8601 week number of year, weeks starting on Monday (added in PHP 4.1.0)</summary>
      </method>
      <method name="F" scope="prototype">
        <summary>A full textual representation of a month, such as January or March</summary>
      </method>
      <method name="m" scope="prototype">
        <summary>Numeric representation of a month, with leading zeros</summary>
      </method>
      <method name="M" scope="prototype">
        <summary>A short textual representation of a month, three letters</summary>
      </method>
      <method name="n" scope="prototype">
        <summary>Numeric representation of a month, without leading zeros</summary>
      </method>
      <method name="t" scope="prototype">
        <summary>Number of days in the given month</summary>
      </method>
      <method name="L" scope="prototype">
        <summary>Whether it's a leap year</summary>
      </method>
      <method name="o" scope="prototype">
        <summary>ISO-8601 year number. This has the same value as Y, except that if
	the ISO week number (W) belongs to the previous or next year, that year is used instead. (added in PHP 5.1.0)
	TODO: Figure out what this means</summary>
      </method>
      <method name="Y" scope="prototype">
        <summary>A full numeric representation of a year, 4 digits</summary>
      </method>
      <method name="y" scope="prototype">
        <summary>A two digit representation of a year</summary>
      </method>
      <method name="a" scope="prototype">
        <summary>Lowercase Ante meridiem and Post meridiem</summary>
      </method>
      <method name="b" scope="prototype">
        <summary>Uppercase Ante meridiem and Post meridiem</summary>
      </method>
      <method name="B" scope="prototype">
        <summary>Swatch Internet time
	A day is 1,000 beats. All time is measured from GMT + 1</summary>
      </method>
      <method name="g" scope="prototype">
        <summary>12-hour format of an hour without leading zeros</summary>
      </method>
      <method name="G" scope="prototype">
        <summary>24-hour format of an hour without leading zeros</summary>
      </method>
      <method name="h" scope="prototype">
        <summary>12-hour format of an hour with leading zeros</summary>
      </method>
      <method name="H" scope="prototype">
        <summary>24-hour format of an hour with leading zeros</summary>
      </method>
      <method name="i" scope="prototype">
        <summary>Minutes with leading zeros</summary>
      </method>
      <method name="s" scope="prototype">
        <summary>Seconds, with leading zeros</summary>
      </method>
      <method name="e" scope="prototype">
        <summary>Timezone identifier (added in PHP 5.1.0)</summary>
      </method>
      <method name="I" scope="prototype">
        <summary>Whether or not the date is in daylight saving time
	TODO: Can dojo.date do this?</summary>
      </method>
      <method name="O" scope="prototype">
        <summary>Difference to Greenwich time (GMT) in hours</summary>
      </method>
      <method name="P" scope="prototype">
        <summary>Difference to Greenwich time (GMT) with colon between hours and minutes (added in PHP 5.1.3)</summary>
      </method>
      <method name="T" scope="prototype">
        <summary>Timezone abbreviation</summary>
      </method>
      <method name="Z" scope="prototype">
        <summary>Timezone offset in seconds. The offset for timezones west of UTC is always negative,
	and for those east of UTC is always positive.</summary>
      </method>
      <method name="c" scope="prototype">
        <summary>ISO 8601 date (added in PHP 5)</summary>
      </method>
      <method name="r" scope="prototype">
        <summary>RFC 2822 formatted date</summary>
      </method>
      <method name="U" scope="prototype">
        <summary>Seconds since the Unix Epoch (January 1 1970 00:00:00 GMT)</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.date.php.DateFormat.format" type="Function" classlike="true">
    <properties>
      <property name="date" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.date.php.DateFormat.constructor.prototype" type="">
    <properties>
      <property name="regex" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.date.posix">
    <methods>
      <method name="strftime" scope="normal">
        <summary>Formats the date object using the specifications of the POSIX strftime function</summary>
        <description>see http://www.opengroup.org/onlinepubs/007908799/xsh/strftime.html</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getStartOfWeek" scope="normal">
        <summary>Return a date object representing the first day of the given
	date's week.</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="firstDay" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="setIsoWeekOfYear" scope="normal">
        <summary>Set the ISO8601 week number of the given date.
	The week containing January 4th is the first week of the year.</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="week" type="Number" usage="required">
            <summary>can be positive or negative: -1 is the year's last week.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="getIsoWeekOfYear" scope="normal">
        <summary>Get the ISO8601 week number of the given date.
	The week containing January 4th is the first week of the year.
	See http://en.wikipedia.org/wiki/ISO_week_date</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getIsoWeeksInYear" scope="normal">
        <summary>Determine the number of ISO8601 weeks in the year of the given
	date. Most years have 52 but some have 53.
	See http://www.phys.uu.nl/~vgent/calendar/isocalendar_text3.htm</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.date.relative">
    <methods>
      <method name="format" scope="normal">
        <summary>Format a Date object as a String, using locale-specific settings,
	relative to the current date or some other date.</summary>
        <description>Create a string from a Date object using the most significant information
	and a known localized pattern.  This method formats both the date and
	time from dateObject.  Formatting patterns are chosen appropriate to
	the locale.
	If the day portion of the date falls within the current date (or the
	relativeDate option, if present), then the time will be all that
	is displayed
	If the day portion of the date falls within the past week (or the
	week preceeding relativeDate, if present), then the display will show
	day of week and time.  This functionality can be turned off by setting
	weekCheck to false.
	If the year portion of the date falls within the current year (or the
	year portion of relativeDate, if present), then the display will show
	month and day.
	Otherwise, this function is equivalent to calling dojo.date.format with
	formatLength of "medium"</description>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required">
            <summary>the date and time to be formatted.</summary>
          </parameter>
          <parameter name="options" type="dojox.date.relative.__FormatOptions" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.date.relative.__FormatOptions" type="Function" classlike="true" private="true">
    <properties>
      <property name="locale" scope="instance" type="String">
        <summary>override the locale used to determine formatting rules</summary>
      </property>
      <property name="relativeDate" scope="instance" type="Date">
        <summary>Date to calculate relation to (defaults to new Date())</summary>
      </property>
      <property name="weekCheck" scope="instance" type="boolean">
        <summary>Whether or not to display the day of week (defaults true)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojo._contentHandlers" private="true">
    <methods>
      <method name="olson-zoneinfo" scope="normal">
        <parameters>
          <parameter name="xhr" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="auto" scope="normal">
        <parameters>
          <parameter name="xhr" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.drawing">
    <summary>A vector drawing program</summary>
    <properties>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="register" scope="normal">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getRegistered" scope="normal">
        <parameters>
          <parameter name="type" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.drawing.Drawing" type="Function" classlike="true">
    <summary>Drawing is a project that sits on top of DojoX GFX and uses SVG and
	VML vector graphics to draw and display.</summary>
    <description>Drawing is similar to DojoX Sketch, but is designed to be more versatile
	extendable and customizable.
	Drawing currently only initiates from HTML although it's technically not
	a Dijit to keep the file size light. But if Dijit is available, Drawing
	will register itself with it and can be accessed dijit.byId('myDrawing')
	NOTES:
	Although not Drawing and Toolbar, all other objects are created with a custom
	declare. See dojox.drawing.util.oo
	The files are laid out as such:
	- Drawing
	The master class. More than one instance of a Drawing can be placed
	on a page at one time (although this has not yet been tested). Plugins
	can be added in markup.
	- Toolbar
	Like Drawing, Toolbar is a psudeo Dijit that does not need Dijit. It is
	optional. It can be oriented horizontal or vertical by placing one of
	those params in the class (at least one is required).  Plugins
	can be added in markup. A drawingId is required to point toolbar to
	the drawing.
	- defaults
	Contains the default styles and dimensions for Stencils. An individual
	Stencil can be changed by calling stencil.att({color obj}); To change
	all styles, a custom defaults file should be used.
	-Stencils
	Drawing uses a concept of 'Stencils' to avoid confusion between a
	Dojox Shape and a Drawing Shape. The classes in the 'stencils' package
	are display only, they are not used for actually drawing (see 'tools').
	This package contains _Base from which stencils inherit most of their
	methods.(Path and Image are display only and not found in Tools)
	- Tools
	The Tools package contains Stencils that are attached to mouse events
	and can be used for drawing. Items in this package can also be selected
	and modified.
	- Tools / Custom
	Holds tools that do not directly extend Stencil base classes and often
	have very custom code.
	- Library (not implemented)
	The Library package, which is not yet implemented, will be the place to
	hold stencils that have very specific data points that result in a picture.
	Flag-like-banners, fancy borders, or other complex shapes would go here.
	- Annotations
	Annotations 'decorate' and attach to other Stencils, such as a 'Label'
	that can show text on a stencil, or an 'Angle' that shows while dragging
	or modifying a Vector, or an Arrow head that is attached to the beginning
	or end of a line.
	- Manager
	Contains classes that control functionality of a Drawing.
	- Plugins
	Contains optional classes that are 'plugged into' a Drawing. There are two
	types: 'drawing' plugins that modify the canvas, and 'tools' which would
	show in the toolbar.
	- Util
	A collection of common tasks.</description>
    <examples>
      <example>	&lt;div dojoType="dojox.drawing.Drawing" id="drawing" defaults="myCustom.defaults"
			plugins="[{'name':'dojox.drawing.plugins.drawing.Grid', 'options':{gap:100}}]"&gt;
		 &lt;/div&gt;</example>
      <example>	&lt;div dojoType="dojox.drawing.Toolbar" drawingId="drawing" class="drawingToolbar vertical"&gt;
			&lt;div tool="dojox.drawing.tools.Line" selected="false"&gt;Line&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.Rect" selected="false"&gt;Rect&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.Ellipse" selected="false"&gt;Ellipse&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.TextBlock" selected="false"&gt;Statement&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.custom.Equation" selected="false"&gt;Equation&lt;/div&gt;
			&lt;div plugin="dojox.drawing.plugins.tools.Pan" options="{}"&gt;Pan&lt;/div&gt;
			&lt;div plugin="dojox.drawing.plugins.tools.Zoom" options="{zoomInc:.1,minZoom:.5,maxZoom:2}"&gt;Zoom&lt;/div&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="ready" scope="prototype" type="Boolean">
        <summary>Whether or not the canvas has been created and Stencils can be added</summary>
      </property>
      <property name="mode" scope="instance-prototype" type="String">
        <summary>Changes the functionality of the drawing</summary>
      </property>
      <property name="width" scope="instance-prototype" type="Number">
        <summary>Width of the canvas</summary>
      </property>
      <property name="height" scope="instance-prototype" type="Number">
        <summary>Height of the canvas
	defaults : Object
	Optional replacements for native defaults.
	plugins: Object
	Key values of plugins that apply to canvas.</summary>
      </property>
      <property name="canvas" scope="prototype" type="Object"/>
      <property name="plugins" scope="instance-prototype" type="Array"/>
      <property name="undo" scope="prototype" type="Object"/>
      <property name="anchors" scope="prototype" type="Object"/>
      <property name="uiStencils" scope="prototype" type="Object"/>
      <property name="stencils" scope="prototype" type="Object"/>
      <property name="currentType" scope="prototype" type="Array"/>
      <property name="currentStencil" scope="prototype" type="Object"/>
      <property name="defaults" scope="instance" type=""/>
      <property name="id" scope="instance" type=""/>
      <property name="util" scope="instance" type=""/>
      <property name="keys" scope="instance" type=""/>
      <property name="mouse" scope="instance" type="Object"/>
      <property name="tools" scope="instance" type="Object"/>
      <property name="stencilTypes" scope="instance" type="Object"/>
      <property name="stencilTypeMap" scope="instance" type="Object"/>
      <property name="srcRefNode" scope="instance" type=""/>
      <property name="domNode" scope="instance" type=""/>
      <property name="widgetId" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="HTMLNode" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Drawing is not a Dijit. This is the master method.
	NOTE:
	props is always null since this is not a real widget
	Will change when Drawing can be created programmatically.</summary>
        <parameters>
          <parameter name="props" type="Object" usage="required"/>
          <parameter name="node" type="HTMLNode" usage="required"/>
        </parameters>
      </method>
      <method name="_createCanvas" scope="prototype"/>
      <method name="resize" scope="prototype">
        <summary>Resizes the canvas.
	If within a ContentPane this will get called automatically.
	Can also be called directly.</summary>
        <parameters>
          <parameter name="box" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="getShapeProps" scope="prototype">
        <summary>The common objects that are mixed into
	a new Stencil. Mostly internal, but could be used.</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required"/>
          <parameter name="mode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addPlugin" scope="prototype">
        <summary>Add a toolbar plugin object to plugins array
	to be parsed</summary>
        <parameters>
          <parameter name="plugin" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="initPlugins" scope="prototype">
        <summary>Called from Toolbar after a plugin has been loaded
	The call to this coming from toobar is a bit funky as the timing
	of IE for canvas load is different than other browsers</summary>
      </method>
      <method name="onSurfaceReady" scope="prototype">
        <summary>Event that to which can be connected.
	Fired when the canvas is ready and can be drawn to.</summary>
      </method>
      <method name="addUI" scope="prototype">
        <summary>Use this method to programmatically add Stencils that display on
	the canvas.
	FIXME: Currently only supports Stencils that have been registered,
	which is items in the toolbar, and the additional Stencils at the
	end of onSurfaceReady. This covers all Stencils, but you can't
	use 'display only' Stencils for Line, Rect, and Ellipse.
	arguments:</summary>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <summary>Object The parameters used to draw the object. See stencil._Base and each
	tool for specific parameters of teh data or points objects.</summary>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="addStencil" scope="prototype">
        <summary>Use this method to programmatically add Stencils that display on
	the canvas.
	FIXME: Currently only supports Stencils that have been registered,
	which is items in the toolbar, and the additional Stencils at the
	end of onSurfaceReady. This covers all Stencils, but you can't
	use 'display only' Stencils for Line, Rect, and Ellipse.
	arguments:</summary>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <summary>Object The parameters used to draw the object. See stencil._Base and each
	tool for specific parameters of teh data or points objects.</summary>
          </parameter>
          <parameter name="options" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeStencil" scope="prototype">
        <summary>Use this method to programmatically remove Stencils from the canvas.
	arguments:
	Stencil: Object
	The Stencil to be removed</summary>
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="removeAll" scope="prototype">
        <summary>Deletes all Stencils on the canvas.</summary>
      </method>
      <method name="selectAll" scope="prototype">
        <summary>Selects all stencils</summary>
      </method>
      <method name="toSelected" scope="prototype">
        <summary>Call a function within all selected Stencils
	like attr()</summary>
        <examples>
          <example>	myDrawing.toSelected('attr', {x:10})</example>
        </examples>
        <parameters>
          <parameter name="func" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="exporter" scope="prototype">
        <summary>Collects all Stencil data and returns an
	Array of objects.</summary>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="importer" scope="prototype">
        <summary>Handles an Array of stencil data and imports the objects
	to the drawing.</summary>
        <parameters>
          <parameter name="objects" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="changeDefaults" scope="prototype">
        <summary>Change the defaults so that all Stencils from this
	point on will use the newly changed style.
	arguments:</summary>
        <examples>
          <example>	myDrawing.changeDefaults({
			norm:{
				fill:"#0000ff",
				width:5,
				color:"#ffff00"
			}
		});</example>
        </examples>
        <parameters>
          <parameter name="newStyle" type="Object" usage="required">
            <summary>An object that represents one of the objects in
	drawing.style that will be mixed in. Not all
	properties are necessary. Only one object may
	be changed at a time. Non-objects like angleSnap
	cannot be changed in this manner.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRenderStencil" scope="prototype">
        <summary>Event that fires when a stencil is drawn. Does not fire from
	'addStencil'.
	console.info(&amp;quot;--------------------------------------dojox.drawing.onRenderStencil:&amp;quot;, stencil.id);</summary>
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDeleteStencil" scope="prototype">
        <summary>Event fired from a stencil that has destroyed itself
	will also be called when it is removed by &amp;quot;removeStencil&amp;quot;
	or stencils.onDelete.</summary>
        <parameters>
          <parameter name="stencil" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="registerTool" scope="prototype">
        <summary>Registers a tool that can be accessed. Internal.</summary>
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getConstructor" scope="prototype">
        <summary>Returns a Stencil constructor base on
	abbreviation</summary>
        <parameters>
          <parameter name="abbr" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setTool" scope="prototype">
        <summary>Sets up a new class to be used to draw. Called from Toolbar,
	and this class... after a tool is used a new one of the same
	type is initialized. Could be called externally.</summary>
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="unSetTool" scope="prototype">
        <summary>Destroys current tool</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.drawing.annotations">
    <properties>
      <property name="Angle" scope="normal" type="Object"/>
      <property name="Arrow" scope="normal" type="Object"/>
      <property name="BoxShadow" scope="normal" type="Object"/>
      <property name="Label" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults">
    <summary>Styles and defaults used for Drawing stencils and text.</summary>
    <description>This object contains defaults for objects used in Drawing.
	To change one item's style, use item.attr();
	To change all these styles, create a copy of this file
	and point to it in the Drawing properties:
		&lt;div dojoType="dojox.drawing.Drawing" id="drawing" defaults="MyCustom.defaults"&gt;&lt;/div&gt;
	See:
	Drawing.changeDefaults</description>
    <properties>
      <property name="current" scope="normal" type="Object">
        <summary>current will point to either null or selected</summary>
      </property>
      <property name="currentHit" scope="normal" type="Object">
        <summary>currentHit will point to either hitNorm or hitSelected</summary>
      </property>
      <property name="angleSnap" scope="normal" type="Number">
        <summary>Line, arrows, vector and axes will all snap to this angle on mouse up
	shown angle also reflects the snap
	currently cannot accept less than 1 degree</summary>
      </property>
      <property name="renderHitLines" scope="normal" type="Boolean">
        <summary>If true, renders a second, larger layer for lines to make
	them more easily clickable.</summary>
      </property>
      <property name="renderHitLayer" scope="normal" type="If">
        <summary>true, renders a second layer for each Stencil, one
	acting as a 'hit' object for a wider mouse-click area.
	It also doubles as a hilight. If true, overrides
	renderHitLines setting.</summary>
      </property>
      <property name="labelSameColor" scope="normal" type="If">
        <summary>true, the label text color will be the same as the
	Stencil's line color.</summary>
      </property>
      <property name="useSelectedStyle" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="copy" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.drawing.defaults.norm">
    <summary>Normal style of all shapes
	will get overridden by
	above andes styles
	square, butt, round</summary>
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="color" scope="normal" type="String"/>
      <property name="style" scope="normal" type="String"/>
      <property name="cap" scope="normal" type="String"/>
      <property name="fill" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.selected">
    <summary>Selected style of all shapes
	styles not shown will used from
	norm</summary>
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.highlighted">
    <summary>Highlighted style of all shapes
	NOT CURRENTLY BEING USED</summary>
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="color" scope="normal" type="String"/>
      <property name="style" scope="normal" type="String"/>
      <property name="cap" scope="normal" type="String"/>
      <property name="fill" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.disabled">
    <summary>Disabled or &amp;quot;locked&amp;quot; or &amp;quot;fade&amp;quot; style of all shapes</summary>
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="color" scope="normal" type="String"/>
      <property name="style" scope="normal" type="String"/>
      <property name="cap" scope="normal" type="String"/>
      <property name="fill" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.hitNorm">
    <summary>Normal style of a hit area</summary>
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="style" scope="normal" type="String"/>
      <property name="cap" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.hitNorm.color">
    <properties>
      <property name="r" scope="normal" type="Number"/>
      <property name="g" scope="normal" type="Number"/>
      <property name="b" scope="normal" type="Number"/>
      <property name="a" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.hitNorm.fill">
    <properties>
      <property name="r" scope="normal" type="Number"/>
      <property name="g" scope="normal" type="Number"/>
      <property name="b" scope="normal" type="Number"/>
      <property name="a" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.hitSelected">
    <summary>Selected style of a hit area</summary>
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="color" scope="normal" type="String"/>
      <property name="style" scope="normal" type="String"/>
      <property name="cap" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.hitSelected.fill">
    <properties>
      <property name="r" scope="normal" type="Number"/>
      <property name="g" scope="normal" type="Number"/>
      <property name="b" scope="normal" type="Number"/>
      <property name="a" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.hitHighlighted">
    <summary>Highlighted style of a hit area</summary>
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="color" scope="normal" type="String"/>
      <property name="style" scope="normal" type="String"/>
      <property name="cap" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.hitHighlighted.fill">
    <properties>
      <property name="r" scope="normal" type="Number"/>
      <property name="g" scope="normal" type="Number"/>
      <property name="b" scope="normal" type="Number"/>
      <property name="a" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.anchors">
    <summary>Style for the anchor resize-points
	not really an anchor prop</summary>
    <properties>
      <property name="size" scope="normal" type="Number"/>
      <property name="width" scope="normal" type="Number"/>
      <property name="color" scope="normal" type="String"/>
      <property name="style" scope="normal" type="String"/>
      <property name="fill" scope="normal" type="String"/>
      <property name="cap" scope="normal" type="String"/>
      <property name="minSize" scope="normal" type="Number"/>
      <property name="marginZero" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.arrows">
    <summary>Size of arrows on vectors.
	length is in pixels
	width is actually an angle
	but is close to pixels in size</summary>
    <properties>
      <property name="length" scope="normal" type="Number"/>
      <property name="width" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.text">
    <summary>Style of text</summary>
    <properties>
      <property name="minWidth" scope="normal" type="Number"/>
      <property name="deleteEmptyCreate" scope="normal" type="Object"/>
      <property name="deleteEmptyModify" scope="normal" type="Object"/>
      <property name="pad" scope="normal" type="Number"/>
      <property name="size" scope="normal" type="String"/>
      <property name="family" scope="normal" type="String"/>
      <property name="weight" scope="normal" type="String"/>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.textDisabled">
    <summary>Style of disabled text</summary>
    <properties>
      <property name="size" scope="normal" type="String"/>
      <property name="family" scope="normal" type="String"/>
      <property name="weight" scope="normal" type="String"/>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.textMode">
    <summary>These styles apply to the containing
	text box (edit mode), and not the text itself</summary>
  </object>
  <object location="dojox.drawing.defaults.textMode.create">
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="style" scope="normal" type="String"/>
      <property name="color" scope="normal" type="String"/>
      <property name="fill" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.textMode.edit">
    <properties>
      <property name="width" scope="normal" type="Number"/>
      <property name="style" scope="normal" type="String"/>
      <property name="color" scope="normal" type="String"/>
      <property name="fill" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button"/>
  <object location="dojox.drawing.defaults.button.norm">
    <properties>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button.norm.fill">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x1" scope="normal" type="Number"/>
      <property name="x2" scope="normal" type="Number"/>
      <property name="y1" scope="normal" type="Number"/>
      <property name="y2" scope="normal" type="Number"/>
      <property name="colors" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button.over">
    <properties>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button.over.fill">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x1" scope="normal" type="Number"/>
      <property name="x2" scope="normal" type="Number"/>
      <property name="y1" scope="normal" type="Number"/>
      <property name="y2" scope="normal" type="Number"/>
      <property name="colors" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button.down">
    <properties>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button.down.fill">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x1" scope="normal" type="Number"/>
      <property name="x2" scope="normal" type="Number"/>
      <property name="y1" scope="normal" type="Number"/>
      <property name="y2" scope="normal" type="Number"/>
      <property name="colors" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button.selected">
    <properties>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button.selected.fill">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x1" scope="normal" type="Number"/>
      <property name="x2" scope="normal" type="Number"/>
      <property name="y1" scope="normal" type="Number"/>
      <property name="y2" scope="normal" type="Number"/>
      <property name="colors" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button.icon"/>
  <object location="dojox.drawing.defaults.button.icon.norm">
    <properties>
      <property name="fill" scope="normal" type="Object"/>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.defaults.button.icon.selected">
    <properties>
      <property name="fill" scope="normal" type="String"/>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.library"/>
  <object location="dojox.drawing.library.icons">
    <summary>A collection of icon Stencils for use with the buttons in the ui/Toolbar.</summary>
    <description>Each icon name coresponds to a Stencil or a Plugin. One can be inserted
	into a button by adding the property: 'icon', which points to one of
	these Stencil objects.</description>
  </object>
  <object location="dojox.drawing.library.icons.line">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="x1" scope="normal" type="Number"/>
      <property name="y1" scope="normal" type="Number"/>
      <property name="x2" scope="normal" type="Number"/>
      <property name="y2" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.ellipse">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="cx" scope="normal" type="Number"/>
      <property name="cy" scope="normal" type="Number"/>
      <property name="rx" scope="normal" type="Number"/>
      <property name="ry" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.rect">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="width" scope="normal" type="Number"/>
      <property name="height" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.triangle">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="Object"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.path">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="Object"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.arrow">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="bool"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.textBlock">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="Object"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.axes">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="bool"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.vector">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="bool"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.pan">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="Object"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.plus">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="bool"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.zoomIn">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="bool"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.zoomOut">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="bool"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.zoom100">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="text" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.iconize">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="Object"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.library.icons.pencil">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="borderWidth" scope="normal" type="Number"/>
      <property name="closePath" scope="normal" type="Object"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.drawing.manager">
    <properties>
      <property name="Anchors" scope="normal" type="Object"/>
      <property name="Anchor" scope="normal" type="Object"/>
      <property name="Canvas" scope="normal" type="Object"/>
      <property name="Mouse" scope="normal" type="Object"/>
      <property name="Stencil" scope="normal" type="Object"/>
      <property name="StencilUI" scope="normal" type="Object"/>
      <property name="Undo" scope="normal" type="Object"/>
      <property name="_registry" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.drawing.manager.keys">
    <summary>A singleton, master object that detects
	keyboard keys and events
	Connect to it like:
	dojo.connect(this.keys, &amp;quot;onEnter&amp;quot;, ....);</summary>
    <properties>
      <property name="arrowIncrement" scope="normal" type="Number">
        <summary>The amount, in pixels, a selected Stencil will
	move on an arrow key event</summary>
      </property>
      <property name="arrowShiftIncrement" scope="normal" type="Number">
        <summary>The amount, in pixels, a selected Stencil will
	move on an arrow key + SHIFT event</summary>
      </property>
      <property name="shift" scope="normal" type="Boolean">
        <summary>Indicates whether the Shift key is currently pressed</summary>
      </property>
      <property name="ctrl" scope="normal" type="Boolean">
        <summary>Indicates whether the Control key is currently pressed</summary>
      </property>
      <property name="alt" scope="normal" type="Boolean">
        <summary>Indicates whether the Alt or Option key is currently pressed</summary>
      </property>
      <property name="cmmd" scope="normal" type="Boolean">
        <summary>Indicates whether the Apple Command key is currently pressed
	apple key</summary>
      </property>
      <property name="meta" scope="normal" type="Boolean">
        <summary>Indicates whether any 'meta' key is currently pressed:
	shift || ctrl || cmmd || alt
	any meta key</summary>
      </property>
      <property name="listeners" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method name="onDelete" scope="normal">
        <summary>Event fires when Delete key is released</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onEsc" scope="normal">
        <summary>Event fires when ESC key is released</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onEnter" scope="normal">
        <summary>Event fires when Enter key is released</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onArrow" scope="normal">
        <summary>Event fires when an Arrow key is released
	You will have to further check if evt.keyCode
	is 37,38,39, or 40</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="normal">
        <summary>Event fires when any key is pressed</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="normal">
        <summary>Event fires when any key is released</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="register" scope="normal">
        <summary>Register an object and callback to be notified
	of events.
	NOTE: Not really used in code, but should work.
	See manager.mouse for similar usage</summary>
        <parameters>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getLetter" scope="normal">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_mixin" scope="normal">
        <summary>Internal. Mixes in key events.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="editMode" scope="normal">
        <summary>Relinquishes control of events to another portion
	of Drawing; namely the TextBlock.</summary>
        <parameters>
          <parameter name="_isedit" type="" usage="required"/>
        </parameters>
      </method>
      <method name="enable" scope="normal">
        <summary>Enables or disables key events, to relinquish
	control to something outside of Drawing; input
	fields for example.
	You may need to call this directly if you are
	using textareas or contenteditables.
	NOTE: See scanForFields</summary>
        <parameters>
          <parameter name="_enabled" type="" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="normal">
        <summary>Initialize the keys object
	a little extra time is needed in some browsers</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.drawing.manager.keys.scanForFields" type="Function" classlike="true">
    <summary>Scans the document for inputs
	and calls this automatically. However you may need
	to call this if you create inputs after the fact.</summary>
    <properties>
      <property name="_fieldCons" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.drawing.plugins">
    <properties>
      <property name="_Plugin" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.drawing.plugins.drawing">
    <properties>
      <property name="Grid" scope="normal" type="Object"/>
      <property name="Silverlight" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.drawing.plugins.tools">
    <properties>
      <property name="Zoom" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.drawing.plugins.tools.Iconize"/>
  <object location="dojox.drawing.plugins.tools.Iconize.setup">
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.plugins.tools.Pan"/>
  <object location="dojox.drawing.plugins.tools.Pan.setup">
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.plugins.tools.ZoomIn"/>
  <object location="dojox.drawing.plugins.tools.ZoomIn.setup">
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.plugins.tools.Zoom100"/>
  <object location="dojox.drawing.plugins.tools.Zoom100.setup">
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.plugins.tools.ZoomOut"/>
  <object location="dojox.drawing.plugins.tools.ZoomOut.setup">
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="__StencilData" private="true">
    <summary>the data used to create the dojox.gfx Shape</summary>
    <properties>
      <property name="cx" scope="normal" type="Number">
        <summary>Center point x</summary>
      </property>
      <property name="cy" scope="normal" type="Number">
        <summary>Center point y</summary>
      </property>
      <property name="rx" scope="normal" type="Number">
        <summary>Horizontal radius</summary>
      </property>
      <property name="ry" scope="normal" type="Number">
        <summary>Vertical radius</summary>
      </property>
    </properties>
  </object>
  <object location="dojox.drawing.stencil">
    <properties>
      <property name="Ellipse" scope="normal" type="Object"/>
      <property name="Image" scope="normal" type="Object"/>
      <property name="Line" scope="normal" type="Object"/>
      <property name="Path" scope="normal" type="Object"/>
      <property name="Rect" scope="normal" type="Object"/>
      <property name="Text" scope="normal" type="Object"/>
      <property name="_Base" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="StencilArgs">
    <properties>
      <property name="container" scope="normal" type="dojo.gfx.group">
        <summary>The parent shape that contains all
	shapes used in a Stencil</summary>
      </property>
      <property name="anchorType" scope="normal" type="String">
        <summary>Optionally blank or 'group'. 'group' tells
	an anchor point that it must constrain
	itself to other anchor points.</summary>
      </property>
      <property name="isText" scope="normal" type="Boolean">
        <summary>Whether this is a text object or not
	(either stencil.text or tools.TextBlock)</summary>
      </property>
      <property name="shortType" scope="normal" type="String">
        <summary>The type of stencil that corresponds with the types and
	constructors used in Drawing.registerTool</summary>
      </property>
      <property name="annotation" scope="normal" type="Boolean">
        <summary>A Stencil used within a Stencil. An annotation
	is not selectable or clickable. A Label would
	be one example.</summary>
      </property>
      <property name="subShape" scope="normal" type="Boolean">
        <summary>A Stencil used within a Stencil. A subShape
	is clickable. An arrow head would be an example.</summary>
      </property>
      <property name="style" scope="normal" type="Object">
        <summary>An instance of the styles and defaults used within
	the Stencil.</summary>
      </property>
      <property name="util" scope="normal" type="Object">
        <summary>Pointer to util.common</summary>
      </property>
      <property name="mouse" scope="normal" type="Object">
        <summary>Pointer to the mouse instance</summary>
      </property>
      <property name="keys" scope="normal" type="Object">
        <summary>Pointer to the keys class</summary>
      </property>
      <property name="points" scope="normal" type="StencilPoints">
        <summary>Points is an array of objects that make up the
	description of a Stencil. The points to a Rect
	that is 100x100 and at x:10 and y:10 would look like:
	[{x:10,y:10}, {x:110, y:10}, {x:110, y:110}, {x:10, y:110}]
	Points go clockwise from the top left. In the case of Paths,
	they would go in the order that the Stencil would be drawn.
	Always when the points Array is set, a data Object is created
	as well. So never set points directly, always use setPoints().
	See:
	setPoints()</summary>
      </property>
      <property name="data" scope="normal" type="StencilData">
        <summary>A data object typically (but not always) resembles the data
	that is used to create the dojox.gfx Shape. The same Rect
	example shown in points above would look like:
	{x:10, y:10, width:100, height:100}
	And an Ellipse with the same coordinates:
	{cx:55, cy:55, rx:50, ry:50}
	The only Stencil that does not support data (at this time)
	is the Path. While x1,x2,x3... culd be used in a data object
	it doesn't provide much benefit.
	Always when a data object is set, a set of points is created
	as well. So never set data directly, always use setData().
	See:
	setData()
	marginZero [readonly] Number
	How closely shape can get to y:0 or x:0. Less than zero has
	bugs in VML. This is set with defaults, and should be equal
	to half the size of an anchor point (5 px)
	created [readonly] Boolean
	Whether the Stencil has been rendered for the first time or
	not.
	highlighted [readonly] Boolean
	Whether the Stencil is highlighted or not.
	selected [readonly] Boolean
	Whether the Stencil is selected or not.
	draws [readonly] Boolean
	Whether the Stencil can draw with a mouse drag or can just
	be created programmtically. If the Stencil comes from the
	stencil package, it should be draw:false. If it comes from
	the tools package it should be draw:true.</summary>
      </property>
      <property name="marginZero" scope="normal" type="Number"/>
      <property name="created" scope="normal" type="bool"/>
      <property name="highlighted" scope="normal" type="bool"/>
      <property name="selected" scope="normal" type="bool"/>
      <property name="draws" scope="normal" type="bool"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools"/>
  <object location="dojox.drawing.tools.Arrow"/>
  <object location="dojox.drawing.tools.Arrow.setup">
    <summary>See stencil._Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools.Ellipse"/>
  <object location="dojox.drawing.tools.Ellipse.setup">
    <summary>See stencil._Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools.Line"/>
  <object location="dojox.drawing.tools.Line.setup">
    <summary>See stencil._Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools.Path"/>
  <object location="dojox.drawing.tools.Path.setup">
    <summary>See Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools.Pencil"/>
  <object location="dojox.drawing.tools.Pencil.setup">
    <summary>See Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools.Rect"/>
  <object location="dojox.drawing.tools.Rect.setup">
    <summary>See stencil._Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools.TextBlock"/>
  <object location="dojox.drawing.tools.TextBlock.setup">
    <summary>See stencil._Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools.custom"/>
  <object location="dojox.drawing.tools.custom.Axes"/>
  <object location="dojox.drawing.tools.custom.Axes.setup">
    <summary>See stencil._Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools.custom.Equation"/>
  <object location="dojox.drawing.tools.custom.Equation.setup">
    <summary>See stencil._Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.tools.custom.Vector"/>
  <object location="dojox.drawing.tools.custom.Vector.setup">
    <summary>See stencil._Base ToolsSetup</summary>
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.ui">
    <properties>
      <property name="Button" scope="normal" type="Object"/>
      <property name="Tooltip" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.drawing.ui.Toolbar" type="Function" classlike="true">
    <summary>A Toolbar used for holding buttons; typically representing the Stencils
	used for a DojoX Drawing.</summary>
    <description>Creates a GFX-based toobar that holds GFX-based buttons. Can be either created
	within the actual drawing or within a seperate DOM element. When within the
	drawing, the toolbar will cover a portion of the drawing; hence the option.
	A Toolbar can be created programmtically or in markup. Currently markup is as
	a separate DOM element and programmtic is within the drawing.
	examples:
		dojo.connect(myDrawing, "onSurfaceReady", function(){
			new dojox.drawing.ui.Toolbar({
				drawing:myDrawing,
				tools:"all",
				plugs:"all",
				selected:"ellipse"
			});
		});
	 &lt;div dojoType="dojox.drawing.ui.Toolbar" id="gfxToolbarNode" drawingId="drawingNode"
			class="gfxToolbar" tools="all" plugs="all" selected="ellipse"&gt;&lt;/div&gt;</description>
    <properties>
      <property name="padding" scope="prototype" type="Number">
        <summary>The amount of spce between the top and left of the toolbar and the buttons.</summary>
      </property>
      <property name="margin" scope="prototype" type="Number">
        <summary>The space between each button.</summary>
      </property>
      <property name="size" scope="prototype" type="Number">
        <summary>The width and height of the button</summary>
      </property>
      <property name="radius" scope="prototype" type="Number">
        <summary>The size of the button's rounded corner</summary>
      </property>
      <property name="toolPlugGap" scope="prototype" type="number">
        <summary>The distnce between the tool buttons and plug buttons</summary>
      </property>
      <property name="strSlelected" scope="prototype" type="String"/>
      <property name="strTools" scope="instance-prototype" type="Object"/>
      <property name="strPlugs" scope="instance-prototype" type="Object"/>
      <property name="buttons" scope="prototype" type="Array"/>
      <property name="plugins" scope="prototype" type="Array"/>
      <property name="util" scope="instance" type=""/>
      <property name="toolDrawing" scope="instance" type="Object"/>
      <property name="drawing" scope="instance" type=""/>
      <property name="width" scope="instance" type=""/>
      <property name="height" scope="instance" type=""/>
      <property name="strSelected" scope="instance" type="Object"/>
      <property name="horizontal" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="makeButtons" scope="prototype">
        <summary>Internal. create buttons.</summary>
      </method>
      <method name="addTool" scope="prototype"/>
      <method name="addPlugin" scope="prototype"/>
      <method name="addBack" scope="prototype">
        <summary>Internal. Adds the back, behind the toolbar.</summary>
      </method>
      <method name="onToolClick" scope="prototype">
        <summary>Tool click event. May be connected to.</summary>
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onPlugClick" scope="prototype">
        <summary>Plugin click event. May be connected to.</summary>
        <parameters>
          <parameter name="button" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_mixprops" scope="prototype">
        <summary>Internally used for mixing in props from an object or
	from a dom node.</summary>
        <parameters>
          <parameter name="props" type="Array" usage="required"/>
          <parameter name="objNode" type="Object" usage="required">
            <summary>| Node</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.drawing.ui.dom">
    <properties>
      <property name="Zoom" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.drawing.ui.dom.Pan"/>
  <object location="dojox.drawing.ui.dom.Pan.setup">
    <properties>
      <property name="name" scope="normal" type="String"/>
      <property name="tooltip" scope="normal" type="String"/>
      <property name="iconClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.drawing.ui.dom.Toolbar" type="Function" classlike="true">
    <summary>Creates a Toolbar to be used with a DojoX Drawing.</summary>
    <description>Currently works in markup only. A class is required with
	either horizontal or vertical as a class (IE prevented using
	either as a default). Assign an attribute of 'drawingId' with
	the id of the DojoX Drawing to which this is assigned.
	The node children will be assigned as the Tools in the toolbar.
	Plugins can also be assigned.
	The Toolbar is largely self contained and has no real public
	methods or events. the Drawing object should be used.</description>
    <examples>
      <example>	&lt;div dojoType="dojox.drawing.Toolbar" drawingId="drawing" class="drawingToolbar vertical"&gt;
			&lt;div tool="dojox.drawing.tools.Line" 				selected="false"&gt;	Line&lt;/div&gt;
			&lt;div tool="dojox.drawing.tools.Rect" 				selected="true"&gt;	Rect&lt;/div&gt;
			&lt;div plugin="dojox.drawing.plugins.tools.Zoom" options="{zoomInc:.1,minZoom:.5,maxZoom:2}"&gt;Zoom&lt;/div&gt;
		&lt;/div&gt;
	TODO: Toolbar works in markup only. Need programmatic.
	NOTE: There are plans to make the toolbar out of dojox.gfx vectors.
	This may change the APIs in the future.</example>
    </examples>
    <properties>
      <property name="baseClass" scope="prototype" type="String">
        <summary>The CSS style to apply to the toolbar node</summary>
      </property>
      <property name="buttonClass" scope="prototype" type="String">
        <summary>The CSS style to apply to each button node</summary>
      </property>
      <property name="iconClass" scope="prototype" type="String">
        <summary>The CSS style to apply to each button icon node</summary>
      </property>
      <property name="drawing" scope="prototype" type="Object"/>
      <property name="toolNodes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createIcon" scope="prototype">
        <summary>Internal. Creates an icon node for each button.
	arguments:</summary>
        <parameters>
          <parameter name="node" type="HTMLNode" usage="required">
            <summary>The button node.</summary>
          </parameter>
          <parameter name="constr" type="?" usage="required">
            <summary>Function Optional. If not supplied, an icon is not created.
	Information for each icon is derived from
	the ToolsSetup object defined at the end
	of each tool. See: stencil._Base</summary>
          </parameter>
        </parameters>
      </method>
      <method name="createTool" scope="prototype">
        <summary>Creates a button on the Toolbar that is
	a Tool, not a Plugin. Tools draw Stencils,
	Plugins do actions.
	arguments:</summary>
        <parameters>
          <parameter name="node" type="HTMLNode" usage="required">
            <summary>The button node.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="parse" scope="prototype">
        <summary>Initializing method that reads the dom node and its
	children for tools and plugins.</summary>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Event fired from clicking a Tool, not a PLugin.
	Plugin clicks are handled within the plugin's class.
	arguments:</summary>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <summary>Fully qualified name of class. ex:
	dojox.drawing.tools.Ellipse</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onSetTool" scope="prototype">
        <summary>handles buttons clicks and selects or deselects</summary>
        <parameters>
          <parameter name="type" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.drawing.util"/>
  <object location="dojox.drawing.util.common">
    <summary>A collection of common methods used for DojoX Drawing.
	This singleton is accessible in most Drawing classes
	as this.util
	NOTE:
	A lot of functions use a EventObject
	as an argument. An attempt was made to accept
	either that object or a list of numbers. That wasn't
	finished (it didn't work well in all cases) but is
	likely to happen in the future.
	In cases where you are not sending a Mouse object,
	form your argument like so:
	var obj = {
	start:{
	x:Number,  	// start x
	y:Number	// start y
	},
	x: Number,		// end x
	y:Number		// end y
	}</summary>
    <properties>
      <property name="objects" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="radToDeg" scope="normal">
        <summary>Convert the passed number to degrees.</summary>
        <parameters>
          <parameter name="n" type="Numer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="degToRad" scope="normal">
        <summary>Convert the passed number to radians.</summary>
        <parameters>
          <parameter name="n" type="Numer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="angle" scope="normal">
        <summary>Return angle based on mouse object
	arguments:</summary>
        <parameters>
          <parameter name="obj" type="EventObject" usage="required">
            <summary>Manager.Mouse event.</summary>
          </parameter>
          <parameter name="snap" type="?" usage="required">
            <summary>Float Returns nearest angle within snap limits
	obj = this.argsToObj.apply(this, arguments);</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Whole Number"/>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="radians" scope="normal">
        <summary>Return the radians derived from the coordinates
	in the Mouse object.
	var o = this.argsToObj.apply(this, arguments);</summary>
        <parameters>
          <parameter name="o" type="EventObject" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="normal">
        <summary>Return the length derived from the coordinates
	in the Mouse object.</summary>
        <parameters>
          <parameter name="o" type="EventObject" usage="required"/>
        </parameters>
      </method>
      <method name="lineSub" scope="normal">
        <summary>Subtract an amount from a line</summary>
        <description>x1,y1,x2,y2 represents the Line. 'amt' represnets the amount
	to subtract from it.</description>
        <parameters>
          <parameter name="x1" type="Number" usage="required"/>
          <parameter name="y1" type="Number" usage="required"/>
          <parameter name="x2" type="Number" usage="required"/>
          <parameter name="y2" type="Number" usage="required"/>
          <parameter name="amt" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="argsToObj" scope="normal">
        <summary>Attempts to determine in a Mouse Object
	was passed or indiviual numbers. Returns
	an object.</summary>
      </method>
      <method name="distance" scope="normal">
        <summary>Return the length derived from the coordinates
	in the Mouse object. Different from util.length
	in that this always returns an absolute value.</summary>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="slope" scope="normal">
        <summary>Given two poits of a line, returns the slope.</summary>
        <parameters>
          <parameter name="p1" type="Object" usage="required"/>
          <parameter name="p2" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="pointOnCircle" scope="normal">
        <summary>A *very* helpful method. If you know the center
	(or starting) point, length and angle, find the
	x,y point at the end of that line.</summary>
        <parameters>
          <parameter name="cx" type="Number" usage="required"/>
          <parameter name="cy" type="Number" usage="required"/>
          <parameter name="radius" type="Number" usage="required"/>
          <parameter name="angle" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="constrainAngle" scope="normal">
        <summary>Ensures the angle in the Mouse Object is within the
	min and max limits. If not one of those limits is used.
	Returns an x,y point for the angle used.</summary>
        <parameters>
          <parameter name="obj" type="EventObject" usage="required"/>
          <parameter name="min" type="Number" usage="required"/>
          <parameter name="max" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="snapAngle" scope="normal">
        <summary>Snaps a line to the nearest angle</summary>
        <parameters>
          <parameter name="obj" type="EventObject" usage="required">
            <summary>Mouse object (see dojox.drawing.Mouse)</summary>
          </parameter>
          <parameter name="ca" type="Float" usage="required">
            <summary>Fractional amount to snap to
	A decimal number fraction of a half circle
	.5 would snap to 90 degrees
	.25  would snap to 45 degrees
	.125 would snap to 22.5 degrees, etc.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="uid" scope="normal">
        <summary>Creates a unique ID.
	arguments:</summary>
        <parameters>
          <parameter name="str" type="?" usage="required">
            <summary>String If provided, kept in a map, incremented
	and used in the id. Otherwise 'shape' is used.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="abbr" scope="normal">
        <summary>Converts a namespace (typically a tool or a stencil) into
	an abbreviation</summary>
        <parameters>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="mixin" scope="normal">
        <parameters>
          <parameter name="o1" type="" usage="required"/>
          <parameter name="o2" type="" usage="required"/>
        </parameters>
      </method>
      <method name="register" scope="normal">
        <summary>Since util is the only Singleton in Drawing (besides
	keys) it is used to help connect the Drawing object
	the Toolbar. Since multiple drawings can be on one
	page, this function serves a little more use than
	on first apearance.</summary>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="byId" scope="normal">
        <summary>Get an object that was registered with util.register</summary>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="normal">
        <summary>Helper function to attach attributes to SVG and VML raw nodes.</summary>
        <parameters>
          <parameter name="elem" type="Object" usage="required"/>
          <parameter name="prop" type="property" usage="required"/>
          <parameter name="value" type="?" usage="required">
            <summary>value</summary>
          </parameter>
          <parameter name="squelchErrors" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.drawing.util.oo">
    <summary>Inheritance utilities used in DojoX Drawing</summary>
    <description>Inheritance utilities used in DojoX Drawing.
	There were designed in a effort to make Drawing as
	fast as possible - especially in a case where thousands
	of objects are being loaded. Drawing declare performs
	about 3 times faster than Dojo declare and 2 times
	faster than Dojox declare. This is not to say Drawing
	declare is wthout limitations. It doesn't have the same
	syntatic sugar and extensibility of the other two. You
	can't inhert methods. It won't work with Dijit. But it
	is simple and effective.</description>
    <methods>
      <method name="declare" scope="normal">
        <summary>Creates a constructor Function from a
	Function, and collection of methods, and
	more Functions that are extended.</summary>
        <description>Similar in look and feel to Dojo declare as
	far as order and number of arguments, although
	constructed a little closer to prototypical
	inheritance. All arguments passed into the
	constructor are passed into all sub constructors.
	arguments:
	Function, [Object|Function....]
	The first argument is always the base
	constructor. The last argument is always
	an object of methods (or empty object) to
	be mixed in (in the future would like to
	make that object optional). Remaining
	arguments are other constructors mixed in
	using extend() (See below).</description>
        <examples>
          <example>	MyFunction = dojox.drawing.util.oo.declare(
			MyOtherFunction,
			YetAnotherFunction,
			function(options){
				// This is my constructor. It will fire last.
				// The other constructors will fire before this.
			},
			{
				customType:"equation", // mixed in property
				doThing: function(){   // mixed in method
				}
			}
		);
		var f = new MyFunction();</example>
        </examples>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="extend" scope="normal">
        <summary>Extends constructors to inherit from other
	constructors .</summary>
        <description>Typically not used by itself - it's used as
	part of declare(). Could be used by itself
	however, to mix together two or more
	constructors.
	arguments:
	Function, [ Function...]
	Any number of arguments, all must be
	function constructors. The first is
	considered the base object and its
	constructor will fire first.</description>
        <examples>
          <example>	var A = function(){};
		var B = function(){};
		var C = function(){};
		var D = dojox.drawing.util.oo.extend(A, B, C);
		var e = new D();</example>
        </examples>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.drawing.util.positioning">
    <methods>
      <method name="label" scope="normal">
        <summary>Returns the optimal position for annotations.Label.
	text position
	label at middle of vector</summary>
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="angle" scope="normal">
        <summary>Returns the optimal position for annotations.Angle.
	angle at first third of vector</summary>
        <parameters>
          <parameter name="start" type="Object" usage="required"/>
          <parameter name="end" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl">
    <summary>Django Templating Language implementation</summary>
    <properties>
      <property name="TOKEN_BLOCK" scope="normal" type="Number"/>
      <property name="TOKEN_VAR" scope="normal" type="Number"/>
      <property name="TOKEN_COMMENT" scope="normal" type="Number"/>
      <property name="TOKEN_TEXT" scope="normal" type="Number"/>
      <property name="_Context" scope="normal" type="Object"/>
      <property name="Template" scope="normal" type="Object"/>
      <property name="_QuickNodeList" scope="normal" type="Object"/>
      <property name="_Filter" scope="normal" type="Object"/>
      <property name="_TextNode" scope="normal" type="Object"/>
      <property name="_Node" scope="normal" type="Object"/>
      <property name="_NodeList" scope="normal" type="Object"/>
      <property name="_VarNode" scope="normal" type="Object"/>
      <property name="_Parser" scope="normal" type="Object"/>
      <property name="mark_safe" scope="normal" type=""/>
      <property name="TOKEN_CHANGE" scope="normal" type="Number"/>
      <property name="TOKEN_ATTR" scope="normal" type="Number"/>
      <property name="TOKEN_CUSTOM" scope="normal" type="Number"/>
      <property name="TOKEN_NODE" scope="normal" type="Number"/>
      <property name="DomTemplate" scope="normal" type="Object"/>
      <property name="DomBuffer" scope="normal" type="Object"/>
      <property name="_DomNode" scope="normal" type="Object"/>
      <property name="_DomNodeList" scope="normal" type="Object"/>
      <property name="_DomVarNode" scope="normal" type="Object"/>
      <property name="ChangeNode" scope="normal" type="Object"/>
      <property name="AttributeNode" scope="normal" type="Object"/>
      <property name="_DomTextNode" scope="normal" type="Object"/>
      <property name="_DomParser" scope="normal" type="Object"/>
      <property name="HtmlTemplate" scope="normal" type=""/>
      <property name="html" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="quickFilter" scope="normal">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.Context" type="Function" classlike="true" superclass="dojox.dtl._Context.prototype">
    <properties>
      <property name="_this" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="dict" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getKeys" scope="prototype"/>
      <method name="extend" scope="prototype">
        <summary>Returns a clone of this context object, with the items from the
	passed objecct mixed in.</summary>
        <parameters>
          <parameter name="obj" type="dojox.dtl.Context|Object" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="prototype">
        <summary>Returns a clone of this context, only containing the items
	defined in the filter.</summary>
        <parameters>
          <parameter name="filter" type="dojox.dtl.Context|Object|String" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="getThis" scope="prototype"/>
      <method name="hasKey" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.Context.setThis" type="Function" classlike="true">
    <properties>
      <property name="_this" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="_this" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.DomInline" type="Function" classlike="true" superclass="dijit._Widget.prototype">
    <properties>
      <property name="context" scope="prototype" type="Object"/>
      <property name="declaredClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.DomInline.render" type="Function" classlike="true">
    <properties>
      <property name="context" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="context" type="dojox.dtl.Context" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.DomInline.buildRendering" type="Function" classlike="true">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="containerNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type=""/>
      <property name="template" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.dtl.DomInline.postMixInProperties" type="Function" classlike="true">
    <properties>
      <property name="context" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.dtl.HtmlInline" type="">
    <properties>
      <property name="declaredClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.dtl.Inline" type="Function" classlike="true" superclass="dijit._Widget.prototype">
    <properties>
      <property name="context" scope="prototype" type="Object"/>
      <property name="declaredClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.Inline.render" type="Function" classlike="true">
    <properties>
      <property name="context" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="context" type="Object|dojox.dtl.Context" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.Inline.render.domNode" type="">
    <properties>
      <property name="innerHTML" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.dtl.Inline.buildRendering" type="Function" classlike="true">
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="srcNodeRef" scope="instance" type=""/>
      <property name="template" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.dtl.Inline.postMixInProperties" type="Function" classlike="true">
    <properties>
      <property name="context" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.dtl._DomTemplated" type="Function" classlike="true" private="true">
    <properties>
      <property name="_dijitTemplateCompat" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getContext" scope="prototype">
        <parameters>
          <parameter name="context" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl._DomTemplated.buildRendering" type="Function" classlike="true">
    <summary>Construct the UI for this widget, setting this.domNode.</summary>
    <properties>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="template" scope="instance" type="Object"/>
      <property name="_render" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.dtl._DomTemplated.setTemplate" type="Function" classlike="true">
    <summary>Quickly switch between templated by location</summary>
    <properties>
      <property name="template" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="template" type="String|dojo._Url" usage="required"/>
          <parameter name="context" type="dojox.dtl.Context" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl._DomTemplated.render" type="Function" classlike="true">
    <properties>
      <property name="template" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="context" type="dojox.dtl.Context" usage="optional"/>
          <parameter name="tpl" type="dojox.dtl.DomTemplate" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl._DomTemplated._getCachedTemplate" type="Function" classlike="true" private="true">
    <properties>
      <property name="_templates" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="templatePath" type="" usage="required"/>
          <parameter name="templateString" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.contrib">
    <properties>
      <property name="html" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.dtl.contrib.dijit" type="">
    <properties>
      <property name="widgetsInTemplate" scope="normal" type="Object"/>
      <property name="AttachNode" scope="normal" type="Object"/>
      <property name="EventNode" scope="normal" type="Object"/>
      <property name="DojoTypeNode" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="dojoAttachPoint" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dojoAttachEvent" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dojoType" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="on" scope="normal">
        <summary>Associates an event type to a function (on the current widget) by name</summary>
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl._HtmlTemplated" type="" private="true">
    <properties>
      <property name="declaredClass" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.dtl._Templated" type="Function" classlike="true" superclass="dijit._Templated">
    <mixins>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="_dijitTemplateCompat" scope="prototype" type="bool"/>
      <property name="_template" scope="prototype" type=""/>
      <property name="domNode" scope="prototype" type=""/>
      <property name="_templateCache" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="getCachedTemplate" scope="prototype">
        <summary>Layer for dijit._Templated.getCachedTemplate</summary>
        <parameters>
          <parameter name="templatePath" type="" usage="required"/>
          <parameter name="templateString" type="" usage="required"/>
          <parameter name="alwaysUseString" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.dtl.Token" type="Function" classlike="true">
    <properties>
      <property name="token_type" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="token_type" type="" usage="required"/>
          <parameter name="contents" type="" usage="required"/>
        </parameters>
      </method>
      <method name="split" scope="instance"/>
      <method name="split_contents" scope="normal">
        <parameters>
          <parameter name="limit" type="Integer" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.Token.contents">
    <properties>
      <property name="split" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.dtl.text">
    <properties>
      <property name="_re" scope="normal" type="RegExp"/>
    </properties>
    <methods>
      <method name="_get" scope="normal">
        <summary>Used to find both tags and filters</summary>
        <parameters>
          <parameter name="module" type="" usage="required"/>
          <parameter name="name" type="" usage="required"/>
          <parameter name="errorless" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getTag" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="errorless" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFilter" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="errorless" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplate" scope="normal">
        <parameters>
          <parameter name="file" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getTemplateString" scope="normal">
        <parameters>
          <parameter name="file" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveLazy" scope="normal">
        <parameters>
          <parameter name="location" type="" usage="required"/>
          <parameter name="sync" type="" usage="required"/>
          <parameter name="json" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveTemplateArg" scope="normal">
        <parameters>
          <parameter name="arg" type="" usage="required"/>
          <parameter name="sync" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_isTemplate" scope="normal">
        <parameters>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_resolveContextArg" scope="normal">
        <parameters>
          <parameter name="arg" type="" usage="required"/>
          <parameter name="sync" type="" usage="required"/>
        </parameters>
      </method>
      <method name="tokenize" scope="normal">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_parseDelims" scope="normal">
        <parameters>
          <parameter name="varr" type="" usage="required"/>
          <parameter name="load" type="" usage="required"/>
          <parameter name="tag" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl._noOpNode" type="Function" classlike="true" private="true">
    <summary>Adds a no-op node. Useful in custom tags</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="render" scope="instance"/>
      <method name="unrender" scope="instance"/>
      <method name="clone" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.dtl.register">
    <methods>
      <method name="get" scope="normal">
        <parameters>
          <parameter name="module" type="String" usage="required"/>
          <parameter name="name" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getAttributeTags" scope="normal"/>
      <method name="_any" scope="normal">
        <parameters>
          <parameter name="type" type="" usage="required"/>
          <parameter name="base" type="" usage="required"/>
          <parameter name="locations" type="" usage="required"/>
        </parameters>
      </method>
      <method name="tags" scope="normal">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="filters" scope="normal">
        <parameters>
          <parameter name="base" type="String" usage="required"/>
          <parameter name="locations" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.register._registry" private="true">
    <properties>
      <property name="attributes" scope="normal" type="Array"/>
      <property name="tags" scope="normal" type="Array"/>
      <property name="filters" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.dtl._base" private="true">
    <methods>
      <method name="escape" scope="normal">
        <summary>Escapes a string's HTML</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="safe" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.contrib.data" type="">
    <properties>
      <property name="_BoundItem" scope="normal" type="Object"/>
      <property name="BindDataNode" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="_get" scope="normal">
        <parameters>
          <parameter name="key" type="" usage="required"/>
        </parameters>
      </method>
      <method name="bind_data" scope="normal">
        <summary>Turns a list of data store items into DTL compatible items</summary>
        <examples>
          <example>`contextItems` and `contextStore` should be an item list
	and a data store that get assigned to `newVariable`
		{% bind_data contextItems to contextStore as newVariable %}</example>
        </examples>
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="bind_query" scope="normal">
        <summary>Queries a data store and makes the returned items DTL compatible</summary>
        <examples>
          <example>You can only use this with data stores that work in a synchronous
	way (meaning that `onComplete` is fired during the `fetch` call).
	A `sync` flag is sent to the fetch call so that stores that usually
	work asynchronously make themselves syncrhonous if possible.
		{% bind_query contextQuery to contextStore as newVariable %}</example>
        </examples>
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.contrib.data._BoundItem.get" type="">
    <properties>
      <property name="safe" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.dtl.contrib.dom" type="">
    <properties>
      <property name="StyleNode" scope="normal" type="Object"/>
      <property name="BufferNode" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="buffer" scope="normal">
        <summary>Buffer large DOM manipulations during re-render.</summary>
        <description>When using DomTemplate, wrap any content
	that you expect to change often during
	re-rendering. It will then remove its parent
	from the main document while it re-renders that
	section of code. It will only remove it from
	the main document if a mainpulation of somes sort
	happens. ie It won't swap out if it diesn't have to.</description>
        <examples>
          <example>By default, it considers only node addition/removal
	to be "changing"
		{% buffer %}{% for item in items %}&lt;li&gt;{{ item }}&lt;/li&gt;{% endfor %}{% endbuffer %}</example>
          <example>You can explicitly declare options:
	* node: Watch node removal/addition
	* class: Watch for a classname to be changed
	* text: Watch for any text to be changed
		{% buffer node class %}{% for item in items %}&lt;li&gt;{{ item }}&lt;/li&gt;{% endfor %}{% endbuffer %}</example>
        </examples>
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="html" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="style_" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.contrib.objects">
    <methods>
      <method name="key" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.BOOLS">
    <properties>
      <property name="checked" scope="normal" type="Number"/>
      <property name="disabled" scope="normal" type="Number"/>
      <property name="readonly" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.dtl.dom">
    <properties>
      <property name="_attributes" scope="normal" type="Object"/>
      <property name="_uppers" scope="normal" type="Object"/>
      <property name="_re4" scope="normal" type="RegExp"/>
      <property name="_reTrim" scope="normal" type="RegExp"/>
      <property name="_reSplit" scope="normal" type="RegExp"/>
      <property name="_swallowed" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method name="tokenize" scope="normal">
        <parameters>
          <parameter name="nodes" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_tokenize" scope="normal">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="tokens" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="__tokenize" scope="normal">
        <parameters>
          <parameter name="child" type="" usage="required"/>
          <parameter name="tokens" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.dom.getTemplate" type="Function" classlike="true">
    <properties>
      <property name="_commentable" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="text" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.ext-dojo">
    <properties>
      <property name="NodeList" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.dtl.filter.dates" type="">
    <methods>
      <method name="_toDate" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="date" scope="normal">
        <summary>Formats a date according to the given format</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="time" scope="normal">
        <summary>Formats a time according to the given format</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="timesince" scope="normal">
        <summary>Formats a date as the time since that date (i.e. &amp;quot;4 days, 6 hours&amp;quot;)</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="timeuntil" scope="normal">
        <summary>Formats a date as the time until that date (i.e. &amp;quot;4 days, 6 hours&amp;quot;)</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.filter"/>
  <object location="dojox.dtl.filter.htmlstrings" type="">
    <properties>
      <property name="_linebreaksrn" scope="normal" type="RegExp"/>
      <property name="_linebreaksn" scope="normal" type="RegExp"/>
      <property name="_linebreakss" scope="normal" type="RegExp"/>
      <property name="_linebreaksbr" scope="normal" type="RegExp"/>
      <property name="_removetagsfind" scope="normal" type="RegExp"/>
      <property name="_striptags" scope="normal" type="RegExp"/>
    </properties>
    <methods>
      <method name="linebreaks" scope="normal">
        <summary>Converts newlines into &amp;lt;p&amp;gt; and &amp;lt;br /&amp;gt;s</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="linebreaksbr" scope="normal">
        <summary>Converts newlines into &amp;lt;br /&amp;gt;s</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removetags" scope="normal">
        <summary>Removes a space separated list of [X]HTML tags from the output&amp;quot;</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="striptags" scope="normal">
        <summary>Strips all [X]HTML tags</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.filter.integers">
    <methods>
      <method name="add" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get_digit" scope="normal">
        <summary>Given a whole number, returns the 1-based requested digit of it
	desciprtion:
	1 is the right-most digit, 2 is the second-right-most digit, etc. Returns the
	original value for invalid input (if input or argument is not an integer,
	or if argument is less than 1). Otherwise, output is always an integer.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.filter.lists">
    <methods>
      <method name="_dictsort" scope="normal">
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dictsort" scope="normal">
        <summary>Takes a list of dicts, returns that list sorted by the property given in the argument.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dictsortreversed" scope="normal">
        <summary>Takes a list of dicts, returns that list sorted in reverse order by the property given in the argument.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="first" scope="normal">
        <summary>Returns the first item in a list</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="join" scope="normal">
        <summary>Joins a list with a string, like Python's `&lt;code&gt;str.join(list)&lt;/code&gt;`</summary>
        <description>Django throws a compile error, but JS can't do arg checks
	so we're left with run time errors, which aren't wise for something
	as trivial here as an empty arg.</description>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="normal">
        <summary>Returns the length of the value - useful for lists</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="length_is" scope="normal">
        <summary>Returns a boolean of whether the value's length is the argument</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="random" scope="normal">
        <summary>Returns a random item from the list</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="slice" scope="normal">
        <summary>Returns a slice of the list.</summary>
        <description>Uses the same syntax as Python's list slicing; see
	http://diveintopython.org/native_data_types/lists.html#odbchelper.list.slice
	for an introduction.
	Also uses the optional third value to denote every X item.</description>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_unordered_list" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="tabs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="unordered_list" scope="normal">
        <summary>Recursively takes a self-nested list and returns an HTML unordered list --
	WITHOUT opening and closing &amp;lt;ul&amp;gt; tags.</summary>
        <description>The list is assumed to be in the proper format. For example, if ``var`` contains
	``['States', [['Kansas', [['Lawrence', []], ['Topeka', []]]], ['Illinois', []]]]``,
	then ``{{ var|unordered_list }}`` would return::
		&lt;li&gt;States
		&lt;ul&gt;
			&lt;li&gt;Kansas
			&lt;ul&gt;
				&lt;li&gt;Lawrence&lt;/li&gt;
				&lt;li&gt;Topeka&lt;/li&gt;
			&lt;/ul&gt;
			&lt;/li&gt;
			&lt;li&gt;Illinois&lt;/li&gt;
		&lt;/ul&gt;
		&lt;/li&gt;</description>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.filter.logic">
    <properties>
      <property name="_yesno" scope="normal" type="RegExp"/>
    </properties>
    <methods>
      <method name="default_" scope="normal">
        <summary>If value is unavailable, use given default</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="default_if_none" scope="normal">
        <summary>If value is null, use given default</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="divisibleby" scope="normal">
        <summary>Returns true if the value is devisible by the argument&amp;quot;</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="yesno" scope="normal">
        <summary>arg being a comma-delimited string, value of true/false/none
	chooses the appropriate item from the string</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.filter.misc">
    <methods>
      <method name="filesizeformat" scope="normal">
        <summary>Format the value like a 'human-readable' file size (i.e. 13 KB, 4.1 MB, 102bytes, etc).</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="pluralize" scope="normal">
        <summary>Returns a plural suffix if the value is not 1, for '1 vote' vs. '2 votes'</summary>
        <description>By default, 's' is used as a suffix; if an argument is provided, that string
	is used instead. If the provided argument contains a comma, the text before
	the comma is used for the singular case.</description>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="phone2numeric" scope="normal">
        <summary>Takes a phone number and converts it in to its numerical equivalent</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="pprint" scope="normal">
        <summary>A wrapper around toJson unless something better comes along</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.filter.misc._phone2numeric" private="true">
    <properties>
      <property name="a" scope="normal" type="Number"/>
      <property name="b" scope="normal" type="Number"/>
      <property name="c" scope="normal" type="Number"/>
      <property name="d" scope="normal" type="Number"/>
      <property name="e" scope="normal" type="Number"/>
      <property name="f" scope="normal" type="Number"/>
      <property name="g" scope="normal" type="Number"/>
      <property name="h" scope="normal" type="Number"/>
      <property name="i" scope="normal" type="Number"/>
      <property name="j" scope="normal" type="Number"/>
      <property name="k" scope="normal" type="Number"/>
      <property name="l" scope="normal" type="Number"/>
      <property name="m" scope="normal" type="Number"/>
      <property name="n" scope="normal" type="Number"/>
      <property name="o" scope="normal" type="Number"/>
      <property name="p" scope="normal" type="Number"/>
      <property name="r" scope="normal" type="Number"/>
      <property name="s" scope="normal" type="Number"/>
      <property name="t" scope="normal" type="Number"/>
      <property name="u" scope="normal" type="Number"/>
      <property name="v" scope="normal" type="Number"/>
      <property name="w" scope="normal" type="Number"/>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.dtl.filter.strings">
    <properties>
      <property name="_fix_ampersands" scope="normal" type="RegExp"/>
      <property name="_strings" scope="normal" type="Object"/>
      <property name="_truncatewords" scope="normal" type="RegExp"/>
      <property name="_truncate_words" scope="normal" type="RegExp"/>
      <property name="_truncate_tag" scope="normal" type="RegExp"/>
      <property name="_urlize" scope="normal" type="RegExp"/>
      <property name="_urlize2" scope="normal" type="RegExp"/>
    </properties>
    <methods>
      <method name="_urlquote" scope="normal">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
          <parameter name="safe" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="addslashes" scope="normal">
        <summary>Adds slashes - useful for passing strings to JavaScript, for example.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="capfirst" scope="normal">
        <summary>Capitalizes the first character of the value</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="center" scope="normal">
        <summary>Centers the value in a field of a given width</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="cut" scope="normal">
        <summary>Removes all values of arg from the given string</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fix_ampersands" scope="normal">
        <summary>Replaces ampersands with `&lt;code&gt;&amp;amp;amp;&lt;/code&gt;` entities</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="floatformat" scope="normal">
        <summary>Format a number according to arg</summary>
        <description>If called without an argument, displays a floating point
	number as 34.2 -- but only if there's a point to be displayed.
	With a positive numeric argument, it displays that many decimal places
	always.
	With a negative numeric argument, it will display that many decimal
	places -- but only if there's places to be displayed.</description>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="iriencode" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="linenumbers" scope="normal">
        <summary>Displays text with line numbers</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="ljust" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="lower" scope="normal">
        <summary>Converts a string into all lowercase</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="make_list" scope="normal">
        <summary>Returns the value turned into a list. For an integer, it's a list of
	digits. For a string, it's a list of characters.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="rjust" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="slugify" scope="normal">
        <summary>Converts to lowercase, removes
	non-alpha chars and converts spaces to hyphens</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="stringformat" scope="normal">
        <summary>Formats the variable according to the argument, a string formatting specifier.
	This specifier uses Python string formating syntax, with the exception that
	the leading &amp;quot;%&amp;quot; is dropped.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="title" scope="normal">
        <summary>Converts a string into titlecase</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="truncatewords" scope="normal">
        <summary>Truncates a string after a certain number of words</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="Integer" usage="required">
            <summary>Number of words to truncate after</summary>
          </parameter>
        </parameters>
      </method>
      <method name="truncatewords_html" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="upper" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="urlencode" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="urlize" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="urlizetrunc" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="' + middle + '&quot; rel=&quot;nofollow&quot;&gt;' + trimmed + '&lt;/a&gt;';"/>
        </return-types>
      </method>
      <method name="wordcount" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="wordwrap" scope="normal">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="arg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.filter.strings._truncate_singlets" private="true">
    <properties>
      <property name="br" scope="normal" type="Object"/>
      <property name="col" scope="normal" type="Object"/>
      <property name="link" scope="normal" type="Object"/>
      <property name="base" scope="normal" type="Object"/>
      <property name="img" scope="normal" type="Object"/>
      <property name="param" scope="normal" type="Object"/>
      <property name="area" scope="normal" type="Object"/>
      <property name="hr" scope="normal" type="Object"/>
      <property name="input" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.dtl.render.dom"/>
  <object location="dojox.dtl.render.dom.Render" type="Function" classlike="true">
    <properties>
      <property name="_tpl" scope="instance" type=""/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="attachPoint" type="DOMNode" usage="optional"/>
          <parameter name="tpl" type="dojox.dtl.DomTemplate" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.render.dom.Render.setAttachPoint" type="Function" classlike="true">
    <properties>
      <property name="domNode" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.render.dom.Render.render" type="Function" classlike="true">
    <properties>
      <property name="_tpl" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="context" type="Object" usage="required"/>
          <parameter name="tpl" type="dojox.dtl.DomTemplate" usage="optional"/>
          <parameter name="buffer" type="dojox.dtl.DomBuffer" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.render"/>
  <object location="dojox.dtl.render.html">
    <properties>
      <property name="Render" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.dtl.tag.date">
    <methods>
      <method name="now" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.tag.date.NowNode" type="Function" classlike="true">
    <properties>
      <property name="_format" scope="instance" type=""/>
      <property name="format" scope="instance" type="Object"/>
      <property name="contents" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="format" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="context" type="" usage="required"/>
          <parameter name="buffer" type="" usage="required"/>
        </parameters>
      </method>
      <method name="unrender" scope="prototype">
        <parameters>
          <parameter name="context" type="" usage="required"/>
          <parameter name="buffer" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clone" scope="prototype">
        <parameters>
          <parameter name="buffer" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.tag"/>
  <object location="dojox.dtl.tag.loader" type="">
    <properties>
      <property name="BlockNode" scope="normal" type="Object"/>
      <property name="ExtendsNode" scope="normal" type="Object"/>
      <property name="IncludeNode" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="block" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="extends_" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="include" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="ssi" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.tag.logic" type="">
    <properties>
      <property name="IfNode" scope="normal" type="Object"/>
      <property name="IfEqualNode" scope="normal" type="Object"/>
      <property name="ForNode" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="if_" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_ifequal" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
          <parameter name="negate" type="" usage="required"/>
        </parameters>
      </method>
      <method name="ifequal" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="ifnotequal" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="for_" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.tag.loop" type="">
    <properties>
      <property name="CycleNode" scope="normal" type="Object"/>
      <property name="IfChangedNode" scope="normal" type="Object"/>
      <property name="RegroupNode" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="cycle" scope="normal">
        <summary>Cycle among the given strings each time this tag is encountered</summary>
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="ifchanged" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="regroup" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.tag.misc" type="">
    <properties>
      <property name="DebugNode" scope="normal" type="Object"/>
      <property name="FilterNode" scope="normal" type="Object"/>
      <property name="FirstOfNode" scope="normal" type="Object"/>
      <property name="SpacelessNode" scope="normal" type="Object"/>
      <property name="TemplateTagNode" scope="normal" type="Object"/>
      <property name="WidthRatioNode" scope="normal" type="Object"/>
      <property name="WithNode" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="comment" scope="normal">
        <summary>Ignore everything between {% comment %} and {% endcomment %}</summary>
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="debug" scope="normal">
        <summary>Output the current context, maybe add more stuff later.</summary>
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="normal">
        <summary>Filter the contents of the blog through variable filters.</summary>
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="firstof" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="spaceless" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="templatetag" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="widthratio" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="with_" scope="normal">
        <parameters>
          <parameter name="parser" type="" usage="required"/>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.utils.date">
    <properties>
      <property name="_chunks" scope="normal" type="Array"/>
      <property name="_months_ap" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method name="format" scope="normal">
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="timesince" scope="normal">
        <summary>Takes two datetime objects and returns the time between then and now
	as a nicely formatted string, e.g &amp;quot;10 minutes&amp;quot;</summary>
        <description>Adapted from http://blog.natbat.co.uk/archive/2003/Jun/14/time_since</description>
        <parameters>
          <parameter name="d" type="" usage="required"/>
          <parameter name="now" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.utils.date.DateFormat" type="Function" classlike="true" superclass="dojox.date.php.DateFormat.prototype">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="f" scope="prototype">
        <summary>Time, in 12-hour hours and minutes, with minutes left off if they're zero.</summary>
        <description>Examples: '1', '1:30', '2:05', '2'
	Proprietary extension.</description>
      </method>
      <method name="N" scope="prototype">
        <summary>Month abbreviation in Associated Press style. Proprietary extension.</summary>
      </method>
      <method name="P" scope="prototype">
        <summary>Time, in 12-hour hours, minutes and 'a.m.'/'p.m.', with minutes left off
	if they're zero and the strings 'midnight' and 'noon' if appropriate.</summary>
        <description>Examples: '1 a.m.', '1:30 p.m.', 'midnight', 'noon', '12:30 p.m.'
	Proprietary extension.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.dtl.utils"/>
  <object location="dojox.editor.plugins">
    <properties>
      <property name="ToolbarLineBreak" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.editor.plugins._BreadcrumbMenuTitle" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>SImple internal, non-clickable, menu entry to act as a menu title bar.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="menuTitle" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setMenuTitleAttr" scope="prototype">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenuTitleAttr" scope="prototype">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins._BreadcrumbMenuTitle.title" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.Breadcrumb" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides Breadcrumb cabability to the editor.  When
	As you move around the editor, it updates with your current indention
	depth.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="_menu" scope="prototype" type="The">
        <summary>popup menu that is displayed.</summary>
      </property>
      <property name="breadcrumbBar" scope="prototype" type="The">
        <summary>toolbar containing the breadcrumb.</summary>
      </property>
      <property name="editor" scope="prototype" type=""/>
      <property name="_buttons" scope="prototype" type="Object"/>
      <property name="_titleTemplate" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride for the setting of the editor.</summary>
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <summary>The editor to configure for this plugin to use.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_selectContents" scope="prototype">
        <summary>Internal function for selecting the contents of a node.</summary>
      </method>
      <method name="_deleteContents" scope="prototype">
        <summary>Internal function for selecting the contents of a node.</summary>
      </method>
      <method name="_selectElement" scope="prototype">
        <summary>Internal function for selecting the contents of a node.</summary>
      </method>
      <method name="_deleteElement" scope="prototype">
        <summary>Internal function for selecting the contents of a node.</summary>
      </method>
      <method name="_moveCToStart" scope="prototype">
        <summary>Internal function for selecting the contents of a node.</summary>
      </method>
      <method name="_moveCToEnd" scope="prototype">
        <summary>Internal function for selecting the contents of a node.</summary>
      </method>
      <method name="_updateBreadcrumb" scope="prototype">
        <summary>Function to trigger updating of the breadcrumb</summary>
      </method>
      <method name="updateState" scope="prototype">
        <summary>Over-ride of updateState to hide the toolbar when the iframe is not visible.
	Also triggers the breadcrumb update.</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Over-ride to clean up the breadcrumb toolbar.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.editor">
    <summary>Extensions for dijit.Editor</summary>
  </object>
  <object location="dojox.editor.plugins.EntityPalette" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A keyboard accessible HTML entity-picking widget (for inserting symbol characters)</summary>
    <description>Grid showing various entities, so the user can pick a certain entity
	Can be used standalone, or as a popup.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dojox.editor.plugins.EntityPalette"&gt;&lt;/div&gt;</example>
      <example>    var picker = new dojox.editor.plugins.EntityPalette({ },srcNode);
		picker.startup();</example>
    </examples>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The basic template used to render the palette.
	Should generally be over-ridden to define different classes.</summary>
      </property>
      <property name="defaultTimeout" scope="prototype" type="Number">
        <summary>Number of milliseconds before a held key or button becomes typematic</summary>
      </property>
      <property name="timeoutChangeRate" scope="prototype" type="Number">
        <summary>Fraction of time used to change the typematic timer between events
	1.0 means that each typematic event fires at defaultTimeout intervals
	&amp;lt; 1.0 means that each typematic event fires at an increasing faster rate</summary>
      </property>
      <property name="showPreview" scope="prototype" type="Boolean">
        <summary>Whether the preview pane will be displayed, to show details about the selected entity.</summary>
      </property>
      <property name="showCode" scope="prototype" type="boolean">
        <summary>Show the character code for the entity.</summary>
      </property>
      <property name="showEntityName" scope="prototype" type="bool"/>
      <property name="palette" scope="prototype" type="String">
        <summary>The symbol pallete to display.  The only current one is 'latin'.</summary>
      </property>
      <property name="value" scope="prototype" type="String">
        <summary>The value of the selected entity.</summary>
      </property>
      <property name="_currentFocus" scope="prototype" type="Integer">
        <summary>Index of the currently focused entity.</summary>
      </property>
      <property name="_xDim" scope="prototype" type="Integer">
        <summary>This is the number of entity columns horizontally across.</summary>
      </property>
      <property name="_yDim" scope="prototype" type="Integer">
        <summary>/		This is the number of entity rows down.</summary>
      </property>
      <property name="tabIndex" scope="prototype" type="String">
        <summary>Widget tab index.</summary>
      </property>
      <property name="_created" scope="prototype" type="boolean">
        <summary>Flag indicating the widget has initialized.</summary>
      </property>
      <property name="_cellNodes" scope="prototype" type="Array"/>
      <property name="entities" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="focus" scope="prototype">
        <summary>Focus this EntityPalette.  Puts focus on the first swatch.</summary>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Callback when a entity is selected.</summary>
        <parameters>
          <parameter name="entity" type="String" usage="required">
            <summary>Entity value corresponding to an html entity character.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_focusFirst" scope="prototype">
        <summary>Focus the first cell in the color picker,
	or the previously selected cell, if there is one</summary>
      </method>
      <method name="_onTableNodeFocus" scope="prototype">
        <summary>Handler for when focus goes to the EntityPalette itself.
	Shifts focus to the first entity or the previously selected
	color.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype">
        <summary>Handler for when the EntityPalette or a entity cell inside of it get focus</summary>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>Handler for when the EntityPalette and the entity cell inside of it lose focus</summary>
      </method>
      <method name="_onCellDijitclick" scope="prototype">
        <summary>Handler for click, enter key &amp;amp; space key. Selects the entity.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellMouseEnter" scope="prototype">
        <summary>Handler for onMouseOver. Put focus on the entity under the mouse.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The mouse event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellFocus" scope="prototype">
        <summary>Handler for onFocus of a cell. Removes highlight of
	the color that just lost focus, and highlights
	the new entity.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The focus event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setCurrent" scope="prototype">
        <summary>Called when a entity is hovered or focused.</summary>
        <description>Removes highlight of the old entity, and highlights
	the new entity.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_displayDetails" scope="prototype">
        <summary>Display the details of the currently focused entity in the preview pane</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_onCellBlur" scope="prototype">
        <summary>needed for Firefox 2 on Mac OS X</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_removeCellHighlight" scope="prototype">
        <summary>Removes the hover CSS class for the specified cell</summary>
        <parameters>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_selectEntity" scope="prototype">
        <summary>This selects an entity. It triggers the onChange event with the string representation of the selected
	entity.
	area:
	The area node that covers the entity being selected.</summary>
        <parameters>
          <parameter name="selectNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_navigateByKey" scope="prototype">
        <summary>This is the callback for typematic.
	It changes the focus and the highlighed entity.</summary>
        <parameters>
          <parameter name="increment" type="How" usage="required">
            <summary>much the key is navigated.</summary>
          </parameter>
          <parameter name="typeCount" type="How" usage="required">
            <summary>many times typematic has fired.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.EntityPalette.domNode.style" type="">
    <properties>
      <property name="position" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.EntityPalette.previewNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.EntityPalette.codeNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.EntityPalette.entityNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.EntityPalette.descNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.editor.plugins._FindReplaceTextBox" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Base class for widgets that contains a label (like &amp;quot;Font:&amp;quot;)
	and a TextBox to pick a value.
	Used as Toolbar entry.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="textId" scope="prototype" type="String"/>
      <property name="label" scope="prototype" type="String"/>
      <property name="widget" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="id" scope="prototype" type="Object"/>
      <property name="disabled" scope="prototype" type="Object"/>
      <property name="value" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype"/>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>Over-ride for the button's 'disabled' attribute so that it can be
	disabled programmatically.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Stub function for change events on the box.</summary>
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins._FindReplaceCheckBox" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Base class for widgets that contains a label (like &amp;quot;Match case: &amp;quot;)
	and a checkbox to indicate if it is checked or not.
	Used as Toolbar entry.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="checkId" scope="prototype" type="String"/>
      <property name="label" scope="prototype" type="String"/>
      <property name="widget" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="id" scope="prototype" type="Object"/>
      <property name="disabled" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <summary>Passthrough for checkbox.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>Passthrough for checkbox.</summary>
      </method>
      <method name="focus" scope="prototype"/>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>Over-ride for the button's 'disabled' attribute so that it can be
	disabled programmatically.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins._FindReplaceCheckBox.checkBox" type="">
    <methods>
      <method name="isFocusable" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.editor.plugins.FindReplace" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides a Find/Replace cabability for the editor.
	Note that this plugin is NOT supported on Opera currently, as opera
	does not implement a window.find or equiv function.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="buttonClass" scope="normal" type="Define">
        <summary>the class of button the editor uses.</summary>
      </property>
      <property name="iconClassPrefix" scope="prototype" type="String">
        <summary>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</summary>
      </property>
      <property name="button" scope="prototype" type="Object"/>
      <property name="_displayed" scope="prototype" type="bool"/>
      <property name="_frToolbar" scope="prototype" type="Object"/>
      <property name="_caseSensitive" scope="prototype" type="Object"/>
      <property name="_backwards" scope="prototype" type="Object"/>
      <property name="_replaceAll" scope="prototype" type="Object"/>
      <property name="_findField" scope="prototype" type="Object"/>
      <property name="_findButton" scope="prototype" type="Object"/>
      <property name="_replaceField" scope="prototype" type="Object"/>
      <property name="_replaceButton" scope="prototype" type="Object"/>
      <property name="_replDialog" scope="prototype" type="Object"/>
      <property name="_dialogTemplate" scope="prototype" type=""/>
      <property name="_replaceDialogTimeout" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the resize button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <parameters>
          <parameter name="editor" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="prototype">
        <summary>Function to allow programmatic toggling of the find toolbar.</summary>
      </method>
      <method name="_toggleFindReplace" scope="prototype">
        <summary>Function to toggle whether or not find/replace is displayed.</summary>
        <parameters>
          <parameter name="show" type="" usage="required"/>
          <parameter name="ignoreState" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="prototype">
        <summary>Over-ride so that find/replace toolbar is appended after the current toolbar.</summary>
        <parameters>
          <parameter name="toolbar" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_checkButtons" scope="prototype"/>
      <method name="_find" scope="prototype">
        <summary>This function invokes a find on the editor document with the noted options for
	find.</summary>
        <return-description>Boolean indicating if the content was found or not.</return-description>
      </method>
      <method name="_replace" scope="prototype"/>
      <method name="_findText" scope="prototype">
        <summary>This function invokes a find with specific options</summary>
        <return-description>Boolean indicating if the content was found or not.</return-description>
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <summary>The text to locate in the document.</summary>
          </parameter>
          <parameter name="caseSensitive" type="boolean" usage="required">
            <summary>Whether or ot to search case-sensitively.</summary>
          </parameter>
          <parameter name="backwards" type="boolean" usage="required">
            <summary>Whether or not to search backwards in the document.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_filterRegexp" scope="prototype">
        <summary>Helper function to convert a simple pattern to a regular expression for matching.</summary>
        <description>Returns a regular expression object that conforms to the defined conversion rules.
	For example:
	ca*   -&gt; /^ca.*$/
	*ca*  -&gt; /^.*ca.*$/
	*c\*a*  -&gt; /^.*c\*a.*$/
	*c\*a?*  -&gt; /^.*c\*a..*$/
	and so on.</description>
        <parameters>
          <parameter name="pattern" type="String" usage="required">
            <summary>string A simple matching pattern to convert that follows basic rules:
	* Means match anything, so ca* means match anything starting with ca
	? Means match single character.  So, b?b will match to bob and bab, and so on.
	\ is an escape character.  So for example, \* means do not treat * as a match, but literal character *.
	To use a \ as a character in the string, it must be escaped.  So in the pattern it should be
	represented by \\ to be treated as an ordinary \ character instead of an escape.</summary>
          </parameter>
          <parameter name="ignoreCase" type="boolean" usage="optional">
            <summary>An optional flag to indicate if the pattern matching should be treated as case-sensitive or not when comparing
	By default, it is assumed case sensitive.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="RegExp"/>
        </return-types>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Cleanup of our custom toolbar.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.FindReplace.editor" type="">
    <properties>
      <property name="window" scope="prototype" type=""/>
      <property name="document" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.InsertEntity" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin allows the user to select from standard Symbols (HTML Entities)
	to insert at the current cursor position.  It binds to the key pattern:
	ctrl-shift-s for opening the insert symbol dropdown.</summary>
    <description>The commands provided by this plugin are:
	* insertEntity - inserts the selected HTML entity character</description>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="prototype" type="String">
        <summary>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</summary>
      </property>
      <property name="dropDown" scope="prototype" type="Object"/>
      <property name="button" scope="prototype" type="Object"/>
      <property name="editor" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the save button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride for the setting of the editor.</summary>
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <summary>The editor to configure for this plugin to use.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_preFilterEntities" scope="prototype">
        <summary>A function to filter out entity characters into their UTF-8 character form
	displayed in the editor.  It gets registered with the preFilters
	of the editor.</summary>
        <parameters>
          <parameter name="s" type="String" usage="required">
            <summary>content passed in</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_postFilterEntities" scope="prototype">
        <summary>A function to filter out entity characters into encoded form so they
	are properly displayed in the editor.  It gets registered with the
	postFilters of the editor.</summary>
        <parameters>
          <parameter name="s" type="String" usage="required">
            <summary>content passed in</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.NormalizeIndentOutdent" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides improved indent and outdent handling to
	the editor.  It tries to generate valid HTML, as well as be
	consistent about how it indents and outdents lists and blocks/elements.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="indentBy" scope="prototype" type="number">
        <summary>The amount to indent by.  Valid values are 1+.  This is combined with
	the indentUnits parameter to determine how much to indent or outdent
	by for regular text.  It does not affect lists.</summary>
      </property>
      <property name="indentUnits" scope="prototype" type="String">
        <summary>The units to apply to the indent amount.  Usually 'px', but can also
	be em.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride for the setting of the editor.</summary>
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <summary>The editor to configure for this plugin to use.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_queryCommandEnabled" scope="prototype">
        <summary>An over-ride for the editor's query command enabled,
	so that we can prevent indents, etc, on bad elements
	or positions (like first element in a list).</summary>
        <parameters>
          <parameter name="command" type="The" usage="required">
            <summary>command passed in to check enablement.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_indentImpl" scope="prototype">
        <summary>Improved implementation of indent, generates correct indent for
	ul/ol</summary>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_indentElement" scope="prototype">
        <summary>Function to indent a block type tag.</summary>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>node who's content to indent.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Return the node that was indented."/>
        </return-types>
      </method>
      <method name="_outdentElement" scope="prototype">
        <summary>Function to outdent a block type tag.</summary>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>node who's content to outdent.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_outdentImpl" scope="prototype">
        <summary>Improved implementation of outdent, generates correct indent for
	ul/ol and other elements.</summary>
        <parameters>
          <parameter name="html" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_indentList" scope="prototype">
        <summary>Internal function to handle indenting a list element.</summary>
        <parameters>
          <parameter name="listItem" type="The" usage="required">
            <summary>list item to indent.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_outdentList" scope="prototype">
        <summary>Internal function to handle outdenting a list element.</summary>
        <parameters>
          <parameter name="listItem" type="The" usage="required">
            <summary>list item to outdent.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_isEmpty" scope="prototype">
        <summary>Internal function to determine if a node is 'empty'
	Eg, contains only blank text.  Used to determine if
	an empty list element should be removed or not.</summary>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>node to check.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_isIndentableElement" scope="prototype">
        <summary>Internal function to detect what element types
	are indent-controllable by us.</summary>
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <summary>tag to check</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_convertIndent" scope="prototype">
        <summary>Function to convert the current indent style to
	the units we're using by some heuristic.</summary>
        <parameters>
          <parameter name="indent" type="The" usage="required">
            <summary>indent amount to convert.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_isLtr" scope="prototype">
        <summary>Function to detect if the editor body is in RTL or LTR.</summary>
      </method>
      <method name="_isInlineFormat" scope="prototype">
        <summary>Function to determine if the current tag is an inline
	element that does formatting, as we don't want to
	break/indent around it, as it can screw up text.</summary>
        <parameters>
          <parameter name="tag" type="The" usage="required">
            <summary>tag to examine</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getTagName" scope="prototype">
        <summary>Internal function to get the tag name of an element
	if any.</summary>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>node to look at.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_isRootInline" scope="prototype">
        <summary>This functions tests whether an indicated node is in root as inline
	or rooted inline elements in the page.</summary>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>node to start at.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_isTextElement" scope="prototype">
        <summary>Helper function to check for text nodes.</summary>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>node to check.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_inSelection" scope="prototype">
        <summary>This function determines if 'node' is
	in the current selection.  Used for multi-line
	select indention.</summary>
        <parameters>
          <parameter name="node" type="The" usage="required">
            <summary>node to check.</summary>
          </parameter>
          <parameter name="range" type="The" usage="required">
            <summary>WC3 (or pseudo W3C range)
	range to check.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.NormalizeIndentOutdent.editor.document" type="">
    <properties>
      <property name="body" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.NormalizeIndentOutdent.editor" type=""/>
  <object location="dojox.editor.plugins.PageBreak" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides a simple CSS page break plugin that
	lets you insert browser pring recognizable page breaks in
	the document.
	This plugin registers the hotkey command: CTRL-SHIFT-ENTER</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="prototype" type="bool"/>
      <property name="iconClassPrefix" scope="prototype" type="String">
        <summary>The CSS class name for the button node is formed from
	&lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</summary>
      </property>
      <property name="_unbreakableNodes" scope="prototype" type="Array">
        <summary>The nodes that should not allow page breaks to be inserted into them.</summary>
      </property>
      <property name="_pbContent" scope="prototype" type="String">
        <summary>The markup used for the pagebreak insert.</summary>
      </property>
      <property name="button" scope="prototype" type="Object"/>
      <property name="_styled" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the resize button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride for the setting of the editor.</summary>
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <summary>The editor to configure for this plugin to use.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_style" scope="prototype">
        <summary>Internal function for inserting dynamic css.  This was originally
	in an editor.onLoadDeferred, but I ran into issues in Chrome with
	the tag being ignored.  Having it done at insert worked better.</summary>
      </method>
      <method name="_insertPageBreak" scope="prototype">
        <summary>Function to insert a CSS page break at the current point in the document</summary>
      </method>
      <method name="_allowBreak" scope="prototype">
        <summary>Internal function to see if we should allow a page break at the document
	location.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.PageBreak.editor" type="">
    <properties>
      <property name="document" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.PrettyPrint" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides a mechanism by wich to 'beautify HTML'
	generated by the editor.  It is by no means perfect.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="indentBy" scope="prototype" type="Number"/>
      <property name="lineLength" scope="prototype" type="Number"/>
      <property name="useDefaultCommand" scope="prototype" type="bool"/>
      <property name="entityMap" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the resize button.</summary>
      </method>
      <method name="setToolbar" scope="prototype">
        <summary>Over-ride to do nothing.
	We don't want to append a button, we take over getValue.</summary>
        <parameters>
          <parameter name="toolbar" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride to take over getValue of editor so that
	we can 'pretty' the output.</summary>
        <parameters>
          <parameter name="editor" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.Preview" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides Preview cabability to the editor.  When
	clicked, the document in the editor frame will displayed in a separate
	window/tab</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="prototype" type="bool"/>
      <property name="styles" scope="prototype" type="String">
        <summary>A string of CSS styles to apply to the previewed content, if any.</summary>
      </property>
      <property name="stylesheets" scope="prototype" type="Array">
        <summary>An array of stylesheets to import into the preview, if any.</summary>
      </property>
      <property name="iconClassPrefix" scope="prototype" type="String">
        <summary>The CSS class name for the button node icon.</summary>
      </property>
      <property name="_nlsResources" scope="prototype" type="Object"/>
      <property name="button" scope="prototype" type="Object"/>
      <property name="editor" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the preview button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride for the setting of the editor.</summary>
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <summary>The editor to configure for this plugin to use.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_preview" scope="prototype">
        <summary>Function to trigger previewing of the editor document</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.Save" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides Save cabability to the editor.  When
	clicked, the document in the editor frame will be osted to the URL
	provided, or none, if none provided.  Users who desire a different save
	function can extend this plugin (via dojo.extend) and over-ride the
	save method	while save is in process, the save button is disabled.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="prototype" type="String">
        <summary>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt;
	and &lt;code&gt;command&lt;/code&gt;</summary>
      </property>
      <property name="url" scope="prototype" type="String"/>
      <property name="logResults" scope="prototype" type="Object"/>
      <property name="button" scope="prototype" type="Object"/>
      <property name="editor" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the save button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride for the setting of the editor.</summary>
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <summary>The editor to configure for this plugin to use.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_save" scope="prototype">
        <summary>Function to trigger saving of the editor document</summary>
      </method>
      <method name="save" scope="prototype">
        <summary>User over-ridable save function for the editor content.
	Please note that the service URL provided should do content
	filtering of the posted content to avoid XSS injection via
	the data from the editor.</summary>
        <parameters>
          <parameter name="content" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSuccess" scope="prototype">
        <summary>User over-ridable save success function for editor content.
	Be sure to call this.inherited(arguments) if over-riding this method.</summary>
        <parameters>
          <parameter name="resp" type="The" usage="required">
            <summary>response from the server, if any, in text format.</summary>
          </parameter>
          <parameter name="ioargs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <summary>User over-ridable save success function for editor content.
	Be sure to call this.inherited(arguments) if over-riding this method.
	resp:
	The response from the server, if any, in text format.</summary>
        <parameters>
          <parameter name="error" type="" usage="required"/>
          <parameter name="ioargs" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.ShowBlockNodes" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin provides ShowBlockNodes cabability to the editor.  When
	clicked, the document in the editor will apply a class to specific
	block nodes to make them visible in the layout.  This info is not
	exposed/extracted when the editor value is obtained, it is purely for help
	while working on the page.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="useDefaultCommand" scope="prototype" type="bool"/>
      <property name="iconClassPrefix" scope="prototype" type="String">
        <summary>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</summary>
      </property>
      <property name="_styled" scope="prototype" type="Object"/>
      <property name="button" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the preview button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride for the setting of the editor.</summary>
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <summary>The editor to configure for this plugin to use.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toggle" scope="prototype">
        <summary>Function to allow programmatic toggling of the view.</summary>
      </method>
      <method name="_showBlocks" scope="prototype">
        <summary>Function to trigger printing of the editor document</summary>
        <parameters>
          <parameter name="show" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_calcBaseUrl" scope="prototype">
        <summary>Internal function used to figure out the full root url (no relatives)
	for loading images in the styles in the iframe.</summary>
        <parameters>
          <parameter name="fullUrl" type="String" usage="required">
            <summary>The full url to tear down to the base.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.ShowBlockNodes.editor" type="">
    <properties>
      <property name="document" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.Smiley" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>This plugin allows the user to select from emoticons or &amp;quot;smileys&amp;quot;
	to insert at the current cursor position.</summary>
    <description>The commands provided by this plugin are:
	* smiley - inserts the selected emoticon</description>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="prototype" type="String">
        <summary>The CSS class name for the button node is formed from &lt;code&gt;iconClassPrefix&lt;/code&gt; and &lt;code&gt;command&lt;/code&gt;</summary>
      </property>
      <property name="dropDown" scope="prototype" type="Object"/>
      <property name="button" scope="prototype" type="Object"/>
      <property name="editor" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype">
        <summary>Over-ride for creation of the save button.</summary>
      </method>
      <method name="setEditor" scope="prototype">
        <summary>Over-ride for the setting of the editor.</summary>
        <parameters>
          <parameter name="editor" type="Object" usage="required">
            <summary>The editor to configure for this plugin to use.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_preFilterEntities" scope="prototype">
        <summary>A function to filter out emoticons into their UTF-8 character form
	displayed in the editor.  It gets registered with the preFilters
	of the editor.</summary>
        <parameters>
          <parameter name="s" type="String" usage="required">
            <summary>content passed in</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_postFilterEntities" scope="prototype">
        <summary>A function to filter out emoticons into encoded form so they
	are properly displayed in the editor.  It gets registered with the
	postFilters of the editor.</summary>
        <parameters>
          <parameter name="s" type="String" usage="required">
            <summary>content passed in</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.GlobalTableHandler" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>A global object that handles common tasks for all the plugins. Since
	there are several plugins that are all calling common methods, it's preferable
	that they call a centralized location that either has a set variable or a
	timeout to only repeat code-heavy calls when necessary.
	FIXME:</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="tablesConnected" scope="prototype" type="bool"/>
      <property name="currentlyAvailable" scope="prototype" type="bool"/>
      <property name="alwaysAvailable" scope="prototype" type="bool"/>
      <property name="availableCurrentlySet" scope="prototype" type="Object"/>
      <property name="initialized" scope="prototype" type="Object"/>
      <property name="tableData" scope="prototype" type="Object"/>
      <property name="shiftKeyDown" scope="prototype" type="bool"/>
      <property name="undoEnabled" scope="normal" type=""/>
      <property name="cnKeyDn" scope="prototype" type="Object"/>
      <property name="cnKeyUp" scope="prototype" type="Object"/>
      <property name="stopEvent" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="doMixins" scope="prototype"/>
      <method name="initialize" scope="prototype">
        <summary>Initialize the global handler upon a plugin's first instance of setEditor</summary>
        <parameters>
          <parameter name="editor" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getTableInfo" scope="prototype">
        <parameters>
          <parameter name="forceNewData" type="" usage="required"/>
        </parameters>
      </method>
      <method name="connectDraggable" scope="prototype"/>
      <method name="onDragStart" scope="prototype"/>
      <method name="onDragEnd" scope="prototype"/>
      <method name="checkAvailable" scope="prototype"/>
      <method name="_prepareTable" scope="prototype">
        <parameters>
          <parameter name="tbl" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getTimeStamp" scope="prototype"/>
      <method name="_tempStoreTableData" scope="prototype">
        <parameters>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_tempAvailability" scope="prototype">
        <parameters>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="connectTableKeys" scope="prototype"/>
      <method name="disconnectTableKeys" scope="prototype"/>
      <method name="onKeyDown" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyUp" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onDisplayChanged" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.editor.plugins.GlobalTableHandler.editorDomNode">
    <properties>
      <property name="ondragstart" scope="prototype" type="Object"/>
      <property name="ondragend" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.GlobalTableHandler.editor" type="">
    <properties>
      <property name="window" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.TablePlugins" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>A collection of Plugins for inserting and modifying tables in the Editor
	See end of this document for all avaiable plugs
	and dojox/editorPlugins/tests/editorTablePlugs.html for an example
	NOT IMPLEMENTED: Not handling cell merge, span or split</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="iconClassPrefix" scope="prototype" type="String"/>
      <property name="useDefaultCommand" scope="prototype" type="bool"/>
      <property name="buttonClass" scope="instance" type=""/>
      <property name="commandName" scope="prototype" type="String"/>
      <property name="label" scope="prototype" type="Object"/>
      <property name="alwaysAvailable" scope="instance-prototype" type="Object"/>
      <property name="undoEnabled" scope="prototype" type="bool"/>
      <property name="available" scope="prototype" type=""/>
      <property name="menu" scope="prototype" type=""/>
      <property name="command" scope="prototype" type=""/>
      <property name="valBeforeUndo" scope="prototype" type="Object"/>
      <property name="editor" scope="prototype" type=""/>
      <property name="dropDown" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="onDisplayChanged" scope="prototype">
        <parameters>
          <parameter name="withinTable" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setEditor" scope="prototype"/>
      <method name="onEditorLoaded" scope="prototype"/>
      <method name="_createContextMenu" scope="prototype"/>
      <method name="selectTable" scope="prototype"/>
      <method name="launchInsertDialog" scope="prototype"/>
      <method name="launchModifyDialog" scope="prototype"/>
      <method name="_initButton" scope="prototype"/>
      <method name="modTable" scope="instance-prototype">
        <parameters>
          <parameter name="cmd" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="begEdit" scope="prototype"/>
      <method name="endEdit" scope="prototype"/>
      <method name="makeColumnsEven" scope="prototype"/>
      <method name="getTableInfo" scope="prototype">
        <parameters>
          <parameter name="forceNewData" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_makeTitle" scope="prototype">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getSelectedCells" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.editor.plugins.TablePlugins.button.domNode" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.editor.plugins.EditorTableDialog" type="Function" classlike="true" superclass="dijit.Dialog">
    <mixins>
      <mixin scope="instance" location="dijit.Dialog"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="onInsert" scope="prototype"/>
      <method name="onBuildTable" scope="prototype">
        <parameters>
          <parameter name="tableText" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.EditorModifyTableDialog" type="Function" classlike="true" superclass="dijit.Dialog">
    <mixins>
      <mixin scope="instance" location="dijit.Dialog"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="table" scope="prototype" type="Object"/>
      <property name="tableAtts" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="brdColor" scope="prototype" type=""/>
      <property name="bkColor" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="setBrdColor" scope="prototype">
        <parameters>
          <parameter name="color" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setBkColor" scope="prototype">
        <parameters>
          <parameter name="color" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSet" scope="prototype"/>
      <method name="onSetTable" scope="prototype">
        <parameters>
          <parameter name="tableText" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins._ToolbarLineBreak" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A 'line break' between two &lt;code&gt;dijit.Toolbar&lt;/code&gt; items so that very
	long toolbars can be organized a bit.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="isFocusable" scope="prototype">
        <summary>This widget isn't focusable, so pass along that fact.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins.UploadImage" type="Function" classlike="true" superclass="dijit._editor._Plugin">
    <summary>Adds an icon to the Editor toolbar that when clicked, opens a system dialog
	Although the toolbar icon is a tiny &amp;quot;image&amp;quot; the uploader could be used for
	any file type</summary>
    <mixins>
      <mixin scope="instance" location="dijit._editor._Plugin"/>
    </mixins>
    <properties>
      <property name="tempImageUrl" scope="prototype" type="String"/>
      <property name="iconClassPrefix" scope="prototype" type="String"/>
      <property name="useDefaultCommand" scope="prototype" type="bool"/>
      <property name="uploadUrl" scope="prototype" type="String"/>
      <property name="button" scope="prototype" type="Object"/>
      <property name="label" scope="prototype" type="String"/>
      <property name="command" scope="prototype" type="String"/>
      <property name="currentImageId" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setToolbar" scope="prototype">
        <parameters>
          <parameter name="toolbar" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_initButton" scope="prototype"/>
      <method name="createFileInput" scope="prototype"/>
      <method name="onComplete" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
          <parameter name="ioArgs" type="" usage="required"/>
          <parameter name="widgetRef" type="" usage="required"/>
        </parameters>
      </method>
      <method name="insertTempImage" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.editor.plugins._SmileyPalette" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A keyboard accessible HTML entity-picking widget (for inserting symbol characters)</summary>
    <description>Grid showing various emoticons
	Can be used standalone, or as a popup.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dojox.editor.plugins._SmileyPalette"&gt;&lt;/div&gt;</example>
      <example>    var picker = new dojox.editor.plugins._SmileyPalette({ },srcNode);
		picker.startup();</example>
    </examples>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The basic template used to render the palette.
	Should generally be over-ridden to define different classes.</summary>
      </property>
      <property name="defaultTimeout" scope="prototype" type="Number">
        <summary>Number of milliseconds before a held key or button becomes typematic</summary>
      </property>
      <property name="timeoutChangeRate" scope="prototype" type="Number">
        <summary>Fraction of time used to change the typematic timer between events
	1.0 means that each typematic event fires at defaultTimeout intervals
	&amp;lt; 1.0 means that each typematic event fires at an increasing faster rate</summary>
      </property>
      <property name="value" scope="prototype" type="String">
        <summary>The value of the selected entity.</summary>
      </property>
      <property name="_currentFocus" scope="prototype" type="Integer">
        <summary>Index of the currently focused entity.</summary>
      </property>
      <property name="_xDim" scope="prototype" type="Integer">
        <summary>This is the number of entity columns horizontally across.</summary>
      </property>
      <property name="_yDim" scope="prototype" type="Integer">
        <summary>/		This is the number of entity rows down.</summary>
      </property>
      <property name="tabIndex" scope="prototype" type="String">
        <summary>Widget tab index.</summary>
      </property>
      <property name="_created" scope="prototype" type="boolean">
        <summary>Flag indicating the widget has initialized.</summary>
      </property>
      <property name="_cellNodes" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="focus" scope="prototype">
        <summary>Focus this EntityPalette.  Puts focus on the first swatch.</summary>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Callback when a entity is selected.</summary>
        <parameters>
          <parameter name="entity" type="String" usage="required">
            <summary>Entity value corresponding to an html entity character.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_focusFirst" scope="prototype">
        <summary>Focus the first cell in the color picker,
	or the previously selected cell, if there is one</summary>
      </method>
      <method name="_onTableNodeFocus" scope="prototype">
        <summary>Handler for when focus goes to the EntityPalette itself.
	Shifts focus to the first entity or the previously selected
	color.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onFocus" scope="prototype">
        <summary>Handler for when the EntityPalette or a entity cell inside of it get focus</summary>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>Handler for when the palette and the cell inside of it lose focus</summary>
      </method>
      <method name="_onCellDijitclick" scope="prototype">
        <summary>Handler for click, enter key &amp;amp; space key. Selects the entity.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellMouseEnter" scope="prototype">
        <summary>Handler for onMouseOver. Put focus on the entity under the mouse.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The mouse event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onCellFocus" scope="prototype">
        <summary>Handler for onFocus of a cell. Removes highlight of
	the color that just lost focus, and highlights
	the new entity.</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required">
            <summary>The focus event.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setCurrent" scope="prototype">
        <summary>Called when a entity is hovered or focused.</summary>
        <description>Removes highlight of the old entity, and highlights
	the new entity.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_onCellBlur" scope="prototype">
        <summary>needed for Firefox 2 on Mac OS X</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_removeCellHighlight" scope="prototype">
        <summary>Removes the hover CSS class for the specified cell</summary>
        <parameters>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_selectEntity" scope="prototype">
        <summary>This selects an entity. It triggers the onChange event with the string representation of the selected
	entity.
	area:
	The area node that covers the entity being selected.</summary>
        <parameters>
          <parameter name="selectNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_navigateByKey" scope="prototype">
        <summary>This is the callback for typematic.
	It changes the focus and the highlighed entity.</summary>
        <parameters>
          <parameter name="increment" type="How" usage="required">
            <summary>much the key is navigated.</summary>
          </parameter>
          <parameter name="typeCount" type="How" usage="required">
            <summary>many times typematic has fired.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.editor.plugins._SmileyPalette.smileys" type="String">
    <summary>The symbol pallete to display.  The only current one is 'latin'.</summary>
    <properties>
      <property name="emoticonSmile" scope="normal" type="String"/>
      <property name="emoticonLaughing" scope="normal" type="String"/>
      <property name="emoticonWink" scope="normal" type="String"/>
      <property name="emoticonGrin" scope="normal" type="String"/>
      <property name="emoticonCool" scope="normal" type="String"/>
      <property name="emoticonAngry" scope="normal" type="String"/>
      <property name="emoticonHalf" scope="normal" type="String"/>
      <property name="emoticonEyebrow" scope="normal" type="String"/>
      <property name="emoticonFrown" scope="normal" type="String"/>
      <property name="emoticonShy" scope="normal" type="String"/>
      <property name="emoticonGoofy" scope="normal" type="String"/>
      <property name="emoticonOops" scope="normal" type="String"/>
      <property name="emoticonTongue" scope="normal" type="String"/>
      <property name="emoticonIdea" scope="normal" type="String"/>
      <property name="emoticonYes" scope="normal" type="String"/>
      <property name="emoticonNo" scope="normal" type="String"/>
      <property name="emoticonAngel" scope="normal" type="String"/>
      <property name="emoticonCrying" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.editor.plugins._SmileyPalette.domNode.style" type="">
    <properties>
      <property name="position" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.embed.Flash" type="Function" classlike="true">
    <summary>Creates a wrapper object around a Flash movie.  Wrapper object will
	insert the movie reference in node; when the browser first starts
	grabbing the movie, onReady will be fired; when the movie has finished
	loading, it will fire onLoad.
	If your movie uses ExternalInterface, you should use the onLoad event
	to do any kind of proxy setup (see dojox.embed.Flash.proxy); this seems
	to be the only consistent time calling EI methods are stable (since the
	Flash movie will shoot several methods into the window object before
	EI callbacks can be used properly).
	arguments:</summary>
    <examples>
      <example>Embed a flash movie in a document using the new operator, and get a reference to it.
		var movie = new dojox.embed.Flash({
			path: "path/to/my/movie.swf",
			width: 400,
			height: 300
		}, myWrapperNode, "testLoaded");</example>
      <example>Embed a flash movie in a document without using the new operator.
		var movie = dojox.embed.Flash({
			path: "path/to/my/movie.swf",
			width: 400,
			height: 300,
			style: "position:absolute;top:0;left:0"
		}, myWrapperNode, "testLoaded");
	File can only be run from a server, due to SWF dependency.</example>
    </examples>
    <properties>
      <property name="minSupported" scope="normal" type="Number">
        <summary>The minimum supported version of the Flash Player, defaults to 8.</summary>
      </property>
      <property name="available" scope="instance" type="Number">
        <summary>Used as both a detection (i.e. if(dojox.embed.Flash.available){ })
	and as a variable holding the major version of the player installed.</summary>
      </property>
      <property name="supported" scope="normal" type="Boolean">
        <summary>Whether or not the Flash Player installed is supported by dojox.embed.</summary>
      </property>
      <property name="minimumRequired" scope="normal" type=""/>
      <property name="version" scope="normal" type="Object">
        <summary>The version of the installed Flash Player; takes the form of
	{ major, minor, rev }.  To get the major version, you'd do this:
	var v=dojox.embed.Flash.version.major;</summary>
      </property>
      <property name="initialized" scope="normal" type="Boolean">
        <summary>Whether or not the Flash engine is available for use.</summary>
      </property>
      <property name="minimumVersion" scope="instance" type="Object"/>
      <property name="id" scope="instance" type="String">
        <summary>The ID of the internal embed/object tag.  Can be used to get a reference to
	the movie itself.</summary>
      </property>
      <property name="movie" scope="instance" type="HTMLObject">
        <summary>A reference to the Flash movie itself.</summary>
      </property>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="kwArgs" type="dojox.embed.__flashArgs" usage="required">
            <summary>See dojox.embed.__flashArgs</summary>
          </parameter>
          <parameter name="node" type="DOMNode" usage="required">
            <summary>DomNode The node where the embed object will be placed
	properties:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onInitialize" scope="normal">
        <summary>A stub you can connect to if you are looking to fire code when the
	engine becomes available.  A note: DO NOT use this event to
	place a movie in a document; it will usually fire before DOMContentLoaded
	is fired, and you will get an error.  Use dojo.addOnLoad instead.</summary>
      </method>
      <method name="__ie_markup__" scope="normal">
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="proxy" scope="normal">
        <summary>Create the set of passed methods on the dojox.embed.Flash object
	so that you can call that object directly, as opposed to having to
	delve into the internal movie to do this.  Intended to make working
	with Flash movies that use ExternalInterface much easier to use.</summary>
        <examples>
          <example>Create "setMessage" and "getMessage" methods on foo.
		var foo = new dojox.embed.Flash(args, someNode);
		dojo.connect(foo, "onLoad", dojo.hitch(foo, function(){
			dojox.embed.Flash.proxy(this, [ "setMessage", "getMessage" ]);
			this.setMessage("dojox.embed.Flash.proxy is pretty cool...");
			console.log(this.getMessage());
		}));</example>
        </examples>
        <parameters>
          <parameter name="obj" type="dojox.embed.Flash" usage="required"/>
          <parameter name="methods" type="Array|String" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="prototype">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="prototype">
        <parameters>
          <parameter name="movie" type="HTMLObject" usage="required"/>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onload" scope="prototype">
        <summary>Internal. Cleans up before calling onLoad.</summary>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="byId" scope="prototype">
        <summary>Gets Flash movie by id.</summary>
        <description>Probably includes methods for outdated
	browsers, but this should catch all cases.
	arguments:</description>
        <examples>
          <example> var movie = dojox.embed.Flash.byId("myId");</example>
        </examples>
        <parameters>
          <parameter name="movieName" type="String" usage="required">
            <summary>The name of the SWF</summary>
          </parameter>
          <parameter name="doc" type="Object" usage="required">
            <summary>The document, if not current window
	(not fully supported)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="place" scope="normal">
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.embed">
    <summary>Base code for embedding for external objects like Flash, Quicktime</summary>
  </object>
  <object location="dojox.embed.Flash.init" type="Function" classlike="true">
    <properties>
      <property name="_poller" scope="instance" type="Object"/>
      <property name="_pollCount" scope="instance" type="Number"/>
      <property name="_pollMax" scope="instance" type="Number"/>
      <property name="pollTime" scope="instance" type="Number"/>
      <property name="id" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="kwArgs" type="dojox.embed.__flashArgs" usage="required"/>
          <parameter name="node" type="DOMNode" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.embed.Flash._destroy" type="Function" classlike="true" private="true">
    <properties>
      <property name="id" scope="instance" type="Object"/>
      <property name="movie" scope="instance" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.embed.__flashArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="id" scope="instance" type="String">
        <summary>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</summary>
      </property>
      <property name="path" scope="instance" type="String">
        <summary>The URL of the movie to embed.</summary>
      </property>
      <property name="width" scope="instance" type="Number">
        <summary>The width of the embedded movie; the default value is 320px.</summary>
      </property>
      <property name="minimumVersion" scope="instance" type="Number">
        <summary>?
	The minimum targeted version of the Flash Player (defaults to 9)</summary>
      </property>
      <property name="height" scope="instance" type="Number">
        <summary>The height of the embedded movie; the default value is 240px</summary>
      </property>
      <property name="style" scope="instance" type="String">
        <summary>Any CSS style information (i.e. style=&amp;quot;background-color:transparent&amp;quot;) you want
	to define on the markup.</summary>
      </property>
      <property name="params" scope="instance" type="Object">
        <summary>A set of key/value pairs that you want to define in the resultant markup.</summary>
      </property>
      <property name="vars" scope="instance" type="Object">
        <summary>A set of key/value pairs that the Flash movie will interpret as FlashVars.</summary>
      </property>
      <property name="expressInstall" scope="instance" type="Boolean">
        <summary>Whether or not to include any kind of expressInstall info. Default is false.</summary>
      </property>
      <property name="redirect" scope="instance" type="String">
        <summary>A url to redirect the browser to if the current Flash version is not supported.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="path" type="String" usage="required">
            <summary>The URL of the movie to embed.</summary>
          </parameter>
          <parameter name="id" type="String" usage="optional">
            <summary>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</summary>
          </parameter>
          <parameter name="width" type="Number" usage="optional">
            <summary>The width of the embedded movie; the default value is 320px.</summary>
          </parameter>
          <parameter name="height" type="Number" usage="optional">
            <summary>The height of the embedded movie; the default value is 240px</summary>
          </parameter>
          <parameter name="style" type="String" usage="optional">
            <summary>Any CSS style information (i.e. style=&amp;quot;background-color:transparent&amp;quot;) you want
	to define on the markup.</summary>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <summary>A set of key/value pairs that you want to define in the resultant markup.</summary>
          </parameter>
          <parameter name="vars" type="Object" usage="optional">
            <summary>A set of key/value pairs that the Flash movie will interpret as FlashVars.</summary>
          </parameter>
          <parameter name="expressInstall" type="Boolean" usage="optional">
            <summary>Whether or not to include any kind of expressInstall info. Default is false.</summary>
          </parameter>
          <parameter name="redirect" type="String" usage="optional">
            <summary>A url to redirect the browser to if the current Flash version is not supported.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.embed.Object" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget you can use to embed either a Flash or Quicktime
	movie.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <examples>
      <example>From markup:
		&lt;div dojoType="dojox.embed.Object" src="path/to/movie.swf"&gt;&lt;/div&gt;</example>
      <example>Programmatic:
		var mov=new dojox.embed.Object({
			src: "path/to/movie.swf"
		}, node);</example>
    </examples>
    <properties>
      <property name="width" scope="prototype" type="Number">
        <summary>The width of the movie. If not provided, the width of this.domNode is used.</summary>
      </property>
      <property name="height" scope="prototype" type="Number">
        <summary>The height of the movie. If not provided, the height of this.domNode is used.</summary>
      </property>
      <property name="src" scope="prototype" type="String">
        <summary>The URL of the movie to embed.</summary>
      </property>
      <property name="movie" scope="prototype" type="HTMLEmbed">
        <summary>The eventual reference to the movie embedded.  If you are looking to script
	control over the movie, you'd access it this way.</summary>
      </property>
      <property name="params" scope="prototype" type="Object">
        <summary>A property bag that is created postCreate.  Any additional attributes you
	define on your domNode will be collected and placed into this, which will
	then be passed to the movie constructor.</summary>
      </property>
      <property name="reFlash" scope="prototype" type="RegExp">
        <summary>Expression used on the src property to determine if this is Flash or Quicktime.</summary>
      </property>
      <property name="reQtMovie" scope="prototype" type="RegExp">
        <summary>Expression used on the src property to determine if this is Flash or Quicktime.</summary>
      </property>
      <property name="reQtAudio" scope="prototype" type="RegExp">
        <summary>Expression used on the src property to determine if this is Flash or Quicktime.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.embed.Object.domNode" type=""/>
  <object location="dojox.embed.Object.domNode.attributes" type="">
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.embed.Quicktime" type="Function">
    <summary>Returns a reference to the HTMLObject/HTMLEmbed that is created to
	place the movie in the document.  You can use this either with or
	without the new operator.  Note that with any other DOM manipulation,
	you must wait until the document is finished loading before trying
	to use this.</summary>
    <examples>
      <example>Embed a QuickTime movie in a document using the new operator, and get a reference to it.
		var movie = new dojox.embed.Quicktime({
			path: "path/to/my/movie.mov",
			width: 400,
			height: 300
		}, myWrapperNode);</example>
      <example>Embed a movie in a document without using the new operator.
		var movie = dojox.embed.Quicktime({
			path: "path/to/my/movie.mov",
			width: 400,
			height: 300
		}, myWrapperNode);</example>
    </examples>
    <properties>
      <property name="minSupported" scope="normal" type="Number">
        <summary>The minimum supported version of the QuickTime Player, defaults to
	6.</summary>
      </property>
      <property name="available" scope="normal" type="Boolean">
        <summary>Whether or not QuickTime is available.</summary>
      </property>
      <property name="supported" scope="normal" type="Boolean">
        <summary>Whether or not the QuickTime Player installed is supported by
	dojox.embed.</summary>
      </property>
      <property name="version" scope="normal" type="Object">
        <summary>The version of the installed QuickTime Player; takes the form of
	{ major, minor, rev }.  To get the major version, you'd do this:
	var v=dojox.embed.Quicktime.version.major;</summary>
      </property>
      <property name="initialized" scope="normal" type="Boolean">
        <summary>Whether or not the QuickTime engine is available for use.</summary>
      </property>
    </properties>
    <methods>
      <method name="onInitialize" scope="normal">
        <summary>A stub you can connect to if you are looking to fire code when the
	engine becomes available.  A note: do NOT use this stub to embed
	a movie in your document; this WILL be fired before DOMContentLoaded
	is fired, and you will get an error.  You should use dojo.addOnLoad
	to place your movie instead.</summary>
      </method>
      <method name="place" scope="normal">
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="QuickTimeObject"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.embed.__QTArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="id" scope="instance" type="String">
        <summary>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</summary>
      </property>
      <property name="path" scope="instance" type="String">
        <summary>The URL of the movie to embed.</summary>
      </property>
      <property name="width" scope="instance" type="Number">
        <summary>The width of the embedded movie; the default value is 320px.</summary>
      </property>
      <property name="height" scope="instance" type="Number">
        <summary>The height of the embedded movie; the default value is 240px</summary>
      </property>
      <property name="params" scope="instance" type="Object">
        <summary>A set of key/value pairs that you want to define in the resultant markup.</summary>
      </property>
      <property name="redirect" scope="instance" type="String">
        <summary>A url to redirect the browser to if the current QuickTime version is not supported.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="path" type="String" usage="required">
            <summary>The URL of the movie to embed.</summary>
          </parameter>
          <parameter name="id" type="String" usage="optional">
            <summary>A unique key that will be used as the id of the created markup.  If you don't
	provide this, a unique key will be generated.</summary>
          </parameter>
          <parameter name="width" type="Number" usage="optional">
            <summary>The width of the embedded movie; the default value is 320px.</summary>
          </parameter>
          <parameter name="height" type="Number" usage="optional">
            <summary>The height of the embedded movie; the default value is 240px</summary>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <summary>A set of key/value pairs that you want to define in the resultant markup.</summary>
          </parameter>
          <parameter name="redirect" type="String" usage="optional">
            <summary>A url to redirect the browser to if the current QuickTime version is not supported.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.embed.flashVars" type="">
    <description>JSON could be done, but Deft does not yet have a JSON parser, and quotes are
	very problematic since Flash cannot use eval(); JSON parsing was successful
	when it was fully escaped, but that made it very large anyway. flashvar
	serialization at most is 200% larger than JSON.
	See:
	Deft/common/flashVars.as</description>
    <methods>
      <method name="serialize" scope="normal">
        <summary>Key method. Serializes an object.</summary>
        <parameters>
          <parameter name="n" type="String" usage="required">
            <summary>The name for the object, such as: &amp;quot;button&amp;quot;</summary>
          </parameter>
          <parameter name="o" type="Object" usage="required">
            <summary>The object to serialize</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding">
    <summary>Various encoding algorithms, including crypto and digests.</summary>
    <properties>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.encoding.ascii85">
    <methods>
      <method name="encode" scope="normal">
        <summary>encodes input data in ascii85 string</summary>
        <parameters>
          <parameter name="input" type="Array:" usage="required">
            <summary>an array of numbers (0-255) to encode</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="normal">
        <summary>decodes the input string back to array of numbers</summary>
        <parameters>
          <parameter name="input" type="String:" usage="required">
            <summary>the input string to decode</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.base64">
    <methods>
      <method name="encode" scope="normal">
        <parameters>
          <parameter name="ba" type="byte[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="decode" scope="normal">
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="byte[]"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.bits"/>
  <object location="dojox.encoding.bits.OutputStream" type="Function" classlike="true">
    <methods>
      <method constructor="constructor"/>
      <method name="getWidth" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.encoding.bits.OutputStream.reset" type="Function" classlike="true">
    <properties>
      <property name="buffer" scope="instance" type="Array"/>
      <property name="accumulator" scope="instance" type="Number"/>
      <property name="available" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.encoding.bits.OutputStream.putBits" type="Function" classlike="true">
    <properties>
      <property name="accumulator" scope="instance" type="Number"/>
      <property name="available" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="width" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.bits.OutputStream.getBuffer" type="Function" classlike="true">
    <properties>
      <property name="buffer" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.encoding.bits.InputStream" type="Function" classlike="true">
    <properties>
      <property name="buffer" scope="instance" type=""/>
      <property name="width" scope="instance" type=""/>
      <property name="bbyte" scope="instance" type="Number"/>
      <property name="bit" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="buffer" type="" usage="required"/>
          <parameter name="width" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.encoding.bits.InputStream.getBits" type="Function" classlike="true">
    <properties>
      <property name="bit" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="width" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.compression.lzw"/>
  <object location="dojox.encoding.compression.lzw.Encoder" type="Function" classlike="true">
    <properties>
      <property name="size" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.compression.lzw.Encoder.init" type="Function" classlike="true">
    <properties>
      <property name="dict" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="code" scope="instance" type=""/>
      <property name="p" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.encoding.compression.lzw.Encoder.encode" type="Function" classlike="true">
    <properties>
      <property name="p" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="stream" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.compression.lzw.Encoder.flush" type="Function" classlike="true">
    <properties>
      <property name="p" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="stream" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.compression.lzw.Decoder" type="Function" classlike="true">
    <properties>
      <property name="size" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.compression.lzw.Decoder.init" type="Function" classlike="true">
    <properties>
      <property name="codes" scope="instance" type="Object"/>
      <property name="width" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.encoding.compression.lzw.Decoder.decode" type="Function" classlike="true">
    <properties>
      <property name="p" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="stream" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.compression">
    <properties>
      <property name="splay" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.encoding.compression.Splay" type="Function" classlike="true">
    <properties>
      <property name="up" scope="instance" type="Object"/>
      <property name="left" scope="instance" type="Object"/>
      <property name="right" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
      <method name="splay" scope="prototype">
        <parameters>
          <parameter name="i" type="" usage="required"/>
        </parameters>
      </method>
      <method name="encode" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="stream" type="" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="prototype">
        <parameters>
          <parameter name="stream" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.crypto">
    <properties>
      <property name="Blowfish" scope="normal" type="Object"/>
      <property name="RSAKey-ext" scope="normal" type="Object"/>
      <property name="SimpleAES" scope="normal" type="Object"/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.encoding.crypto.RSAKey" type="Function" classlike="true">
    <summary>&amp;quot;empty&amp;quot; RSA key constructor
	rndf: Function?:
	function that returns an instance of a random number generator
	(see dojox.math.random for details)</summary>
    <properties>
      <property name="n" scope="instance-prototype" type="Object"/>
      <property name="e" scope="instance-prototype" type="Number"/>
      <property name="rngf" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="dmp1" scope="instance" type="Object"/>
      <property name="dmq1" scope="instance" type="Object"/>
      <property name="coeff" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rngf" type="" usage="required"/>
        </parameters>
      </method>
      <method name="decrypt" scope="prototype">
        <summary>Return the PKCS#1 RSA decryption of &amp;quot;ctext&amp;quot;.</summary>
        <return-description>a plain string.</return-description>
        <parameters>
          <parameter name="ctext" type="String:" usage="required">
            <summary>an even-length hex string</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>&amp;quot;empty&amp;quot; RSA key constructor
	rndf: Function?:
	function that returns an instance of a random number generator
	(see dojox.math.random for details)</summary>
        <parameters>
          <parameter name="rngf" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setPublic" scope="prototype">
        <summary>Set the public key fields N and e from hex strings</summary>
        <parameters>
          <parameter name="N" type="" usage="required"/>
          <parameter name="E" type="" usage="required"/>
        </parameters>
      </method>
      <method name="encrypt" scope="prototype">
        <parameters>
          <parameter name="text" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.crypto.RSAKey.setPrivate" type="Function" classlike="true">
    <summary>Set the private key fields N, e, d and CRT params from hex strings</summary>
    <properties>
      <property name="n" scope="instance" type="Object"/>
      <property name="e" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="N" type="" usage="required"/>
          <parameter name="E" type="" usage="required"/>
          <parameter name="D" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.crypto.RSAKey.setPrivateEx" type="Function" classlike="true">
    <summary>Set the private key fields N, e, d and CRT params from hex strings</summary>
    <properties>
      <property name="n" scope="instance" type="Object"/>
      <property name="e" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="dmp1" scope="instance" type="Object"/>
      <property name="dmq1" scope="instance" type="Object"/>
      <property name="coeff" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="N" type="" usage="required"/>
          <parameter name="E" type="" usage="required"/>
          <parameter name="D" type="" usage="required"/>
          <parameter name="P" type="" usage="required"/>
          <parameter name="Q" type="" usage="required"/>
          <parameter name="DP" type="" usage="required"/>
          <parameter name="DQ" type="" usage="required"/>
          <parameter name="C" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.crypto.RSAKey.generate" type="Function" classlike="true">
    <summary>Generate a new random private key B bits long, using public expt E</summary>
    <properties>
      <property name="e" scope="instance" type="Object"/>
      <property name="p" scope="instance" type="Object"/>
      <property name="q" scope="instance" type="Object"/>
      <property name="n" scope="instance" type="Object"/>
      <property name="d" scope="instance" type="Object"/>
      <property name="dmp1" scope="instance" type="Object"/>
      <property name="dmq1" scope="instance" type="Object"/>
      <property name="coeff" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="B" type="" usage="required"/>
          <parameter name="E" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.math.BigInteger" type="Function" classlike="true">
    <properties>
      <property name="_nbi" scope="normal" type=""/>
      <property name="_nbv" scope="normal" type=""/>
      <property name="_nbits" scope="normal" type=""/>
      <property name="_Montgomery" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.math.random">
    <methods>
      <method name="prng4" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.math.random.Simple" type="Function" classlike="true">
    <summary>Super simple implementation of a random number generator,
	which relies on Math.random().</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="destroy" scope="prototype">
        <summary>Prepares the object for GC. (empty in this case)</summary>
      </method>
      <method name="nextBytes" scope="prototype">
        <summary>Fills in an array of bytes with random numbers</summary>
        <parameters>
          <parameter name="byteArray" type="Array" usage="required">
            <summary>Array: array to be filled in with random numbers, only existing
	elements will be filled.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.crypto.cipherModes">
    <properties>
      <property name="ECB" scope="normal" type="Number"/>
      <property name="CBC" scope="normal" type="Number"/>
      <property name="PCBC" scope="normal" type="Number"/>
      <property name="CFB" scope="normal" type="Number"/>
      <property name="OFB" scope="normal" type="Number"/>
      <property name="CTR" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.encoding.crypto.outputTypes">
    <properties>
      <property name="Base64" scope="normal" type="Number"/>
      <property name="Hex" scope="normal" type="Number"/>
      <property name="String" scope="normal" type="Number"/>
      <property name="Raw" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.encoding.digests" type="">
    <properties>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="addWords" scope="normal">
        <summary>add a pair of words together with rollover</summary>
        <parameters>
          <parameter name="a" type="word" usage="required"/>
          <parameter name="b" type="word" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="word"/>
        </return-types>
      </method>
      <method name="stringToWord" scope="normal">
        <summary>convert a string to a word array</summary>
        <parameters>
          <parameter name="s" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="word[]"/>
        </return-types>
      </method>
      <method name="wordToString" scope="normal">
        <summary>convert an array of words to a string</summary>
        <parameters>
          <parameter name="wa" type="word[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToHex" scope="normal">
        <summary>convert an array of words to a hex tab</summary>
        <parameters>
          <parameter name="wa" type="word[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="wordToBase64" scope="normal">
        <summary>convert an array of words to base64 encoding, should be more efficient
	than using dojox.encoding.base64</summary>
        <parameters>
          <parameter name="wa" type="word[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.digests.MD5" type="Function">
    <methods>
      <method name="_hmac" scope="normal">
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="word[]"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.digests.SHA1" type="Function">
    <summary>Computes the SHA1 digest of the data, and returns the result according to output type.</summary>
    <methods>
      <method name="_hmac" scope="normal">
        <summary>computes the digest of data, and returns the result according to type outputType</summary>
        <parameters>
          <parameter name="data" type="string" usage="required"/>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="outputType" type="dojox.encoding.digests.outputTypes" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="word[]"/>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.encoding.digests.outputTypes">
    <summary>Enumeration for input and output encodings.</summary>
    <properties>
      <property name="Base64" scope="normal" type="Number"/>
      <property name="Hex" scope="normal" type="Number"/>
      <property name="String" scope="normal" type="Number"/>
      <property name="Raw" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.encoding.easy64">
    <methods>
      <method name="encode" scope="normal">
        <summary>encodes input data in easy64 string</summary>
        <parameters>
          <parameter name="input" type="Array:" usage="required">
            <summary>an array of numbers (0-255) to encode</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="decode" scope="normal">
        <summary>decodes the input string back to array of numbers</summary>
        <parameters>
          <parameter name="input" type="String:" usage="required">
            <summary>the input string to decode</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.flash" type="Function">
    <summary>Utilities to embed and communicate with Flash-based objects</summary>
    <description>The goal of dojox.flash is to make it easy to extend Flash's capabilities
	into an Ajax/DHTML environment.
	dojox.flash provides an easy object for interacting with the Flash plugin.
	This object provides methods to determine the current version of the Flash
	plugin (dojox.flash.info); write out the necessary markup to
	dynamically insert a Flash object into the page (dojox.flash.Embed; and
	do dynamic installation and upgrading of the current Flash plugin in
	use (dojox.flash.Install). If you want to call methods on the Flash object
	embedded into the page it is your responsibility to use Flash's ExternalInterface
	API and get a reference to the Flash object yourself.
	To use dojox.flash, you must first wait until Flash is finished loading
	and initializing before you attempt communication or interaction.
	To know when Flash is finished use dojo.connect:
		dojo.connect(dojox.flash, "loaded", myInstance, "myCallback");
	Then, while the page is still loading provide the file name:
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"));
	If no SWF files are specified, then Flash is not initialized.
	Your Flash must use Flash's ExternalInterface to expose Flash methods and
	to call JavaScript.
	setSwf can take an optional 'visible' attribute to control whether
	the Flash object is visible or not on the page; the default is visible:
		dojox.flash.setSwf(dojo.moduleUrl("dojox", "_storage/storage.swf"),
	false);
	Once finished, you can query Flash version information:
		dojox.flash.info.version
	Or can communicate with Flash methods that were exposed:
		var f = dojox.flash.get();
		var results = f.sayHello("Some Message");
	Your Flash files should use DojoExternalInterface.as to register methods;
	this file wraps Flash's normal ExternalInterface but correct various
	serialization bugs that ExternalInterface has.
	Note that dojox.flash is not meant to be a generic Flash embedding
	mechanism; it is as generic as necessary to make Dojo Storage's
	Flash Storage Provider as clean and modular as possible. If you want
	a generic Flash embed mechanism see [SWFObject](http://blog.deconcept.com/swfobject/).
	Notes:
	Note that dojox.flash can currently only work with one Flash object
	on the page; it does not yet support multiple Flash objects on
	the same page.
	Your code can detect whether the Flash player is installing or having
	its version revved in two ways. First, if dojox.flash detects that
	Flash installation needs to occur, it sets dojox.flash.info.installing
	to true. Second, you can detect if installation is necessary with the
	following callback:
		dojo.connect(dojox.flash, "installing", myInstance, "myCallback");
	You can use this callback to delay further actions that might need Flash;
	when installation is finished the full page will be refreshed and the
	user will be placed back on your page with Flash installed.
	-------------------
	Todo/Known Issues
	-------------------
	* On Internet Explorer, after doing a basic install, the page is
	not refreshed or does not detect that Flash is now available. The way
	to fix this is to create a custom small Flash file that is pointed to
	during installation; when it is finished loading, it does a callback
	that says that Flash installation is complete on IE, and we can proceed
	to initialize the dojox.flash subsystem.
	* Things aren't super tested for sending complex objects to Flash
	methods, since Dojo Storage only needs strings
	Author- Brad Neuberg, http://codinginparadise.org</description>
    <properties>
      <property name="ready" scope="normal" type="bool"/>
      <property name="url" scope="normal" type="Object"/>
      <property name="_visible" scope="normal" type="Object"/>
      <property name="_loadedListeners" scope="normal" type="Array"/>
      <property name="_installingListeners" scope="normal" type="Array"/>
      <property name="info" scope="normal" type="Object"/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="addLoadedListener" scope="normal">
        <summary>Adds a listener to know when Flash is finished loading.
	Useful if you don't want a dependency on dojo.event.</summary>
        <parameters>
          <parameter name="listener" type="Function" usage="required">
            <summary>A function that will be called when Flash is done loading.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addInstallingListener" scope="normal">
        <summary>Adds a listener to know if Flash is being installed.
	Useful if you don't want a dependency on dojo.event.</summary>
        <parameters>
          <parameter name="listener" type="Function" usage="required">
            <summary>A function that will be called if Flash is being
	installed</summary>
          </parameter>
        </parameters>
      </method>
      <method name="loaded" scope="normal">
        <summary>Called back when the Flash subsystem is finished loading.</summary>
        <description>A callback when the Flash subsystem is finished loading and can be
	worked with. To be notified when Flash is finished loading, add a
	loaded listener:
	dojox.flash.addLoadedListener(loadedListener);</description>
      </method>
      <method name="installing" scope="normal">
        <summary>Called if Flash is being installed.</summary>
        <description>A callback to know if Flash is currently being installed or
	having its version revved. To be notified if Flash is installing, connect
	your callback to this method using the following:
	dojo.event.connect(dojox.flash, "installing", myInstance, "myCallback");</description>
      </method>
      <method name="_initialize" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.flash.setSwf" type="Function" classlike="true">
    <summary>Sets the SWF files and versions we are using.</summary>
    <properties>
      <property name="url" scope="instance" type="String">
        <summary>The URL to this Flash file.
	visible: boolean?
	Whether the Flash file is visible or not. If it is not visible we hide
	it off the screen. This defaults to true (i.e. the Flash file is
	visible).</summary>
      </property>
      <property name="_visible" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="url" type="String" usage="required">
            <summary>The URL to this Flash file.</summary>
          </parameter>
          <parameter name="visible" type="boolean" usage="optional">
            <summary>Whether the Flash file is visible or not. If it is not visible we hide
	it off the screen. This defaults to true (i.e. the Flash file is
	visible).</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.flash.Info" type="Function" classlike="true">
    <summary>A class that helps us determine whether Flash is available.</summary>
    <description>A class that helps us determine whether Flash is available,
	it's major and minor versions, and what Flash version features should
	be used for Flash/JavaScript communication. Parts of this code
	are adapted from the automatic Flash plugin detection code autogenerated
	by the Macromedia Flash 8 authoring environment.
	An instance of this class can be accessed on dojox.flash.info after
	the page is finished loading.</description>
    <properties>
      <property name="version" scope="prototype" type="String">
        <summary>The full version string, such as &amp;quot;8r22&amp;quot;.</summary>
      </property>
      <property name="versionMajor" scope="prototype" type="Number"/>
      <property name="versionMinor" scope="prototype" type="Number"/>
      <property name="versionRevision" scope="prototype" type="Number"/>
      <property name="capable" scope="prototype" type="Boolean">
        <summary>Whether this platform has Flash already installed.</summary>
      </property>
      <property name="installing" scope="prototype" type="Boolean">
        <summary>Set if we are in the middle of a Flash installation session.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="isVersionOrAbove" scope="prototype">
        <summary>Asserts that this environment has the given major, minor, and revision
	numbers for the Flash player.</summary>
        <description>Asserts that this environment has the given major, minor, and revision
	numbers for the Flash player.
	Example- To test for Flash Player 7r14:
	dojox.flash.info.isVersionOrAbove(7, 0, 14)</description>
        <return-description>Returns true if the player is equal
	or above the given version, false otherwise.</return-description>
        <parameters>
          <parameter name="reqMajorVer" type="int" usage="required"/>
          <parameter name="reqMinorVer" type="int" usage="required"/>
          <parameter name="reqVer" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="_JSFlashInfo" scope="prototype">
        <parameters>
          <parameter name="testVersion" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.flash.Info._detectVersion" type="Function" classlike="true" private="true">
    <properties>
      <property name="capable" scope="instance" type="Object"/>
      <property name="versionMajor" scope="instance" type=""/>
      <property name="versionMinor" scope="instance" type=""/>
      <property name="versionRevision" scope="instance" type=""/>
      <property name="version" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.flash.Embed" type="Function" classlike="true">
    <summary>A class that is used to write out the Flash object into the page.</summary>
    <description>Writes out the necessary tags to embed a Flash file into the page. Note that
	these tags are written out as the page is loaded using document.write, so
	you must call this class before the page has finished loading.</description>
    <properties>
      <property name="_visible" scope="instance-prototype" type="Object"/>
      <property name="width" scope="prototype" type="int">
        <summary>The width of this Flash applet. The default is the minimal width
	necessary to show the Flash settings dialog. Current value is
	215 pixels.</summary>
      </property>
      <property name="height" scope="prototype" type="int">
        <summary>The height of this Flash applet. The default is the minimal height
	necessary to show the Flash settings dialog. Current value is
	138 pixels.</summary>
      </property>
      <property name="id" scope="prototype" type="String">
        <summary>The id of the Flash object. Current value is 'flashObject'.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="visible" type="" usage="required"/>
        </parameters>
      </method>
      <method name="protocol" scope="prototype"/>
      <method name="write" scope="prototype">
        <summary>Writes the Flash into the page.</summary>
        <description>This must be called before the page
	is finished loading.</description>
        <parameters>
          <parameter name="doExpressInstall" type="Boolean" usage="optional">
            <summary>Whether to write out Express Install
	information. Optional value; defaults to false.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <summary>Gets the Flash object DOM node.</summary>
      </method>
      <method name="setVisible" scope="prototype">
        <summary>Sets the visibility of this Flash object.</summary>
        <parameters>
          <parameter name="visible" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.flash.Embed.center" type="Function" classlike="true">
    <summary>Centers the flash applet on the page.</summary>
    <properties>
      <property name="width" scope="instance" type=""/>
      <property name="height" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.flash.Communicator" type="Function" classlike="true">
    <summary>A class that is used to communicate between Flash and JavaScript.</summary>
    <description>This class helps mediate Flash and JavaScript communication. Internally
	it uses Flash 8's ExternalInterface API, but adds functionality to fix
	various encoding bugs that ExternalInterface has.</description>
    <methods>
      <method constructor="constructor"/>
      <method name="_addExternalInterfaceCallback" scope="prototype">
        <parameters>
          <parameter name="methodName" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_encodeData" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_decodeData" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_execFlash" scope="prototype">
        <parameters>
          <parameter name="methodName" type="" usage="required"/>
          <parameter name="methodArgs" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.flash.Install" type="Function" classlike="true">
    <summary>Helps install Flash plugin if needed.</summary>
    <description>Figures out the best way to automatically install the Flash plugin
	for this browser and platform. Also determines if installation or
	revving of the current plugin is needed on this platform.</description>
    <methods>
      <method constructor="constructor"/>
      <method name="needed" scope="prototype">
        <summary>Determines if installation or revving of the current plugin is
	needed.</summary>
      </method>
      <method name="install" scope="prototype">
        <summary>Performs installation or revving of the Flash plugin.</summary>
      </method>
      <method name="_onInstallStatus" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form">
    <summary>Form-related widgets</summary>
    <properties>
      <property name="DropDownSelect" scope="normal" type="Object"/>
      <property name="RangeSlider" scope="normal" type="Object"/>
      <property name="_FormSelectWidget" scope="normal" type="Object"/>
      <property name="_HasDropDown" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form._BusyButtonMixin" type="Function" classlike="true">
    <properties>
      <property name="isBusy" scope="prototype" type="bool"/>
      <property name="busyLabel" scope="prototype" type="String"/>
      <property name="timeout" scope="prototype" type="Object"/>
      <property name="useIcon" scope="prototype" type="Object"/>
      <property name="_label" scope="prototype" type=""/>
      <property name="_initTimeout" scope="prototype" type=""/>
      <property name="_timeout" scope="prototype" type="Object"/>
      <property name="label" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype">
        <summary>stores initial label and timeout for reference</summary>
      </method>
      <method name="makeBusy" scope="prototype">
        <summary>sets state from idle to busy</summary>
      </method>
      <method name="cancel" scope="prototype">
        <summary>if no timeout is set or for other reason the user can put the button back
	to being idle</summary>
      </method>
      <method name="resetTimeout" scope="prototype">
        <summary>to reset existing timeout and setting a new timeout</summary>
        <parameters>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="setLabel" scope="prototype">
        <summary>reset the label (text) of the button; takes an HTML string</summary>
        <parameters>
          <parameter name="content" type="String" usage="required"/>
          <parameter name="timeout" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="_clicked" scope="prototype">
        <summary>on button click the button state gets changed</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form._BusyButtonMixin.containerNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form._BusyButtonMixin.titleNode" type="">
    <properties>
      <property name="title" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form.BusyButton" type="Function" classlike="true" superclass="dijit.form.Button">
    <mixins>
      <mixin scope="prototype" location="dojox.form._BusyButtonMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.Button"/>
      <mixin scope="instance" location="dojox.form._BusyButtonMixin"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.form.BusyComboButton" type="Function" classlike="true" superclass="dijit.form.ComboButton">
    <mixins>
      <mixin scope="prototype" location="dojox.form._BusyButtonMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.ComboButton"/>
      <mixin scope="instance" location="dojox.form._BusyButtonMixin"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.form.BusyDropDownButton" type="Function" classlike="true" superclass="dijit.form.DropDownButton">
    <mixins>
      <mixin scope="prototype" location="dojox.form._BusyButtonMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.DropDownButton"/>
      <mixin scope="instance" location="dojox.form._BusyButtonMixin"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.form._CheckedMultiSelectItem" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>The individual items for a CheckedMultiSelect</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="parent" scope="prototype" type="Object"/>
      <property name="disabled" scope="prototype" type="boolean">
        <summary>Whether or not this widget is disabled</summary>
      </property>
      <property name="readOnly" scope="prototype" type="boolean">
        <summary>Whether or not this widget is readOnly</summary>
      </property>
      <property name="_type" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype">
        <summary>Set the appropriate _subClass value - based on if we are multi-
	or single-select</summary>
      </method>
      <method name="postCreate" scope="prototype">
        <summary>Set innerHTML here - since the template gets messed up sometimes
	with rich text</summary>
      </method>
      <method name="_changeBox" scope="prototype">
        <summary>Called to force the select to match the state of the check box
	(only on click of the checkbox)  Radio-based calls _setValueAttr
	instead.</summary>
      </method>
      <method name="_onMouse" scope="prototype">
        <summary>Sets the hover state depending on mouse state (passes through
	to the check box)</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="prototype">
        <summary>Sets the click state (passes through to the check box)</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateBox" scope="prototype">
        <summary>Called to force the box to match the state of the select</summary>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>Disables (or enables) all the children as well</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="prototype">
        <summary>Sets read only (or unsets) all the children as well</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form._CheckedMultiSelectItem.option" type="dojox.form.__SelectOption">
    <summary>The option that is associated with this item</summary>
    <properties>
      <property name="disabled" scope="prototype" type="bool"/>
      <property name="selected" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form._CheckedMultiSelectItem.labelNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form.CheckedMultiSelect" type="Function" classlike="true" superclass="dijit.form._FormSelectWidget">
    <summary>Extends the core dijit MultiSelect to provide a &amp;quot;checkbox&amp;quot; selector</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormSelectWidget"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="readOnly" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_mouseDown" scope="prototype">
        <summary>Cancels the mousedown event to prevent others from stealing
	focus</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_addOptionItem" scope="prototype">
        <parameters>
          <parameter name="option" type="dojox.form.__SelectOption" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelection" scope="prototype"/>
      <method name="_getChildren" scope="prototype"/>
      <method name="invertSelection" scope="prototype">
        <summary>Invert the selection</summary>
        <parameters>
          <parameter name="onChange" type="Boolean" usage="required">
            <summary>If null, onChange is not fired.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>Disable (or enable) all the children as well</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyAttr" scope="prototype">
        <summary>Sets read only (or unsets) all the children as well</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="uninitialize" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.form.DateTextBox" type="Function" classlike="true" superclass="dijit.form._DateTimeTextBox">
    <summary>A validating, serializable, range-bound date text box with a popup calendar</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form._DateTimeTextBox"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="prototype" type="String">
        <summary>The popup widget to use. In this case, a calendar with Day, Month and Year views.</summary>
      </property>
      <property name="_selector" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_open" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.form.DayTextBox" type="Function" classlike="true" superclass="dojox.form.DateTextBox">
    <summary>A validating, serializable, range-bound date text box with a popup calendar that contains just months.</summary>
    <mixins>
      <mixin scope="instance" location="dojox.form.DateTextBox"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="prototype" type="String">
        <summary>The popup widget to use. In this case, a calendar with just a Month view.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="parse" scope="prototype">
        <parameters>
          <parameter name="displayVal" type="" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_open" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.form.DayTextBox._picker" type="">
    <properties>
      <property name="onValueSelected" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form.MonthTextBox" type="Function" classlike="true" superclass="dojox.form.DateTextBox">
    <summary>A validating, serializable, range-bound date text box with a popup calendar that contains only years</summary>
    <mixins>
      <mixin scope="instance" location="dojox.form.DateTextBox"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="prototype" type="String">
        <summary>The popup widget to use. In this case, a calendar with just a Year view.</summary>
      </property>
      <property name="selector" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="parse" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="constraints" type="" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="constraints" type="" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_open" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.form.MonthTextBox.constraints" type="">
    <properties>
      <property name="datePattern" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.MonthTextBox._picker" type="">
    <properties>
      <property name="onValueSelected" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form.YearTextBox" type="Function" classlike="true" superclass="dojox.form.DateTextBox">
    <summary>A validating, serializable, range-bound date text box with a popup calendar that contains only years</summary>
    <mixins>
      <mixin scope="instance" location="dojox.form.DateTextBox"/>
    </mixins>
    <properties>
      <property name="popupClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="validator" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_open" scope="prototype"/>
      <method name="parse" scope="prototype">
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="dojo.date.locale.__FormatOptions" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="filter" scope="prototype">
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form.YearTextBox._picker" type="">
    <properties>
      <property name="onValueSelected" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form.DropDownStack" type="Function" classlike="true" superclass="dijit.form.Select">
    <summary>A dropdown-based select stack.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.form._SelectStackMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.Select"/>
      <mixin scope="instance" location="dojox.form._SelectStackMixin"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.form.FileInput" type="Function" classlike="true" superclass="dijit.form._FormWidget">
    <summary>A styled input type=&amp;quot;file&amp;quot;</summary>
    <description>A input type="file" form widget, with a button for uploading to be styled via css,
	a cancel button to clear selection, and FormWidget mixin to provide standard dijit.form.Form
	support (FIXME: maybe not fully implemented)</description>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormWidget"/>
    </mixins>
    <properties>
      <property name="label" scope="prototype" type="String">
        <summary>the title text of the &amp;quot;Browse&amp;quot; button</summary>
      </property>
      <property name="cancelText" scope="prototype" type="String">
        <summary>the title of the &amp;quot;Cancel&amp;quot; button</summary>
      </property>
      <property name="name" scope="prototype" type="String">
        <summary>ugh, this should be pulled from this.domNode</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_listener" scope="prototype" type="Object"/>
      <property name="_keyListener" scope="prototype" type="Object"/>
      <property name="fileInput" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>listen for changes on our real file input</summary>
      </method>
      <method name="_matchValue" scope="prototype">
        <summary>set the content of the upper input based on the semi-hidden file input</summary>
      </method>
      <method name="setLabel" scope="prototype">
        <summary>method to allow use to change button label</summary>
        <parameters>
          <parameter name="label" type="String" usage="required"/>
          <parameter name="cssClass" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <summary>on click of cancel button, since we can't clear the input because of
	security reasons, we destroy it, and add a new one in it's place.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form.FileInput.inputNode" type="">
    <properties>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.FileInput.cancelNode.style" type="">
    <properties>
      <property name="visibility" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.FileInput.titleNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form.FileInputAuto" type="Function" classlike="true" superclass="dojox.form.FileInput">
    <summary>An extension on dojox.form.FileInput providing background upload progress</summary>
    <description>An extended version of FileInput - when the user focuses away from the input
	the selected file is posted via dojo.io.iframe to the url. example implementation
	comes with PHP solution for handling upload, and returning required data.
	notes: the return data from the io.iframe is used to populate the input element with
	data regarding the results. it will be a JSON object, like:
	results = { size: "1024", filename: "file.txt" }
	all the parameters allowed to dojox.form.FileInput apply</description>
    <mixins>
      <mixin scope="instance" location="dojox.form.FileInput"/>
    </mixins>
    <properties>
      <property name="url" scope="prototype" type="String">
        <summary>the URL where our background FileUpload will be sent</summary>
      </property>
      <property name="blurDelay" scope="prototype" type="Integer">
        <summary>time in ms before an un-focused widget will wait before uploading the file to the url=&amp;quot;&amp;quot; specified
	default: 2 seconds</summary>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <summary>The time in ms to use as the generic timing mechanism for the animations
	set to 1 or 0 for &amp;quot;immediate respose&amp;quot;</summary>
      </property>
      <property name="uploadMessage" scope="prototype" type="String">
        <summary>FIXME: i18n somehow?</summary>
      </property>
      <property name="triggerEvent" scope="prototype" type="String">
        <summary>Event which triggers the upload. Defaults to onblur, sending the file selected
	'blurDelay' milliseconds after losing focus. Set to &amp;quot;onchange&amp;quot; with a low blurDelay
	to send files immediately after uploading.</summary>
      </property>
      <property name="_sent" scope="prototype" type="bool"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_blurListener" scope="prototype" type="Object"/>
      <property name="_focusListener" scope="prototype" type="Object"/>
      <property name="_blurTimer" scope="prototype" type="Object"/>
      <property name="_sending" scope="prototype" type="bool"/>
      <property name="fileInput" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>add our extra blur listeners</summary>
      </method>
      <method name="_onFocus" scope="prototype">
        <summary>clear the upload timer</summary>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>start the upload timer</summary>
      </method>
      <method name="setMessage" scope="prototype">
        <summary>set the text of the progressbar</summary>
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_sendFile" scope="prototype">
        <summary>triggers the chain of events needed to upload a file in the background.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleSend" scope="prototype">
        <summary>The callback to toggle the progressbar, and fire the user-defined callback</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
          <parameter name="ioArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <summary>accomodate our extra focusListeners</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="prototype">
        <summary>stub function fired when an upload has finished.</summary>
        <parameters>
          <parameter name="data" type="the" usage="required">
            <summary>raw data found in the first [TEXTAREA] tag of the post url</summary>
          </parameter>
          <parameter name="ioArgs" type="the" usage="required">
            <summary>dojo.Deferred data being passed from the handle: callback</summary>
          </parameter>
          <parameter name="widgetRef" type="this" usage="required">
            <summary>widget pointer, so you can set this.overlay to a completed/error message easily</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form.FileInputAuto.overlay.style" type="">
    <properties>
      <property name="backgroundImage" scope="prototype" type="String"/>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.FileInputAuto.fileInput.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.FileInputAuto.fakeNodeHolder.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.FileInputBlind" type="Function" classlike="true" superclass="dojox.form.FileInputAuto">
    <summary>An extended version of dojox.form.FileInputAuto
	that does not display an input node, but rather only a button
	and otherwise behaves just like FileInputAuto</summary>
    <mixins>
      <mixin scope="instance" location="dojox.form.FileInputAuto"/>
    </mixins>
    <properties>
      <property name="_off" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>hide our fileInput input field</summary>
      </method>
      <method name="_fixPosition" scope="prototype">
        <summary>in this case, set the button under where the visible button is</summary>
      </method>
      <method name="reset" scope="prototype">
        <summary>onclick, we need to reposition our newly created input type=&amp;quot;file&amp;quot;</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form.FileInputBlind.inputNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.FilePickerTextBox" type="Function" classlike="true" superclass="dijit.form.ValidationTextBox">
    <summary>A validating text box tied to a file picker popup</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._HasDropDown.prototype"/>
      <mixin scope="instance" location="dijit.form.ValidationTextBox"/>
      <mixin scope="instance" location="dijit._HasDropDown"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="searchDelay" scope="prototype" type="Integer">
        <summary>Delay in milliseconds between when user types something and we start
	searching based on that value</summary>
      </property>
      <property name="_stopClickEvents" scope="prototype" type="bool"/>
      <property name="valueItem" scope="prototype" type="item">
        <summary>The item, in our store, of the directory relating to our value</summary>
      </property>
      <property name="numPanes" scope="prototype" type="number">
        <summary>The number of panes to display in our box (if we don't have any
	minPaneWidth specified by our constraints)</summary>
      </property>
      <property name="_skip" scope="prototype" type="Object"/>
      <property name="_hasValidPath" scope="prototype" type="bool"/>
      <property name="_menuFocus" scope="prototype" type=""/>
      <property name="_allowBlur" scope="prototype" type="Object"/>
      <property name="_settingBlurValue" scope="prototype" type="Object"/>
      <property name="_hasSelection" scope="prototype" type="bool"/>
      <property name="_searchTimer" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <summary>sets the value of this widget</summary>
        <parameters>
          <parameter name="value" type="string" usage="required"/>
          <parameter name="priorityChange" type="" usage="required"/>
          <parameter name="fromWidget" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onWidgetChange" scope="prototype">
        <summary>called when the path gets changed in the dropdown</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="openDropDown" scope="prototype"/>
      <method name="toggleDropDown" scope="prototype"/>
      <method name="_focusBlur" scope="prototype">
        <summary>called when the focus node gets blurred</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusFocus" scope="prototype">
        <summary>called when the focus node gets focus</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBlur" scope="prototype">
        <summary>called when focus is shifted away from this widget</summary>
      </method>
      <method name="_setBlurValue" scope="prototype">
        <summary>sets the value of the widget once focus has left</summary>
      </method>
      <method name="parse" scope="prototype">
        <summary>Function to convert a formatted string to a value - we use
	it to verify that it *really* is a valid value</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="constraints" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearchFromInput" scope="prototype">
        <summary>kicks off a search based off the current text value of the widget</summary>
      </method>
      <method name="_onKey" scope="prototype">
        <summary>callback when the user presses a key on menu popup node</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form.FilePickerTextBox.focusNode" type="">
    <properties>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.FilePickerTextBox.dropDown.domNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.FilePickerTextBox.dropDown">
    <properties>
      <property name="topDir" scope="prototype" type=""/>
      <property name="pathSeparator" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form.FileUploader" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Handles File Uploading to a server (PHP script included for testing)
	***NEW: FileUploader is now a WIDGET. You do not have to pass a button
	in. Passing a button is still supported until version 1.5 to maintain
	backwards compatibility, but it is not reccomended. Just create your
	uploader like any other widget.</summary>
    <description>If the correct version of Flash Player is available (&gt; 9.0) , a SWF
	is used. If Flash Player is not installed or is outdated, a typical
	html fileInput is used. This process can be overridden with</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <examples>
      <example>fileMask = ["Images", "*.jpg;*.jpeg;*.gif;*.png"]
	or
	fileMask = [
	["Jpeg File", 	"*.jpg;*.jpeg"],
	["GIF File", 	"*.gif"],
	["PNG File", 	"*.png"],
	["All Images", 	"*.jpg;*.jpeg;*.gif;*.png"],
	]
	NOTE: MacType is not supported, as it does not work very well.
	fileMask will work on a Mac, but differently than
	Windows.</example>
    </examples>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="uploadUrl" scope="prototype" type="String">
        <summary>The url targeted for upload. An absolute URL is preferred. Relative URLs are
	changed to absolute.
	button: dijit.form.Button or a domNode
	DEPRECATED: The &amp;quot;fake&amp;quot; button that when clicked, launches the upload dialog
	button:&amp;quot;&amp;quot;,</summary>
      </property>
      <property name="isDebug" scope="prototype" type="Boolean">
        <summary>If true, outputs traces from the SWF to console. What exactly gets passed
	is very relative, and depends upon what traces have been left in the DEFT SWF.</summary>
      </property>
      <property name="devMode" scope="prototype" type="Boolean.">
        <summary>Re-implemented. devMode increases the logging, adding style tracing from the SWF.
	id: String
	The object id, just like any other widget in Dojo. However, this id
	is also used as a reference for the SWF
	id: &amp;quot;&amp;quot;,</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String">
        <summary>The name of the class that will style the button in a &amp;quot;normal&amp;quot; state.
	If baseClass is not defined, 'class' will be used.
	NOTE: By default the uploader will be styled like a dijit buttons and
	adhere to the the themes. Tundra, Soria, and Nihilo are supported.
	You can cascade the existing style by using 'class' or 'style'. If you
	overwrite baseClass, you should overwrite the remaing state classes
	that follow) as well.</summary>
      </property>
      <property name="hoverClass" scope="prototype" type="String">
        <summary>The name of the class that will style the button in a &amp;quot;hover&amp;quot; state. A specific
	class should be made to do this. Do not rely on a target like button:hover{...}</summary>
      </property>
      <property name="activeClass" scope="prototype" type="String">
        <summary>The name of the class that will style the button in a &amp;quot;press&amp;quot; state. A specific
	class should be made to do this. Do not rely on a target like button:active{...}</summary>
      </property>
      <property name="disabledClass" scope="prototype" type="String">
        <summary>The name of the class that will style the button when its disabled.</summary>
      </property>
      <property name="force" scope="prototype" type="String">
        <summary>Use &amp;quot;flash&amp;quot; to always use Flash (and hopefully force the user to download the plugin
	if they don't have it). Use &amp;quot;html&amp;quot; to always use the HTML uploader. An empty string
	(default) will check for the right version of Flash and use HTML if not available.</summary>
      </property>
      <property name="uploaderType" scope="prototype" type="String">
        <summary>Internal. What type of uploader is being used: &amp;quot;flash&amp;quot; or &amp;quot;html&amp;quot;</summary>
      </property>
      <property name="flashDiv" scope="prototype" type="HTMLNode">
        <summary>DEPRECATED for insideNode
	The div that holds the SWF and form/fileInput</summary>
      </property>
      <property name="deferredUploading" scope="prototype" type="Number">
        <summary>(1 - X)
	(Flash only) throttles the upload to a certain amount of files at a time.
	By default, Flash uploads file one at a time to the server, but in parallel.
	Firefox will try to queue all files at once, leading to problems. Set this
	to the amount to upload in parallel at a time.
	Generally, 1 should work fine, but you can experiment with queuing more than
	one at a time.
	This is of course ignored if selectMultipleFiles equals false.</summary>
      </property>
      <property name="fileListId" scope="prototype" type="String">
        <summary>The id of a dom node to be used as a container for the pending file list.</summary>
      </property>
      <property name="uploadOnChange" scope="prototype" type="Boolean">
        <summary>If true, uploads imediately after a file has been selected. If false,
	waits for upload() to be called.</summary>
      </property>
      <property name="selectMultipleFiles" scope="prototype" type="Boolean">
        <summary>If true and flash mode, multiple files may be selected from the dialog.
	If html mode, files are not uploaded until upload() is called. The references
	to each file is incremented:uploadedfile0, uploadedfile1, uploadedfile2... etc.</summary>
      </property>
      <property name="htmlFieldName" scope="prototype" type="String">
        <summary>The name of the field of the fileInput that the server is expecting</summary>
      </property>
      <property name="flashFieldName" scope="prototype" type="String">
        <summary>The name of the field of the flash uploaded files that the server is expecting</summary>
      </property>
      <property name="fileMask" scope="prototype" type="Array[">
        <summary>Array[Description, FileTypes], Array[...]...]
	(an array, or an array of arrays)
	Restrict file selection to certain file types
	Empty array defaults to &amp;quot;All Files&amp;quot;</summary>
      </property>
      <property name="minFlashVersion" scope="prototype" type="Number">
        <summary>The minimum of version of Flash player to target. 0 would always install Flash, 100
	would never install it. The Flash Player has supported multiple uploads since
	version 8, so it could go as low as that safely.</summary>
      </property>
      <property name="tabIndex" scope="prototype" type="Number|String">
        <summary>The tab order in the DOM. Only supported by Flash. HTML Uploaders have security
	protection to prevent you from tabbing to the uploader. Stupid.</summary>
      </property>
      <property name="showProgress" scope="prototype" type="Boolean">
        <summary>If true, the button changes to a progress bar during upload.</summary>
      </property>
      <property name="progressMessage" scope="prototype" type="String">
        <summary>The message shown while the button is changed to a progress bar</summary>
      </property>
      <property name="progressBackgroundUrl" scope="prototype" type="String|Uri">
        <summary>The background image to use for the button-progress</summary>
      </property>
      <property name="progressBackgroundColor" scope="prototype" type="String|Number">
        <summary>The background color to use for the button-progress</summary>
      </property>
      <property name="progressWidgetId" scope="prototype" type="String">
        <summary>The widget id of a Dijit Progress bar. The Uploader will bind to it and update it
	automatically.</summary>
      </property>
      <property name="skipServerCheck" scope="prototype" type="Boolean">
        <summary>If true, will not verify that the server was sent the correct format.
	This can be safely set to true. The purpose of the server side check
	is mainly to show the dev if they've implemented the different returns
	correctly.</summary>
      </property>
      <property name="serverTimeout" scope="prototype" type="Number">
        <summary>(milliseconds)
	The amount of time given to the uploaded file
	to wait for a server response. After this amount
	of time, the onComplete is fired but with a 'server timeout'
	error in the returned item.</summary>
      </property>
      <property name="fileList" scope="prototype" type="Array"/>
      <property name="_cons" scope="prototype" type="Array"/>
      <property name="fileInputs" scope="prototype" type="Array"/>
      <property name="fileCount" scope="prototype" type="Number"/>
      <property name="flashReady" scope="prototype" type="bool"/>
      <property name="_disabled" scope="prototype" type="bool"/>
      <property name="swfPath" scope="prototype" type=""/>
      <property name="_refNode" scope="prototype" type=""/>
      <property name="button" scope="prototype" type="Object"/>
      <property name="_hiddenNode" scope="prototype" type=""/>
      <property name="srcNodeRef" scope="prototype" type=""/>
      <property name="pressClass" scope="prototype" type="String"/>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
      <property name="over" scope="prototype" type="Object"/>
      <property name="down" scope="prototype" type="Object"/>
      <property name="dsbl" scope="prototype" type="Object"/>
      <property name="restoreProgDisplay" scope="prototype" type="String"/>
      <property name="postData" scope="prototype" type=""/>
      <property name="nextFocusObject" scope="prototype" type=""/>
      <property name="dialogIsOpen" scope="prototype" type="bool"/>
      <property name="id" scope="prototype" type=""/>
      <property name="_subs" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="flashMovie" scope="prototype">
        <summary>The SWF. Mostly Internal.</summary>
      </method>
      <method name="log" scope="prototype">
        <summary>Due to the excessive logging necessary to make this code happen,
	It's easier to turn it on and off here in one place.
	Also helpful if there are multiple uploaders on one page.</summary>
      </method>
      <method name="constructor" scope="prototype"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="getButtonStyle" scope="prototype">
        <summary>Internal.
	Get necessary style information from srcRefNode and
	assigned styles</summary>
      </method>
      <method name="setButtonStyle" scope="prototype">
        <summary>Internal.
	Set up internal dom nodes for button construction.</summary>
      </method>
      <method name="onChange" scope="prototype">
        <summary>stub to connect
	Fires when files are selected
	Event is an array of last files selected</summary>
        <parameters>
          <parameter name="dataArray" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onProgress" scope="prototype">
        <summary>Stub to connect
	Fires as progress returns from SWF
	Event is an array of all files uploading
	Can be connected to for HTML uploader,
	but will not return anything.</summary>
        <parameters>
          <parameter name="dataArray" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onComplete" scope="prototype">
        <summary>stub to connect
	Fires when all files have uploaded
	Event is an array of all files</summary>
        <parameters>
          <parameter name="dataArray" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="prototype">
        <summary>Stub to connect
	Fires when dialog box has been closed
	without a file selection</summary>
      </method>
      <method name="onError" scope="prototype">
        <summary>Fires on errors
	FIXME: Unsure of a standard form for receiving errors</summary>
        <parameters>
          <parameter name="evtObject" type="Object" usage="required">
            <summary>or String</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onReady" scope="prototype">
        <summary>Stub - Fired when dojox.embed.Flash has created the
	Flash object, but it has not necessarilly finished
	downloading, and is ready to be communicated with.</summary>
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="prototype">
        <summary>Stub - SWF has been downloaded 100%.</summary>
        <parameters>
          <parameter name="uploader" type="dojox.form.FileUploader" usage="required"/>
        </parameters>
      </method>
      <method name="submit" scope="prototype">
        <summary>If FileUploader is in a form, and other data should be sent
	along with the files, use this instead of form submit.</summary>
        <parameters>
          <parameter name="form" type="form" usage="required">
            <summary>node ?</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="upload" scope="prototype">
        <summary>When called, begins file upload</summary>
        <parameters>
          <parameter name="data" type="Object" usage="required">
            <summary>postData to be sent to server</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeFile" scope="prototype">
        <summary>Removes a file from the pending file list.
	Removes pending data from the Flash movie
	and fileInputes from the HTML uploader.
	If a file container node is bound, the file
	will also be removed.</summary>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <summary>The name of the file to be removed. Typically the file name,
	such as: picture01.png</summary>
          </parameter>
          <parameter name="noListEdit" type="Boolean" usage="required">
            <summary>Internal. If true don't remove files from list.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="destroyAll" scope="prototype">
        <summary>Destroys button</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroys uploader button</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Hides the upload button.</summary>
      </method>
      <method name="show" scope="prototype">
        <summary>Shows the upload button. This is called
	when within a dialog.</summary>
      </method>
      <method name="disable" scope="prototype">
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_displayProgress" scope="prototype">
        <summary>Shows and updates the built-in progress bar.</summary>
        <parameters>
          <parameter name="display" type="Boolean" usage="required">
            <summary>or Number</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_animateProgress" scope="prototype">
        <summary>Internal. Animated the built-in progress bar</summary>
      </method>
      <method name="_error" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_addToFileList" scope="prototype">
        <summary>Internal only. If there is a file list, adds a file to it.
	If you need to use a function such as this, connect to
	onChange and update outside of this widget.</summary>
      </method>
      <method name="_change" scope="prototype">
        <summary>Internal. Updates uploader selection</summary>
        <parameters>
          <parameter name="dataArray" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_complete" scope="prototype">
        <summary>Internal. Handles tasks after files have finished uploading</summary>
        <parameters>
          <parameter name="dataArray" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_progress" scope="prototype">
        <summary>Internal. Calculate progress</summary>
        <parameters>
          <parameter name="dataObject" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getDisabledAttr" scope="prototype">
        <summary>Internal. To get disabled use: widget.attr(&amp;quot;disabled&amp;quot;);</summary>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>Internal. To set disabled use: widget.attr(&amp;quot;disabled&amp;quot;, true | false);</summary>
        <parameters>
          <parameter name="disabled" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onFlashBlur" scope="prototype">
        <summary>Internal. Detects when Flash movies reliquishes focus.
	We have to find all the tabIndexes in the doc and figure
	out whom to give focus to next.</summary>
      </method>
      <method name="_disconnect" scope="prototype">
        <summary>Internal. Disconnects fileInput in favor of new one.</summary>
      </method>
      <method name="uploadHTML" scope="prototype">
        <summary>Internal. You could use this, but you should use upload() or submit();
	which can also handle the post data.
	NOTE on deferredUploading:
	This is not enabled for HTML. Workaround would be to force
	singleFile uploads.
	TODO:
	Investigate removing fileInputs and resending form
	multiple times adding each fileInput</summary>
      </method>
      <method name="createHtmlUploader" scope="prototype">
        <summary>Internal. Fires of methods to build HTML Uploader.</summary>
      </method>
      <method name="_connectInput" scope="prototype">
        <summary>Internal. HTML Uploader connections. These get disconnected
	after upload or if multi upload.</summary>
      </method>
      <method name="_checkHtmlCancel" scope="prototype">
        <summary>Internal. Check if the dialog was opened and canceled without file selection.</summary>
        <parameters>
          <parameter name="mouseType" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_styleContent" scope="prototype">
        <summary>Internal.Apply style to node</summary>
      </method>
      <method name="_resetHTML" scope="prototype">
        <summary>Internal. After upload, this is called to clear the form and build a new
	fileInput.</summary>
      </method>
      <method name="_buildForm" scope="prototype">
        <summary>Build the form that holds the fileInput</summary>
      </method>
      <method name="_buildFileInput" scope="prototype">
        <summary>Build the fileInput field</summary>
      </method>
      <method name="_renumberInputs" scope="prototype"/>
      <method name="_setFormStyle" scope="prototype">
        <summary>Apply a dynamic style to the form and input</summary>
      </method>
      <method name="_setHtmlPostData" scope="prototype">
        <summary>Internal.Apply postData to hidden fields in form</summary>
      </method>
      <method name="uploadFlash" scope="prototype">
        <summary>Internal. You should use upload() or submit();</summary>
      </method>
      <method name="createFlashUploader" scope="prototype">
        <summary>Internal. Creates Flash Uploader</summary>
      </method>
      <method name="_connectFlash" scope="prototype">
        <summary>Subscribing to published topics coming from the
	Flash uploader.</summary>
        <description>Sacrificing some readbilty for compactness. this.id
	will be on the beginning of the topic, so more than
	one uploader can be on a page and can have unique calls.</description>
      </method>
      <method name="_doSub" scope="prototype">
        <summary>Internal. Shortcut for subscribes to Flash movie</summary>
        <parameters>
          <parameter name="subStr" type="" usage="required"/>
          <parameter name="funcStr" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form.FileUploader.norm">
    <properties>
      <property name="lh" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form.FileUploader.progTextNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form.FileUploader.insideNode" type="HTMLNode">
    <summary>The div that holds the SWF and form/fileInput</summary>
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form.FileUploader.fhtml"/>
  <object location="dojox.form.FileUploader._formNode" private="true">
    <properties>
      <property name="encoding" scope="prototype" type="String"/>
      <property name="id" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form.FileUploader._fileInput" private="true">
    <properties>
      <property name="id" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.form.FileUploader.fhtml.nr" type="">
    <properties>
      <property name="w" scope="prototype" type=""/>
      <property name="h" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form.FileUploader.flashObject" type="dojox.embed.Flash">
    <summary>The object that creates the SWF embed object. Mostly Internal.</summary>
    <properties>
      <property name="onError" scope="prototype" type="Object"/>
      <property name="onReady" scope="prototype" type="Object"/>
      <property name="onLoad" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form.ListInput" type="Function" classlike="true" superclass="dijit.form._FormValueWidget">
    <summary>An automatic list maker</summary>
    <description>you can add value to list with add method.
	you can only remove by clicking close button</description>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormValueWidget"/>
    </mixins>
    <properties>
      <property name="inputClass" scope="prototype" type="String">
        <summary>Class which will be used to create the input box. You can implements yours.
	It must be a widget, focusNode or domNode must have &amp;quot;onkeydown&amp;quot; event
	It must have .attr(&amp;quot;value&amp;quot;) to get value
	It also must impement an (or more) handler for the &amp;quot;onChange&amp;quot; method</summary>
      </property>
      <property name="inputHandler" scope="prototype" type="String">
        <summary>|| Array
	The widget will connect on all handler to check input value
	You can use comma separated list</summary>
      </property>
      <property name="submitOnlyValidValue" scope="prototype" type="Boolean">
        <summary>If true, only valid value will be submited with form</summary>
      </property>
      <property name="useOnBlur" scope="prototype" type="Boolean">
        <summary>If true, onBlur event do a validate (like pressing ENTER)</summary>
      </property>
      <property name="readOnlyInput" scope="prototype" type="Boolean">
        <summary>if false, the list will be editable
	Can only be set when instanciate</summary>
      </property>
      <property name="maxItems" scope="prototype" type="Int">
        <summary>Specify max item the list can have
	null = infiny</summary>
      </property>
      <property name="showCloseButtonWhenValid" scope="prototype" type="Boolean">
        <summary>if true, a close button will be added on valid item</summary>
      </property>
      <property name="showCloseButtonWhenInvalid" scope="prototype" type="Boolean">
        <summary>if true, a close button will be added on invalid item</summary>
      </property>
      <property name="regExp" scope="instance-prototype" type="String">
        <summary>regular expression string used to validate the input
	Do not specify both regExp and regExpGen
	&amp;quot;[a-zA-Z.-_]+@[a-zA-Z.-_]+.[a-zA-Z]+&amp;quot;,</summary>
      </property>
      <property name="delimiter" scope="instance-prototype" type="String">
        <summary>|| Array
	delimiter for the string. Every match will be splitted
	The string can contain only one delimiter</summary>
      </property>
      <property name="constraints" scope="prototype" type="dijit.form.ValidationTextBox.__Constraints">
        <summary>user-defined object needed to pass parameters to the validator functions</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="type" scope="prototype" type="String"/>
      <property name="value" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="useAnim" scope="prototype" type="Boolean">
        <summary>If true, then item will use an anime to show hide itself</summary>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <summary>Animation duration</summary>
      </property>
      <property name="easingIn" scope="prototype" type="function">
        <summary>function used to easing on fadeIn end</summary>
      </property>
      <property name="easingOut" scope="prototype" type="function">
        <summary>function used to easing on fadeOut end</summary>
      </property>
      <property name="readOnlyItem" scope="prototype" type="Boolean">
        <summary>If true, items can be edited
	Can only be set when instanciate</summary>
      </property>
      <property name="useArrowForEdit" scope="prototype" type="Boolean">
        <summary>If true, arraow left and right can be used for editing
	Can only be set when instanciate</summary>
      </property>
      <property name="_items" scope="instance-prototype" type="Array">
        <summary>Array of widget.
	Contain all reference to _ListInputInputItem</summary>
      </property>
      <property name="_currentItem" scope="prototype" type="Widget">
        <summary>Widget currently in edition</summary>
      </property>
      <property name="_input" scope="prototype" type="Widget">
        <summary>Widget use for input box</summary>
      </property>
      <property name="_count" scope="prototype" type="Int">
        <summary>Count items</summary>
      </property>
      <property name="_lastValueReported" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="postCreate" scope="prototype">
        <summary>If closeButton is used, add a class</summary>
      </method>
      <method name="_setReadOnlyInputAttr" scope="prototype">
        <summary>Change status and if needed, create the inputbox</summary>
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_setReadOnlyItemAttr" scope="prototype">
        <summary>set read only items</summary>
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_createInputBox" scope="prototype">
        <summary>Create the input box</summary>
      </method>
      <method name="compare" scope="prototype">
        <summary>Compare 2 values (as returned by attr('value') for this widget).</summary>
        <parameters>
          <parameter name="val1" type="Array" usage="required"/>
          <parameter name="val2" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="prototype">
        <summary>Create new list element</summary>
        <parameters>
          <parameter name="values" type="String" usage="required">
            <summary>|| Array</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setReadOnlyWhenMaxItemsReached" scope="prototype">
        <summary>set input to readonly when max is reached</summary>
      </method>
      <method name="_setSelectNode" scope="prototype">
        <summary>put all item in the select (for a submit)</summary>
      </method>
      <method name="_placeItem" scope="prototype">
        <summary>Place item in the list</summary>
        <parameters>
          <parameter name="node" type="domNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getCursorPos" scope="prototype">
        <summary>get current cursor pos</summary>
        <parameters>
          <parameter name="node" type="domNode" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemClose" scope="prototype">
        <summary>Destroy a list element when close button is clicked</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemKeyDown" scope="prototype">
        <summary>Call when item get a keypress</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_editBefore" scope="prototype">
        <summary>move trough items</summary>
        <parameters>
          <parameter name="item" type="widget" usage="required"/>
        </parameters>
      </method>
      <method name="_editAfter" scope="prototype">
        <summary>move trough items</summary>
        <parameters>
          <parameter name="item" type="widget" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemChange" scope="prototype">
        <summary>Call when item value change</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemEdit" scope="prototype">
        <summary>Call when item is edited</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_testItem" scope="prototype">
        <summary>Change class of item (match, mismatch)</summary>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>get all value in then list and return an array</summary>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Hook so attr('value', value) works.</summary>
        <description>Sets the value of the widget.
	If the value has changed, then fire onChange event, unless priorityChange
	is specified as null (or false?)</description>
        <parameters>
          <parameter name="newValue" type="Array" usage="required">
            <summary>|| String</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_parseValue" scope="prototype">
        <summary>search for delemiters and split if needed</summary>
        <parameters>
          <parameter name="newValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="regExpGen" scope="prototype">
        <summary>Overridable function used to generate regExp when dependent on constraints.
	Do not specify both regExp and regExpGen.</summary>
        <parameters>
          <parameter name="constraints" type="dijit.form.ValidationTextBox.__Constraints" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>also enable/disable editable items</summary>
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandler" scope="prototype">
        <summary>When handlers of input are fired, this method check input value and (if needed) modify it</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onClick" scope="prototype">
        <summary>give focus to inputbox</summary>
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_focusInput" scope="prototype">
        <summary>give focus to input</summary>
      </method>
      <method name="_inputOnKeyDown" scope="prototype">
        <summary>Used to add keybord interactivity</summary>
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_inputOnBlur" scope="prototype">
        <summary>Remove focus class and act like pressing ENTER key</summary>
      </method>
      <method name="_getMatchedValueAttr" scope="prototype">
        <summary>get value that match regexp in then list and return an array</summary>
      </method>
      <method name="_getMismatchedValueAttr" scope="prototype">
        <summary>get value that mismatch regexp in then list and return an array</summary>
      </method>
      <method name="_getValues" scope="prototype">
        <summary>return values with comparator constraint</summary>
        <parameters>
          <parameter name="validator" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="_nullValidator" scope="prototype">
        <summary>return true or false</summary>
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_matchValidator" scope="prototype">
        <summary>return true or false</summary>
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_mismatchValidator" scope="prototype">
        <summary>return true or false</summary>
        <parameters>
          <parameter name="itemValue" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getLastItemAttr" scope="prototype">
        <summary>return the last item in list</summary>
      </method>
      <method name="_getSomeItem" scope="prototype">
        <summary>return the item before the one in params</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="position" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getPreviousItem" scope="prototype">
        <summary>return the item before the one in params</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_getNextItem" scope="prototype">
        <summary>return the item before the one in params</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_destroyItem" scope="prototype">
        <summary>destroy an item</summary>
        <parameters>
          <parameter name="item" type="dijit._Widget" usage="required"/>
          <parameter name="updateValue" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_updateValues" scope="prototype">
        <summary>update this.value and the select node</summary>
      </method>
      <method name="_destroyAllItems" scope="prototype">
        <summary>destroy all items</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroy all widget</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.form.ListInput.inputProperties" type="String">
    <summary>|| Object
	Properties used to create input box
	If String, it must be a valid JSON</summary>
    <properties>
      <property name="minWidth" scope="normal" type="Number"/>
      <property name="regExp" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form.ListInput._lastAddedItem" type="Widget" private="true">
    <summary>Contain a reference to the last created item</summary>
    <properties>
      <property name="onClose" scope="prototype" type="Object"/>
      <property name="onChange" scope="prototype" type="Object"/>
      <property name="onEdit" scope="prototype" type="Object"/>
      <property name="onKeyDown" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form.ListInput._selectNode.options" type="">
    <properties>
      <property name="length" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.form._ListInputInputItem" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Item created by ListInputInput when delimiter is found</summary>
    <description>Simple &lt;li&gt; with close button added to ListInputInput when delimiter is found</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="closeButtonNode" scope="prototype" type="domNode">
        <summary>ref to the close button node</summary>
      </property>
      <property name="readOnlyItem" scope="prototype" type="Boolean">
        <summary>if true, item is editable</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="value" scope="prototype" type="String">
        <summary>value of item</summary>
      </property>
      <property name="regExp" scope="prototype" type="String">
        <summary>regular expression string used to validate the input
	Do not specify both regExp and regExpGen</summary>
      </property>
      <property name="_editBox" scope="prototype" type="Widget">
        <summary>inline edit box</summary>
      </property>
      <property name="_handleKeyDown" scope="prototype" type="handle">
        <summary>handle for the keyDown connect</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype">
        <summary>Create the close button if needed</summary>
      </method>
      <method name="startup" scope="prototype">
        <summary>add the edit box</summary>
      </method>
      <method name="_setReadOnlyItemAttr" scope="prototype">
        <summary>change the readonly state</summary>
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_createInlineEditBox" scope="prototype">
        <summary>create the inline editbox if needed</summary>
      </method>
      <method name="edit" scope="prototype">
        <summary>enter inline editbox in edit mode</summary>
      </method>
      <method name="_onCloseEdit" scope="prototype">
        <summary>call when inline editor close himself</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_onEdit" scope="prototype">
        <summary>call when inline editor start editing</summary>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <summary>disable inline edit box</summary>
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype">
        <summary>return value</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroy the inline editbox</summary>
      </method>
      <method name="_onCloseEnter" scope="prototype">
        <summary>Called when user hovers over close icon</summary>
      </method>
      <method name="_onCloseLeave" scope="prototype">
        <summary>Called when user stops hovering over close icon</summary>
      </method>
      <method name="onClose" scope="prototype">
        <summary>callback when close button is clicked</summary>
      </method>
      <method name="onEdit" scope="prototype">
        <summary>callback when widget come in edition</summary>
      </method>
      <method name="onClick" scope="prototype">
        <summary>callback when widget is click</summary>
      </method>
      <method name="onChange" scope="prototype">
        <summary>callback when widget change its content</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <summary>callback when widget get a KeyDown</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form._ListInputInputItem.attributeMap"/>
  <object location="dojox.form._ListInputInputItem.attributeMap.value">
    <properties>
      <property name="node" scope="normal" type="String"/>
      <property name="type" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.form._ListInputInputBox" type="Function" classlike="true" superclass="dijit.form.ValidationTextBox">
    <summary>auto-sized text box</summary>
    <description>Auto sized textbox based on dijit.form.TextBox</description>
    <mixins>
      <mixin scope="instance" location="dijit.form.ValidationTextBox"/>
    </mixins>
    <properties>
      <property name="minWidth" scope="prototype" type="Integer">
        <summary>Min width of the input box</summary>
      </property>
      <property name="intermediateChanges" scope="prototype" type="Boolean">
        <summary>Fires onChange for each value change or only on demand
	Force to true in order to get onChanged called</summary>
      </property>
      <property name="regExp" scope="prototype" type="String">
        <summary>regular expression string used to validate the input
	Do not specify both regExp and regExpGen</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onChange" scope="prototype">
        <summary>compute content width</summary>
        <parameters>
          <parameter name="value" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>destroy the widget</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.form._ListInputInputBox._sizer" type="DomNode" private="true">
    <summary>Used to get size of textbox content</summary>
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.form.Manager" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>The widget to orchestrate dynamic forms.</summary>
    <description>This widget hosts dojox.form.manager mixins.
	See dojox.form.manager._Mixin for more info.</description>
    <mixins>
      <mixin scope="prototype" location="dojox.form.manager._Mixin.prototype"/>
      <mixin scope="prototype" location="dojox.form.manager._NodeMixin.prototype"/>
      <mixin scope="prototype" location="dojox.form.manager._FormMixin.prototype"/>
      <mixin scope="prototype" location="dojox.form.manager._ValueMixin.prototype"/>
      <mixin scope="prototype" location="dojox.form.manager._EnableMixin.prototype"/>
      <mixin scope="prototype" location="dojox.form.manager._DisplayMixin.prototype"/>
      <mixin scope="prototype" location="dojox.form.manager._ClassMixin.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dojox.form.manager._Mixin"/>
      <mixin scope="instance" location="dojox.form.manager._NodeMixin"/>
      <mixin scope="instance" location="dojox.form.manager._FormMixin"/>
      <mixin scope="instance" location="dojox.form.manager._ValueMixin"/>
      <mixin scope="instance" location="dojox.form.manager._EnableMixin"/>
      <mixin scope="instance" location="dojox.form.manager._DisplayMixin"/>
      <mixin scope="instance" location="dojox.form.manager._ClassMixin"/>
    </mixins>
    <properties>
      <property name="domNode" scope="prototype" type=""/>
      <property name="containerNode" scope="prototype" type=""/>
      <property name="_attachPoints" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="destroyRendering" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.form.MultiComboBox" type="Function" classlike="true" superclass="dijit.form.ValidationTextBox">
    <summary>A ComboBox that accpets multiple inputs on a single line?</summary>
    <mixins>
      <mixin scope="prototype" location="dijit.form.ComboBoxMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.ValidationTextBox"/>
      <mixin scope="instance" location="dijit.form.ComboBoxMixin"/>
    </mixins>
    <properties>
      <property name="delimiter" scope="prototype" type="String">
        <summary>The character to use to separate items in the ComboBox input</summary>
      </property>
      <property name="_previousMatches" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_addPreviousMatches" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cleanupDelimiters" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_autoCompleteText" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_startSearch" scope="prototype">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form._ChildTextBox" type="Function" classlike="true" superclass="dijit.form.ValidationTextBox">
    <summary>A class that is shared between all our children - extends
	ValidationTextBox and provides some shared functionality</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form.ValidationTextBox"/>
    </mixins>
    <properties>
      <property name="containerWidget" scope="prototype" type="widget">
        <summary>Our parent (the PasswordValidator)</summary>
      </property>
      <property name="type" scope="prototype" type="string">
        <summary>Don't override this - we are all &amp;quot;password&amp;quot; types</summary>
      </property>
      <property name="_hasBeenBlurred" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="reset" scope="prototype">
        <summary>Force-set to empty string (we don't save passwords EVER)...and
	since _OldPWBox overrides _setValueAttr to check for empty string,
	call our parent class directly (not this.inherited())</summary>
      </method>
      <method name="postCreate" scope="prototype">
        <summary>We want to remove the &amp;quot;name&amp;quot; attribute from our focus node if
	we don't have one set - this prevents all our extra values
	from being posted on submit</summary>
      </method>
      <method name="_onChildKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form._OldPWBox" type="Function" classlike="true" superclass="dojox.form._ChildTextBox">
    <summary>A class representing our &amp;quot;old password&amp;quot; box.</summary>
    <mixins>
      <mixin scope="instance" location="dojox.form._ChildTextBox"/>
    </mixins>
    <properties>
      <property name="_isPWValid" scope="prototype" type="boolean">
        <summary>Whether or not the password is valid</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setValueAttr" scope="prototype">
        <summary>Updates _isPWValid if this isn't our initial update by calling
	our PasswordValidator's pwCheck function</summary>
        <parameters>
          <parameter name="newVal" type="anything" usage="required"/>
          <parameter name="priority" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="isValid" scope="prototype">
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="prototype">
        <parameters>
          <parameter name="e" type="event" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype"/>
      <method name="_setBlurValue" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.form._NewPWBox" type="Function" classlike="true" superclass="dojox.form._ChildTextBox">
    <summary>A class representing our new password textbox</summary>
    <mixins>
      <mixin scope="instance" location="dojox.form._ChildTextBox"/>
    </mixins>
    <properties>
      <property name="required" scope="prototype" type="boolean">
        <summary>Whether or not this widget is required (default: true)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onChange" scope="prototype">
        <summary>Validates our verify box - to make sure that a change to me is
	reflected there</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.form._VerifyPWBox" type="Function" classlike="true" superclass="dojox.form._ChildTextBox">
    <summary>A class representing our verify textbox</summary>
    <mixins>
      <mixin scope="instance" location="dojox.form._ChildTextBox"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="isValid" scope="prototype">
        <summary>Validates that we match the &amp;quot;real&amp;quot; password</summary>
        <parameters>
          <parameter name="isFocused" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form.PasswordValidator" type="Function" classlike="true" superclass="dijit.form._FormValueWidget">
    <summary>A password validation widget that simplifies the &amp;quot;old/new/verify&amp;quot;
	style of requesting passwords.  You will probably want to override
	this class and implement your own pwCheck function.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormValueWidget"/>
    </mixins>
    <properties>
      <property name="required" scope="prototype" type="boolean">
        <summary>Whether or not it is required for form submission</summary>
      </property>
      <property name="_inputWidgets" scope="prototype" type="Array"/>
      <property name="oldName" scope="prototype" type="string">
        <summary>The name to send our old password as (when form is posted)</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_hasBeenBlurred" scope="prototype" type="bool"/>
      <property name="containerNode" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="isValid" scope="prototype">
        <summary>we are valid if ALL our children are valid</summary>
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="validate" scope="prototype">
        <summary>Validating this widget validates all our children</summary>
        <parameters>
          <parameter name="isFocused" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <summary>Resetting this widget resets all our children</summary>
      </method>
      <method name="_createSubWidgets" scope="prototype">
        <summary>Turns the inputs inside this widget into &amp;quot;real&amp;quot; validation
	widgets - and sets up the needed connections.</summary>
      </method>
      <method name="pwCheck" scope="prototype">
        <summary>Overridable function for validation of the old password box.
	This function is called and passed the old password.  Return
	true if it's OK to continue, and false if it is not.
	IMPORTANT SECURITY NOTE:  Do NOT EVER EVER EVER check this in
	HTML or JavaScript!!!
	You will probably want to override this function to callback
	to a server to verify the password (the callback will need to
	be syncronous) - and it's probably a good idea to validate
	it again on form submission before actually doing
	anything destructive - that's why the &amp;quot;oldName&amp;quot; value
	is available.
	And don't just fetch the password from the server
	either :)  Send the test password (probably hashed, for
	security) and return from the server a status instead.
	Again - DON'T BE INSECURE!!!  Security is left as an exercise
	for the reader :)</summary>
        <parameters>
          <parameter name="password" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype">
        <summary>Sets up the correct widgets.  You *MUST* specify one child
	text box (a simple HTML &amp;lt;input&amp;gt; element) with pwType=&amp;quot;new&amp;quot;
	*and* one child text box with pwType=&amp;quot;verify&amp;quot;.  You *MAY*
	specify a third child text box with pwType=&amp;quot;old&amp;quot; in order to
	prompt the user to enter in their old password before the
	widget returns that it is valid.</summary>
      </method>
      <method name="_childValueAttr" scope="prototype">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setDisabledAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setRequiredAttribute" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueAttr" scope="prototype"/>
      <method name="focus" scope="prototype">
        <summary>places focus on the first invalid input widget - if all
	input widgets are valid, the first widget is focused.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.form.RadioStack" type="Function" classlike="true" superclass="dojox.form.CheckedMultiSelect">
    <summary>A radio-based select stack.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.form._SelectStackMixin.prototype"/>
      <mixin scope="instance" location="dojox.form.CheckedMultiSelect"/>
      <mixin scope="instance" location="dojox.form._SelectStackMixin"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.form._RangeSliderMixin" type="Function" classlike="true">
    <properties>
      <property name="value" scope="prototype" type="Object"/>
      <property name="_movableMax" scope="prototype" type="Object"/>
      <property name="_movableBar" scope="prototype" type="Object"/>
      <property name="_lastValueReported" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onHandleClickMax" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onClkIncBumper" scope="prototype"/>
      <method name="_bumpValue" scope="prototype">
        <parameters>
          <parameter name="signedChange" type="" usage="required"/>
          <parameter name="useMaxValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getBumpValue" scope="prototype">
        <parameters>
          <parameter name="signedChange" type="" usage="required"/>
          <parameter name="useMaxValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onBarClick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onRemainingBarClick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setPixelValue" scope="prototype">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
          <parameter name="priorityChange" type="Boolean" usage="required"/>
          <parameter name="isMaxVal" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getValueByPixelValue" scope="prototype">
        <parameters>
          <parameter name="pixelValue" type="Number" usage="required"/>
          <parameter name="maxPixels" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="Array" usage="required">
            <summary>or Number</summary>
          </parameter>
          <parameter name="priorityChange" type="Boolean," usage="required">
            <summary>optional</summary>
          </parameter>
          <parameter name="isMaxVal" type="Boolean," usage="required">
            <summary>optional</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_printSliderBar" scope="prototype">
        <parameters>
          <parameter name="priorityChange" type="" usage="required"/>
          <parameter name="isMaxVal" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form._RangeSliderMixin.valueNode" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dijit.form._SliderMoverMax" type="Function" classlike="true" superclass="dijit.form._SliderMover">
    <mixins>
      <mixin scope="instance" location="dijit.form._SliderMover"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dijit.form._SliderMoverMax.widget" type="">
    <properties>
      <property name="_abspos" scope="prototype" type="Object"/>
      <property name="_setPixelValue_" scope="prototype" type="Object"/>
      <property name="_isReversed_" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dijit.form._SliderBarMover" type="Function" classlike="true" superclass="dojo.dnd.Mover">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Mover"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dijit.form._SliderBarMover.widget" type="">
    <properties>
      <property name="_abspos" scope="prototype" type="Object"/>
      <property name="_setPixelValue_" scope="prototype" type="Object"/>
      <property name="_getValueByPixelValue_" scope="prototype" type="Object"/>
      <property name="_isReversed_" scope="prototype" type="Object"/>
      <property name="_bar" scope="prototype" type="Object"/>
      <property name="_mouseOffset" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.form.HorizontalRangeSlider" type="Function" classlike="true" superclass="dijit.form.HorizontalSlider">
    <summary>A form widget that allows one to select a range with two horizontally draggable images</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.form._RangeSliderMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.HorizontalSlider"/>
      <mixin scope="instance" location="dojox.form._RangeSliderMixin"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.form.VerticalRangeSlider" type="Function" classlike="true" superclass="dijit.form.VerticalSlider">
    <summary>A form widget that allows one to select a range with two vertically draggable images</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.form._RangeSliderMixin.prototype"/>
      <mixin scope="instance" location="dijit.form.VerticalSlider"/>
      <mixin scope="instance" location="dojox.form._RangeSliderMixin"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.form.Rating" type="Function" classlike="true" superclass="dijit.form._FormWidget">
    <summary>A widget for rating using stars.
	required: Boolean
	TODO: Can be true or false, default is false.
	required: false,</summary>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormWidget"/>
    </mixins>
    <properties>
      <property name="templateString" scope="instance-prototype" type="Object"/>
      <property name="numStars" scope="prototype" type="Integer/Float">
        <summary>The number of stars to show, default is 3.</summary>
      </property>
      <property name="value" scope="prototype" type="Integer/Float">
        <summary>The current value of the Rating</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_onMouse" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_renderStars" scope="prototype">
        <summary>Render the stars depending on the value.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
          <parameter name="hover" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onStarClick" scope="prototype">
        <summary>Connect on this method to get noticed when a star was clicked.</summary>
        <examples>
          <example>dojo.connect(widget, "onStarClick", function(event){ ... })</example>
        </examples>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="prototype">
        <summary>Connect here, the value is passed to this function as the second parameter!</summary>
      </method>
      <method name="setAttribute" scope="prototype">
        <summary>When calling setAttribute(&amp;quot;value&amp;quot;, 4), set the value and render the stars accordingly.</summary>
        <parameters>
          <parameter name="key" type="String" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form.TimeSpinner" type="Function" classlike="true" superclass="dijit.form._Spinner">
    <summary>Time Spinner</summary>
    <description>This widget is the same as a normal NumberSpinner, but for the time component of a date object instead</description>
    <mixins>
      <mixin scope="instance" location="dijit.form._Spinner"/>
    </mixins>
    <properties>
      <property name="required" scope="prototype" type="bool"/>
      <property name="smallDelta" scope="prototype" type="Number"/>
      <property name="largeDelta" scope="prototype" type="Number"/>
      <property name="timeoutChangeRate" scope="prototype" type="Number"/>
      <property name="serialize" scope="normal" type=""/>
      <property name="value" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="adjust" scope="prototype">
        <parameters>
          <parameter name="val" type="Object" usage="required"/>
          <parameter name="delta" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="isValid" scope="prototype"/>
      <method name="parse" scope="prototype">
        <parameters>
          <parameter name="time" type="" usage="required"/>
          <parameter name="locale" type="" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="time" type="" usage="required"/>
          <parameter name="locale" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form._SelectStackMixin" type="Function" classlike="true">
    <summary>Mix this class in to a dijit.form._FormSelectWidget in order to
	provide support for &amp;quot;selectable&amp;quot; multiforms.  The widget is pointed
	to a dijit.layout.StackContainer and will handle displaying and
	submitting the values of only the appropriate pane.
	The options for this widget will be automatically set - based on
	the panes that are in the stack container.  The &amp;quot;title&amp;quot; attribute of
	the pane will be used for the display of the option.  The &amp;quot;id&amp;quot; attribute
	of the pane will be used as the value of the option.  In order to
	avoid running into unique ID constraint issues, a stackPrefix mechanism
	is provided.</summary>
    <properties>
      <property name="stackId" scope="prototype" type="string">
        <summary>The id of the stack that this widget is supposed to control</summary>
      </property>
      <property name="stackPrefix" scope="prototype" type="string">
        <summary>A prefix to remove from our stack pane ids when setting our options.
	This exists so that we won't run into unique ID constraints.  For
	example, if stackPrefix is set to &amp;quot;foo_&amp;quot;, and there are three panes
	in our stack with ids of &amp;quot;foo_a&amp;quot;, &amp;quot;foo_b&amp;quot;, and &amp;quot;foo_c&amp;quot;, then the values
	of the options created for the stack controller widget will be &amp;quot;a&amp;quot;,
	&amp;quot;b&amp;quot;, and &amp;quot;c&amp;quot;.  This allows you to have multiple select stack widgets
	with the same values - without having to have the panes require the
	same ids.</summary>
      </property>
      <property name="_savedValue" scope="prototype" type=""/>
      <property name="_panes" scope="prototype" type="Object"/>
      <property name="_subscriptions" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_paneIdFromOption" scope="prototype">
        <summary>Gets the pane ID given an option value</summary>
        <parameters>
          <parameter name="oVal" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_optionValFromPane" scope="prototype">
        <summary>Gets the option value given a pane ID</summary>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_togglePane" scope="prototype">
        <summary>called when a pane is either shown or hidden (so that
	we can toggle the widgets on it)</summary>
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="shown" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_connectTitle" scope="prototype">
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onAddChild" scope="prototype">
        <summary>Called when the stack container adds a new pane</summary>
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="Integer" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="attr" scope="prototype">
        <parameters>
          <parameter name="name" type="String|Object" usage="required"/>
          <parameter name="value" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="onRemoveChild" scope="prototype">
        <summary>Called when the stack container removes a pane</summary>
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectChild" scope="prototype">
        <summary>Called when the stack container selects a new pane</summary>
        <parameters>
          <parameter name="pane" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="onStartup" scope="prototype">
        <summary>Called when the stack container is started up</summary>
        <parameters>
          <parameter name="info" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="_handleSelfOnChange" scope="prototype">
        <summary>Called when form select widget's value has changed</summary>
        <parameters>
          <parameter name="val" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.form.manager">
    <methods>
      <method name="actionAdapter" scope="normal">
        <summary>Adapter that automates application of actions to arrays.</summary>
        <parameters>
          <parameter name="action" type="Function:" usage="required">
            <summary>Function that takes three parameters: a name, an object
	(usually node or widget), and a value. This action will
	be applied to all elements of array.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="inspectorAdapter" scope="normal">
        <summary>Adapter that applies an inspector only to the first item of the array.</summary>
        <parameters>
          <parameter name="inspector" type="Function:" usage="required">
            <summary>Function that takes three parameters: a name, an object
	(usually node or widget), and a value.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_keys" scope="normal">
        <parameters>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
      <method name="changeEvent" scope="normal">
        <summary>Function that returns a valid &amp;quot;onchange&amp;quot; event for a given form node.</summary>
        <parameters>
          <parameter name="node" type="Node:" usage="required">
            <summary>Form node.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.form.manager._ClassMixin" type="Function" classlike="true">
    <summary>Form manager's mixin for testing/assigning/removing
	classes of controlled elements.</summary>
    <description>This mixin provides unified way to check/add/remove a class
	of controlled elements.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method constructor="constructor"/>
      <method name="gatherClassState" scope="prototype">
        <summary>Gather the presence of a certain class in all controlled elements.</summary>
        <parameters>
          <parameter name="className" type="String:" usage="required">
            <summary>The class name to test for.</summary>
          </parameter>
          <parameter name="names" type="Object:" usage="optional">
            <summary>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="addClass" scope="prototype">
        <summary>Add a class to nodes according to the supplied set of names</summary>
        <parameters>
          <parameter name="className" type="String:" usage="required">
            <summary>Class name to add.</summary>
          </parameter>
          <parameter name="names" type="Object:" usage="optional">
            <summary>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="removeClass" scope="prototype">
        <summary>Remove a class from nodes according to the supplied set of names</summary>
        <parameters>
          <parameter name="className" type="String:" usage="required">
            <summary>Class name to remove.</summary>
          </parameter>
          <parameter name="names" type="Object:" usage="optional">
            <summary>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.form.manager._DisplayMixin" type="Function" classlike="true">
    <summary>Form manager's mixin for controlling show/hide state of
	controlled elements (defined by dojoAttachPoint attributes).</summary>
    <description>This mixin provides unified show/hide functionality for
	controlled elements (indicated by dojoAttachPoint attribute).
	Essentially it provides a way to change "style.display"
	parameter of controlled nodes.
	It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method constructor="constructor"/>
      <method name="gatherDisplayState" scope="prototype">
        <summary>Gather display state of all attached elements and return as a dictionary.</summary>
        <parameters>
          <parameter name="names" type="Object:" usage="optional">
            <summary>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known attach point nodes are to be processed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="show" scope="prototype">
        <summary>Show attached nodes according to the supplied state object.</summary>
        <parameters>
          <parameter name="state" type="Object:" usage="optional">
            <summary>Optional. If a name-value dictionary, the value is true
	to show and false to hide. If an array, all names in the
	array will be set to defaultState. If omitted, all form
	elements will be set to defaultState.</summary>
          </parameter>
          <parameter name="defaultState" type="Boolean:" usage="optional">
            <summary>The default state (true, if omitted).</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="hide" scope="prototype">
        <summary>Hide attached nodes according to the supplied state object.</summary>
        <parameters>
          <parameter name="state" type="Object:" usage="optional">
            <summary>Optional. If a name-value dictionary, the value is true
	to show and false to hide. If an array, all names in the
	array will be hidden. If omitted, all form elements
	will be hidden.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.form.manager._EnableMixin" type="Function" classlike="true">
    <summary>Form manager's mixin for controlling enable/disable state of
	form elements.</summary>
    <description>This mixin provides unified enable/disable functionality for
	form widgets and form elements. It should be used together
	with dojox.form.manager.Mixin.</description>
    <methods>
      <method constructor="constructor"/>
      <method name="gatherEnableState" scope="prototype">
        <summary>Gather enable state of all form elements and return as a dictionary.</summary>
        <parameters>
          <parameter name="names" type="Object:" usage="optional">
            <summary>If it is an array, it is a list of names to be processed.
	If it is an object, dictionary keys are names to be processed.
	If it is omitted, all known form elements are to be processed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="enable" scope="prototype">
        <summary>Enable form controls according to the supplied state object.</summary>
        <parameters>
          <parameter name="state" type="Object:" usage="optional">
            <summary>Optional. If a name-value dictionary, the value is true
	to enable and false to disable. If an array, all names in the
	array will be set to defaultState. If omitted, all form
	elements will be set to defaultState.</summary>
          </parameter>
          <parameter name="defaultState" type="Boolean:" usage="required">
            <summary>The default state (true, if omitted).</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="disable" scope="prototype">
        <summary>Disable form controls according to the supplied state object
	returning the previous state.</summary>
        <parameters>
          <parameter name="state" type="Object:" usage="optional">
            <summary>Optional. If a name-value dictionary, the value is true
	to enable and false to disable. If an array, all names in the
	array will be disabled. If omitted, disables all.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.form.manager._FormMixin" type="Function" classlike="true">
    <summary>Form manager's mixin for form-specific functionality.</summary>
    <description>This mixin adds automated "onreset", and "onsubmit" event processing
	if we are based on a form node, defines onReset(), onSubmit(),
	reset(), submit(), and isValid() methods like dijit.form.Form.
	It should be used together with dojox.form.manager.Mixin.</description>
    <properties>
      <property name="name" scope="prototype" type="String"/>
      <property name="action" scope="prototype" type="String"/>
      <property name="method" scope="prototype" type="String"/>
      <property name="encType" scope="prototype" type="String"/>
      <property name="accept-charset" scope="prototype" type="String"/>
      <property name="accept" scope="prototype" type="String"/>
      <property name="target" scope="prototype" type="String"/>
      <property name="isForm" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="_onReset" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onReset" scope="prototype">
        <summary>Callback when user resets the form. This method is intended
	to be over-ridden. When the &lt;code&gt;reset&lt;/code&gt; method is called
	programmatically, the return value from &lt;code&gt;onReset&lt;/code&gt; is used
	to compute whether or not resetting should proceed</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="reset" scope="prototype">
        <summary>Resets form widget values.</summary>
      </method>
      <method name="_onSubmit" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSubmit" scope="prototype">
        <summary>Callback when user submits the form. This method is
	intended to be over-ridden, but by default it checks and
	returns the validity of form elements. When the &lt;code&gt;submit&lt;/code&gt;
	method is called programmatically, the return value from
	&lt;code&gt;onSubmit&lt;/code&gt; is used to compute whether or not submission
	should proceed</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="submit" scope="prototype">
        <summary>programmatically submit form if and only if the &lt;code&gt;onSubmit&lt;/code&gt; returns true</summary>
      </method>
      <method name="isValid" scope="prototype">
        <summary>Make sure that every widget that has a validator function returns true.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.form.manager._Mixin" type="Function" classlike="true">
    <summary>Mixin to orchestrate dynamic forms.</summary>
    <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, general event
	processing, I/O orchestration, and common form-related
	functionality. See additional mixins in dojox.form.manager
	namespace.</description>
    <properties>
      <property name="watch" scope="prototype" type="Object"/>
      <property name="formWidgets" scope="prototype" type="Object"/>
      <property name="formNodes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>Called after all the widgets have been instantiated and their
	dom nodes have been inserted somewhere under dojo.doc.body.</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Called when the widget is being destroyed</summary>
      </method>
      <method name="registerWidget" scope="prototype">
        <summary>Register a widget with the form manager</summary>
        <return-description>Object:
	Returns self</return-description>
        <parameters>
          <parameter name="widget" type="String|Node|dijit.form._FormWidget:" usage="required">
            <summary>A widget, or its widgetId, or its DOM node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="unregisterWidget" scope="prototype">
        <summary>Removes the widget by name from internal tables unregistering
	connected observers</summary>
        <return-description>Object:
	Returns self</return-description>
        <parameters>
          <parameter name="name" type="String:" usage="required">
            <summary>Name of the to unregister</summary>
          </parameter>
        </parameters>
      </method>
      <method name="registerWidgetDescendants" scope="prototype">
        <summary>Register widget's descendants with the form manager</summary>
        <return-description>Object:
	Returns self</return-description>
        <parameters>
          <parameter name="widget" type="String|Node|dijit._Widget:" usage="required">
            <summary>A widget, or its widgetId, or its DOM node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="unregisterWidgetDescendants" scope="prototype">
        <summary>Unregister widget's descendants with the form manager</summary>
        <return-description>Object:
	Returns self</return-description>
        <parameters>
          <parameter name="widget" type="String|Node|dijit._Widget:" usage="required">
            <summary>A widget, or its widgetId, or its DOM node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="formWidgetValue" scope="prototype">
        <summary>Set or get a form widget by name.</summary>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <parameters>
          <parameter name="elem" type="String|Object|Array:" usage="required">
            <summary>Form element's name, widget object, or array or radio widgets.</summary>
          </parameter>
          <parameter name="value" type="Object:" usage="optional">
            <summary>Optional. The value to set.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="formPointValue" scope="prototype">
        <summary>Set or get a node context by name (using dojoAttachPoint).</summary>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <parameters>
          <parameter name="elem" type="String|Object|Array:" usage="required">
            <summary>A node.</summary>
          </parameter>
          <parameter name="value" type="Object:" usage="optional">
            <summary>Optional. The value to set.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="inspectFormWidgets" scope="prototype">
        <summary>Run an inspector function on controlled widgets returning a result object.</summary>
        <parameters>
          <parameter name="inspector" type="Function:" usage="required">
            <summary>A function to be called on a widget. Takes three arguments: a name, a widget object
	or an array of widget objects, and a supplied value. Runs in the context of
	the form manager. Returns a value that will be collected and returned as a state.</summary>
          </parameter>
          <parameter name="state" type="Object:" usage="optional">
            <summary>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all widgets will be processed with defaultValue.</summary>
          </parameter>
          <parameter name="defaultValue" type="Object:" usage="optional">
            <summary>Optional. The default state (true, if omitted).</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspectAttachedPoints" scope="prototype">
        <summary>Run an inspector function on &amp;quot;dojoAttachPoint&amp;quot; nodes returning a result object.</summary>
        <parameters>
          <parameter name="inspector" type="Function:" usage="required">
            <summary>A function to be called on a node. Takes three arguments: a name, a node or
	an array of nodes, and a supplied value. Runs in the context of the form manager.
	Returns a value that will be collected and returned as a state.</summary>
          </parameter>
          <parameter name="state" type="Object:" usage="optional">
            <summary>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all attached point nodes will be processed with defaultValue.</summary>
          </parameter>
          <parameter name="defaultValue" type="Object:" usage="optional">
            <summary>Optional. The default state (true, if omitted).</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="inspect" scope="prototype">
        <summary>Run an inspector function on controlled elements returning a result object.</summary>
        <parameters>
          <parameter name="inspector" type="Function:" usage="required">
            <summary>A function to be called on a widget, form element, and an attached node.
	Takes three arguments: a name, a node (domNode in the case of widget) or
	an array of such objects, and a supplied value. Runs in the context of
	the form manager. Returns a value that will be collected and returned as a state.</summary>
          </parameter>
          <parameter name="state" type="Object:" usage="optional">
            <summary>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all controlled elements will be processed with defaultValue.</summary>
          </parameter>
          <parameter name="defaultValue" type="Object:" usage="optional">
            <summary>Optional. The default state (true, if omitted).</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.form.manager._NodeMixin" type="Function" classlike="true">
    <summary>Mixin to orchestrate dynamic forms (works with DOM nodes).</summary>
    <description>This mixin provideas a foundation for an enhanced form
	functionality: unified access to individual form elements,
	unified "onchange" event processing, and general event
	processing. It complements dojox.form.manager._Mixin
	extending the functionality to DOM nodes.</description>
    <properties>
      <property name="formNodes" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="destroy" scope="prototype">
        <summary>Called when the widget is being destroyed</summary>
      </method>
      <method name="registerNode" scope="prototype">
        <summary>Register a node with the form manager</summary>
        <return-description>Object:
	Returns self</return-description>
        <parameters>
          <parameter name="node" type="String|Node:" usage="required">
            <summary>A node, or its id</summary>
          </parameter>
        </parameters>
      </method>
      <method name="unregisterNode" scope="prototype">
        <summary>Removes the node by name from internal tables unregistering
	connected observers</summary>
        <return-description>Object:
	Returns self</return-description>
        <parameters>
          <parameter name="name" type="String:" usage="required">
            <summary>Name of the to unregister</summary>
          </parameter>
        </parameters>
      </method>
      <method name="registerNodeDescendants" scope="prototype">
        <summary>Register node's descendants (form nodes) with the form manager</summary>
        <return-description>Object:
	Returns self</return-description>
        <parameters>
          <parameter name="node" type="String|Node:" usage="required">
            <summary>A widget, or its widgetId, or its DOM node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="unregisterNodeDescendants" scope="prototype">
        <summary>Unregister node's descendants (form nodes) with the form manager</summary>
        <return-description>Object:
	Returns self</return-description>
        <parameters>
          <parameter name="node" type="String|Node:" usage="required">
            <summary>A widget, or its widgetId, or its DOM node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="formNodeValue" scope="prototype">
        <summary>Set or get a form element by name.</summary>
        <return-description>Object:
	For a getter it returns the value, for a setter it returns
	self. If the elem is not valid, null will be returned.</return-description>
        <parameters>
          <parameter name="elem" type="String|Node|Array:" usage="required">
            <summary>Form element's name, DOM node, or array or radio nodes.</summary>
          </parameter>
          <parameter name="value" type="Object:" usage="optional">
            <summary>Optional. The value to set.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="self"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="inspectFormNodes" scope="prototype">
        <summary>Run an inspector function on controlled form elements returning a result object.</summary>
        <parameters>
          <parameter name="inspector" type="Function:" usage="required">
            <summary>A function to be called on a form element. Takes three arguments: a name, a node or
	an array of nodes, and a supplied value. Runs in the context of the form manager.
	Returns a value that will be collected and returned as a state.</summary>
          </parameter>
          <parameter name="state" type="Object:" usage="optional">
            <summary>Optional. If a name-value dictionary --- only listed names will be processed.
	If an array, all names in the array will be processed with defaultValue.
	If omitted or null, all form elements will be processed with defaultValue.</summary>
          </parameter>
          <parameter name="defaultValue" type="Object:" usage="optional">
            <summary>Optional. The default state (true, if omitted).</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.form.manager._ValueMixin" type="Function" classlike="true">
    <summary>Form manager's mixin for getting/setting form values in the unified manner.</summary>
    <description>This mixin adds unified access to form widgets and form elements
	in terms of name-value regardless of the underlying type of
	an element. It should be used together with dojox.form.manager.Mixin.</description>
    <methods>
      <method constructor="constructor"/>
      <method name="elementValue" scope="prototype">
        <summary>Set or get a form widget/element or an attached point node by name.</summary>
        <parameters>
          <parameter name="name" type="String:" usage="required">
            <summary>The name.</summary>
          </parameter>
          <parameter name="value" type="Object:" usage="optional">
            <summary>Optional. The value to set.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="gatherFormValues" scope="prototype">
        <summary>Collect form values.</summary>
        <parameters>
          <parameter name="names" type="Object:" usage="optional">
            <summary>If it is an array, it is a list of names of form elements to be collected.
	If it is an object, dictionary keys are names to be collected.
	If it is omitted, all known form elements are to be collected.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFormValues" scope="prototype">
        <summary>Set values to form elements</summary>
        <parameters>
          <parameter name="values" type="Object:" usage="required">
            <summary>A dictionary of key-value pairs.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.fx">
    <summary>Extension animations to the core dojo FX project</summary>
    <description>A package of animations, and FX-related code, extending Dojo Core fx.
	Including this package includes all the Base and Core fx packages.</description>
    <properties>
      <property name="_base" scope="normal" type="Object"/>
      <property name="_core" scope="normal" type="Object"/>
      <property name="easing" scope="normal" type="Object">
        <summary>An Alias to &lt;code&gt;dojo.fx.easing&lt;/code&gt;. Moved to Core in Dojo 1.2.</summary>
      </property>
      <property name="scroll" scope="normal" type="Object">
        <summary>Module to provide scroll-related FX</summary>
      </property>
      <property name="split" scope="normal" type="Object"/>
      <property name="_allowedProperties" scope="normal" type="Array"/>
      <property name="style" scope="normal" type="Object">
        <summary>Module to provide CSS animations</summary>
      </property>
    </properties>
    <methods>
      <method name="anim" scope="normal">
        <summary>Alias of &lt;code&gt;dojo.anim&lt;/code&gt; - the shorthand &lt;code&gt;dojo.animateProperty&lt;/code&gt; with auto-play</summary>
      </method>
      <method name="animateProperty" scope="normal">
        <summary>Alias of &lt;code&gt;dojo.animateProperty&lt;/code&gt; - animate any CSS property</summary>
      </method>
      <method name="fadeTo" scope="normal">
        <summary>Fade an element from an opacity to an opacity.
	Omit &lt;code&gt;start:&lt;/code&gt; property to detect. &lt;code&gt;end:&lt;/code&gt; property is required.
	Ultimately an alias to &lt;code&gt;dojo._fade&lt;/code&gt;</summary>
      </method>
      <method name="fadeIn" scope="normal">
        <summary>Alias of &lt;code&gt;dojo.fadeIn&lt;/code&gt; - Fade a node in.</summary>
      </method>
      <method name="fadeOut" scope="normal">
        <summary>Alias of &lt;code&gt;dojo.fadeOut&lt;/code&gt; - Fades a node out.</summary>
      </method>
      <method name="combine" scope="normal">
        <summary>Alias of &lt;code&gt;dojo.fx.combine&lt;/code&gt; - Run an array of animations in parallel</summary>
      </method>
      <method name="chain" scope="normal">
        <summary>Alias of &lt;code&gt;dojo.fx.chain&lt;/code&gt; - Run an array of animations in sequence</summary>
      </method>
      <method name="slideTo" scope="normal">
        <summary>Alias of &lt;code&gt;dojo.fx.slideTo&lt;/code&gt; - Slide a node to a defined top/left coordinate</summary>
      </method>
      <method name="wipeIn" scope="normal">
        <summary>Alias of &lt;code&gt;dojo.fx.wipeIn&lt;/code&gt; - Wipe a node to visible</summary>
      </method>
      <method name="wipeOut" scope="normal">
        <summary>Alias of &lt;code&gt;dojo.fx.wipeOut&lt;/code&gt; - Wipe a node to non-visible</summary>
      </method>
      <method name="sizeTo" scope="normal">
        <summary>Creates an animation that will size a node</summary>
        <description>Returns an animation that will size the target node
	defined in args Object about it's center to
	a width and height defined by (args.width, args.height),
	supporting an optional method: chain||combine mixin
	(defaults to chain).
	- works best on absolutely or relatively positioned elements</description>
        <examples>
          <example>	// size #myNode to 400px x 200px over 1 second
		dojo.fx.sizeTo({
			node:'myNode',
			duration: 1000,
			width: 400,
			height: 200,
			method: "combine"
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="slideBy" scope="normal">
        <summary>Returns an animation to slide a node by a defined offset.</summary>
        <description>Returns an animation that will slide a node (args.node) from it's
	current position to it's current posision plus the numbers defined
	in args.top and args.left. standard dojo.fx mixin's apply.</description>
        <examples>
          <example>	// slide domNode 50px down, and 22px left
		dojox.fx.slideBy({
			node: domNode, duration:400,
			top: 50, left: -22
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="crossFade" scope="normal">
        <summary>Returns an animation cross fading two element simultaneously</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.nodes: Array - two element array of domNodes, or id's
	all other standard animation args mixins apply. args.node ignored.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="highlight" scope="normal">
        <summary>Highlight a node</summary>
        <description>Returns an animation that sets the node background to args.color
	then gradually fades back the original node background color</description>
        <examples>
          <example>	dojox.fx.highlight({ node:"foo" }).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="wipeTo" scope="normal">
        <summary>Animate a node wiping to a specific width or height</summary>
        <description>Returns an animation that will expand the
	node defined in 'args' object from it's current to
	the height or width value given by the args object.
	default to height:, so leave height null and specify width:
	to wipeTo a width. note: this may be deprecated by a
	Note that the final value should not include
	units and should be an integer.  Thus a valid args object
	would look something like this:
		dojox.fx.wipeTo({ node: "nodeId", height: 200 }).play();
	Node must have no margin/border/padding, so put another
	node inside your target node for additional styling.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="flip" scope="normal">
        <summary>Animate a node flipping following a specific direction</summary>
        <description>Returns an animation that will flip the
	node around a central axis:
	if args.dir is "left" or "right" --&gt; y axis
	if args.dir is "top" or "bottom" --&gt; x axis
	This effect is obtained using a border distorsion applied to a helper node.
	The user can specify three background colors for the helper node:
	darkColor: the darkest color reached during the animation
	lightColor: the brightest color
	endColor: the final backgroundColor for the node
	depth: Float
	0 &lt;= depth &lt;= 1 overrides the computed "depth"
	(0: min distorsion, 1: max distorsion)
	whichAnim: String
	"first"          : the first half animation
	"last"           : the second one
	"both" (default) : both
	axis: String
	"center" (default)    : the node is flipped around his center
	"shortside"           : the node is flipped around his "short" (in perspective) side
	"longside"            : the node is flipped around his "long" (in perspective) side
	"cube"                : the node flips around the central axis of the cube
	shift: Integer
	node translation, perpendicular to the rotation axis</description>
        <examples>
          <example>	var anim = dojox.fx.flip({
			node: dojo.byId("nodeId"),
			dir: "top",
			darkColor: "#555555",
			lightColor: "#dddddd",
			endColor: "#666666",
			depth: .5,
			shift: 50,
			duration:300
		  });</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="flipCube" scope="normal">
        <summary>An extension to &lt;code&gt;dojox.fx.flip&lt;/code&gt; providing a more 3d-like rotation</summary>
        <description>An extension to `dojox.fx.flip` providing a more 3d-like rotation.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties.</description>
        <examples>
          <example>See `dojox.fx.flip`</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flipPage" scope="normal">
        <summary>An extension to &lt;code&gt;dojox.fx.flip&lt;/code&gt; providing a page flip like animation.</summary>
        <description>An extension to `dojox.fx.flip` providing a page flip effect.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties.</description>
        <examples>
          <example>See `dojox.fx.flip`</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="flipGrid" scope="normal">
        <summary>An extension to &lt;code&gt;dojox.fx.flip&lt;/code&gt; providing a decomposition in rows * cols flipping elements</summary>
        <description>An extension to `dojox.fx.flip` providing a page flip effect.
	Behaves the same as `dojox.fx.flip`, using the same attributes and
	other standard `dojo.Animation` properties and
	cols: Integer columns
	rows: Integer rows
	duration: the single flip duration</description>
        <examples>
          <example>See `dojox.fx.flip`</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="smoothScroll" scope="normal">
        <summary>Returns an animation that will smooth-scroll to a node (specified in etup())</summary>
        <description>This implementation support either horizental or vertical scroll, as well as
	both. In addition, element in iframe can be scrolled to correctly.
	offset: {x: int, y: int} this will be added to the target position
	duration: Duration of the animation in milliseconds.
	win: a node or window object to scroll</description>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="_split" scope="normal">
        <summary>Split a node into rectangular pieces and animate them.</summary>
        <description>Returns an animation that will split the node into a grid
	of pieces that move independently.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.crop: Boolean - If true, pieces will only be visible inside node's boundries
	args.rows: Integer - The number of horizontal pieces (default is 3)
	args.columns: Integer - The number of vertical pieces (default is 3)
	args.pieceAnimation: Function(piece, x, y, coords) - Returns either the dojo.Animation
	or an array of dojo.Animation objects for the piece at location (x, y) in the node's grid;
	coords is the result of dojo.coords(args.node, true);</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="explode" scope="normal">
        <summary>Explode a node into rectangular pieces</summary>
        <description>Returns an animation that will split the node into a grid
	of pieces that fly away from the center.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.rows: Integer - The number of horizontal pieces (default is 3)
	args.columns: Integer - The number of vertical pieces (default is 3)
	args.random: Float - If set, pieces fly to random distances, for random durations,
	and in slightly random directions.  The value defines how much
	randomness is introduced.
	args.distance: Float - Multiplier for the distance the pieces fly (even when random)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.fadeEasing: Function - If args.fade is true, the fade animations use this easing function
	args.unhide: Boolean - If true, the animation is reversed
	args.sync: Boolean - If args.unhide is true, all the pieces converge at the same time
	(default is true)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="converge" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disintegrate" scope="normal">
        <summary>Split a node into rectangular pieces and let them fall</summary>
        <description>Returns an animation that will split the node into a grid
	of pieces that drop.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.rows: Integer - The number of horizontal pieces (default is 5)
	args.columns: Integer - The number of vertical pieces (default is 5)
	args.interval: Float - The number of milliseconds between each piece's animation
	args.distance: Float - The number of the node's heights to drop (default is 1.5)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If set, pieces fall in random order. The value defines how much
	randomness is introduced.
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the peices fall from above and land in place</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="build" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="shear" scope="normal">
        <summary>Split a node into rectangular pieces and slide them in alternating directions</summary>
        <description>Returns an animation that will split the node into a grid
	of pieces that slide in alternating directions.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.rows: Integer - The number of horizontal pieces (default is 6)
	args.columns: Integer - The number of vertical pieces (default is 6)
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.distance: Float - The multiple of the node's dimensions to slide (default is 1)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the animation is reversed</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="unShear" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pinwheel" scope="normal">
        <summary>Split a node into rectangular pieces and wipe them in alternating directions</summary>
        <description>Returns an animation that will split the node into a grid
	of pieces that wipe in alternating directions.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.rows: Integer - The number of horizontal pieces (default is 4)
	args.columns: Integer - The number of vertical pieces (default is 4)
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.distance: Float - The percentage of the piece's dimensions the piece should wipe
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced.
	args.unhide: Boolean - If true, the animation is reversed</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="unPinwheel" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="blockFadeOut" scope="normal">
        <summary>Split a node into rectangular pieces and fade them</summary>
        <description>Returns an animation that will split the node into a grid
	of pieces that fade in or out.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.rows: Integer - The number of horizontal pieces (default is 5)
	args.columns: Integer - The number of vertical pieces (default is 5)
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the animation is reversed</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="blockFadeIn" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="addClass" scope="normal">
        <summary>Animate the effects of adding a class to a node</summary>
        <description>Creates an animation that will animate
	the properties of a node to the properties
	defined in a standard CSS .class definition.
	(calculating the differences itself)</description>
        <examples>
          <example>	.bar { line-height: 12px; }
		.foo { line-height: 40px; }
		&lt;div class="bar" id="test"&gt;
		Multi&lt;br&gt;line&lt;br&gt;text
		&lt;/div&gt;
		// animate to line-height:40px
		dojo.fx.addClass("test", "foo").play();</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <summary>A String ID or DomNode referce to animate</summary>
          </parameter>
          <parameter name="cssClass" type="String" usage="required">
            <summary>The CSS class name to add to the node</summary>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <summary>Additional optional &lt;code&gt;dojo.animateProperty&lt;/code&gt; arguments, such as
	duration, easing and so on.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="removeClass" scope="normal">
        <summary>Animate the effects of removing a class from a node</summary>
        <description>Creates an animation that will animate the properties of a
	node (args.node) to the properties calculated after removing
	a standard CSS className from a that node.
	calls dojo.removeClass(args.cssClass) onEnd of animation
	standard dojo.Animation object rules apply.</description>
        <examples>
          <example>	// animate the removal of "foo" from a node with id="bar"
		dojox.fx.removeClass("bar", "foo").play()</example>
        </examples>
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cssClass" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="toggleClass" scope="normal">
        <summary>Animate the effects of Toggling a class on a Node</summary>
        <description>creates an animation that will animate the effect of
	toggling a class on or off of a node.
	Adds a class to node if not present, or removes if present.
	Pass a boolean condition if you want to explicitly add or remove.</description>
        <examples>
          <example>	// add the class "sampleClass" to a node id="theNode"
		dojox.fx.toggleClass("theNode","sampleClass",true).play();</example>
          <example>	// toggle the class "sampleClass" on the node id="theNode"
		dojox.fx.toggleClass("theNode","sampleClass").play();</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required">
            <summary>The domNode (or string of the id) to toggle</summary>
          </parameter>
          <parameter name="cssClass" type="String" usage="required">
            <summary>String of the classname to add to the node</summary>
          </parameter>
          <parameter name="condition" type="Boolean" usage="optional">
            <summary>If passed, true means to add the class, false means to remove.</summary>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <summary>Additional &lt;code&gt;dojo.Animation&lt;/code&gt; args to pass along.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.fx.Shadow" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Adds a drop-shadow to a node.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <examples>
      <example>	// add drop shadows to all nodes with class="hasShadow"
		dojo.query(".hasShadow").forEach(function(n){
			var foo = new dojox.fx.Shadow({ node: n });
			foo.startup();
		});</example>
    </examples>
    <properties>
      <property name="shadowPng" scope="prototype" type="String">
        <summary>Base location for drop-shadow images</summary>
      </property>
      <property name="shadowThickness" scope="prototype" type="Integer">
        <summary>How wide (in px) to make the shadow</summary>
      </property>
      <property name="shadowOffset" scope="prototype" type="Integer">
        <summary>How deep to make the shadow appear to be</summary>
      </property>
      <property name="opacity" scope="prototype" type="Float">
        <summary>Overall opacity of the shadow</summary>
      </property>
      <property name="animate" scope="prototype" type="Boolean">
        <summary>A toggle to disable animated transitions</summary>
      </property>
      <property name="node" scope="prototype" type="DomNode">
        <summary>The node we will be applying this shadow to</summary>
      </property>
      <property name="pieces" scope="prototype" type="Object"/>
      <property name="nodeList" scope="prototype" type="Object"/>
      <property name="disabled" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>Initializes the shadow.</summary>
      </method>
      <method name="_makePiece" scope="prototype">
        <summary>append a shadow pieces to the node, and position it</summary>
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="vertAttach" type="" usage="required"/>
          <parameter name="vertCoord" type="" usage="required"/>
          <parameter name="horzAttach" type="" usage="required"/>
          <parameter name="horzCoord" type="" usage="required"/>
          <parameter name="sizing" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setOpacity" scope="prototype">
        <summary>set the opacity of the underlay
	note: does not work in IE? FIXME.</summary>
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
          <parameter name="animArgs" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setDisabled" scope="prototype">
        <summary>enable / disable the shadow</summary>
        <parameters>
          <parameter name="disabled" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <summary>Resizes the shadow based on width and height.</summary>
        <parameters>
          <parameter name="args" type="dojox.fx._arg.ShadowResizeArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.fx.Shadow.node.style" type="">
    <properties>
      <property name="position" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.fx._arg" private="true"/>
  <object location="dojox.fx._arg.StyleArgs" type="Function" classlike="true">
    <summary>The node and CSS class to use for style manipulations.</summary>
    <properties>
      <property name="node" scope="instance" type="DOMNode">
        <summary>The node to manipulate</summary>
      </property>
      <property name="cssClass" scope="instance" type="String">
        <summary>The class to use during the manipulation</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.fx._arg.ShadowResizeArgs" type="Function" classlike="true">
    <summary>The odd way to document object parameters.</summary>
    <properties>
      <property name="x" scope="instance" type="Integer">
        <summary>the width to set</summary>
      </property>
      <property name="y" scope="instance" type="Integer">
        <summary>the height to set</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.fx._Line" type="Function" classlike="true" private="true">
    <summary>a custom _Line to accomodate multi-dimensional values</summary>
    <description>a normal dojo._Line is the curve, and does Line(start,end)
	for propertyAnimation. as we make more complicatied animations, we realize
	some properties can have 2, or 4 values relevant (x,y) or (t,l,r,b) for example
	this function provides support for those Lines, and is ported directly from 0.4
	this is a lot of extra code for something so seldom used, so we'll put it here as
	and optional core addition. you can create a new line, and use it during onAnimate
	as you see fit.</description>
    <examples>
      <example>see dojox.fx.smoothScroll</example>
      <example>	// this is 10 .. 100 and 50 .. 500
		var curve = new dojox.fx._Line([10,50],[100,500]);
		// dojo.Animation.onAnimate is called at every step of the animation
		// to define current values. this _Line returns an array
	 	// at each step. arguments[0] and [1] in this example.</example>
    </examples>
    <properties>
      <property name="start" scope="instance" type="Integer|Array">
        <summary>An Integer (or an Array of integers) to use as a starting point</summary>
      </property>
      <property name="end" scope="instance" type="Integer|Array">
        <summary>An Integer (or an Array of integers) to use as an ending point</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="start" type="Integer|Array" usage="required">
            <summary>An Integer (or an Array of integers) to use as a starting point</summary>
          </parameter>
          <parameter name="end" type="Integer|Array" usage="required">
            <summary>An Integer (or an Array of integers) to use as an ending point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Decimal"/>
        </return-types>
      </method>
      <method name="getValue" scope="instance">
        <summary>Returns the point on the line, or an array of points</summary>
        <return-description>Mixed</return-description>
        <parameters>
          <parameter name="n" type="float" usage="required">
            <summary>a floating point number greater than 0 and less than 1</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Decimal"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.fx.ext-dojo">
    <summary>Direct extensions to dojo.fx namespace</summary>
    <properties>
      <property name="NodeList-style" scope="normal" type="Object"/>
      <property name="NodeList" scope="normal" type="Object">
        <summary>module to include to support dojox.fx animations in dojo.query()</summary>
      </property>
    </properties>
  </object>
  <object location="dojox.fx.text">
    <methods>
      <method name="_split" scope="normal">
        <summary>Split a block of text into words or letters</summary>
        <description>Returns an animation that will split the node into a grid
	of pieces that move independently.
	NOTE:
	In some rendering engines, the text will appear to "jump" from its initial position
	when the animation begins.	To work around this bug, enclose the node's text in a &lt;p&gt; or &lt;div&gt;.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.crop: Boolean - If true, pieces will be positioned relatively rather than absolutely
	args.text: String - Text to place inside the node (otherwise node.innerHTML is used)
	args.words: Boolean - If true, the text will be split into words rather than characters
	args.pieceAnimation: Function(piece, pieceCoords, nodeCoords, number, numPieces)
	- Returns either the dojo.Animation or an array of dojo.Animation objects for the piece;
	pieceCoords is the result of dojo.coords(piece, true);
	nodeCoords is the result of dojo.coords(args.node, true);
	number is the piece's position in the array of pieces, and numPieces is the array.length</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="explode" scope="normal">
        <summary>Explode a block of text into words or letters</summary>
        <description>Returns an animation that will split the text into a spans
	of words or characters that fly away from the center.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.crop: Boolean - If true, pieces will be positioned relatively rather than absolutely
	args.words: Boolean - If true, text will be split into words rather than characters
	args.random: Float - If set, pieces fly to random distances, for random durations,
	and in slightly random directions. The value defines how much
	randomness is introduced.
	args.distance: Float - Multiplier for the distance the pieces fly (even when random)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.fadeEasing: Function - If args.fade is true, the fade animations use this easing function
	args.unhide: Boolean - If true, the animation is reversed
	args.sync: Boolean - If args.unhide is true, all the pieces converge at the same time
	(default is true)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="converge" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="disintegrate" scope="normal">
        <summary>Split a block of text into words or letters and let them fall</summary>
        <description>Returns an animation that will split the text into spans of words
	or characters that drop.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.crop: Boolean - If true, pieces will be positioned relatively rather than absolutely
	args.words: Boolean - If true, text will be split into words rather than characters
	args.interval: Float - The number of milliseconds between each piece's animation
	args.distance: Float - The number of the node's heights to drop (default is 1.5)
	args.fade: Boolean - If true, pieces fade out while in motion (default is true)
	args.random: Float - If set, pieces fall in random order. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the peices fall from above and land in place</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="build" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="blockFadeOut" scope="normal">
        <summary>Split a block of text into words or letters and fade them</summary>
        <description>Returns an animation that will split the text into spans of words
	or characters that fade in or out.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.words: Boolean - If true, text will be split into words rather than characters
	args.interval: Float - The number of milliseconds between each piece's animation (default is 0)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced
	args.reverseOrder: Boolean - If true, pieces animate in reversed order
	args.unhide: Boolean - If true, the animation is reversed</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="blockFadeIn" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="backspace" scope="normal">
        <summary>Split a block of text into words or letters and backspace them in sequence</summary>
        <description>Returns an animation that will split the text into spans of words
	or characters that appear as if they were being backspaced (or typed) in real-time.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>args.interval: Float - The number of milliseconds between each piece's animation
	(default is determined by text length and args.duration);
	args.wordDelay: Integer - The number of milliseconds between each word
	(only effective when args.unhide = true)
	args.fixed: Boolean - If true, only style.opacity changes; otherwise, style.display
	changes between none and inline, adding realism (default = false)
	args.random: Float - If true, pieces have a random delay. The value defines how much
	randomness is introduced (only effective when args.unhide = true)
	args.unhide: Boolean - If true, the animation is reversed</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="type" scope="normal">
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Moveable" type="Function" classlike="true">
    <summary>an object, which makes a shape moveable</summary>
    <properties>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="shape" scope="instance-prototype" type="dojox.gfx.Shape:">
        <summary>a shape object to be moved
	params: Object: an optional object with additional parameters;
	following parameters are recognized:</summary>
      </property>
      <property name="_lastX" scope="prototype" type=""/>
      <property name="_lastY" scope="prototype" type=""/>
      <property name="delay" scope="instance" type="Number:">
        <summary>delay move by this number of pixels</summary>
      </property>
      <property name="mover" scope="instance" type="Object:">
        <summary>a constructor of custom Mover</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>a shape object to be moved</summary>
          </parameter>
          <parameter name="params" type="Object:" usage="required">
            <summary>an optional object with additional parameters;
	following parameters are recognized:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>an object, which makes a shape moveable</summary>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>a shape object to be moved</summary>
          </parameter>
          <parameter name="params" type="Object:" usage="required">
            <summary>an optional object with additional parameters;
	following parameters are recognized:</summary>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>stops watching for possible move, deletes all references, so the object can be garbage-collected</summary>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>event processor for onmousedown, creates a Mover for the shape</summary>
        <parameters>
          <parameter name="e" type="Event:" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <summary>event processor for onmousemove, used only for delayed drags</summary>
        <parameters>
          <parameter name="e" type="Event:" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>event processor for onmouseup, used only for delayed delayed drags</summary>
        <parameters>
          <parameter name="e" type="Event:" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMoveStart" scope="prototype">
        <summary>called before every move operation</summary>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMoveStop" scope="prototype">
        <summary>called after every move operation</summary>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <summary>called during the very first move notification,
	can be used to initialize coordinates, can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="onMove" scope="prototype">
        <summary>called during every move notification,
	should actually move the node, can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoving" scope="prototype">
        <summary>called before every incremental move,
	can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onMoved" scope="prototype">
        <summary>called after every incremental move,
	can be overwritten.</summary>
        <parameters>
          <parameter name="mover" type="dojox.gfx.Mover" usage="required"/>
          <parameter name="shift" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Mover" type="Function" classlike="true">
    <summary>an object, which makes a shape follow the mouse,
	used as a default mover, and as a base class for custom movers</summary>
    <properties>
      <property name="lastX" scope="instance-prototype" type=""/>
      <property name="lastY" scope="instance-prototype" type=""/>
      <property name="host" scope="instance-prototype" type="Object:">
        <summary>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</summary>
      </property>
      <property name="events" scope="instance-prototype" type="Array"/>
      <property name="shape" scope="instance-prototype" type="dojox.gfx.Shape:">
        <summary>a shape object to be moved
	e: Event: a mouse event, which started the move;
	only clientX and clientY properties are used</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>a shape object to be moved</summary>
          </parameter>
          <parameter name="e" type="Event:" usage="required">
            <summary>a mouse event, which started the move;
	only clientX and clientY properties are used</summary>
          </parameter>
          <parameter name="host" type="Object:" usage="optional">
            <summary>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>an object, which makes a shape follow the mouse,
	used as a default mover, and as a base class for custom movers</summary>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>a shape object to be moved</summary>
          </parameter>
          <parameter name="e" type="Event:" usage="required">
            <summary>a mouse event, which started the move;
	only clientX and clientY properties are used</summary>
          </parameter>
          <parameter name="host" type="Object:" usage="optional">
            <summary>object which implements the functionality of the move,
	and defines proper events (onMoveStart and onMoveStop)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <summary>event processor for onmousemove</summary>
        <parameters>
          <parameter name="e" type="Event:" usage="required">
            <summary>mouse event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <summary>it is meant to be called only once</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>stops the move, deletes all references, so the object can be garbage-collected</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.vectorFontFitting">
    <properties>
      <property name="NONE" scope="normal" type="Number"/>
      <property name="FLOW" scope="normal" type="Number"/>
      <property name="FIT" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultVectorText">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="width" scope="normal" type="Object"/>
      <property name="height" scope="normal" type="Object"/>
      <property name="text" scope="normal" type="String"/>
      <property name="align" scope="normal" type="String"/>
      <property name="decoration" scope="normal" type="String"/>
      <property name="fitting" scope="normal" type="Number"/>
      <property name="leading" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultVectorFont">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="size" scope="normal" type="String"/>
      <property name="family" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx.VectorFont" type="Function" classlike="true">
    <summary>Create this font object based on the SVG Font definition at url.</summary>
    <properties>
      <property name="_entityRe" scope="prototype" type="RegExp"/>
      <property name="name" scope="prototype" type=""/>
      <property name="family" scope="prototype" type=""/>
      <property name="_defaultLeading" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="_decodeEntitySequence" scope="prototype">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_parse" scope="prototype">
        <summary>Take the loaded SVG Font definition file and convert the info
	into things we can use. The SVG Font definition must follow
	the SVG 1.1 Font specification.</summary>
        <parameters>
          <parameter name="svg" type="String" usage="required"/>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_clean" scope="prototype">
        <summary>Clean off all of the given mixin parameters.</summary>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Create this font object based on the SVG Font definition at url.</summary>
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
      </method>
      <method name="load" scope="prototype">
        <summary>Load the passed SVG and send it to the parser for parsing.</summary>
        <parameters>
          <parameter name="url" type="String|dojo._Url" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.VectorFont"/>
        </return-types>
      </method>
      <method name="initialized" scope="prototype">
        <summary>Return if we've loaded a font def, and the parsing was successful.</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="_round" scope="prototype">
        <parameters>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_leading" scope="prototype">
        <parameters>
          <parameter name="unit" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_normalize" scope="prototype">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getWidth" scope="prototype">
        <parameters>
          <parameter name="glyphs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getLongestLine" scope="prototype">
        <parameters>
          <parameter name="lines" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_trim" scope="prototype">
        <parameters>
          <parameter name="lines" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_split" scope="prototype">
        <summary>split passed chars into nLines by finding the closest whitespace.</summary>
        <parameters>
          <parameter name="chars" type="" usage="required"/>
          <parameter name="nLines" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getSizeFactor" scope="prototype">
        <parameters>
          <parameter name="size" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getFitFactor" scope="prototype">
        <summary>Find the scaling factor for the given phrase set.</summary>
        <parameters>
          <parameter name="lines" type="" usage="required"/>
          <parameter name="w" type="" usage="required"/>
          <parameter name="h" type="" usage="required"/>
          <parameter name="l" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFit" scope="prototype">
        <summary>Get the best number of lines to return given w and h.</summary>
        <parameters>
          <parameter name="chars" type="" usage="required"/>
          <parameter name="w" type="" usage="required"/>
          <parameter name="h" type="" usage="required"/>
          <parameter name="ldng" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getBestFlow" scope="prototype">
        <summary>Based on the given scale, do the best line splitting possible.</summary>
        <parameters>
          <parameter name="chars" type="" usage="required"/>
          <parameter name="w" type="" usage="required"/>
          <parameter name="scale" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="prototype">
        <summary>Get the width of the rendered text without actually rendering it.</summary>
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getLineHeight" scope="prototype">
        <summary>return the height of a single line, sans leading, based on scale.</summary>
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="getCenterline" scope="prototype">
        <summary>return the y coordinate that is the center of the viewbox.</summary>
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
      </method>
      <method name="getBaseline" scope="prototype">
        <summary>Find the baseline coord for alignment; adjust for scale if passed.</summary>
        <parameters>
          <parameter name="scale" type="Float" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Float"/>
        </return-types>
      </method>
      <method name="draw" scope="prototype">
        <summary>based on the passed parameters, draw the given text using paths
	defined by this font.</summary>
        <description>The main method of a VectorFont, draw() will take a text fragment
	and render it in a set of groups and paths based on the parameters
	passed.
	The basics of drawing text are simple enough: pass it your text as
	part of the textArgs object, pass size and family info as part of
	the fontArgs object, pass at least a color as the fillArgs object,
	and if you are looking to create an outline, pass the strokeArgs
	object as well. fillArgs and strokeArgs are the same as any other
	gfx fill and stroke arguments; they are simply applied to any path
	object generated by this method.
	Resulting GFX structure
	-----------------------
	The result of this function is a set of gfx objects in the following
	structure:
		dojox.gfx.Group 			//	the parent group generated by this function
		+	dojox.gfx.Group[]		//	a group generated for each line of text
			+	dojox.gfx.Path[]	//	each glyph/character in the text
	Scaling transformations (i.e. making the generated text the correct size)
	are always applied to the parent Group that is generated (i.e. the top
	node in the above example).  In theory, if you are looking to do any kind
	of other transformations (such as a translation), you should apply it to
	the group reference you pass to this method.  If you find that you need
	to apply transformations to the group that is returned by this method,
	you will need to reapply the scaling transformation as the *last* transform,
	like so:
		textGroup.setTransform(new dojox.gfx.Matrix2D([
			dojox.gfx.matrix.translate({ dx: dx, dy: dy }),
			textGroup.getTransform()
		]));
	In general, this should never be necessary unless you are doing advanced
	placement of your text.
	Advanced Layout Functionality
	-----------------------------
	In addition to straight text fragments, draw() supports a few advanced
	operations not normally available with vector graphics:
	* Flow operations (i.e. wrap to a given width)
	* Fitting operations (i.e. find a best fit to a given rectangle)
	To enable either, pass a `fitting` property along with the textArgs object.
	The possible values are contained in the dojox.gfx.vectorFontFitting enum
	(NONE, FLOW, FIT).
	`Flow fitting`
	Flow fitting requires both a passed size (in the fontArgs object) and a
	width (passed with the textArgs object).  draw() will attempt to split the
	passed text up into lines, at the closest whitespace according to the
	passed width.  If a width is missing, it will revert to NONE.
	`Best fit fitting`
	Doing a "best fit" means taking the passed text, and finding the largest
	size and line breaks so that it is the closest fit possible.  With best
	fit, any size arguments are ignored; if a height is missing, it will revert
	to NONE.
	Other notes
	-----------
	`a11y`
	Since the results of this method are rendering using pure paths (think
	"convert to outlines" in Adobe Illustrator), any text rendered by this
	code is NOT considered a11y-friendly.  If a11y is a requirement, we
	suggest using other, more a11y-friendly methods.
	`Font sources`
	Always make sure that you are legally allowed to use any fonts that you
	convert to SVG format; we claim no responsibility for any licensing
	infractions that may be caused by the use of this code.</description>
        <parameters>
          <parameter name="group" type="dojox.gfx.Container" usage="required"/>
          <parameter name="textArgs" type="dojox.gfx.__TextArgs" usage="required"/>
          <parameter name="fontArgs" type="dojox.gfx.__FontArgs" usage="required"/>
          <parameter name="fillArgs" type="dojox.gfx.__FillArgs" usage="required"/>
          <parameter name="strokeArgs" type="dojox.gfx.__StrokeArgs" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Group"/>
        </return-types>
      </method>
      <method name="onLoadBegin" scope="prototype">
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="prototype">
        <parameters>
          <parameter name="font" type="dojox.gfx.VectorFont" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.VectorFont.viewbox" type="">
    <properties>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultPath">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="path" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultPolyline">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultRect">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="width" scope="normal" type="Number"/>
      <property name="height" scope="normal" type="Number"/>
      <property name="r" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultEllipse">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="cx" scope="normal" type="Number"/>
      <property name="cy" scope="normal" type="Number"/>
      <property name="rx" scope="normal" type="Number"/>
      <property name="ry" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultCircle">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="cx" scope="normal" type="Number"/>
      <property name="cy" scope="normal" type="Number"/>
      <property name="r" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultLine">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x1" scope="normal" type="Number"/>
      <property name="y1" scope="normal" type="Number"/>
      <property name="x2" scope="normal" type="Number"/>
      <property name="y2" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultImage">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="width" scope="normal" type="Number"/>
      <property name="height" scope="normal" type="Number"/>
      <property name="src" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultText">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="text" scope="normal" type="String"/>
      <property name="align" scope="normal" type="String"/>
      <property name="decoration" scope="normal" type="String"/>
      <property name="rotated" scope="normal" type="bool"/>
      <property name="kerning" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultTextPath">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="text" scope="normal" type="String"/>
      <property name="align" scope="normal" type="String"/>
      <property name="decoration" scope="normal" type="String"/>
      <property name="rotated" scope="normal" type="bool"/>
      <property name="kerning" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultStroke">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="color" scope="normal" type="String"/>
      <property name="style" scope="normal" type="String"/>
      <property name="width" scope="normal" type="Number"/>
      <property name="cap" scope="normal" type="String"/>
      <property name="join" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultLinearGradient">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x1" scope="normal" type="Number"/>
      <property name="y1" scope="normal" type="Number"/>
      <property name="x2" scope="normal" type="Number"/>
      <property name="y2" scope="normal" type="Number"/>
      <property name="colors" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultRadialGradient">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="cx" scope="normal" type="Number"/>
      <property name="cy" scope="normal" type="Number"/>
      <property name="r" scope="normal" type="Number"/>
      <property name="colors" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultPattern">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="width" scope="normal" type="Number"/>
      <property name="height" scope="normal" type="Number"/>
      <property name="src" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.defaultFont">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="style" scope="normal" type="String"/>
      <property name="variant" scope="normal" type="String"/>
      <property name="weight" scope="normal" type="String"/>
      <property name="size" scope="normal" type="String"/>
      <property name="family" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx._base" type="" private="true">
    <methods>
      <method name="_getFontMeasurements" scope="normal">
        <summary>Returns an object that has pixel equivilents of standard font
	size values.</summary>
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="_getCachedFontMeasurements" scope="normal">
        <parameters>
          <parameter name="recalculate" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getTextBox" scope="normal">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
          <parameter name="className" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="_getUniqueId" scope="normal">
        <summary>returns a unique string for use with any DOM element</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.arc">
    <properties>
      <property name="unitArcAsBezier" scope="normal" type=""/>
      <property name="curvePI4" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="arcAsBezier" scope="normal">
        <summary>calculates an arc as a series of Bezier curves
	given the last point and a standard set of SVG arc parameters,
	it returns an array of arrays of parameters to form a series of
	absolute Bezier curves.</summary>
        <parameters>
          <parameter name="last" type="Object:" usage="required">
            <summary>a point-like object as a start of the arc</summary>
          </parameter>
          <parameter name="rx" type="Number:" usage="required">
            <summary>a horizontal radius for the virtual ellipse</summary>
          </parameter>
          <parameter name="ry" type="Number:" usage="required">
            <summary>a vertical radius for the virtual ellipse</summary>
          </parameter>
          <parameter name="xRotg" type="Number:" usage="required">
            <summary>a rotation of an x axis of the virtual ellipse in degrees</summary>
          </parameter>
          <parameter name="large" type="Boolean:" usage="required">
            <summary>which part of the ellipse will be used (the larger arc if true)</summary>
          </parameter>
          <parameter name="sweep" type="Boolean:" usage="required">
            <summary>direction of the arc (CW if true)</summary>
          </parameter>
          <parameter name="x" type="Number:" usage="required">
            <summary>the x coordinate of the end point of the arc</summary>
          </parameter>
          <parameter name="y" type="Number:" usage="required">
            <summary>the y coordinate of the end point of the arc</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Creator">
    <summary>VML shape creators</summary>
    <methods>
      <method name="createObject" scope="normal">
        <summary>creates an instance of the passed shapeType class</summary>
        <parameters>
          <parameter name="shapeType" type="Function:" usage="required">
            <summary>a class constructor to create an instance of</summary>
          </parameter>
          <parameter name="rawShape" type="Object:" usage="required">
            <summary>properties to be passed in to the classes &amp;quot;setShape&amp;quot; method
	overrideSize: Boolean: set the size explicitly, if true</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="createShape" scope="normal">
        <summary>creates a shape object based on its type; it is meant to be used
	by group-like objects</summary>
        <parameters>
          <parameter name="shape" type="Object:" usage="required">
            <summary>a shape descriptor object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="createGroup" scope="normal">
        <summary>creates a VML group shape</summary>
        <return-types>
          <return-type type="dojox.gfx.Group"/>
        </return-types>
      </method>
      <method name="createRect" scope="normal">
        <summary>creates a rectangle shape</summary>
        <parameters>
          <parameter name="rect" type="Object:" usage="required">
            <summary>a path object (see dojox.gfx.defaultRect)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Rect"/>
        </return-types>
      </method>
      <method name="createEllipse" scope="normal">
        <summary>creates an ellipse shape</summary>
        <parameters>
          <parameter name="ellipse" type="Object:" usage="required">
            <summary>an ellipse object (see dojox.gfx.defaultEllipse)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Ellipse"/>
        </return-types>
      </method>
      <method name="createCircle" scope="normal">
        <summary>creates a circle shape</summary>
        <parameters>
          <parameter name="circle" type="Object:" usage="required">
            <summary>a circle object (see dojox.gfx.defaultCircle)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Circle"/>
        </return-types>
      </method>
      <method name="createLine" scope="normal">
        <summary>creates a line shape</summary>
        <parameters>
          <parameter name="line" type="Object:" usage="required">
            <summary>a line object (see dojox.gfx.defaultLine)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Line"/>
        </return-types>
      </method>
      <method name="createPolyline" scope="normal">
        <summary>creates a polyline/polygon shape</summary>
        <parameters>
          <parameter name="points" type="Object:" usage="required">
            <summary>a points object (see dojox.gfx.defaultPolyline)
	or an Array of points</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Polyline"/>
        </return-types>
      </method>
      <method name="createText" scope="normal">
        <summary>creates a text shape</summary>
        <parameters>
          <parameter name="text" type="Object:" usage="required">
            <summary>a text object (see dojox.gfx.defaultText)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Text"/>
        </return-types>
      </method>
      <method name="createPath" scope="normal">
        <summary>creates a path shape</summary>
        <parameters>
          <parameter name="path" type="Object:" usage="required">
            <summary>a path object (see dojox.gfx.defaultPath)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Path"/>
        </return-types>
      </method>
      <method name="createTextPath" scope="normal">
        <summary>creates a text shape</summary>
        <parameters>
          <parameter name="text" type="Object:" usage="required">
            <summary>a textpath object (see dojox.gfx.defaultTextPath)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.TextPath"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape"/>
  <object location="dojox.gfx.Shape" type="Function" classlike="true" superclass="dojox.gfx.shape._eventsProcessing">
    <summary>VML-specific implementation of dojox.gfx.Shape methods</summary>
    <mixins>
      <mixin scope="prototype" location="eventsProcessing"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="instance-prototype" type="Object"/>
      <property name="fillStyle" scope="instance-prototype" type="Object"/>
      <property name="strokeStyle" scope="instance-prototype" type="Object"/>
      <property name="matrix" scope="instance-prototype" type="Object"/>
      <property name="parent" scope="instance-prototype" type="Object"/>
      <property name="parentMatrix" scope="instance-prototype" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:">
        <summary>underlying node</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_render" scope="prototype">
        <summary>render the shape</summary>
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="getEventSource" scope="prototype">
        <summary>returns a Node, which is used as
	a source of events for this shape</summary>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="connect" scope="prototype"/>
      <method name="disconnect" scope="prototype"/>
      <method name="constructor" scope="prototype"/>
      <method name="getNode" scope="prototype">
        <summary>returns the current DOM Node or null</summary>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="getShape" scope="prototype">
        <summary>returns the current shape object or null
	(see dojox.gfx.defaultPath,
	dojox.gfx.defaultPolyline,
	dojox.gfx.defaultRect,
	dojox.gfx.defaultEllipse,
	dojox.gfx.defaultCircle,
	dojox.gfx.defaultLine,
	or dojox.gfx.defaultImage)</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getTransform" scope="prototype">
        <summary>returns the current transformation matrix or null</summary>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="getFill" scope="prototype">
        <summary>returns the current fill object or null
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getStroke" scope="prototype">
        <summary>returns the current stroke object or null
	(see dojox.gfx.defaultStroke)</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getParent" scope="prototype">
        <summary>returns the parent or null
	(see dojox.gfx.Surface,
	dojox.gfx.shape.VirtualGroup,
	or dojox.gfx.Group)</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <summary>returns the bounding box or null
	(see dojox.gfx.defaultRect)</summary>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="getTransformedBoundingBox" scope="prototype">
        <summary>returns an array of four points or null
	four points represent four corners of the untransformed bounding box</summary>
        <return-types>
          <return-type type="null"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="setTransform" scope="prototype">
        <summary>sets a transformation matrix</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToFront" scope="prototype">
        <summary>moves a shape to front of its parent's list of shapes</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="moveToBack" scope="prototype">
        <summary>moves a shape to back of its parent's list of shapes</summary>
      </method>
      <method name="applyRightTransform" scope="prototype">
        <summary>multiplies the existing matrix with an argument on right side
	(this.matrix * matrix)</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="prototype">
        <summary>multiplies the existing matrix with an argument on left side
	(matrix * this.matrix)</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyTransform" scope="prototype">
        <summary>a shortcut for dojox.gfx.Shape.applyRightTransform</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx.Matrix2D
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="removeShape" scope="prototype">
        <summary>removes the shape from its parent's list of shapes</summary>
        <parameters>
          <parameter name="silently" type="Boolean:" usage="optional">
            <summary>if true, do not redraw a picture yet</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setParent" scope="prototype">
        <summary>sets a parent</summary>
        <parameters>
          <parameter name="parent" type="Object:" usage="required">
            <summary>a parent or null
	(see dojox.gfx.Surface,
	dojox.gfx.shape.VirtualGroup,
	or dojox.gfx.Group)</summary>
          </parameter>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required">
            <summary>a 2D matrix or a matrix-like object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateParentMatrix" scope="prototype">
        <summary>updates the parent matrix with new matrix</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.Matrix2D:" usage="required">
            <summary>a 2D matrix or a matrix-like object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getRealMatrix" scope="prototype">
        <summary>returns the cumulative (&amp;quot;real&amp;quot;) transformation matrix
	by combining the shape's matrix with its parent's matrix</summary>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="_getParentSurface" scope="prototype"/>
      <method name="_getAdjustedMatrix" scope="prototype">
        <summary>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</summary>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="_translate" scope="prototype">
        <parameters>
          <parameter name="dict" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setDimensions" scope="prototype">
        <summary>sets the width and height of the rawNode,
	if the surface sixe has been changed</summary>
        <parameters>
          <parameter name="width" type="String:" usage="required">
            <summary>width in pixels</summary>
          </parameter>
          <parameter name="height" type="String:" usage="required">
            <summary>height in pixels</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._renderTransform" type="Function" classlike="true" private="true">
    <properties>
      <property name="canvasTransform" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._renderFill" type="Function" classlike="true" private="true">
    <properties>
      <property name="canvasFill" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._renderStroke" type="Function" classlike="true" private="true">
    <properties>
      <property name="strokeStyle" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
          <parameter name="apply" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Group" type="Function" classlike="true" superclass="Container">
    <summary>a group shape (VML), which can be used
	to logically group shapes (e.g, to propagate matricies)
	apply transformation</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.gfx.shape.Creator"/>
      <mixin scope="prototype" location="dojox.gfx.Shape"/>
      <mixin scope="prototype" location="dojox.gfx.silverlight.Container"/>
      <mixin scope="prototype" location="dojox.gfx.svg.Container"/>
      <mixin scope="prototype" location="dojox.gfx.vml.Container"/>
      <mixin scope="instance" location="dojox.gfx.Shape"/>
    </mixins>
    <properties>
      <property name="nodeType" scope="normal" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="_render" scope="prototype">
        <summary>render the group</summary>
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setRawNode" scope="prototype">
        <summary>sets a raw SVG node to be used by this shape</summary>
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>an SVG node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_applyTransform" scope="prototype">
        <summary>applies a transformation matrix to a group</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setDimensions" scope="prototype">
        <summary>sets the width and height of the rawNode,
	if the surface sixe has been changed</summary>
        <parameters>
          <parameter name="width" type="String:" usage="required">
            <summary>width in pixels</summary>
          </parameter>
          <parameter name="height" type="String:" usage="required">
            <summary>height in pixels</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Surface" type="Function" classlike="true" superclass="Container">
    <summary>a surface object to be used for drawings (VML)</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.gfx.shape.Creator"/>
      <mixin scope="prototype" location="dojox.gfx.shape.Surface"/>
      <mixin scope="prototype" location="dojox.gfx.silverlight.Container"/>
      <mixin scope="prototype" location="eventsProcessing"/>
      <mixin scope="prototype" location="dojox.gfx.svg.Container"/>
      <mixin scope="prototype" location="dojox.gfx.vml.Container"/>
      <mixin scope="instance" location="dojox.gfx.shape.Surface"/>
    </mixins>
    <properties>
      <property name="width" scope="prototype" type="Object"/>
      <property name="height" scope="prototype" type="Object"/>
      <property name="pendingRender" scope="prototype" type="Object"/>
      <property name="pendingImageCount" scope="instance" type="Number"/>
      <property name="defNode" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="setDimensions" scope="prototype">
        <summary>sets the width and height of the rawNode</summary>
        <parameters>
          <parameter name="width" type="String:" usage="required">
            <summary>width of surface, e.g., &amp;quot;100px&amp;quot;</summary>
          </parameter>
          <parameter name="height" type="String:" usage="required">
            <summary>height of surface, e.g., &amp;quot;100px&amp;quot;</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getDimensions" scope="prototype">
        <summary>returns an object with properties &amp;quot;width&amp;quot; and &amp;quot;height&amp;quot;</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_render" scope="prototype">
        <summary>render the all shapes</summary>
      </method>
      <method name="makeDirty" scope="prototype">
        <summary>internal method, which is called when we may need to redraw</summary>
      </method>
      <method name="downloadImage" scope="prototype">
        <summary>internal method, which starts an image download and renders, when it is ready</summary>
        <parameters>
          <parameter name="img" type="Image:" usage="required">
            <summary>the image object</summary>
          </parameter>
          <parameter name="url" type="String:" usage="required">
            <summary>the url of the image</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onImageLoad" scope="prototype"/>
      <method name="getEventSource" scope="prototype"/>
      <method name="connect" scope="prototype"/>
      <method name="disconnect" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="createViewport" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx.Rect" type="Function" classlike="true" superclass="dojox.gfx.shape.Rect">
    <summary>a rectangle shape (VML)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.shape.Rect"/>
    </mixins>
    <properties>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="matrix" scope="prototype" type=""/>
      <property name="nodeType" scope="normal" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <summary>sets a rectangle shape object (VML)</summary>
        <parameters>
          <parameter name="newShape" type="Object:" usage="required">
            <summary>a rectangle shape object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="prototype">
        <summary>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</summary>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Rect.shape">
    <properties>
      <property name="x" scope="prototype" type=""/>
      <property name="y" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Ellipse" type="Function" classlike="true" superclass="dojox.gfx.shape.Ellipse">
    <summary>an ellipse shape (VML)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.shape.Ellipse"/>
    </mixins>
    <properties>
      <property name="shape" scope="prototype" type="Object"/>
      <property name="canvasEllipse" scope="prototype" type=""/>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="matrix" scope="prototype" type=""/>
      <property name="nodeType" scope="normal" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setShape" scope="prototype">
        <summary>sets an ellipse shape object (VML)</summary>
        <parameters>
          <parameter name="newShape" type="Object:" usage="required">
            <summary>an ellipse shape object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAdjustedMatrix" scope="prototype">
        <summary>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</summary>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Circle" type="Function" classlike="true" superclass="dojox.gfx.shape.Circle">
    <summary>a circle shape (VML)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.shape.Circle"/>
    </mixins>
    <properties>
      <property name="shape" scope="prototype" type="Object"/>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="matrix" scope="prototype" type=""/>
      <property name="nodeType" scope="normal" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <summary>sets a circle shape object (VML)</summary>
        <parameters>
          <parameter name="newShape" type="Object:" usage="required">
            <summary>a circle shape object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_getAdjustedMatrix" scope="prototype">
        <summary>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</summary>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Line" type="Function" classlike="true" superclass="dojox.gfx.shape.Line">
    <summary>a line shape (VML)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.shape.Line"/>
    </mixins>
    <properties>
      <property name="shape" scope="prototype" type="Object"/>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="nodeType" scope="normal" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <summary>sets a line shape object (VML)</summary>
        <parameters>
          <parameter name="newShape" type="Object:" usage="required">
            <summary>a line shape object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Polyline" type="Function" classlike="true" superclass="dojox.gfx.shape.Polyline">
    <summary>a polyline/polygon shape (VML)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.shape.Polyline"/>
    </mixins>
    <properties>
      <property name="canvasPolyline" scope="prototype" type=""/>
      <property name="box" scope="prototype" type="Object"/>
      <property name="nodeType" scope="normal" type="String"/>
      <property name="bbox" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <summary>sets a polyline/polygon shape object (VML)</summary>
        <parameters>
          <parameter name="points" type="Object:" usage="required">
            <summary>a polyline/polygon shape object</summary>
          </parameter>
          <parameter name="closed" type="Boolean:" usage="required">
            <summary>if true, close the polyline explicitely</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Polyline.shape"/>
  <object location="dojox.gfx.Polyline.shape.points" type="">
    <properties>
      <property name="0" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Image" type="Function" classlike="true" superclass="dojox.gfx.shape.Image">
    <summary>an image (VML)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.shape.Image"/>
    </mixins>
    <properties>
      <property name="canvasImage" scope="prototype" type=""/>
      <property name="shape" scope="prototype" type="Object"/>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="matrix" scope="prototype" type=""/>
      <property name="nodeType" scope="normal" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setShape" scope="prototype">
        <summary>sets an image shape object (VML)</summary>
        <parameters>
          <parameter name="newShape" type="Object:" usage="required">
            <summary>an image shape object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_getAdjustedMatrix" scope="prototype">
        <summary>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</summary>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="setRawNode" scope="prototype">
        <summary>assigns and clears the underlying node that will represent this
	shape. Once set, transforms, gradients, etc, can be applied.
	(no fill &amp;amp; stroke by default)</summary>
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_applyTransform" scope="prototype">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setDimensions" scope="prototype">
        <summary>sets the width and height of the rawNode,
	if the surface sixe has been changed</summary>
        <parameters>
          <parameter name="width" type="String:" usage="required">
            <summary>width in pixels</summary>
          </parameter>
          <parameter name="height" type="String:" usage="required">
            <summary>height in pixels</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Text" type="Function" classlike="true" superclass="dojox.gfx.shape.Text">
    <summary>an anchored text (VML)</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.gfx.silverlight.Font"/>
      <mixin scope="prototype" location="dojox.gfx.svg.Font"/>
      <mixin scope="instance" location="dojox.gfx.shape.Text"/>
    </mixins>
    <properties>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="_delay" scope="prototype" type="Object"/>
      <property name="_delta" scope="prototype" type="Object"/>
      <property name="matrix" scope="prototype" type=""/>
      <property name="nodeType" scope="normal" type="String"/>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <summary>sets a text shape object (VML)</summary>
        <parameters>
          <parameter name="newShape" type="Object:" usage="required">
            <summary>a text shape object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_delayAlignment" scope="prototype"/>
      <method name="_getAdjustedMatrix" scope="prototype">
        <summary>returns the adjusted (&amp;quot;real&amp;quot;) transformation matrix</summary>
      </method>
      <method name="setStroke" scope="prototype">
        <summary>ignore setting a stroke style</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFillAttr" scope="prototype">
        <parameters>
          <parameter name="f" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setRawNode" scope="prototype">
        <summary>assigns and clears the underlying node that will represent this
	shape. Once set, transforms, gradients, etc, can be applied.
	(no fill &amp;amp; stroke by default)</summary>
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getTextWidth" scope="prototype">
        <summary>get the text width, in px</summary>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setFont" scope="prototype">
        <summary>sets a font object (VML)</summary>
      </method>
      <method name="_getRealMatrix" scope="prototype">
        <summary>returns the cumulative (&amp;quot;real&amp;quot;) transformation matrix
	by combining the shape's matrix with its parent's matrix;
	it makes a correction for a font size</summary>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Path" type="Function" classlike="true" superclass="dojox.gfx.path.Path">
    <summary>a path shape (VML)
	VML-specific segment renderers</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.path.Path"/>
    </mixins>
    <properties>
      <property name="canvasPath" scope="prototype" type="Array"/>
      <property name="nodeType" scope="normal" type="String"/>
      <property name="vmlPath" scope="instance-prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <summary>forms a path using a shape (VML)</summary>
        <parameters>
          <parameter name="newShape" type="Object:" usage="required">
            <summary>an VML path string or a path object (see dojox.gfx.defaultPath)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_updateWithSegment" scope="prototype">
        <summary>updates the bounding box of path with new segment</summary>
        <parameters>
          <parameter name="segment" type="Object:" usage="required">
            <summary>a segment</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_moveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToA" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_lineToR" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToA" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_hLineToR" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToA" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_vLineToR" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_curveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_smoothCurveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_qCurveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToA" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_qSmoothCurveToR" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_arcTo" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_closePath" scope="prototype">
        <parameters>
          <parameter name="result" type="" usage="required"/>
          <parameter name="action" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_addArgs" scope="prototype">
        <parameters>
          <parameter name="path" type="" usage="required"/>
          <parameter name="segment" type="" usage="required"/>
          <parameter name="from" type="" usage="required"/>
          <parameter name="upto" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelCrd" scope="prototype">
        <parameters>
          <parameter name="last" type="" usage="required"/>
          <parameter name="segment" type="" usage="required"/>
          <parameter name="step" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustRelPos" scope="prototype">
        <parameters>
          <parameter name="last" type="" usage="required"/>
          <parameter name="segment" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Path.last" type="">
    <properties>
      <property name="x" scope="prototype" type=""/>
      <property name="y" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Path.lastControl">
    <properties>
      <property name="x" scope="prototype" type="Number"/>
      <property name="y" scope="prototype" type="Number"/>
      <property name="type" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.TextPath" type="Function" classlike="true" superclass="dojox.gfx.path.TextPath">
    <summary>a textpath shape (VML)</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.gfx.svg.Font"/>
      <mixin scope="prototype" location="dojox.gfx.Path"/>
      <mixin scope="instance" location="dojox.gfx.path.TextPath"/>
      <mixin scope="instance" location="dojox.gfx.Path"/>
    </mixins>
    <properties>
      <property name="shape" scope="prototype" type=""/>
      <property name="nodeType" scope="normal" type="String"/>
      <property name="text" scope="instance-prototype" type="Object"/>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_renderShape" scope="prototype">
        <parameters>
          <parameter name="ctx" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="prototype">
        <summary>updates the bounding box of path with new segment</summary>
        <parameters>
          <parameter name="segment" type="Object:" usage="required">
            <summary>a segment</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <summary>forms a path using a shape (SVG)</summary>
        <parameters>
          <parameter name="newShape" type="Object:" usage="required">
            <summary>an SVG path string or a path object (see dojox.gfx.defaultPath)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setText" scope="prototype">
        <summary>sets a text shape object (VML)</summary>
      </method>
      <method name="_setTextPath" scope="prototype"/>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setText" scope="prototype">
        <summary>sets a text to be drawn along the path</summary>
        <parameters>
          <parameter name="newText" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFont" scope="prototype">
        <summary>sets a font for text</summary>
        <parameters>
          <parameter name="newFont" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setFont" scope="prototype">
        <summary>sets a font object (VML)</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Surface.rawNode" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
      <property name="coordsize" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.matrix" type="">
    <summary>class constants, and methods of dojox.gfx.matrix</summary>
    <properties>
      <property name="identity" scope="normal" type="dojox.gfx.matrix.Matrix2D">
        <summary>an identity matrix constant: identity * (x, y) == (x, y)</summary>
      </property>
      <property name="flipX" scope="normal" type="dojox.gfx.matrix.Matrix2D">
        <summary>a matrix, which reflects points at x = 0 line: flipX * (x, y) == (-x, y)</summary>
      </property>
      <property name="flipY" scope="normal" type="dojox.gfx.matrix.Matrix2D">
        <summary>a matrix, which reflects points at y = 0 line: flipY * (x, y) == (x, -y)</summary>
      </property>
      <property name="flipXY" scope="normal" type="dojox.gfx.matrix.Matrix2D">
        <summary>a matrix, which reflects points at the origin of coordinates: flipXY * (x, y) == (-x, -y)</summary>
      </property>
    </properties>
    <methods>
      <method name="multiplyPoint" scope="normal">
        <summary>applies a matrix to a point</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required">
            <summary>a 2D matrix object to be applied</summary>
          </parameter>
          <parameter name="a" type="Number||Point" usage="required">
            <summary>Number: an x coordinate of a point</summary>
          </parameter>
          <parameter name="b" type="Number," usage="required">
            <summary>Number: a y coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Point"/>
        </return-types>
      </method>
      <method name="translate" scope="normal">
        <summary>forms a translation matrix</summary>
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required">
            <summary>an x coordinate value</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a y coordinate value</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="scale" scope="normal">
        <summary>forms a scaling matrix</summary>
        <description>The resulting matrix is used to scale (magnify) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required">
            <summary>a scaling factor used for the x coordinate</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a scaling factor used for the y coordinate</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotate" scope="normal">
        <summary>forms a rotating matrix</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an angle of rotation in radians (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotateg" scope="normal">
        <summary>forms a rotating matrix</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.rotate() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an angle of rotation in degrees (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewX" scope="normal">
        <summary>forms an x skewing matrix</summary>
        <description>The resulting matrix is used to skew points in the x dimension
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an skewing angle in radians</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXg" scope="normal">
        <summary>forms an x skewing matrix</summary>
        <description>The resulting matrix is used to skew points in the x dimension
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.skewX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an skewing angle in degrees</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewY" scope="normal">
        <summary>forms a y skewing matrix</summary>
        <description>The resulting matrix is used to skew points in the y dimension
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an skewing angle in radians</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYg" scope="normal">
        <summary>forms a y skewing matrix</summary>
        <description>The resulting matrix is used to skew points in the y dimension
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx.matrix.skewY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an skewing angle in degrees</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="reflect" scope="normal">
        <summary>forms a reflection matrix</summary>
        <description>The resulting matrix is used to reflect points around a vector,
	which goes through the origin.</description>
        <parameters>
          <parameter name="a" type="dojox.gfx.Point:" usage="required">
            <summary>a point-like object, which specifies a vector of reflection</summary>
          </parameter>
          <parameter name="b" type="null" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="project" scope="normal">
        <summary>forms an orthogonal projection matrix</summary>
        <description>The resulting matrix is used to project points orthogonally on a vector,
	which goes through the origin.</description>
        <parameters>
          <parameter name="a" type="dojox.gfx.Point:" usage="required">
            <summary>a point-like object, which specifies a vector of projection</summary>
          </parameter>
          <parameter name="b" type="null" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="normalize" scope="normal">
        <summary>converts an object to a matrix, if necessary</summary>
        <description>Converts any 2D matrix-like object or an array of
	such objects to a valid dojox.gfx.matrix.Matrix2D object.</description>
        <parameters>
          <parameter name="matrix" type="Object:" usage="required">
            <summary>an object, which is converted to a matrix, if necessary</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="clone" scope="normal">
        <summary>creates a copy of a 2D matrix</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required">
            <summary>a 2D matrix-like object to be cloned</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="invert" scope="normal">
        <summary>inverts a 2D matrix</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required">
            <summary>a 2D matrix-like object to be inverted</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_multiplyPoint" scope="normal">
        <summary>applies a matrix to a point</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required">
            <summary>a 2D matrix object to be applied</summary>
          </parameter>
          <parameter name="x" type="Number:" usage="required">
            <summary>an x coordinate of a point</summary>
          </parameter>
          <parameter name="y" type="Number:" usage="required">
            <summary>a y coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Point"/>
        </return-types>
      </method>
      <method name="multiply" scope="normal">
        <summary>combines matrices by multiplying them sequentially in the given order</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="one-or-more">
            <summary>a 2D matrix-like object,
	all subsequent arguments are matrix-like objects too</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_sandwich" scope="normal">
        <summary>applies a matrix at a centrtal point</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix2D:" usage="required">
            <summary>a 2D matrix-like object, which is applied at a central point</summary>
          </parameter>
          <parameter name="x" type="Number:" usage="required">
            <summary>an x component of the central point</summary>
          </parameter>
          <parameter name="y" type="Number:" usage="required">
            <summary>a y component of the central point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="scaleAt" scope="normal">
        <summary>scales a picture using a specified point as a center of scaling</summary>
        <description>Compare with dojox.gfx.matrix.scale().</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required">
            <summary>a scaling factor used for the x coordinate</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a scaling factor used for the y coordinate</summary>
          </parameter>
          <parameter name="c" type="Number:" usage="required">
            <summary>an x component of a central point</summary>
          </parameter>
          <parameter name="d" type="Number:" usage="required">
            <summary>a y component of a central point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotateAt" scope="normal">
        <summary>rotates a picture using a specified point as a center of rotation</summary>
        <description>Compare with dojox.gfx.matrix.rotate().</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an angle of rotation in radians (&amp;gt;0 for CW)</summary>
          </parameter>
          <parameter name="a" type="Number:" usage="required">
            <summary>an x component of a central point</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a y component of a central point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="rotategAt" scope="normal">
        <summary>rotates a picture using a specified point as a center of rotation</summary>
        <description>Compare with dojox.gfx.matrix.rotateg().</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an angle of rotation in degrees (&amp;gt;0 for CW)</summary>
          </parameter>
          <parameter name="a" type="Number:" usage="required">
            <summary>an x component of a central point</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a y component of a central point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXAt" scope="normal">
        <summary>skews a picture along the x axis using a specified point as a center of skewing</summary>
        <description>Compare with dojox.gfx.matrix.skewX().</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an skewing angle in radians</summary>
          </parameter>
          <parameter name="a" type="Number:" usage="required">
            <summary>an x component of a central point</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a y component of a central point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewXgAt" scope="normal">
        <summary>skews a picture along the x axis using a specified point as a center of skewing</summary>
        <description>Compare with dojox.gfx.matrix.skewXg().</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an skewing angle in degrees</summary>
          </parameter>
          <parameter name="a" type="Number:" usage="required">
            <summary>an x component of a central point</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a y component of a central point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYAt" scope="normal">
        <summary>skews a picture along the y axis using a specified point as a center of skewing</summary>
        <description>Compare with dojox.gfx.matrix.skewY().</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an skewing angle in radians</summary>
          </parameter>
          <parameter name="a" type="Number:" usage="required">
            <summary>an x component of a central point</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a y component of a central point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="skewYgAt" scope="normal">
        <summary>skews a picture along the y axis using a specified point as a center of skewing</summary>
        <description>Compare with dojox.gfx.matrix.skewYg().</description>
        <parameters>
          <parameter name="degree" type="Number" usage="required">
            <summary>Number: an skewing angle in degrees</summary>
          </parameter>
          <parameter name="a" type="Number||Point" usage="required">
            <summary>Number: an x component of a central point</summary>
          </parameter>
          <parameter name="b" type="Number," usage="required">
            <summary>Number: a y component of a central point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.matrix.Matrix2D"/>
        </return-types>
      </method>
      <method name="_degToRad" scope="normal">
        <parameters>
          <parameter name="degree" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_radToDeg" scope="normal">
        <parameters>
          <parameter name="radian" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.fx">
    <methods>
      <method name="animateStroke" scope="normal">
        <summary>Returns an animation which will change stroke properties over time</summary>
        <examples>
          <example>	dojox.gfx.fx.animateStroke{{
			shape: shape,
			duration: 500,
			color: {start: "red", end: "green"},
			width: {end: 15},
			join:  {values: ["miter", "bevel", "round"]}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateFill" scope="normal">
        <summary>Returns an animation which will change fill color over time.
	Only solid fill color is supported at the moment</summary>
        <examples>
          <example>	dojox.gfx.fx.animateFill{{
			shape: shape,
			duration: 500,
			color: {start: "red", end: "green"}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateFont" scope="normal">
        <summary>Returns an animation which will change font properties over time</summary>
        <examples>
          <example>	dojox.gfx.fx.animateFont{{
			shape: shape,
			duration: 500,
			variant: {values: ["normal", "small-caps"]},
			size:  {end: 10, units: "pt"}
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="animateTransform" scope="normal">
        <summary>Returns an animation which will change transformation over time</summary>
        <examples>
          <example>	dojox.gfx.fx.animateTransform{{
			shape: shape,
			duration: 500,
			transform: [
				{name: "translate", start: [0, 0], end: [200, 200]},
				{name: "original"}
			]
		}).play();</example>
        </examples>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.matrix.Matrix2D" type="Function" classlike="true">
    <summary>a 2D matrix object</summary>
    <description>Normalizes a 2D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
    <properties>
      <property name="xx" scope="instance-prototype" type="Number"/>
      <property name="xy" scope="prototype" type="Number"/>
      <property name="yx" scope="prototype" type="Number"/>
      <property name="yy" scope="instance-prototype" type="Number"/>
      <property name="dx" scope="prototype" type="Number"/>
      <property name="dy" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="arg" type="Object" usage="required">
            <summary>a 2D matrix-like object, a number, or an array of such objects</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.path">
    <methods>
      <method name="_calcArc" scope="normal">
        <parameters>
          <parameter name="alpha" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.path.Path" type="Function" classlike="true" superclass="dojox.gfx.Shape">
    <summary>a generalized path shape</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.Shape"/>
    </mixins>
    <properties>
      <property name="absolute" scope="instance-prototype" type="Object"/>
      <property name="segments" scope="instance-prototype" type="Array"/>
      <property name="_2PI" scope="prototype" type="Number"/>
      <property name="rawNode" scope="instance" type="Node:">
        <summary>a DOM node to be used by this path object</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM node to be used by this path object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>a path constructor</summary>
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM node to be used by this path object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setAbsoluteMode" scope="prototype">
        <summary>sets an absolute or relative mode for path points</summary>
        <parameters>
          <parameter name="mode" type="Boolean:" usage="required">
            <summary>true/false or &amp;quot;absolute&amp;quot;/&amp;quot;relative&amp;quot; to specify the mode</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getAbsoluteMode" scope="prototype">
        <summary>returns a current value of the absolute mode</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <summary>returns the bounding box {x, y, width, height} or null</summary>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="getLastPosition" scope="prototype">
        <summary>returns the last point in the path, or null</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_updateBBox" scope="prototype">
        <summary>updates the bounding box of path with new point</summary>
        <parameters>
          <parameter name="x" type="Number:" usage="required">
            <summary>an x coordinate</summary>
          </parameter>
          <parameter name="y" type="Number:" usage="required">
            <summary>a y coordinate</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_updateWithSegment" scope="prototype">
        <summary>updates the bounding box of path with new segment</summary>
        <parameters>
          <parameter name="segment" type="Object:" usage="required">
            <summary>a segment</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_pushSegment" scope="prototype">
        <summary>adds a segment</summary>
        <parameters>
          <parameter name="action" type="String:" usage="required">
            <summary>valid SVG code for a segment's type</summary>
          </parameter>
          <parameter name="args" type="Array:" usage="required">
            <summary>a list of parameters for this segment</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_collectArgs" scope="prototype">
        <summary>converts an array of arguments to plain numeric values</summary>
        <parameters>
          <parameter name="array" type="Array:" usage="required">
            <summary>an output argument (array of numbers)</summary>
          </parameter>
          <parameter name="args" type="Array:" usage="required">
            <summary>an input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="moveTo" scope="prototype">
        <summary>formes a move segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="prototype">
        <summary>formes a line segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="hLineTo" scope="prototype">
        <summary>formes a horizontal line segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="vLineTo" scope="prototype">
        <summary>formes a vertical line segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="curveTo" scope="prototype">
        <summary>formes a curve segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="smoothCurveTo" scope="prototype">
        <summary>formes a smooth curve segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qCurveTo" scope="prototype">
        <summary>formes a quadratic curve segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="qSmoothCurveTo" scope="prototype">
        <summary>formes a quadratic smooth curve segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="arcTo" scope="prototype">
        <summary>formes an elliptic arc segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="closePath" scope="prototype">
        <summary>closes a path</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_setPath" scope="prototype">
        <summary>forms a path using an SVG path string</summary>
        <parameters>
          <parameter name="path" type="String:" usage="required">
            <summary>an SVG path string</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <summary>forms a path using a shape</summary>
        <parameters>
          <parameter name="newShape" type="Object:" usage="required">
            <summary>an SVG path string or a path object (see dojox.gfx.defaultPath)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.path.Path.bbox">
    <properties>
      <property name="l" scope="prototype" type=""/>
      <property name="r" scope="prototype" type=""/>
      <property name="t" scope="prototype" type=""/>
      <property name="b" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.path.Path.last">
    <properties>
      <property name="x" scope="prototype" type=""/>
      <property name="y" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.path.Path._validSegments" private="true">
    <properties>
      <property name="m" scope="normal" type="Number"/>
      <property name="l" scope="normal" type="Number"/>
      <property name="h" scope="normal" type="Number"/>
      <property name="v" scope="normal" type="Number"/>
      <property name="c" scope="normal" type="Number"/>
      <property name="s" scope="normal" type="Number"/>
      <property name="q" scope="normal" type="Number"/>
      <property name="t" scope="normal" type="Number"/>
      <property name="a" scope="normal" type="Number"/>
      <property name="z" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.path.Path.shape">
    <properties>
      <property name="path" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx.path.TextPath" type="Function" classlike="true" superclass="dojox.gfx.path.Path">
    <summary>a generalized TextPath shape</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.path.Path"/>
    </mixins>
    <properties>
      <property name="text" scope="instance-prototype" type="Object"/>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM node to be used by this TextPath object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>a TextPath shape constructor</summary>
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM node to be used by this TextPath object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getText" scope="prototype">
        <summary>returns the current text object or null</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setText" scope="prototype">
        <summary>sets a text to be drawn along the path</summary>
        <parameters>
          <parameter name="newText" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getFont" scope="prototype">
        <summary>returns the current font object or null</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFont" scope="prototype">
        <summary>sets a font for text</summary>
        <parameters>
          <parameter name="newFont" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Surface" type="Function" classlike="true" superclass="dojox.gfx.shape._eventsProcessing">
    <summary>a surface object to be used for drawings</summary>
    <properties>
      <property name="_nodes" scope="instance-prototype" type="Array"/>
      <property name="_events" scope="instance-prototype" type="Array"/>
      <property name="rawNode" scope="instance-prototype" type="Object"/>
      <property name="isLoaded" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="destroy" scope="prototype">
        <summary>destroy all relevant external resources and release all
	external references to make this object garbage-collectible</summary>
      </method>
      <method name="getEventSource" scope="prototype">
        <summary>returns a node, which can be used to attach event listeners</summary>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
      <method name="_getRealMatrix" scope="prototype">
        <summary>always returns the identity matrix</summary>
        <return-types>
          <return-type type="dojox.gfx.Matrix2D"/>
        </return-types>
      </method>
      <method name="onLoad" scope="prototype">
        <summary>local event, fired once when the surface is created
	asynchronously, used only when isLoaded is false, required
	only for Silverlight.</summary>
        <parameters>
          <parameter name="surface" type="dojox.gfx.Surface" usage="required"/>
        </parameters>
      </method>
      <method name="whenLoaded" scope="prototype">
        <parameters>
          <parameter name="context" type="Object" usage="optional"/>
          <parameter name="method" type="Function|String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape.setShape" type="Function" classlike="true">
    <summary>sets a shape object (SVG)</summary>
    <properties>
      <property name="shape" scope="instance" type="Object:">
        <summary>a shape object
	(see dojox.gfx.defaultPath,
	dojox.gfx.defaultPolyline,
	dojox.gfx.defaultRect,
	dojox.gfx.defaultEllipse,
	dojox.gfx.defaultCircle,
	dojox.gfx.defaultLine,
	or dojox.gfx.defaultImage)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="shape" type="Object:" usage="required">
            <summary>a shape object
	(see dojox.gfx.defaultPath,
	dojox.gfx.defaultPolyline,
	dojox.gfx.defaultRect,
	dojox.gfx.defaultEllipse,
	dojox.gfx.defaultCircle,
	dojox.gfx.defaultLine,
	or dojox.gfx.defaultImage)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape.setFill" type="Function" classlike="true">
    <summary>sets a fill object (VML)</summary>
    <properties>
      <property name="fillStyle" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="fill" type="Object:" usage="required">
            <summary>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	or dojo.Color)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape.setStroke" type="Function" classlike="true">
    <summary>sets a stroke object (VML)</summary>
    <properties>
      <property name="strokeStyle" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="stroke" type="Object:" usage="required">
            <summary>a stroke object
	(see dojox.gfx.defaultStroke)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._applyTransform" type="Function" classlike="true" private="true">
    <summary>physically sets a matrix</summary>
    <properties>
      <property name="matrix" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._moveToFront" type="Function" classlike="true" private="true">
    <summary>moves a shape to front of its parent's list of shapes (VML)</summary>
    <properties>
      <property name="rawNode" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._moveToBack" type="Function" classlike="true" private="true">
    <summary>moves a shape to back of its parent's list of shapes (VML)</summary>
    <methods>
      <method constructor="constructor">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Surface._parent" private="true">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Point" type="Function" classlike="true">
    <summary>a hypothetical 2D point to be used for drawings - {x, y}</summary>
    <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2}.</description>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.gfx.Rectangle" type="Function" classlike="true">
    <summary>a hypothetical rectangle - {x, y, width, height}</summary>
    <description>This object is defined for documentation purposes.
	You should use the naked object instead: {x: 1, y: 2, width: 100, height: 200}.</description>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Rect" type="Function" classlike="true" superclass="dojox.gfx.Shape">
    <summary>a generic rectangle</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.Shape"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:">
        <summary>a DOM Node</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <summary>returns the bounding box (its shape in this case)</summary>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Ellipse" type="Function" classlike="true" superclass="dojox.gfx.Shape">
    <summary>a generic ellipse</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.Shape"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:">
        <summary>a DOM Node</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <summary>returns the bounding box</summary>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Circle" type="Function" classlike="true" superclass="dojox.gfx.Shape">
    <summary>a generic circle
	(this is a helper object, which is defined for convenience)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.Shape"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:">
        <summary>a DOM Node</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <summary>returns the bounding box</summary>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Line" type="Function" classlike="true" superclass="dojox.gfx.Shape">
    <summary>a generic line
	(this is a helper object, which is defined for convenience)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.Shape"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:">
        <summary>a DOM Node</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <summary>returns the bounding box</summary>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Polyline" type="Function" classlike="true" superclass="dojox.gfx.Shape">
    <summary>a generic polyline/polygon
	(this is a helper object, which is defined for convenience)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.Shape"/>
    </mixins>
    <properties>
      <property name="bbox" scope="prototype" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:">
        <summary>a DOM Node</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setShape" scope="prototype">
        <summary>sets a polyline/polygon shape object</summary>
        <parameters>
          <parameter name="points" type="Object:" usage="required">
            <summary>a polyline/polygon shape object</summary>
          </parameter>
          <parameter name="closed" type="Boolean:" usage="required">
            <summary>close the polyline to make a polygon</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <summary>returns the bounding box</summary>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Polyline.shape"/>
  <object location="dojox.gfx.shape.Polyline.shape.points" type="">
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.shape.Image" type="Function" classlike="true" superclass="dojox.gfx.Shape">
    <summary>a generic image
	(this is a helper object, which is defined for convenience)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.Shape"/>
    </mixins>
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:">
        <summary>a DOM Node</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getBoundingBox" scope="prototype">
        <summary>returns the bounding box (its shape in this case)</summary>
        <return-types>
          <return-type type="dojox.gfx.Rectangle"/>
        </return-types>
      </method>
      <method name="setStroke" scope="prototype">
        <summary>ignore setting a stroke style</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="prototype">
        <summary>ignore setting a fill style</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Text" type="Function" classlike="true" superclass="dojox.gfx.Shape">
    <summary>a generic text</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx.Shape"/>
    </mixins>
    <properties>
      <property name="fontStyle" scope="instance-prototype" type="Object"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rawNode" scope="instance" type="Node:">
        <summary>a DOM Node</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="rawNode" type="Node:" usage="required">
            <summary>a DOM Node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFont" scope="prototype">
        <summary>returns the current font object or null</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="setFont" scope="prototype">
        <summary>sets a font for text</summary>
        <parameters>
          <parameter name="newFont" type="Object:" usage="required">
            <summary>a font object (see dojox.gfx.defaultFont) or a font string</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape._eventsProcessing" private="true">
    <methods>
      <method name="connect" scope="normal">
        <summary>connects a handler to an event on this shape</summary>
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="object" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="disconnect" scope="normal">
        <summary>connects a handler by token from an event on this shape</summary>
        <parameters>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Container">
    <summary>a container of shapes, which can be used
	as a foundation for renderer-specific groups, or as a way
	to logically group shapes (e.g, to propagate matricies)</summary>
    <methods>
      <method name="add" scope="normal">
        <summary>adds a shape to the list</summary>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>a shape</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="normal">
        <summary>removes a shape from the list</summary>
        <parameters>
          <parameter name="shape" type="" usage="required"/>
          <parameter name="silently" type="Boolean:" usage="optional">
            <summary>if true, do not redraw a picture yet</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveChildToFront" scope="normal">
        <summary>moves a shape to front of the list of shapes</summary>
        <parameters>
          <parameter name="shape" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="_moveChildToBack" scope="normal">
        <summary>moves a shape to back of the list of shapes</summary>
        <parameters>
          <parameter name="shape" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Container._init" type="Function" classlike="true" private="true">
    <properties>
      <property name="children" scope="instance" type="Array:">
        <summary>a list of children</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Container.clear" type="Function" classlike="true">
    <summary>removes all shapes from a group/surface</summary>
    <properties>
      <property name="children" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Creator.createImage" type="Function" classlike="true">
    <summary>creates a VML image shape</summary>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="image" type="Object:" usage="required">
            <summary>an image object (see dojox.gfx.defaultImage)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx.Image"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._setFillAttr" type="Function" classlike="true" private="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="f" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._setFillAttr.rawNode" type="">
    <properties>
      <property name="fill" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape.setStroke.rawNode" type="">
    <properties>
      <property name="strokeThickness" scope="instance" type=""/>
      <property name="strokeStartLineCap" scope="instance" type=""/>
      <property name="strokeEndLineCap" scope="instance" type=""/>
      <property name="strokeDashCap" scope="instance" type=""/>
      <property name="strokeLineJoin" scope="instance" type="String"/>
      <property name="strokeMiterLimit" scope="instance" type=""/>
      <property name="strokeDashArray" scope="instance" type="Object"/>
      <property name="stroked" scope="instance" type="Object"/>
      <property name="strokecolor" scope="instance" type="Object"/>
      <property name="strokeweight" scope="instance" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape._applyTransform.rawNode" type="">
    <properties>
      <property name="renderTransform" scope="instance" type="Object"/>
      <property name="style" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape.setRawNode" type="Function" classlike="true">
    <summary>assigns and clears the underlying node that will represent this
	shape. Once set, transforms, gradients, etc, can be applied.
	(no fill &amp;amp; stroke by default)</summary>
    <properties>
      <property name="rawNode" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rawNode" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._moveToFront.parent.rawNode" type="">
    <properties>
      <property name="children" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape._moveToBack.parent.rawNode" type="">
    <properties>
      <property name="children" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Rect.rawNode" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
      <property name="radiusX" scope="prototype" type=""/>
      <property name="radiusY" scope="prototype" type=""/>
      <property name="parentNode" scope="prototype" type=""/>
      <property name="arcsize" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Ellipse.rawNode" type="">
    <properties>
      <property name="width" scope="prototype" type="Number"/>
      <property name="height" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.Circle.rawNode" type="">
    <properties>
      <property name="width" scope="prototype" type="Number"/>
      <property name="height" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.Line.rawNode" type="">
    <properties>
      <property name="x1" scope="prototype" type=""/>
      <property name="y1" scope="prototype" type=""/>
      <property name="x2" scope="prototype" type=""/>
      <property name="y2" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Polyline.rawNode" type="">
    <properties>
      <property name="points" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx.Image.rawNode" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
      <property name="source" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Text.rawNode" type="">
    <properties>
      <property name="text" scope="prototype" type=""/>
      <property name="textDecorations" scope="prototype" type=""/>
      <property name="actualWidth" scope="prototype" type=""/>
      <property name="actualHeight" scope="prototype" type=""/>
      <property name="foreground" scope="prototype" type=""/>
      <property name="textContent" scope="prototype" type=""/>
      <property name="parentNode" scope="prototype" type=""/>
      <property name="childNodes" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Text.rawNode.Canvas" type="">
    <properties>
      <property name="Left" scope="prototype" type="Number"/>
      <property name="Top" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.Text.shape">
    <properties>
      <property name="x" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Path.shape" type="">
    <properties>
      <property name="path" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Path.rawNode" type="">
    <properties>
      <property name="data" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.silverlight">
    <properties>
      <property name="surfaces" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="hexColor" scope="normal">
        <summary>converts a color object to a Silverlight hex color string (#aarrggbb)</summary>
        <parameters>
          <parameter name="color" type="String|Array|dojo.Color" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="nullFunc" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.gfx.silverlight.dasharray">
    <properties>
      <property name="solid" scope="normal" type="String"/>
      <property name="shortdash" scope="normal" type="Array"/>
      <property name="shortdot" scope="normal" type="Array"/>
      <property name="shortdashdot" scope="normal" type="Array"/>
      <property name="shortdashdotdot" scope="normal" type="Array"/>
      <property name="dot" scope="normal" type="Array"/>
      <property name="dash" scope="normal" type="Array"/>
      <property name="longdash" scope="normal" type="Array"/>
      <property name="dashdot" scope="normal" type="Array"/>
      <property name="longdashdot" scope="normal" type="Array"/>
      <property name="longdashdotdot" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx.silverlight.fontweight">
    <properties>
      <property name="normal" scope="normal" type="Number"/>
      <property name="bold" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.silverlight.caps">
    <properties>
      <property name="butt" scope="normal" type="String"/>
      <property name="round" scope="normal" type="String"/>
      <property name="square" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.silverlight.joins">
    <properties>
      <property name="bevel" scope="normal" type="String"/>
      <property name="round" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.silverlight.fonts">
    <properties>
      <property name="serif" scope="normal" type="String"/>
      <property name="times" scope="normal" type="String"/>
      <property name="sans-serif" scope="normal" type="String"/>
      <property name="helvetica" scope="normal" type="String"/>
      <property name="monotone" scope="normal" type="String"/>
      <property name="courier" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.silverlight.Font"/>
  <object location="dojox.gfx.silverlight.Font._setFont" type="Function" classlike="true" private="true">
    <summary>sets a font object (Silverlight)</summary>
    <properties>
      <property name="fontStyle" scope="instance" type=""/>
      <property name="_delay" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.gfx.silverlight.Font._setFont.rawNode" type="">
    <properties>
      <property name="fontStyle" scope="instance" type=""/>
      <property name="fontWeight" scope="instance" type="Array"/>
      <property name="fontSize" scope="instance" type="Object"/>
      <property name="fontFamily" scope="instance" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx.silverlight.Container">
    <properties>
      <property name="_moveChildToFront" scope="normal" type=""/>
      <property name="_moveChildToBack" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="_init" scope="normal"/>
      <method name="add" scope="normal">
        <summary>adds a shape to a group/surface</summary>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>a Silverlight shape object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="normal">
        <summary>remove a shape from a group/surface</summary>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>a Silverlight shape object</summary>
          </parameter>
          <parameter name="silently" type="Boolean:" usage="optional">
            <summary>if true, regenerate a picture</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="clear" scope="normal">
        <summary>removes all shapes from a group/surface</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.Shape._setFillObject" type="Function" classlike="true" private="true">
    <properties>
      <property name="fillStyle" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="f" type="" usage="required"/>
          <parameter name="nodeType" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.svg" type="">
    <methods>
      <method name="getRef" scope="normal">
        <summary>returns a DOM Node specified by the name argument or null</summary>
        <parameters>
          <parameter name="name" type="String:" usage="required">
            <summary>an SVG external reference</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.svg.xmlns">
    <properties>
      <property name="xlink" scope="normal" type="String"/>
      <property name="svg" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.svg.dasharray">
    <properties>
      <property name="solid" scope="normal" type="String"/>
      <property name="shortdash" scope="normal" type="Array"/>
      <property name="shortdot" scope="normal" type="Array"/>
      <property name="shortdashdot" scope="normal" type="Array"/>
      <property name="shortdashdotdot" scope="normal" type="Array"/>
      <property name="dot" scope="normal" type="Array"/>
      <property name="dash" scope="normal" type="Array"/>
      <property name="longdash" scope="normal" type="Array"/>
      <property name="dashdot" scope="normal" type="Array"/>
      <property name="longdashdot" scope="normal" type="Array"/>
      <property name="longdashdotdot" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx.svg.Font"/>
  <object location="dojox.gfx.svg.Font._setFont" type="Function" classlike="true" private="true">
    <summary>sets a font object (SVG)</summary>
    <properties>
      <property name="fontStyle" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.gfx.svg.Container">
    <properties>
      <property name="_moveChildToFront" scope="normal" type=""/>
      <property name="_moveChildToBack" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="_init" scope="normal"/>
      <method name="add" scope="normal">
        <summary>adds a shape to a group/surface</summary>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>an VML shape object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="normal">
        <summary>remove a shape from a group/surface</summary>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>an VML shape object</summary>
          </parameter>
          <parameter name="silently" type="Boolean:" usage="optional">
            <summary>if true, regenerate a picture</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.svg.Container.clear" type="Function" classlike="true">
    <summary>removes all shapes from a group/surface</summary>
    <properties>
      <property name="rawNode" scope="instance" type=""/>
      <property name="defNode" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.gfx.utils" type="">
    <properties>
      <property name="_gfxSvgProxy" scope="normal" type="Object"/>
      <property name="_initSvgSerializerDeferred" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="forEach" scope="normal">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface" usage="required">
            <summary>|| dojox.gfx.Shape</summary>
          </parameter>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="serialize" scope="normal">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface" usage="required">
            <summary>|| dojox.gfx.Shape</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="toJson" scope="normal">
        <parameters>
          <parameter name="object" type="dojox.gfx.Surface" usage="required">
            <summary>|| dojox.gfx.Shape</summary>
          </parameter>
          <parameter name="prettyPrint" type="Boolean" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="deserialize" scope="normal">
        <parameters>
          <parameter name="parent" type="dojox.gfx.Surface" usage="required">
            <summary>|| dojox.gfx.Shape</summary>
          </parameter>
          <parameter name="object" type="dojox.gfx.Shape" usage="required">
            <summary>|| Array</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="fromJson" scope="normal">
        <parameters>
          <parameter name="parent" type="dojox.gfx.Surface" usage="required">
            <summary>|| dojox.gfx.Shape</summary>
          </parameter>
          <parameter name="json" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type=""/>
          <return-type type="dojox.gfx.Shape"/>
        </return-types>
      </method>
      <method name="toSvg" scope="normal">
        <summary>Function to serialize a GFX surface to SVG text.</summary>
        <description>Function to serialize a GFX surface to SVG text.  The value of this output
	is that there are numerous serverside parser libraries that can render
	SVG into images in various formats.  This provides a way that GFX objects
	can be captured in a known format and sent serverside for serialization
	into an image.</description>
        <return-description>Deferred object that will be called when SVG serialization is complete.</return-description>
        <parameters>
          <parameter name="surface" type="GFX" usage="required">
            <summary>The GFX surface to serialize.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred that will be called when serialization finishes."/>
        </return-types>
      </method>
      <method name="_svgSerializerInitialized" scope="normal">
        <summary>Internal function to call when the serializer init completed.</summary>
      </method>
      <method name="_initSvgSerializer" scope="normal">
        <summary>Internal function to initialize the hidden iframe where SVG rendering
	will occur.</summary>
      </method>
      <method name="_innerXML" scope="normal">
        <summary>Implementation of MS's innerXML function, borrowed from dojox.xml.parser.</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>The node from which to generate the XML text representation.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_cleanSvg" scope="normal">
        <summary>Internal function that cleans up artifacts in extracted SVG content.</summary>
        <parameters>
          <parameter name="svg" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Cleaned SVG text."/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Creator.createImage.rawNode" type="">
    <properties>
      <property name="ownerDocument" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.shape.Creator._overrideSize" type="Function" classlike="true" private="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.shape.Creator._overrideSize.rawNode" type=""/>
  <object location="dojox.gfx.shape.Creator._overrideSize.rawNode.style" type="">
    <properties>
      <property name="width" scope="instance" type=""/>
      <property name="height" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape.setFill.rawNode" type="">
    <properties>
      <property name="filled" scope="instance" type="Object"/>
      <property name="fillcolor" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape.setFill.rawNode.fill" type="">
    <properties>
      <property name="opacity" scope="instance" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape.setStroke.rawNode.stroke">
    <properties>
      <property name="opacity" scope="instance" type=""/>
      <property name="endcap" scope="instance" type="Object"/>
      <property name="joinstyle" scope="instance" type="String"/>
      <property name="miterlimit" scope="instance" type=""/>
      <property name="dashstyle" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape._capMap" private="true">
    <properties>
      <property name="butt" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape._capMapReversed" private="true">
    <properties>
      <property name="flat" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Shape._moveToBack.rawNode" type=""/>
  <object location="dojox.gfx.Shape._moveToBack.rawNode.parentNode" type="">
    <properties>
      <property name="firstChild" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Group.rawNode" type="">
    <properties>
      <property name="coordsize" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Group.bgNode" type=""/>
  <object location="dojox.gfx.Group.rawNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Group.bgNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Rect.rawNode.style" type="">
    <properties>
      <property name="left" scope="prototype" type="Object"/>
      <property name="top" scope="prototype" type="Object"/>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Ellipse.rawNode.style" type="">
    <properties>
      <property name="left" scope="prototype" type="Object"/>
      <property name="top" scope="prototype" type="Object"/>
      <property name="width" scope="prototype" type="Object"/>
      <property name="height" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx.Circle.rawNode.style" type="">
    <properties>
      <property name="left" scope="prototype" type="Object"/>
      <property name="top" scope="prototype" type="Object"/>
      <property name="width" scope="prototype" type="Object"/>
      <property name="height" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx.Line.rawNode.path" type="">
    <properties>
      <property name="v" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Polyline.rawNode.path" type="">
    <properties>
      <property name="v" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx.Image.rawNode.firstChild" type="">
    <properties>
      <property name="src" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Image.rawNode.style" type="">
    <properties>
      <property name="filter" scope="prototype" type="String"/>
      <property name="width" scope="prototype" type="Object"/>
      <property name="height" scope="prototype" type="Object"/>
      <property name="left" scope="prototype" type="String"/>
      <property name="top" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Image.rawNode.parentNode" type="">
    <properties>
      <property name="style" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Image.rawNode.filters.DXImageTransform.Microsoft" type=""/>
  <object location="dojox.gfx.Image.rawNode.filters.DXImageTransform.Microsoft.Matrix" type="">
    <properties>
      <property name="M11" scope="prototype" type=""/>
      <property name="M12" scope="prototype" type=""/>
      <property name="M21" scope="prototype" type=""/>
      <property name="M22" scope="prototype" type=""/>
      <property name="Dx" scope="prototype" type=""/>
      <property name="Dy" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Text._alignment" private="true">
    <properties>
      <property name="start" scope="normal" type="String"/>
      <property name="middle" scope="normal" type="String"/>
      <property name="end" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Text.rawNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Path.rawNode.path" type="">
    <properties>
      <property name="v" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Path._pathVmlToSvgMap" private="true">
    <properties>
      <property name="m" scope="normal" type="String"/>
      <property name="l" scope="normal" type="String"/>
      <property name="t" scope="normal" type="String"/>
      <property name="r" scope="normal" type="String"/>
      <property name="c" scope="normal" type="String"/>
      <property name="v" scope="normal" type="String"/>
      <property name="qb" scope="normal" type="String"/>
      <property name="x" scope="normal" type="String"/>
      <property name="e" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Path.renderers">
    <properties>
      <property name="M" scope="normal" type="String"/>
      <property name="m" scope="normal" type="String"/>
      <property name="L" scope="normal" type="String"/>
      <property name="l" scope="normal" type="String"/>
      <property name="H" scope="normal" type="String"/>
      <property name="h" scope="normal" type="String"/>
      <property name="V" scope="normal" type="String"/>
      <property name="v" scope="normal" type="String"/>
      <property name="C" scope="normal" type="String"/>
      <property name="c" scope="normal" type="String"/>
      <property name="S" scope="normal" type="String"/>
      <property name="s" scope="normal" type="String"/>
      <property name="Q" scope="normal" type="String"/>
      <property name="q" scope="normal" type="String"/>
      <property name="T" scope="normal" type="String"/>
      <property name="t" scope="normal" type="String"/>
      <property name="A" scope="normal" type="String"/>
      <property name="a" scope="normal" type="String"/>
      <property name="Z" scope="normal" type="String"/>
      <property name="z" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.TextPath.rawNode" type="">
    <properties>
      <property name="childNodes" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Surface.clipNode" type=""/>
  <object location="dojox.gfx.Surface.bgNode" type=""/>
  <object location="dojox.gfx.Surface._parent" type=""/>
  <object location="dojox.gfx.Surface._parent.style" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Surface.clipNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
      <property name="clip" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.Surface.rawNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.Surface.bgNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx.vml" type="">
    <properties>
      <property name="xmlns" scope="normal" type="String"/>
    </properties>
    <methods>
      <method name="_parseFloat" scope="normal">
        <summary>a helper function to parse VML-specific floating-point values</summary>
        <parameters>
          <parameter name="str" type="String:" usage="required">
            <summary>a representation of a floating-point number</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.vml.text_alignment">
    <properties>
      <property name="start" scope="normal" type="String"/>
      <property name="middle" scope="normal" type="String"/>
      <property name="end" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx.vml._bool" private="true">
    <properties>
      <property name="t" scope="normal" type="Number"/>
      <property name="true" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx.vml.Container">
    <properties>
      <property name="_moveChildToFront" scope="normal" type=""/>
      <property name="_moveChildToBack" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="_init" scope="normal"/>
      <method name="add" scope="normal">
        <summary>adds a shape to a group/surface</summary>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>an VML shape object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="remove" scope="normal">
        <summary>remove a shape from a group/surface</summary>
        <parameters>
          <parameter name="shape" type="dojox.gfx.Shape:" usage="required">
            <summary>an VML shape object</summary>
          </parameter>
          <parameter name="silently" type="Boolean:" usage="optional">
            <summary>if true, regenerate a picture</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx.vml.Container.clear" type="Function" classlike="true">
    <summary>removes all shapes from a group/surface</summary>
    <properties>
      <property name="rawNode" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.defaultEdges">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="style" scope="normal" type="Object"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultTriangles">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="style" scope="normal" type="Object"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultQuads">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="style" scope="normal" type="Object"/>
      <property name="points" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultOrbit">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="radius" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultOrbit.center">
    <properties>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="z" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultPath3d">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="path" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultPolygon">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="path" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultCube">
    <properties>
      <property name="type" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultCube.bottom">
    <properties>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="z" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultCube.top">
    <properties>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="z" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultCylinder">
    <properties>
      <property name="type" scope="normal" type="String"/>
      <property name="height" scope="normal" type="Number"/>
      <property name="radius" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.defaultCylinder.center">
    <properties>
      <property name="x" scope="normal" type="Number"/>
      <property name="y" scope="normal" type="Number"/>
      <property name="z" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting" type="">
    <methods>
      <method name="black" scope="normal"/>
      <method name="white" scope="normal"/>
      <method name="toStdColor" scope="normal">
        <parameters>
          <parameter name="c" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fromStdColor" scope="normal">
        <parameters>
          <parameter name="c" type="" usage="required"/>
        </parameters>
      </method>
      <method name="scaleColor" scope="normal">
        <parameters>
          <parameter name="s" type="" usage="required"/>
          <parameter name="c" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addColor" scope="normal">
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="multiplyColor" scope="normal">
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="saturateColor" scope="normal">
        <parameters>
          <parameter name="c" type="" usage="required"/>
        </parameters>
      </method>
      <method name="mixColor" scope="normal">
        <parameters>
          <parameter name="c1" type="" usage="required"/>
          <parameter name="c2" type="" usage="required"/>
          <parameter name="s" type="" usage="required"/>
        </parameters>
      </method>
      <method name="diff2Color" scope="normal">
        <parameters>
          <parameter name="c1" type="" usage="required"/>
          <parameter name="c2" type="" usage="required"/>
        </parameters>
      </method>
      <method name="length2Color" scope="normal">
        <parameters>
          <parameter name="c" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dot" scope="normal">
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="scale" scope="normal">
        <parameters>
          <parameter name="s" type="" usage="required"/>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="normal">
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="saturate" scope="normal">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="length" scope="normal">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="normalize" scope="normal">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="faceforward" scope="normal">
        <parameters>
          <parameter name="n" type="" usage="required"/>
          <parameter name="i" type="" usage="required"/>
        </parameters>
      </method>
      <method name="reflect" scope="normal">
        <parameters>
          <parameter name="i" type="" usage="required"/>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
      <method name="diffuse" scope="normal">
        <parameters>
          <parameter name="normal" type="" usage="required"/>
          <parameter name="lights" type="" usage="required"/>
        </parameters>
      </method>
      <method name="specular" scope="normal">
        <parameters>
          <parameter name="normal" type="" usage="required"/>
          <parameter name="v" type="" usage="required"/>
          <parameter name="roughness" type="" usage="required"/>
          <parameter name="lights" type="" usage="required"/>
        </parameters>
      </method>
      <method name="phong" scope="normal">
        <parameters>
          <parameter name="normal" type="" usage="required"/>
          <parameter name="v" type="" usage="required"/>
          <parameter name="size" type="" usage="required"/>
          <parameter name="lights" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.lighting.Model" type="Function" classlike="true">
    <properties>
      <property name="incident" scope="instance" type="Object"/>
      <property name="lights" scope="instance" type="Array"/>
      <property name="npr_cool" scope="instance" type="Object"/>
      <property name="npr_warm" scope="instance" type="Object"/>
      <property name="npr_alpha" scope="instance" type="Number"/>
      <property name="npr_beta" scope="instance" type="Number"/>
      <property name="npr_scale" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="incident" type="" usage="required"/>
          <parameter name="lights" type="" usage="required"/>
          <parameter name="ambient" type="" usage="required"/>
          <parameter name="specular" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="incident" type="" usage="required"/>
          <parameter name="lights" type="" usage="required"/>
          <parameter name="ambient" type="" usage="required"/>
          <parameter name="specular" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constant" scope="prototype">
        <parameters>
          <parameter name="normal" type="" usage="required"/>
          <parameter name="finish" type="" usage="required"/>
          <parameter name="pigment" type="" usage="required"/>
        </parameters>
      </method>
      <method name="matte" scope="prototype">
        <parameters>
          <parameter name="normal" type="" usage="required"/>
          <parameter name="finish" type="" usage="required"/>
          <parameter name="pigment" type="" usage="required"/>
        </parameters>
      </method>
      <method name="metal" scope="prototype">
        <parameters>
          <parameter name="normal" type="" usage="required"/>
          <parameter name="finish" type="" usage="required"/>
          <parameter name="pigment" type="" usage="required"/>
        </parameters>
      </method>
      <method name="plastic" scope="prototype">
        <parameters>
          <parameter name="normal" type="" usage="required"/>
          <parameter name="finish" type="" usage="required"/>
          <parameter name="pigment" type="" usage="required"/>
        </parameters>
      </method>
      <method name="npr" scope="prototype">
        <parameters>
          <parameter name="normal" type="" usage="required"/>
          <parameter name="finish" type="" usage="required"/>
          <parameter name="pigment" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.lighting.Model.ambient">
    <properties>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.Model.specular">
    <properties>
      <property name="a" scope="instance" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish"/>
  <object location="dojox.gfx3d.lighting.finish.defaults">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.dull">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.shiny">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.glossy">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.phong_dull">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="phong" scope="normal" type="Number"/>
      <property name="phong_size" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.phong_shiny">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="phong" scope="normal" type="Number"/>
      <property name="phong_size" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.phong_glossy">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="phong" scope="normal" type="Number"/>
      <property name="phong_size" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.luminous">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.metalA">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.metalB">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.metalC">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.metalD">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.lighting.finish.metalE">
    <properties>
      <property name="Ka" scope="normal" type="Number"/>
      <property name="Kd" scope="normal" type="Number"/>
      <property name="Ks" scope="normal" type="Number"/>
      <property name="roughness" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.matrix" type="">
    <summary>class constants, and methods of dojox.gfx3d.matrix</summary>
    <properties>
      <property name="identity" scope="normal" type="dojox.gfx3d.matrix.Matrix3D">
        <summary>an identity matrix constant: identity * (x, y, z) == (x, y, z)</summary>
      </property>
    </properties>
    <methods>
      <method name="translate" scope="normal">
        <summary>forms a translation matrix</summary>
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required">
            <summary>an x coordinate value</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a y coordinate value</summary>
          </parameter>
          <parameter name="c" type="Number:" usage="required">
            <summary>a z coordinate value</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="scale" scope="normal">
        <summary>forms a scaling matrix</summary>
        <description>The resulting matrix is used to scale (magnify) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required">
            <summary>a scaling factor used for the x coordinate</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a scaling factor used for the y coordinate</summary>
          </parameter>
          <parameter name="c" type="Number:" usage="required">
            <summary>a scaling factor used for the z coordinate</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateX" scope="normal">
        <summary>forms a rotating matrix (about the x axis)</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an angle of rotation in radians (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateXg" scope="normal">
        <summary>forms a rotating matrix (about the x axis)</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an angle of rotation in degrees (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateY" scope="normal">
        <summary>forms a rotating matrix (about the y axis)</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an angle of rotation in radians (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateYg" scope="normal">
        <summary>forms a rotating matrix (about the y axis)</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an angle of rotation in degrees (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZ" scope="normal">
        <summary>forms a rotating matrix (about the z axis)</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an angle of rotation in radians (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="rotateZg" scope="normal">
        <summary>forms a rotating matrix (about the z axis)</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateZ() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an angle of rotation in degrees (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraTranslate" scope="normal">
        <summary>forms a translation matrix</summary>
        <description>The resulting matrix is used to translate (move) points by specified offsets.</description>
        <parameters>
          <parameter name="a" type="Number:" usage="required">
            <summary>an x coordinate value</summary>
          </parameter>
          <parameter name="b" type="Number:" usage="required">
            <summary>a y coordinate value</summary>
          </parameter>
          <parameter name="c" type="Number:" usage="required">
            <summary>a z coordinate value</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateX" scope="normal">
        <summary>forms a rotating matrix (about the x axis) in cameraTransform manner</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an angle of rotation in radians (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateXg" scope="normal">
        <summary>forms a rotating matrix (about the x axis)in cameraTransform manner</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateX() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an angle of rotation in degrees (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateY" scope="normal">
        <summary>forms a rotating matrix (about the y axis) in cameraTransform manner</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an angle of rotation in radians (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateYg" scope="normal">
        <summary>forms a rotating matrix (about the y axis) in cameraTransform manner</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateY() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an angle of rotation in degrees (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZ" scope="normal">
        <summary>forms a rotating matrix (about the z axis) in cameraTransform manner</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified angle.</description>
        <parameters>
          <parameter name="angle" type="Number:" usage="required">
            <summary>an angle of rotation in radians (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="cameraRotateZg" scope="normal">
        <summary>forms a rotating matrix (about the z axis) in cameraTransform manner</summary>
        <description>The resulting matrix is used to rotate points
	around the origin of coordinates (0, 0) by specified degree.
	See dojox.gfx3d.matrix.rotateZ() for comparison.</description>
        <parameters>
          <parameter name="degree" type="Number:" usage="required">
            <summary>an angle of rotation in degrees (&amp;gt;0 for CW)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="normalize" scope="normal">
        <summary>converts an object to a matrix, if necessary</summary>
        <description>Converts any 3D matrix-like object or an array of
	such objects to a valid dojox.gfx3d.matrix.Matrix3D object.</description>
        <parameters>
          <parameter name="matrix" type="Object:" usage="required">
            <summary>an object, which is converted to a matrix, if necessary</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="clone" scope="normal">
        <summary>creates a copy of a 3D matrix</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D:" usage="required">
            <summary>a 3D matrix-like object to be cloned</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="invert" scope="normal">
        <summary>inverts a 2D matrix</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx.matrix.Matrix3D:" usage="required">
            <summary>a 2D matrix-like object to be inverted</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="_multiplyPoint" scope="normal">
        <summary>applies a matrix to a point
	matrix: dojox.gfx3d.matrix.Matrix3D: a 3D matrix object to be applied</summary>
        <parameters>
          <parameter name="m" type="" usage="required"/>
          <parameter name="x" type="Number:" usage="required">
            <summary>an x coordinate of a point</summary>
          </parameter>
          <parameter name="y" type="Number:" usage="required">
            <summary>a y coordinate of a point</summary>
          </parameter>
          <parameter name="z" type="Number:" usage="required">
            <summary>a z coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="multiplyPoint" scope="normal">
        <summary>applies a matrix to a point</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D:" usage="required">
            <summary>a 3D matrix object to be applied</summary>
          </parameter>
          <parameter name="a" type="Number||Point" usage="required">
            <summary>Number: an x coordinate of a point</summary>
          </parameter>
          <parameter name="b" type="Number," usage="required">
            <summary>Number: a y coordinate of a point</summary>
          </parameter>
          <parameter name="c" type="Number," usage="required">
            <summary>Number: a z coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="multiply" scope="normal">
        <summary>combines matrices by multiplying them sequentially in the given order</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D:" usage="one-or-more">
            <summary>a 3D matrix-like object,
	all subsequent arguments are matrix-like objects too</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.matrix.Matrix3D"/>
        </return-types>
      </method>
      <method name="_project" scope="normal">
        <summary>applies a matrix to a point
	matrix: dojox.gfx3d.matrix.Matrix3D: a 3D matrix object to be applied</summary>
        <parameters>
          <parameter name="m" type="" usage="required"/>
          <parameter name="x" type="Number:" usage="required">
            <summary>an x coordinate of a point</summary>
          </parameter>
          <parameter name="y" type="Number:" usage="required">
            <summary>a y coordinate of a point</summary>
          </parameter>
          <parameter name="z" type="Number:" usage="required">
            <summary>a z coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="project" scope="normal">
        <summary>applies a matrix to a point</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix3D:" usage="required">
            <summary>a 3D matrix object to be applied</summary>
          </parameter>
          <parameter name="a" type="Number||Point" usage="required">
            <summary>Number: an x coordinate of a point</summary>
          </parameter>
          <parameter name="b" type="Number," usage="required">
            <summary>Number: a y coordinate of a point</summary>
          </parameter>
          <parameter name="c" type="Number," usage="required">
            <summary>Number: a z coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_degToRad" scope="normal">
        <parameters>
          <parameter name="degree" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_radToDeg" scope="normal">
        <parameters>
          <parameter name="radian" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.matrix.Matrix3D" type="Function" classlike="true">
    <summary>a 3D matrix object</summary>
    <description>Normalizes a 3D matrix-like object. If arrays is passed,
	all objects of the array are normalized and multiplied sequentially.</description>
    <properties>
      <property name="xx" scope="instance-prototype" type="Number"/>
      <property name="xy" scope="prototype" type="Number"/>
      <property name="xz" scope="prototype" type="Number"/>
      <property name="yx" scope="prototype" type="Number"/>
      <property name="yy" scope="instance-prototype" type="Number"/>
      <property name="yz" scope="prototype" type="Number"/>
      <property name="zx" scope="prototype" type="Number"/>
      <property name="zy" scope="prototype" type="Number"/>
      <property name="zz" scope="instance-prototype" type="Number"/>
      <property name="dx" scope="prototype" type="Number"/>
      <property name="dy" scope="prototype" type="Number"/>
      <property name="dz" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="arg" type="Object" usage="required">
            <summary>a 3D matrix-like object, a number, or an array of such objects</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.Viewport" type="Function" classlike="true" superclass="dojox.gfx3d._creators">
    <summary>a viewport/container for 3D objects, which knows
	the camera and lightings</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.gfx.Group"/>
      <mixin scope="instance" location="dojox.gfx.Group"/>
    </mixins>
    <properties>
      <property name="camera" scope="prototype" type="Object"/>
      <property name="lights" scope="instance-prototype" type="Array"/>
      <property name="lighting" scope="instance-prototype" type="Object"/>
      <property name="deep" scope="instance-prototype" type="bool"/>
      <property name="todos" scope="instance-prototype" type="Array"/>
      <property name="dimension" scope="instance-prototype" type="Object:">
        <summary>the dimension of the canvas</summary>
      </property>
      <property name="objects" scope="instance-prototype" type="Array"/>
      <property name="renderer" scope="instance" type="Object"/>
      <property name="schedule" scope="instance" type=""/>
      <property name="draw" scope="instance" type=""/>
      <property name="nodeType" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a viewport/container for 3D objects, which knows
	the camera and lightings</summary>
      </method>
      <method name="setCameraTransform" scope="prototype">
        <summary>sets a transformation matrix</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraRightTransform" scope="prototype">
        <summary>multiplies the existing matrix with an argument on right side
	(this.matrix * matrix)</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraLeftTransform" scope="prototype">
        <summary>multiplies the existing matrix with an argument on left side
	(matrix * this.matrix)</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyCameraTransform" scope="prototype">
        <summary>a shortcut for dojox.gfx3d.Object.applyRightTransform</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setLights" scope="prototype">
        <summary>set the lights</summary>
        <parameters>
          <parameter name="lights" type="Array" usage="required">
            <summary>Array: an array of light object
	or lights object</summary>
          </parameter>
          <parameter name="ambient" type="Color," usage="required">
            <summary>Color: an ambient object</summary>
          </parameter>
          <parameter name="specular" type="Color," usage="required">
            <summary>Color: an specular object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addLights" scope="prototype">
        <summary>add new light/lights to the viewport.</summary>
        <parameters>
          <parameter name="lights" type="Array" usage="required">
            <summary>|| light object: light object(s)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addTodo" scope="prototype">
        <parameters>
          <parameter name="newObject" type="" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="prototype"/>
      <method name="setDimensions" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <summary>iterate all children and call their render callback function.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.Scene" type="Function" classlike="true" superclass="dojox.gfx3d._creators">
    <summary>the Scene is just a containter.
	note: we have the following assumption:
	all objects in the Scene are not overlapped with other objects
	outside of the scene.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.gfx3d.Object"/>
      <mixin scope="instance" location="dojox.gfx3d.Object"/>
    </mixins>
    <properties>
      <property name="fillStyle" scope="prototype" type=""/>
      <property name="strokeStyle" scope="prototype" type=""/>
      <property name="todos" scope="instance-prototype" type="Array"/>
      <property name="objects" scope="instance-prototype" type="Array"/>
      <property name="schedule" scope="instance" type=""/>
      <property name="_draw" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a containter of other 3D objects</summary>
      </method>
      <method name="setFill" scope="prototype">
        <parameters>
          <parameter name="fill" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setStroke" scope="prototype">
        <parameters>
          <parameter name="stroke" type="" usage="required"/>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
          <parameter name="deep" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addTodo" scope="prototype">
        <parameters>
          <parameter name="newObject" type="" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="prototype"/>
      <method name="getZOrder" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.Object" type="Function" classlike="true">
    <summary>a Object object, which knows how to map
	3D objects to 2D shapes.</summary>
    <properties>
      <property name="object" scope="instance-prototype" type="Object:">
        <summary>an abstract Object object
	(see dojox.gfx3d.defaultEdges,
	dojox.gfx3d.defaultTriangles,
	dojox.gfx3d.defaultQuads
	dojox.gfx3d.defaultOrbit
	dojox.gfx3d.defaultCube
	or dojox.gfx3d.defaultCylinder)</summary>
      </property>
      <property name="matrix" scope="instance-prototype" type="Object"/>
      <property name="fillStyle" scope="instance-prototype" type="Object"/>
      <property name="strokeStyle" scope="instance-prototype" type="Object"/>
      <property name="shape" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="instance" type="Object"/>
      <property name="renderer" scope="instance" type="Object"/>
      <property name="parent" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a Object object, which knows how to map
	3D objects to 2D shapes.</summary>
      </method>
      <method name="setObject" scope="prototype">
        <summary>sets a Object object</summary>
        <parameters>
          <parameter name="newObject" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setTransform" scope="prototype">
        <summary>sets a transformation matrix</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx3d.matrix.Matrix
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyRightTransform" scope="prototype">
        <summary>multiplies the existing matrix with an argument on right side
	(this.matrix * matrix)</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyLeftTransform" scope="prototype">
        <summary>multiplies the existing matrix with an argument on left side
	(matrix * this.matrix)</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="applyTransform" scope="prototype">
        <summary>a shortcut for dojox.gfx.Shape.applyRightTransform</summary>
        <parameters>
          <parameter name="matrix" type="dojox.gfx3d.matrix.Matrix:" usage="required">
            <summary>a matrix or a matrix-like object
	(see an argument of dojox.gfx.matrix.Matrix
	constructor for a list of acceptable arguments)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="setFill" scope="prototype">
        <summary>sets a fill object
	(the default implementation is to delegate to
	the underlying 2D shape).</summary>
        <parameters>
          <parameter name="fill" type="Object:" usage="required">
            <summary>a fill object
	(see dojox.gfx.defaultLinearGradient,
	dojox.gfx.defaultRadialGradient,
	dojox.gfx.defaultPattern,
	dojo.Color
	or dojox.gfx.MODEL)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setStroke" scope="prototype">
        <summary>sets a stroke object
	(the default implementation simply ignores it)</summary>
        <parameters>
          <parameter name="stroke" type="Object:" usage="required">
            <summary>a stroke object
	(see dojox.gfx.defaultStroke)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toStdFill" scope="prototype">
        <parameters>
          <parameter name="lighting" type="" usage="required"/>
          <parameter name="normal" type="" usage="required"/>
        </parameters>
      </method>
      <method name="invalidate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
      <method name="getOutline" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.Edges" type="Function" classlike="true" superclass="dojox.gfx3d.Object">
    <summary>a generic edge in 3D viewport</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx3d.Object"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="prototype" type="Object"/>
      <property name="shape" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a generic edge in 3D viewport</summary>
      </method>
      <method name="setObject" scope="prototype">
        <summary>setup the object</summary>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <summary>of points || Object</summary>
          </parameter>
          <parameter name="style" type="String," usage="required">
            <summary>optional</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.Orbit" type="Function" classlike="true" superclass="dojox.gfx3d.Object">
    <summary>a generic edge in 3D viewport</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx3d.Object"/>
    </mixins>
    <properties>
      <property name="cache" scope="prototype" type="Object"/>
      <property name="shape" scope="prototype" type="Object"/>
      <property name="object" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a generic edge in 3D viewport</summary>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.Path3d" type="Function" classlike="true" superclass="dojox.gfx3d.Object">
    <summary>a generic line
	(this is a helper object, which is defined for convenience)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx3d.Object"/>
    </mixins>
    <properties>
      <property name="cache" scope="prototype" type=""/>
      <property name="object" scope="instance" type="Object"/>
      <property name="segments" scope="instance" type="Array"/>
      <property name="absolute" scope="instance" type="Object"/>
      <property name="last" scope="instance" type="Object"/>
      <property name="path" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a generic line
	(this is a helper object, which is defined for convenience)</summary>
      </method>
      <method name="_collectArgs" scope="prototype">
        <summary>converts an array of arguments to plain numeric values</summary>
        <parameters>
          <parameter name="array" type="Array:" usage="required">
            <summary>an output argument (array of numbers)</summary>
          </parameter>
          <parameter name="args" type="Array:" usage="required">
            <summary>an input argument (can be values of Boolean, Number, dojox.gfx.Point, or an embedded array of them)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_pushSegment" scope="prototype">
        <summary>adds a segment</summary>
        <parameters>
          <parameter name="action" type="String:" usage="required">
            <summary>valid SVG code for a segment's type</summary>
          </parameter>
          <parameter name="args" type="Array:" usage="required">
            <summary>a list of parameters for this segment</summary>
          </parameter>
        </parameters>
      </method>
      <method name="moveTo" scope="prototype">
        <summary>formes a move segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="lineTo" scope="prototype">
        <summary>formes a line segment</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="closePath" scope="prototype">
        <summary>closes a path</summary>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_draw" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.Path3d._validSegments" private="true">
    <properties>
      <property name="m" scope="normal" type="Number"/>
      <property name="l" scope="normal" type="Number"/>
      <property name="z" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.Triangles" type="Function" classlike="true" superclass="dojox.gfx3d.Object">
    <summary>a generic triangle
	(this is a helper object, which is defined for convenience)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx3d.Object"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="prototype" type="Object"/>
      <property name="shape" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a generic triangle
	(this is a helper object, which is defined for convenience)</summary>
      </method>
      <method name="setObject" scope="prototype">
        <summary>setup the object</summary>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <summary>of points || Object</summary>
          </parameter>
          <parameter name="style" type="String," usage="required">
            <summary>optional</summary>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.Quads" type="Function" classlike="true" superclass="dojox.gfx3d.Object">
    <summary>a generic triangle
	(this is a helper object, which is defined for convenience)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx3d.Object"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="prototype" type="Object"/>
      <property name="shape" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a generic triangle
	(this is a helper object, which is defined for convenience)</summary>
      </method>
      <method name="setObject" scope="prototype">
        <summary>setup the object</summary>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <summary>of points || Object</summary>
          </parameter>
          <parameter name="style" type="String," usage="required">
            <summary>optional</summary>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.Polygon" type="Function" classlike="true" superclass="dojox.gfx3d.Object">
    <summary>a generic triangle
	(this is a helper object, which is defined for convenience)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx3d.Object"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="prototype" type="Object"/>
      <property name="shape" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a generic triangle
	(this is a helper object, which is defined for convenience)</summary>
      </method>
      <method name="setObject" scope="prototype">
        <summary>setup the object</summary>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <summary>of points || Object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
      <method name="getOutline" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.Cube" type="Function" classlike="true" superclass="dojox.gfx3d.Object">
    <summary>a generic triangle
	(this is a helper object, which is defined for convenience)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.gfx3d.Object"/>
    </mixins>
    <properties>
      <property name="object" scope="instance-prototype" type="Object"/>
      <property name="cache" scope="prototype" type="Object"/>
      <property name="shape" scope="prototype" type="Object"/>
      <property name="polygons" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>a generic triangle
	(this is a helper object, which is defined for convenience)</summary>
      </method>
      <method name="setObject" scope="prototype">
        <summary>setup the object</summary>
        <parameters>
          <parameter name="newObject" type="Array" usage="required">
            <summary>of points || Object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <parameters>
          <parameter name="lighting" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getZOrder" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.Cube.cache.0" type="">
    <properties>
      <property name="0" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx3d.Cube.cache.1" type="">
    <properties>
      <property name="2" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx3d.Cylinder" type="Function" classlike="true" superclass="dojox.gfx3d.Object">
    <mixins>
      <mixin scope="instance" location="dojox.gfx3d.Object"/>
    </mixins>
    <properties>
      <property name="cache" scope="prototype" type="Object"/>
      <property name="shape" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="render" scope="prototype">
        <parameters>
          <parameter name="camera" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.gfx3d.Cylinder.object">
    <properties>
      <property name="radius" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.gfx3d.Viewport.rawNode" type=""/>
  <object location="dojox.gfx3d.Viewport.rawNode.style" type="">
    <properties>
      <property name="height" scope="prototype" type=""/>
      <property name="width" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.gfx3d._creators" private="true">
    <summary>object creators
	todo : override the add/remove if necessary</summary>
    <methods>
      <method name="createEdges" scope="normal">
        <summary>creates an edge object
	line: Object: a edge object (see dojox.gfx3d.defaultPath)</summary>
        <parameters>
          <parameter name="edges" type="" usage="required"/>
          <parameter name="style" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createTriangles" scope="normal">
        <summary>creates an edge object
	line: Object: a edge object (see dojox.gfx3d.defaultPath)</summary>
        <parameters>
          <parameter name="tris" type="" usage="required"/>
          <parameter name="style" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createQuads" scope="normal">
        <summary>creates an edge object
	line: Object: a edge object (see dojox.gfx3d.defaultPath)</summary>
        <parameters>
          <parameter name="quads" type="" usage="required"/>
          <parameter name="style" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createPolygon" scope="normal">
        <summary>creates an triangle object</summary>
        <parameters>
          <parameter name="points" type="Array" usage="required">
            <summary>of points || Object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Polygon"/>
        </return-types>
      </method>
      <method name="createOrbit" scope="normal">
        <summary>creates an triangle object
	points: Array of points || Object</summary>
        <parameters>
          <parameter name="orbit" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createCube" scope="normal">
        <summary>creates an triangle object
	points: Array of points || Object</summary>
        <parameters>
          <parameter name="cube" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createCylinder" scope="normal">
        <summary>creates an triangle object
	points: Array of points || Object</summary>
        <parameters>
          <parameter name="cylinder" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Cube"/>
        </return-types>
      </method>
      <method name="createPath3d" scope="normal">
        <summary>creates an edge object
	line: Object: a edge object (see dojox.gfx3d.defaultPath)</summary>
        <parameters>
          <parameter name="path" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Edge"/>
        </return-types>
      </method>
      <method name="createScene" scope="normal">
        <summary>creates an triangle object
	line: Object: a triangle object (see dojox.gfx3d.defaultPath)</summary>
        <return-types>
          <return-type type="dojox.gfx3d.Scene"/>
        </return-types>
      </method>
      <method name="create3DObject" scope="normal">
        <summary>creates an instance of the passed shapeType class
	shapeType: Function: a class constructor to create an instance of
	rawShape: Object: properties to be passed in to the classes &amp;quot;setShape&amp;quot; method</summary>
        <parameters>
          <parameter name="objectType" type="" usage="required"/>
          <parameter name="rawObject" type="" usage="required"/>
          <parameter name="style" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.gfx3d.Object"/>
        </return-types>
      </method>
      <method name="adopt" scope="normal">
        <summary>adds a shape to the list
	shape: dojox.gfx.Shape: a shape</summary>
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="abandon" scope="normal">
        <summary>removes a shape from the list</summary>
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="silently" type="Boolean:" usage="optional">
            <summary>if true, do not redraw a picture yet</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="self"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d._creators.setScheduler" type="Function" classlike="true">
    <properties>
      <property name="schedule" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="scheduler" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d._creators.setDrawer" type="Function" classlike="true">
    <properties>
      <property name="draw" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="drawer" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.scheduler" type="">
    <methods>
      <method name="zOrder" scope="normal">
        <parameters>
          <parameter name="buffer" type="" usage="required"/>
          <parameter name="order" type="" usage="required"/>
        </parameters>
      </method>
      <method name="bsp" scope="normal">
        <parameters>
          <parameter name="buffer" type="" usage="required"/>
          <parameter name="outline" type="" usage="required"/>
        </parameters>
      </method>
      <method name="order" scope="normal">
        <parameters>
          <parameter name="it" type="" usage="required"/>
        </parameters>
      </method>
      <method name="outline" scope="normal">
        <parameters>
          <parameter name="it" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.drawer">
    <methods>
      <method name="conservative" scope="normal">
        <parameters>
          <parameter name="todos" type="" usage="required"/>
          <parameter name="objects" type="" usage="required"/>
          <parameter name="viewport" type="" usage="required"/>
        </parameters>
      </method>
      <method name="chart" scope="normal">
        <parameters>
          <parameter name="todos" type="" usage="required"/>
          <parameter name="objects" type="" usage="required"/>
          <parameter name="viewport" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.scheduler.BinarySearchTree" type="Function" classlike="true">
    <summary>build the binary search tree, using binary space partition algorithm.
	The idea is for any polygon, for example, (a, b, c), the space is divided by
	the plane into two space: plus and minus.
	for any arbitary vertex p, if(p - a) dotProduct n = 0, p is inside the plane,
	&amp;gt; 0, p is in the plus space, vice versa for minus space.
	n is the normal vector that is perpendicular the plate, defined as:
	n = ( b - a) crossProduct ( c - a )
	in this implementation, n is declared as normal, ,a is declared as orient.</summary>
    <properties>
      <property name="normal" scope="instance-prototype" type="Object"/>
      <property name="orient" scope="instance-prototype" type=""/>
      <property name="minus" scope="instance-prototype" type="Object"/>
      <property name="plus" scope="instance-prototype" type="Object"/>
      <property name="object" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="object:" usage="required">
            <summary>dojox.gfx3d.Object</summary>
          </parameter>
          <parameter name="outline" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>build the binary search tree, using binary space partition algorithm.
	The idea is for any polygon, for example, (a, b, c), the space is divided by
	the plane into two space: plus and minus.
	for any arbitary vertex p, if(p - a) dotProduct n = 0, p is inside the plane,
	&amp;gt; 0, p is in the plus space, vice versa for minus space.
	n is the normal vector that is perpendicular the plate, defined as:
	n = ( b - a) crossProduct ( c - a )
	in this implementation, n is declared as normal, ,a is declared as orient.</summary>
        <parameters>
          <parameter name="obj" type="object:" usage="required">
            <summary>dojox.gfx3d.Object</summary>
          </parameter>
          <parameter name="outline" type="" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="prototype">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="outline" type="" usage="required"/>
        </parameters>
      </method>
      <method name="iterate" scope="prototype">
        <parameters>
          <parameter name="outline" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.gfx3d.vector">
    <methods>
      <method name="sum" scope="normal">
        <summary>sum of the vectors</summary>
      </method>
      <method name="center" scope="normal">
        <summary>center of the vectors</summary>
      </method>
      <method name="substract" scope="normal">
        <parameters>
          <parameter name="a" type="Pointer" usage="required"/>
          <parameter name="b" type="Pointer" usage="required"/>
        </parameters>
      </method>
      <method name="_crossProduct" scope="normal">
        <summary>applies a cross product of two vectorss, (x, y, z) and (u, v, w)</summary>
        <parameters>
          <parameter name="x" type="Number:" usage="required">
            <summary>an x coordinate of a point</summary>
          </parameter>
          <parameter name="y" type="Number:" usage="required">
            <summary>a y coordinate of a point</summary>
          </parameter>
          <parameter name="z" type="Number:" usage="required">
            <summary>a z coordinate of a point</summary>
          </parameter>
          <parameter name="u" type="Number:" usage="required">
            <summary>an x coordinate of a point</summary>
          </parameter>
          <parameter name="v" type="Number:" usage="required">
            <summary>a y coordinate of a point</summary>
          </parameter>
          <parameter name="w" type="Number:" usage="required">
            <summary>a z coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="crossProduct" scope="normal">
        <summary>applies a matrix to a point
	matrix: dojox.gfx3d.matrix.Matrix3D: a 3D matrix object to be applied</summary>
        <parameters>
          <parameter name="a" type="Number||Point" usage="required">
            <summary>Number: an x coordinate of a point</summary>
          </parameter>
          <parameter name="b" type="Number||Point" usage="required">
            <summary>Number: a y coordinate of a point</summary>
          </parameter>
          <parameter name="c" type="Number," usage="required">
            <summary>Number: a z coordinate of a point</summary>
          </parameter>
          <parameter name="d" type="Number," usage="required">
            <summary>Number: an x coordinate of a point</summary>
          </parameter>
          <parameter name="e" type="Number," usage="required">
            <summary>Number: a y coordinate of a point</summary>
          </parameter>
          <parameter name="f" type="Number," usage="required">
            <summary>Number: a z coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_dotProduct" scope="normal">
        <summary>applies a cross product of two vectorss, (x, y, z) and (u, v, w)</summary>
        <parameters>
          <parameter name="x" type="Number:" usage="required">
            <summary>an x coordinate of a point</summary>
          </parameter>
          <parameter name="y" type="Number:" usage="required">
            <summary>a y coordinate of a point</summary>
          </parameter>
          <parameter name="z" type="Number:" usage="required">
            <summary>a z coordinate of a point</summary>
          </parameter>
          <parameter name="u" type="Number:" usage="required">
            <summary>an x coordinate of a point</summary>
          </parameter>
          <parameter name="v" type="Number:" usage="required">
            <summary>a y coordinate of a point</summary>
          </parameter>
          <parameter name="w" type="Number:" usage="required">
            <summary>a z coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="dotProduct" scope="normal">
        <summary>applies a matrix to a point
	matrix: dojox.gfx3d.matrix.Matrix3D: a 3D matrix object to be applied</summary>
        <parameters>
          <parameter name="a" type="Number||Point" usage="required">
            <summary>Number: an x coordinate of a point</summary>
          </parameter>
          <parameter name="b" type="Number||Point" usage="required">
            <summary>Number: a y coordinate of a point</summary>
          </parameter>
          <parameter name="c" type="Number," usage="required">
            <summary>Number: a z coordinate of a point</summary>
          </parameter>
          <parameter name="d" type="Number," usage="required">
            <summary>Number: an x coordinate of a point</summary>
          </parameter>
          <parameter name="e" type="Number," usage="required">
            <summary>Number: a y coordinate of a point</summary>
          </parameter>
          <parameter name="f" type="Number," usage="required">
            <summary>Number: a z coordinate of a point</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="normalize" scope="normal">
        <summary>find the normal of the implicit surface</summary>
        <parameters>
          <parameter name="a" type="Point||Array" usage="required">
            <summary>Object: a point</summary>
          </parameter>
          <parameter name="b" type="Point" usage="required">
            <summary>Object: a point</summary>
          </parameter>
          <parameter name="c" type="Point" usage="required">
            <summary>Object: a point</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid">
    <summary>An advanced Grid widget with virtual scrolling, cell editing, and much more</summary>
    <properties>
      <property name="_Builder" scope="normal" type="Object"/>
      <property name="_ContentBuilder" scope="normal" type="Object"/>
      <property name="_HeaderBuilder" scope="normal" type="Object"/>
      <property name="_TableMap" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.__DataCellDef" type="Function" classlike="true" superclass="dojox.grid.__CellDef" private="true">
    <mixins>
      <mixin scope="instance" location="dojox.grid.__CellDef"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid.__DataViewDef" type="Function" classlike="true" superclass="dojox.grid.__ViewDef" private="true">
    <mixins>
      <mixin scope="instance" location="dojox.grid.__ViewDef"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid.DataGrid" type="Function" classlike="true" superclass="dojox.grid._Grid">
    <mixins>
      <mixin scope="instance" location="dojox.grid._Grid"/>
    </mixins>
    <properties>
      <property name="store" scope="prototype" type="Object"/>
      <property name="query" scope="prototype" type="Object"/>
      <property name="queryOptions" scope="prototype" type="Object"/>
      <property name="fetchText" scope="prototype" type="String"/>
      <property name="sortFields" scope="prototype" type="Object"/>
      <property name="updateDelay" scope="prototype" type="int">
        <summary>Time, in milliseconds, to delay updates automatically so that multiple
	calls to onSet/onNew/onDelete don't keep rerendering the grid.  Set
	to 0 to immediately cause updates.  A higher value will result in
	better performance at the expense of responsiveness of the grid.</summary>
      </property>
      <property name="structure" scope="prototype" type="dojox.grid.__DataViewDef|dojox.grid.__DataViewDef[]|dojox.grid.__DataCellDef[]|Array[dojox.grid.__DataCellDef[]]">
        <summary>View layout defintion.</summary>
      </property>
      <property name="items" scope="prototype" type="Object"/>
      <property name="_store_connects" scope="prototype" type="Array"/>
      <property name="_by_idty" scope="prototype" type="Object"/>
      <property name="_cache" scope="prototype" type="Array"/>
      <property name="_pages" scope="prototype" type="Array"/>
      <property name="_pending_requests" scope="prototype" type="Object"/>
      <property name="_bop" scope="prototype" type="Number"/>
      <property name="_eop" scope="prototype" type="String"/>
      <property name="_requests" scope="prototype" type="Number"/>
      <property name="rowCount" scope="prototype" type="Number"/>
      <property name="_isLoaded" scope="prototype" type="bool"/>
      <property name="_isLoading" scope="prototype" type="bool"/>
      <property name="selection" scope="prototype" type="Object"/>
      <property name="_endUpdateDelay" scope="prototype" type="Object"/>
      <property name="_addingItem" scope="prototype" type="bool"/>
      <property name="_canEdit" scope="prototype" type=""/>
      <property name="_hasIdentity" scope="prototype" type="bool"/>
      <property name="_skipRowRenormalize" scope="prototype" type="bool"/>
      <property name="rowsPerPage" scope="prototype" type=""/>
      <property name="_lastScrollTop" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="createSelection" scope="prototype"/>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inItem" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_checkUpdateStatus" scope="prototype"/>
      <method name="_onSet" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="oldValue" type="" usage="required"/>
          <parameter name="newValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_createItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="index" type="" usage="required"/>
          <parameter name="noUpdate" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="parentInfo" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onRevert" scope="prototype"/>
      <method name="setStore" scope="prototype">
        <parameters>
          <parameter name="store" type="" usage="required"/>
          <parameter name="query" type="" usage="required"/>
          <parameter name="queryOptions" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setQuery" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="queryOptions" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setItems" scope="prototype">
        <parameters>
          <parameter name="items" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setQuery" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="queryOptions" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="prototype">
        <parameters>
          <parameter name="store" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchBegin" scope="prototype">
        <parameters>
          <parameter name="size" type="" usage="required"/>
          <parameter name="req" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchComplete" scope="prototype">
        <parameters>
          <parameter name="items" type="" usage="required"/>
          <parameter name="req" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onFetchError" scope="prototype">
        <parameters>
          <parameter name="err" type="" usage="required"/>
          <parameter name="req" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchError" scope="prototype">
        <parameters>
          <parameter name="err" type="" usage="required"/>
          <parameter name="req" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fetch" scope="prototype">
        <parameters>
          <parameter name="start" type="" usage="required"/>
          <parameter name="isRender" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_clearData" scope="prototype"/>
      <method name="getItem" scope="prototype">
        <parameters>
          <parameter name="idx" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getItemIndex" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemIndex" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="isDeleted" type="" usage="required"/>
        </parameters>
      </method>
      <method name="filter" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="reRender" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemAttr" scope="prototype">
        <parameters>
          <parameter name="idx" type="" usage="required"/>
          <parameter name="attr" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_render" scope="prototype"/>
      <method name="_requestsPending" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_rowToPage" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_pageToRow" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_preparePage" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_needPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_requestPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_refresh" scope="prototype">
        <parameters>
          <parameter name="isRender" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sort" scope="prototype"/>
      <method name="canSort" scope="prototype"/>
      <method name="getSortProps" scope="prototype"/>
      <method name="styleRowState" scope="prototype">
        <summary>Perform row styling</summary>
        <parameters>
          <parameter name="inRow" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="prototype">
        <parameters>
          <parameter name="inRow" type="" usage="required"/>
        </parameters>
      </method>
      <method name="canEdit" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_copyAttr" scope="prototype">
        <parameters>
          <parameter name="idx" type="" usage="required"/>
          <parameter name="attr" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inAttrName" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inDataAttr" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeSelectedRows" scope="prototype">
        <summary>Remove the selected rows from the grid.</summary>
      </method>
      <method name="cell_markupFactory" scope="normal">
        <parameters>
          <parameter name="cellFunc" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cellDef" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
          <parameter name="ctor" type="" usage="required"/>
          <parameter name="cellFunc" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.DataGrid.grid" type="">
    <properties>
      <property name="store" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.DataGrid._by_idx" type="Array" private="true">
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.DataSelection" type="Function" classlike="true" superclass="dojox.grid.Selection">
    <mixins>
      <mixin scope="instance" location="dojox.grid.Selection"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="getFirstSelected" scope="prototype"/>
      <method name="getNextSelected" scope="prototype">
        <parameters>
          <parameter name="inPrev" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="prototype"/>
      <method name="addToSelection" scope="prototype">
        <parameters>
          <parameter name="inItemOrIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="prototype">
        <parameters>
          <parameter name="inItemOrIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="prototype">
        <parameters>
          <parameter name="inItemOrIndex" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.DataSelection.selected" type="">
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.EnhancedGrid" type="Function" classlike="true" superclass="dojox.grid.DataGrid">
    <summary>Provides enhanced features for DataGrid, including:
	1. Nested Sorting
	2. Built-in support for Indirect Selection (radio buttons and check boxes)
	3. Declarative context menu
	4. Selecting rows/columns via swipe
	5. Drag-n-drop: columns,rows - MOVE</summary>
    <description>EnhancedGrid features are implemented as plugins that could be loaded on demand.
	Explicit dojo.require() is needed to use these feature plugins.</description>
    <mixins>
      <mixin scope="instance" location="dojox.grid.DataGrid"/>
    </mixins>
    <examples>
      <example>A quick sample to use all EnhancedGrid features:
	Step 1. Load EnhancedGrid and required features
		 &lt;script type="text/javascript"&gt;
			dojo.require("dojox.grid.EnhancedGrid");
			dojo.require("dojox.grid.enhanced.plugins.DnD");
			dojo.require("dojox.grid.enhanced.plugins.Menu");
			dojo.require("dojox.grid.enhanced.plugins.NestedSorting");
			dojo.require("dojox.grid.enhanced.plugins.IndirectSelection");
		&lt;/script&gt;
	Step 2. Use EnhancedGrid
	- Via HTML markup
		&lt;div dojoType="dojox.grid.EnhancedGrid" ...
			 plugins="{nestedSorting: true, dnd: true, indirectSelection: true,
			 menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",
					 selectedRegionMenu:"selectedRegionMenuId"}}"&gt;
				...
		&lt;/div&gt;
	- Or via JavaScript
		&lt;script type="text/javascript"&gt;
			var grid = new dojox.grid.EnhancedGrid({plugins : {nestedSorting: true, dnd: true, indirectSelection: true,
		               menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",selectedRegionMenu:"selectedRegionMenuId"}},
				       ... }, dojo.byId('gridDiv'));
			grid.startup();
		&lt;/script&gt;</example>
    </examples>
    <properties>
      <property name="plugins" scope="prototype" type="Object">
        <summary>Plugin properties, e.g. {nestedSorting: true, dnd: true, ...}</summary>
      </property>
      <property name="pluginMgr" scope="prototype" type="Object">
        <summary>Singleton plugin manager</summary>
      </property>
      <property name="doubleAffordance" scope="prototype" type="Boolean">
        <summary>For special cell hover style</summary>
      </property>
      <property name="_nls" scope="prototype" type="Object"/>
      <property name="menuContainer" scope="prototype" type=""/>
      <property name="textSizeChanging" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_fillContent" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="textSizeChanged" scope="prototype">
        <summary>Overwritten, see _Grid.textSizeChanged()
	fix #10088 - in Webkit, this method is invoked by two parallel threads which caused #10088</summary>
      </method>
      <method name="removeSelectedRows" scope="prototype">
        <summary>Overwritten, see DataGrid.removeSelectedRows()</summary>
      </method>
      <method name="doApplyCellEdit" scope="prototype">
        <summary>Overwritten, see DataGrid.doApplyCellEdit()</summary>
        <parameters>
          <parameter name="inValue" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inAttrName" type="" usage="required"/>
        </parameters>
      </method>
      <method name="mixin" scope="prototype">
        <parameters>
          <parameter name="target" type="" usage="required"/>
          <parameter name="source" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_copyAttr" scope="prototype">
        <summary>Overwritten, see DataGrid._copyAttr()
	Fix cell TAB navigation for single click editting</summary>
        <parameters>
          <parameter name="idx" type="" usage="required"/>
          <parameter name="attr" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
          <parameter name="ctor" type="" usage="required"/>
          <parameter name="cellFunc" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.Selection" type="Function" classlike="true">
    <summary>Manages row selection for grid. Owned by grid and used internally
	for selection. Override to implement custom selection.</summary>
    <properties>
      <property name="mode" scope="prototype" type="String"/>
      <property name="updating" scope="prototype" type="Number"/>
      <property name="selectedIndex" scope="prototype" type="Number"/>
      <property name="grid" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setMode" scope="prototype">
        <parameters>
          <parameter name="mode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCanSelect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCanDeselect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onChanging" scope="prototype"/>
      <method name="onChanged" scope="prototype"/>
      <method name="isSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="prototype"/>
      <method name="getNextSelected" scope="prototype">
        <parameters>
          <parameter name="inPrev" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="prototype"/>
      <method name="getSelectedCount" scope="prototype"/>
      <method name="_beginUpdate" scope="prototype"/>
      <method name="_endUpdate" scope="prototype"/>
      <method name="select" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
          <parameter name="inSelect" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSelect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="prototype">
        <parameters>
          <parameter name="inFrom" type="" usage="required"/>
          <parameter name="inTo" type="" usage="required"/>
          <parameter name="func" type="" usage="required"/>
        </parameters>
      </method>
      <method name="selectRange" scope="prototype">
        <parameters>
          <parameter name="inFrom" type="" usage="required"/>
          <parameter name="inTo" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deselectRange" scope="prototype">
        <parameters>
          <parameter name="inFrom" type="" usage="required"/>
          <parameter name="inTo" type="" usage="required"/>
        </parameters>
      </method>
      <method name="insert" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deselectAll" scope="prototype">
        <parameters>
          <parameter name="inExcept" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelect" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
          <parameter name="inCtrlKey" type="" usage="required"/>
          <parameter name="inShiftKey" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clickSelectEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid.Selection.selected" type="Array">
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._TreeAggregator" type="Function" classlike="true">
    <properties>
      <property name="cells" scope="instance-prototype" type="Array"/>
      <property name="grid" scope="instance-prototype" type="Object"/>
      <property name="childFields" scope="instance-prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_cacheValue" scope="prototype">
        <parameters>
          <parameter name="cache" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clearSubtotalCache" scope="prototype">
        <summary>Clears the subtotal cache so that we are forced to recalc it
	(or reread it) again.  This is needed, for example, when
	column order is changed.</summary>
      </method>
      <method name="cnt" scope="prototype">
        <summary>calculates the count of the children of item at the given level</summary>
        <parameters>
          <parameter name="cell" type="" usage="required"/>
          <parameter name="level" type="" usage="required"/>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sum" scope="prototype">
        <summary>calculates the sum of the children of item at the given level</summary>
        <parameters>
          <parameter name="cell" type="" usage="required"/>
          <parameter name="level" type="" usage="required"/>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="value" scope="prototype">
        <summary>Empty function so that we can set &amp;quot;aggregate='value'&amp;quot; to
	force loading from the data - and bypass calculating</summary>
        <parameters>
          <parameter name="cell" type="" usage="required"/>
          <parameter name="level" type="" usage="required"/>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getForCell" scope="prototype">
        <summary>Gets the value of the given cell at the given level and type.
	type can be one of &amp;quot;sum&amp;quot;, &amp;quot;cnt&amp;quot;, or &amp;quot;value&amp;quot;.  If itemAggregates
	is set and can be used, it is used instead.  Values are also
	cached to prevent calculating them too often.</summary>
        <parameters>
          <parameter name="cell" type="" usage="required"/>
          <parameter name="level" type="" usage="required"/>
          <parameter name="item" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._TreeAggregator.store" type="">
    <properties>
      <property name="_cachedAggregates" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid._TreeLayout" type="Function" classlike="true" superclass="dojox.grid._Layout">
    <mixins>
      <mixin scope="instance" location="dojox.grid._Layout"/>
    </mixins>
    <properties>
      <property name="_isCollapsable" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getInternalStructure" scope="prototype">
        <parameters>
          <parameter name="inStructure" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="prototype">
        <parameters>
          <parameter name="inStructure" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inCellIndex" type="" usage="required"/>
          <parameter name="inDef" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._TreeLayout.grid" type="">
    <properties>
      <property name="aggregator" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid._TreeLayout.grid.scroller" type="">
    <properties>
      <property name="defaultRowHeight" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.grid.TreePath" type="Function" classlike="true">
    <properties>
      <property name="level" scope="instance-prototype" type="Number"/>
      <property name="_str" scope="instance-prototype" type="Object"/>
      <property name="_arr" scope="instance-prototype" type="Object"/>
      <property name="store" scope="instance-prototype" type="Object"/>
      <property name="cell" scope="instance-prototype" type="Object"/>
      <property name="_item" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="path" type="String|Integer[]|Integer|dojox.grid.TreePath" usage="required"/>
          <parameter name="grid" type="dojox.grid.TreeGrid" usage="required"/>
        </parameters>
      </method>
      <method name="item" scope="prototype">
        <summary>gets the dojo.data item associated with this path</summary>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="path" type="String|Integer[]|Integer|dojox.grid.TreePath" usage="required"/>
          <parameter name="grid" type="dojox.grid.TreeGrid" usage="required"/>
        </parameters>
      </method>
      <method name="compare" scope="prototype">
        <summary>compares two paths</summary>
        <parameters>
          <parameter name="path" type="dojox.grid.TreePath|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="isOpen" scope="prototype">
        <summary>Returns the open state of this cell.</summary>
      </method>
      <method name="previous" scope="prototype">
        <summary>Returns the path that is before this path in the
	grid. If no path is found, returns null.</summary>
      </method>
      <method name="next" scope="prototype">
        <summary>Returns the next path in the grid.  If no path
	is found, returns null.</summary>
      </method>
      <method name="children" scope="prototype">
        <summary>Returns the child data items of this row.  If this
	row isn't open and alwaysReturn is falsey, returns null.</summary>
        <parameters>
          <parameter name="alwaysReturn" type="" usage="required"/>
        </parameters>
      </method>
      <method name="childPaths" scope="prototype"/>
      <method name="parent" scope="prototype">
        <summary>Returns the parent path of this path.  If this is a
	top-level row, returns null.</summary>
      </method>
      <method name="lastChild" scope="prototype">
        <summary>Returns the last child row below this path.  If traverse
	is true, will traverse down to find the last child row
	of this branch.  If there are no children, returns itself.</summary>
        <parameters>
          <parameter name="traverse" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="toString" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid.TreePath.grid"/>
  <object location="dojox.grid.TreePath.grid.treeModel" type="">
    <properties>
      <property name="store" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._TreeFocusManager" type="Function" classlike="true" superclass="dojox.grid._FocusManager">
    <mixins>
      <mixin scope="instance" location="dojox.grid._FocusManager"/>
    </mixins>
    <properties>
      <property name="rowIndex" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setFocusCell" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isLastFocusCell" scope="prototype"/>
      <method name="next" scope="prototype">
        <summary>focus next grid cell</summary>
      </method>
      <method name="previous" scope="prototype">
        <summary>focus previous grid cell</summary>
      </method>
      <method name="move" scope="prototype">
        <parameters>
          <parameter name="inRowDelta" type="" usage="required"/>
          <parameter name="inColDelta" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._TreeFocusManager.grid" type="">
    <properties>
      <property name="scroller" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._TreeFocusManager.cell" type="">
    <properties>
      <property name="index" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.TreeGrid" type="Function" classlike="true" superclass="dojox.grid.DataGrid">
    <summary>A grid that supports nesting rows - it provides an expando function
	similar to dijit.Tree.  It also provides mechanisms for aggregating
	the values of subrows</summary>
    <description>TreeGrid currently only works on "simple" structures.  That is,
	single-view structures with a single row in them.
	The TreeGrid works using the concept of "levels" - level 0 are the
	top-level items.</description>
    <mixins>
      <mixin scope="instance" location="dojox.grid.DataGrid"/>
    </mixins>
    <properties>
      <property name="defaultOpen" scope="prototype" type="Boolean">
        <summary>Whether or not we default to open (all levels).  This defaults to
	false for grids with a treeModel.</summary>
      </property>
      <property name="sortChildItems" scope="prototype" type="Boolean">
        <summary>If true, child items will be returned sorted according to the sorting
	properties of the grid.</summary>
      </property>
      <property name="openAtLevels" scope="prototype" type="Array">
        <summary>Which levels we are open at (overrides defaultOpen for the values
	that exist here).  Its values can be a boolean (true/false) or an
	integer (for the # of children to be closed if there are more than
	that)</summary>
      </property>
      <property name="expandoCell" scope="prototype" type="Integer">
        <summary>When used in conjunction with a treeModel (see above), this is a 0-based
	index of the cell in which to place the actual expando</summary>
      </property>
      <property name="_layoutClass" scope="normal" type=""/>
      <property name="selection" scope="prototype" type="Object"/>
      <property name="store" scope="prototype" type=""/>
      <property name="_by_idty_paths" scope="prototype" type="Object"/>
      <property name="rows" scope="prototype" type="Object"/>
      <property name="focus" scope="prototype" type="Object"/>
      <property name="edit" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="createSelection" scope="prototype"/>
      <method name="_childItemSorter" scope="prototype">
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="descending" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onNew" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="parentInfo" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onSet" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="attribute" type="" usage="required"/>
          <parameter name="oldValue" type="" usage="required"/>
          <parameter name="newValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onDelete" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_cleanupExpandoCache" scope="prototype">
        <parameters>
          <parameter name="index" type="" usage="required"/>
          <parameter name="identity" type="" usage="required"/>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_addItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="index" type="" usage="required"/>
          <parameter name="noUpdate" type="" usage="required"/>
          <parameter name="dontUpdateRoot" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="prototype">
        <summary>overridden so that you can pass in a '/' delimited string of indexes to get the
	item based off its path...that is, passing in &amp;quot;1/3/2&amp;quot; will get the
	3rd (0-based) child from the 4th child of the 2nd top-level item.</summary>
        <parameters>
          <parameter name="idx" type="integer|Array|String" usage="required"/>
        </parameters>
      </method>
      <method name="_getItemIndex" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
          <parameter name="isDeleted" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="setModel" scope="prototype">
        <parameters>
          <parameter name="treeModel" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setModel" scope="prototype">
        <parameters>
          <parameter name="treeModel" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createScroller" scope="prototype"/>
      <method name="createManagers" scope="prototype">
        <summary>create grid managers for various tasks including rows, focus, selection, editing</summary>
      </method>
      <method name="_setStore" scope="prototype">
        <parameters>
          <parameter name="store" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultOpenState" scope="prototype">
        <summary>Returns the default open state for the given definition and item
	It reads from the openAtLevels and defaultOpen values of the
	grid to calculate if the given item should default to open or
	not.</summary>
        <parameters>
          <parameter name="cellDef" type="" usage="required"/>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="prototype">
        <parameters>
          <parameter name="row" type="" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCanSelect" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="canEdit" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inAttrName" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
          <parameter name="ctor" type="" usage="required"/>
          <parameter name="cellFunc" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.TreeGrid.treeModel" type="dijit.tree.ForestStoreModel">
    <summary>A dijit.Tree model that will be used instead of using aggregates.
	Setting this value will make the TreeGrid behave like a columnar
	tree.  When setting this value, defaultOpen will default to false,
	and openAtLevels will be ignored.</summary>
    <properties>
      <property name="childrenAttrs" scope="prototype" type="Array"/>
    </properties>
  </object>
  <object location="dojox.grid.TreeGrid.scroller" type="">
    <properties>
      <property name="_origDefaultRowHeight" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.TreeGrid.treeModel.root" type="">
    <properties>
      <property name="children" scope="prototype" type="Array"/>
    </properties>
  </object>
  <object location="dojox.grid.TreeGrid.aggregator">
    <summary>The aggregator class - it will be populated automatically if we
	are a collapsable grid</summary>
    <properties>
      <property name="store" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.TreeSelection" type="Function" classlike="true" superclass="dojox.grid.DataSelection">
    <mixins>
      <mixin scope="instance" location="dojox.grid.DataSelection"/>
    </mixins>
    <properties>
      <property name="selected" scope="prototype" type="Object"/>
      <property name="sorted_sel" scope="prototype" type="Array"/>
      <property name="sorted_ltos" scope="prototype" type="Object"/>
      <property name="sorted_stol" scope="prototype" type="Object"/>
      <property name="selectedIndex" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setMode" scope="prototype">
        <parameters>
          <parameter name="mode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addToSelection" scope="prototype">
        <parameters>
          <parameter name="inItemOrIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="prototype">
        <parameters>
          <parameter name="inItemOrIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getSelected" scope="prototype"/>
      <method name="getSelectedCount" scope="prototype"/>
      <method name="_bsearch" scope="prototype">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_comparePaths" scope="prototype">
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_insertSortedSelection" scope="prototype">
        <parameters>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_removeSortedSelection" scope="prototype">
        <parameters>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="prototype"/>
      <method name="getNextSelected" scope="prototype">
        <parameters>
          <parameter name="inPrev" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_range" scope="prototype">
        <parameters>
          <parameter name="inFrom" type="" usage="required"/>
          <parameter name="inTo" type="" usage="required"/>
          <parameter name="func" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.TreeSelection.grid.layout" type="">
    <properties>
      <property name="cells" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.TreeSelection.grid" type="">
    <properties>
      <property name="store" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.util" type="">
    <properties>
      <property name="rowIndexTag" scope="normal" type="String"/>
      <property name="gridViewTag" scope="normal" type="String"/>
      <property name="na" scope="normal" type="String"/>
      <property name="mouseEvents" scope="normal" type="Array"/>
      <property name="keyEvents" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method name="fire" scope="normal">
        <parameters>
          <parameter name="ob" type="" usage="required"/>
          <parameter name="ev" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setStyleHeightPx" scope="normal">
        <parameters>
          <parameter name="inElement" type="" usage="required"/>
          <parameter name="inHeight" type="" usage="required"/>
        </parameters>
      </method>
      <method name="funnelEvents" scope="normal">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inObject" type="" usage="required"/>
          <parameter name="inMethod" type="" usage="required"/>
          <parameter name="inEvents" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeNode" scope="normal">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="arrayCompare" scope="normal">
        <parameters>
          <parameter name="inA" type="" usage="required"/>
          <parameter name="inB" type="" usage="required"/>
        </parameters>
      </method>
      <method name="arrayInsert" scope="normal">
        <parameters>
          <parameter name="inArray" type="" usage="required"/>
          <parameter name="inIndex" type="" usage="required"/>
          <parameter name="inValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="arrayRemove" scope="normal">
        <parameters>
          <parameter name="inArray" type="" usage="required"/>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="arraySwap" scope="normal">
        <parameters>
          <parameter name="inArray" type="" usage="required"/>
          <parameter name="inI" type="" usage="required"/>
          <parameter name="inJ" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._CheckBoxSelector" type="Function" classlike="true" superclass="dojox.grid._Selector" private="true">
    <mixins>
      <mixin scope="instance" location="dojox.grid._Selector"/>
    </mixins>
    <properties>
      <property name="inputType" scope="prototype" type="String"/>
      <property name="_headerBuilderClass" scope="normal" type=""/>
      <property name="_contentBuilderClass" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="renderHeader" scope="prototype"/>
      <method name="_updateVisibility" scope="prototype">
        <parameters>
          <parameter name="rowCount" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectionChanged" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid._EditManager" type="Function" classlike="true">
    <summary>Controls grid cell editing process. Owned by grid and used internally for editing.</summary>
    <properties>
      <property name="_boomerangWindow" scope="prototype" type="Number"/>
      <property name="_catchBoomerang" scope="prototype" type="String"/>
      <property name="grid" scope="instance" type=""/>
      <property name="connections" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="dojox.Grid" usage="required">
            <summary>The dojox.Grid this editor should be attached to</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="dojox.Grid" usage="required">
            <summary>The dojox.Grid this editor should be attached to</summary>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="cellFocus" scope="prototype">
        <summary>Invoke editing when cell is focused</summary>
        <parameters>
          <parameter name="inCell" type="cell" usage="required">
            <summary>object
	Grid cell object</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="rowClick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="prototype">
        <parameters>
          <parameter name="inRow" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isEditing" scope="prototype">
        <summary>Indicates editing state of the grid.</summary>
        <return-description>Boolean
	True if grid is actively editing</return-description>
      </method>
      <method name="isEditCell" scope="prototype">
        <summary>Indicates if the given cell is being edited.</summary>
        <return-description>Boolean
	True if given cell is being edited</return-description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Grid row index</summary>
          </parameter>
          <parameter name="inCellIndex" type="Integer" usage="required">
            <summary>Grid cell index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isEditRow" scope="prototype">
        <summary>Indicates if the given row is being edited.</summary>
        <return-description>Boolean
	True if given row is being edited</return-description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setEditCell" scope="prototype">
        <summary>Set the given cell to be edited</summary>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <summary>Grid cell object</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_focusEditor" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="focusEditor" scope="prototype"/>
      <method name="_shouldCatchBoomerang" scope="prototype"/>
      <method name="_boomerangFocus" scope="prototype"/>
      <method name="_doCatchBoomerang" scope="prototype"/>
      <method name="start" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inEditing" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_editorDo" scope="prototype">
        <parameters>
          <parameter name="inMethod" type="" usage="required"/>
        </parameters>
      </method>
      <method name="editorApply" scope="prototype"/>
      <method name="editorCancel" scope="prototype"/>
      <method name="applyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="" usage="required"/>
          <parameter name="inCell" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="applyRowEdit" scope="prototype"/>
      <method name="apply" scope="prototype">
        <summary>Apply a grid edit</summary>
      </method>
      <method name="cancel" scope="prototype">
        <summary>Cancel a grid edit</summary>
      </method>
      <method name="save" scope="prototype">
        <summary>Save the grid editing state</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Grid row index</summary>
          </parameter>
          <parameter name="inView" type="Object" usage="required">
            <summary>Grid view</summary>
          </parameter>
        </parameters>
      </method>
      <method name="restore" scope="prototype">
        <summary>Restores the grid editing state</summary>
        <parameters>
          <parameter name="inView" type="Object" usage="required">
            <summary>Grid view</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Grid row index</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._EditManager.info">
    <properties>
      <property name="cell" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._Events" type="Function" classlike="true">
    <summary>_Grid mixin that provides default implementations for grid events.</summary>
    <description>Default synthetic events dispatched for _Grid. dojo.connect to events to
	retain default implementation or override them for custom handling.</description>
    <properties>
      <property name="cellOverClass" scope="prototype" type="String">
        <summary>css class to apply to grid cells over which the cursor is placed.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onKeyEvent" scope="prototype">
        <summary>top level handler for Key Events</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onContentEvent" scope="prototype">
        <summary>Top level handler for Content events</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderEvent" scope="prototype">
        <summary>Top level handler for header events</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="prototype">
        <summary>Perform row styling on a given row. Called whenever row styling is updated.</summary>
        <examples>
          <example>onStyleRow({ selected: true, over:true, odd:false })</example>
        </examples>
        <parameters>
          <parameter name="inRow" type="Object" usage="required">
            <summary>Object containing row state information: selected, true if the row is selcted; over:
	true of the mouse is over the row; odd: true if the row is odd. Use customClasses and
	customStyles to control row css classes and styles; both properties are strings.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <summary>Grid key event handler. By default enter begins editing and applies edits, escape cancels an edit,
	tab, shift-tab, and arrow keys move grid cell focus.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOver" scope="prototype">
        <summary>Event fired when mouse is over the grid.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <summary>Event fired when mouse moves out of the grid.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object that contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>Event fired when mouse is down inside grid.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object that contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOverRow" scope="prototype">
        <summary>Event fired when mouse is over any row (data or header).</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOutRow" scope="prototype">
        <summary>Event fired when mouse moves out of any row (data or header).</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseDownRow" scope="prototype">
        <summary>Event fired when mouse is down inside grid row</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object that contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseOver" scope="prototype">
        <summary>Event fired when mouse is over a cell.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseOut" scope="prototype">
        <summary>Event fired when mouse moves out of a cell.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="prototype">
        <summary>Event fired when mouse is down in a header cell.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCellClick" scope="prototype">
        <summary>Event fired when a cell is clicked.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="prototype">
        <summary>Event fired when a cell is double-clicked.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCellContextMenu" scope="prototype">
        <summary>Event fired when a cell context menu is accessed via mouse right click.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCellFocus" scope="prototype">
        <summary>Event fired when a cell receives focus.</summary>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <summary>Cell object containing properties of the grid column.</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the grid row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRowClick" scope="prototype">
        <summary>Event fired when a row is clicked.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRowDblClick" scope="prototype">
        <summary>Event fired when a row is double clicked.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOver" scope="prototype">
        <summary>Event fired when mouse moves over a data row.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOut" scope="prototype">
        <summary>Event fired when mouse moves out of a data row.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseDown" scope="prototype">
        <summary>Event fired when mouse is down in a row.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="prototype">
        <summary>Event fired when a row context menu is accessed via mouse right click.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderMouseOver" scope="prototype">
        <summary>Event fired when mouse moves over the grid header.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderMouseOut" scope="prototype">
        <summary>Event fired when mouse moves out of the grid header.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOver" scope="prototype">
        <summary>Event fired when mouse moves over a header cell.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="prototype">
        <summary>Event fired when mouse moves out of a header cell.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="prototype">
        <summary>Event fired when mouse is down in a header cell.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="prototype">
        <summary>Event fired when the grid header is clicked.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="prototype">
        <summary>Event fired when a header cell is clicked.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderDblClick" scope="prototype">
        <summary>Event fired when the grid header is double clicked.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellDblClick" scope="prototype">
        <summary>Event fired when a header cell is double clicked.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellContextMenu" scope="prototype">
        <summary>Event fired when a header cell context menu is accessed via mouse right click.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderContextMenu" scope="prototype">
        <summary>Event fired when the grid header context menu is accessed via mouse right click.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onStartEdit" scope="prototype">
        <summary>Event fired when editing is started for a given grid cell</summary>
        <parameters>
          <parameter name="inCell" type="Object" usage="required">
            <summary>Cell object containing properties of the grid column.</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the grid row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onApplyCellEdit" scope="prototype">
        <summary>Event fired when editing is applied for a given grid cell</summary>
        <parameters>
          <parameter name="inValue" type="String" usage="required">
            <summary>Value from cell editor</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the grid row</summary>
          </parameter>
          <parameter name="inFieldIndex" type="Integer" usage="required">
            <summary>Index in the grid's data store</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCancelEdit" scope="prototype">
        <summary>Event fired when editing is cancelled for a given grid cell</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the grid row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onApplyEdit" scope="prototype">
        <summary>Event fired when editing is applied for a given grid row</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the grid row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCanSelect" scope="prototype">
        <summary>Event to determine if a grid row may be selected</summary>
        <return-description>Boolean
	true if the row can be selected</return-description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the grid row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCanDeselect" scope="prototype">
        <summary>Event to determine if a grid row may be deselected</summary>
        <return-description>Boolean
	true if the row can be deselected</return-description>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the grid row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onSelected" scope="prototype">
        <summary>Event fired when a grid row is selected</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the grid row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onDeselected" scope="prototype">
        <summary>Event fired when a grid row is deselected</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the grid row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onSelectionChanged" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid._Events.focus" type="">
    <properties>
      <property name="focusView" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid._Events._click" type="">
    <properties>
      <property name="0" scope="prototype" type=""/>
      <property name="1" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._FocusManager" type="Function" classlike="true">
    <summary>Controls grid cell focus. Owned by grid and used internally for focusing.
	Note: grid cell actually receives keyboard input only when cell is being edited.</summary>
    <properties>
      <property name="_colHeadNode" scope="prototype" type="Object"/>
      <property name="_colHeadFocusIdx" scope="prototype" type="Number"/>
      <property name="tabbingOut" scope="prototype" type="bool"/>
      <property name="focusClass" scope="prototype" type="String"/>
      <property name="focusView" scope="prototype" type="Object"/>
      <property name="rowIndex" scope="instance-prototype" type="Number"/>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="initFocusView" scope="prototype"/>
      <method name="isFocusCell" scope="prototype">
        <summary>states if the given cell is focused</summary>
        <return-description>true of the given grid cell is focused</return-description>
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <summary>grid cell object</summary>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isLastFocusCell" scope="prototype"/>
      <method name="isFirstFocusCell" scope="prototype"/>
      <method name="isNoFocusCell" scope="prototype"/>
      <method name="isNavHeader" scope="prototype">
        <summary>states whether currently navigating among column headers.</summary>
        <return-description>true if focus is on a column header; false otherwise.</return-description>
      </method>
      <method name="getHeaderIndex" scope="prototype">
        <summary>if one of the column headers currently has focus, return its index.</summary>
        <return-description>index of the focused column header, or -1 if none have focus.</return-description>
      </method>
      <method name="_focusifyCellNode" scope="prototype">
        <parameters>
          <parameter name="inBork" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_delayedCellFocus" scope="prototype"/>
      <method name="_delayedHeaderFocus" scope="prototype"/>
      <method name="_initColumnHeaders" scope="prototype"/>
      <method name="_findHeaderCells" scope="prototype"/>
      <method name="_setActiveColHeader" scope="prototype">
        <parameters>
          <parameter name="colHeaderNode" type="Node" usage="required"/>
          <parameter name="colFocusIdx" type="Integer" usage="required"/>
          <parameter name="prevColFocusIdx" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="prototype"/>
      <method name="_scrollInfo" scope="prototype">
        <parameters>
          <parameter name="cell" type="" usage="required"/>
          <parameter name="domNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_scrollHeader" scope="prototype">
        <parameters>
          <parameter name="currentIdx" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_isHeaderHidden" scope="prototype">
        <summary>determine if the grid headers are hidden
	relies on documented technique of setting .dojoxGridHeader { display:none; }</summary>
        <return-description>Boolean
	true if headers are hidden
	false if headers are not hidden</return-description>
      </method>
      <method name="colSizeAdjust" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
          <parameter name="colIdx" type="" usage="required"/>
          <parameter name="delta" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="can't adjust single col. grid"/>
        </return-types>
      </method>
      <method name="styleRow" scope="prototype">
        <parameters>
          <parameter name="inRow" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setFocusIndex" scope="prototype">
        <summary>focuses the given grid cell</summary>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
          <parameter name="inCellIndex" type="int" usage="required">
            <summary>grid cell index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setFocusCell" scope="prototype">
        <summary>focuses the given grid cell</summary>
        <parameters>
          <parameter name="inCell" type="object" usage="required">
            <summary>grid cell object</summary>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="next" scope="prototype">
        <summary>focus next grid cell</summary>
      </method>
      <method name="previous" scope="prototype">
        <summary>focus previous grid cell</summary>
      </method>
      <method name="move" scope="prototype">
        <summary>focus grid cell or  simulate focus to column header based on position relative to current focus</summary>
        <parameters>
          <parameter name="inRowDelta" type="int" usage="required">
            <summary>vertical distance from current focus</summary>
          </parameter>
          <parameter name="inColDelta" type="int" usage="required">
            <summary>horizontal distance from current focus</summary>
          </parameter>
        </parameters>
      </method>
      <method name="previousKey" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="tabOut" scope="prototype">
        <parameters>
          <parameter name="inFocusNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="focusGridView" scope="prototype"/>
      <method name="focusGrid" scope="prototype">
        <parameters>
          <parameter name="inSkipFocusCell" type="" usage="required"/>
        </parameters>
      </method>
      <method name="findAndFocusGridCell" scope="prototype">
        <summary>find the first focusable grid cell</summary>
        <return-description>Boolean
	true if focus was set to a cell
	false if no cell found to set focus onto</return-description>
      </method>
      <method name="focusHeader" scope="prototype"/>
      <method name="doFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doLastNodeFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doLastNodeBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderFocus" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderBlur" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._FocusManager.cell.view.scrollboxNode" type="">
    <properties>
      <property name="scrollLeft" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._FocusManager.grid" type="">
    <properties>
      <property name="scroller" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._FocusManager.cell">
    <properties>
      <property name="index" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._Grid" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A grid widget with virtual scrolling, cell editing, complex rows,
	sorting, fixed columns, sizeable columns, etc.</summary>
    <description>_Grid provides the full set of grid features without any
	direct connection to a data store.
	The grid exposes a get function for the grid, or optionally
	individual columns, to populate cell contents.
	The grid is rendered based on its structure, an object describing
	column and cell layout.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dojox.grid._Events.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dojox.grid._Events"/>
    </mixins>
    <examples>
      <example>A quick sample:
	define a get function
		function get(inRowIndex){ // called in cell context
			return [this.index, inRowIndex].join(', ');
		}
	define the grid structure:
		var structure = [ // array of view objects
			{ cells: [// array of rows, a row is an array of cells
				[
					{ name: "Alpha", width: 6 },
					{ name: "Beta" },
					{ name: "Gamma", get: get }]
			]}
		];
		&lt;div id="grid"
			rowCount="100" get="get"
			structure="structure"
			dojoType="dojox.grid._Grid"&gt;&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="classTag" scope="prototype" type="String">
        <summary>CSS class applied to the grid's domNode</summary>
      </property>
      <property name="get" scope="prototype" type="Object">
        <summary>Default data getter.</summary>
      </property>
      <property name="rowCount" scope="prototype" type="Integer">
        <summary>Number of rows to display.</summary>
      </property>
      <property name="keepRows" scope="prototype" type="Integer">
        <summary>Number of rows to keep in the rendering cache.</summary>
      </property>
      <property name="rowsPerPage" scope="prototype" type="Integer">
        <summary>Number of rows to render at a time.</summary>
      </property>
      <property name="autoWidth" scope="prototype" type="Boolean">
        <summary>If autoWidth is true, grid width is automatically set to fit the data.</summary>
      </property>
      <property name="initialWidth" scope="prototype" type="String">
        <summary>A css string to use to set our initial width (only used if autoWidth
	is true).  The first rendering of the grid will be this width, any
	resizing of columns, etc will result in the grid switching to
	autoWidth mode.  Note, this width will override any styling in a
	stylesheet or directly on the node.</summary>
      </property>
      <property name="autoHeight" scope="prototype" type="Boolean|Integer">
        <summary>If autoHeight is true, grid height is automatically set to fit the data.
	If it is an integer, the height will be automatically set to fit the data
	if there are fewer than that many rows - and the height will be set to show
	that many rows if there are more</summary>
      </property>
      <property name="rowHeight" scope="prototype" type="Integer">
        <summary>If rowHeight is set to a positive number, it will define the height of the rows
	in pixels. This can provide a significant performance advantage, since it
	eliminates the need to measure row sizes during rendering, which is one
	the primary bottlenecks in the DataGrid's performance.</summary>
      </property>
      <property name="autoRender" scope="prototype" type="Boolean">
        <summary>If autoRender is true, grid will render itself after initialization.</summary>
      </property>
      <property name="defaultHeight" scope="prototype" type="String">
        <summary>default height of the grid, measured in any valid css unit.</summary>
      </property>
      <property name="height" scope="prototype" type="String">
        <summary>explicit height of the grid, measured in any valid css unit.  This will be populated (and overridden)
	if the height: css attribute exists on the source node.</summary>
      </property>
      <property name="structure" scope="prototype" type="dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]">
        <summary>View layout defintion.</summary>
      </property>
      <property name="elasticView" scope="prototype" type="Integer">
        <summary>Override defaults and make the indexed grid view elastic, thus filling available horizontal space.</summary>
      </property>
      <property name="singleClickEdit" scope="prototype" type="boolean">
        <summary>Single-click starts editing. Default is double-click</summary>
      </property>
      <property name="selectionMode" scope="prototype" type="String">
        <summary>Set the selection mode of grid's Selection.  Value must be 'single', 'multiple',
	or 'extended'.  Default is 'extended'.</summary>
      </property>
      <property name="rowSelector" scope="prototype" type="Boolean|String">
        <summary>If set to true, will add a row selector view to this grid.  If set to a CSS width, will add
	a row selector of that width to this grid.</summary>
      </property>
      <property name="columnReordering" scope="prototype" type="Boolean">
        <summary>If set to true, will add drag and drop reordering to views with one row of columns.</summary>
      </property>
      <property name="headerMenu" scope="prototype" type="dijit.Menu">
        <summary>If set to a dijit.Menu, will use this as a context menu for the grid headers.</summary>
      </property>
      <property name="placeholderLabel" scope="prototype" type="String">
        <summary>Label of placeholders to search for in the header menu to replace with column toggling
	menu items.</summary>
      </property>
      <property name="selectable" scope="prototype" type="Boolean">
        <summary>Set to true if you want to be able to select the text within the grid.</summary>
      </property>
      <property name="_click" scope="prototype" type="Array"/>
      <property name="loadingMessage" scope="prototype" type="String">
        <summary>Message that shows while the grid is loading</summary>
      </property>
      <property name="errorMessage" scope="prototype" type="String">
        <summary>Message that shows when the grid encounters an error loading</summary>
      </property>
      <property name="noDataMessage" scope="prototype" type="String">
        <summary>Message that shows if the grid has no data - wrap it in a
	span with class 'dojoxGridNoData' if you want it to be
	styled similar to the loading and error messages</summary>
      </property>
      <property name="escapeHTMLInData" scope="prototype" type="Boolean">
        <summary>This will escape HTML brackets from the data to prevent HTML from
	user-inputted data being rendered with may contain JavaScript and result in
	XSS attacks. This is true by default, and it is recommended that it remain
	true. Setting this to false will allow data to be displayed in the grid without
	filtering, and should be only used if it is known that the data won't contain
	malicious scripts. If HTML is needed in grid cells, it is recommended that
	you use the formatter function to generate the HTML (the output of
	formatter functions is not filtered, even with escapeHTMLInData set to true).</summary>
      </property>
      <property name="formatterScope" scope="prototype" type="Object">
        <summary>An object to execute format functions within.  If not set, the
	format functions will execute within the scope of the cell that
	has a format function.</summary>
      </property>
      <property name="editable" scope="prototype" type="boolean">
        <summary>indicates if the grid contains editable cells, default is false
	set to true if editable cell encountered during rendering</summary>
      </property>
      <property name="sortInfo" scope="prototype" type="Number"/>
      <property name="themeable" scope="prototype" type="Object"/>
      <property name="_placeholders" scope="prototype" type="Object"/>
      <property name="_layoutClass" scope="normal" type="Object">
        <summary>The class to use for our layout - can be overridden by grid subclasses</summary>
      </property>
      <property name="lastScrollTop" scope="prototype" type="Number"/>
      <property name="scrollTop" scope="prototype" type="Number"/>
      <property name="_autoHeight" scope="prototype" type="bool"/>
      <property name="rows" scope="prototype" type="Object"/>
      <property name="focus" scope="prototype" type="Object"/>
      <property name="edit" scope="prototype" type="Object"/>
      <property name="selection" scope="prototype" type="Object"/>
      <property name="_pendingChangeSize" scope="prototype" type=""/>
      <property name="_pendingResultSize" scope="prototype" type="Object"/>
      <property name="_padBorder" scope="prototype" type="Object"/>
      <property name="fitTo" scope="prototype" type="String"/>
      <property name="_parentContentBoxHeight" scope="prototype" type="Object"/>
      <property name="updating" scope="prototype" type="bool"/>
      <property name="fastScroll" scope="prototype" type="Boolean">
        <summary>flag modifies vertical scrolling behavior. Defaults to true but set to false for slower
	scroll performance but more immediate scrolling feedback</summary>
      </property>
      <property name="delayScroll" scope="prototype" type="bool"/>
      <property name="scrollRedrawThreshold" scope="prototype" type="int">
        <summary>pixel distance a user must scroll vertically to trigger grid scrolling.</summary>
      </property>
      <property name="_pendingScroll" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="_setAutoHeightAttr" scope="prototype">
        <parameters>
          <parameter name="ah" type="" usage="required"/>
          <parameter name="skipRender" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getRowCountAttr" scope="prototype"/>
      <method name="textSizeChanged" scope="prototype"/>
      <method name="sizeChange" scope="prototype"/>
      <method name="createManagers" scope="prototype">
        <summary>create grid managers for various tasks including rows, focus, selection, editing</summary>
      </method>
      <method name="createSelection" scope="prototype">
        <summary>Creates a new Grid selection manager.</summary>
      </method>
      <method name="createScroller" scope="prototype">
        <summary>Creates a new virtual scroller</summary>
      </method>
      <method name="createLayout" scope="prototype">
        <summary>Creates a new Grid layout</summary>
      </method>
      <method name="onMoveColumn" scope="prototype"/>
      <method name="onResizeColumn" scope="prototype">
        <parameters>
          <parameter name="cellIdx" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="createViews" scope="prototype"/>
      <method name="createView" scope="prototype">
        <parameters>
          <parameter name="inClass" type="" usage="required"/>
          <parameter name="idx" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildViews" scope="prototype"/>
      <method name="_setStructureAttr" scope="prototype">
        <parameters>
          <parameter name="structure" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="prototype">
        <summary>Install a new structure and rebuild the grid.</summary>
        <parameters>
          <parameter name="inStructure" type="dojox.grid.__ViewDef|dojox.grid.__ViewDef[]|dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]" usage="required"/>
        </parameters>
      </method>
      <method name="getColumnTogglingItems" scope="prototype"/>
      <method name="_setHeaderMenuAttr" scope="prototype">
        <parameters>
          <parameter name="menu" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setHeaderMenu" scope="prototype">
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="required"/>
        </parameters>
      </method>
      <method name="setupHeaderMenu" scope="prototype"/>
      <method name="_fetch" scope="prototype">
        <parameters>
          <parameter name="start" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getItem" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="showMessage" scope="prototype">
        <parameters>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_structureChanged" scope="prototype"/>
      <method name="hasLayout" scope="prototype"/>
      <method name="resize" scope="prototype">
        <summary>Update the grid's rendering dimensions and resize it</summary>
        <parameters>
          <parameter name="changeSize" type="" usage="required"/>
          <parameter name="resultSize" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getPadBorder" scope="prototype"/>
      <method name="_getHeaderHeight" scope="prototype"/>
      <method name="_resize" scope="prototype">
        <parameters>
          <parameter name="changeSize" type="" usage="required"/>
          <parameter name="resultSize" type="" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="prototype"/>
      <method name="adaptHeight" scope="prototype">
        <parameters>
          <parameter name="inHeaderHeight" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="render" scope="prototype">
        <summary>Render the grid, headers, and views. Edit and scrolling states are reset. To retain edit and
	scrolling states, see Update.</summary>
      </method>
      <method name="update" scope="prototype">
        <summary>Update the grid, retaining edit and scrolling states.</summary>
      </method>
      <method name="_render" scope="prototype"/>
      <method name="prerender" scope="prototype"/>
      <method name="postrender" scope="prototype"/>
      <method name="postresize" scope="prototype"/>
      <method name="renderRow" scope="prototype">
        <summary>private, used internally to render rows</summary>
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inNodes" type="" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="prototype">
        <summary>private, used internally to remove rows</summary>
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="beginUpdate" scope="prototype">
        <summary>Use to make multiple changes to rows while queueing row updating.
	NOTE: not currently supporting nested begin/endUpdate calls</summary>
      </method>
      <method name="endUpdate" scope="prototype">
        <summary>Use after calling beginUpdate to render any changes made to rows.</summary>
      </method>
      <method name="defaultUpdate" scope="prototype"/>
      <method name="updateRow" scope="prototype">
        <summary>Render a single row.</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Index of the row to render</summary>
          </parameter>
        </parameters>
      </method>
      <method name="updateRows" scope="prototype">
        <summary>Render consecutive rows at once.</summary>
        <parameters>
          <parameter name="startIndex" type="Integer" usage="required">
            <summary>Index of the starting row to render</summary>
          </parameter>
          <parameter name="howMany" type="Integer" usage="required">
            <summary>How many rows to update.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="updateRowCount" scope="prototype">
        <summary>Change the number of rows.</summary>
        <parameters>
          <parameter name="inRowCount" type="int" usage="required">
            <summary>Number of rows in the grid.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <summary>Update the styles for a row after it's state has changed.</summary>
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getRowNode" scope="prototype">
        <summary>find the rowNode that is not a rowSelector</summary>
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="prototype">
        <summary>Update grid when the height of a row has changed. Row height is handled automatically as rows
	are rendered. Use this function only to update a row's height outside the normal rendering process.</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>index of the row that has changed height</summary>
          </parameter>
        </parameters>
      </method>
      <method name="scrollTo" scope="prototype">
        <summary>Vertically scroll the grid to a given pixel position</summary>
        <parameters>
          <parameter name="inTop" type="Integer" usage="required">
            <summary>vertical position of the grid in pixels</summary>
          </parameter>
        </parameters>
      </method>
      <method name="finishScrollJob" scope="prototype"/>
      <method name="setScrollTop" scope="prototype">
        <parameters>
          <parameter name="inTop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="scrollToRow" scope="prototype">
        <summary>Scroll the grid to a specific row.</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_mouseOut" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getCell" scope="prototype">
        <summary>Retrieves the cell object for a given grid column.</summary>
        <return-description>a grid cell</return-description>
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <summary>Grid column index of cell to retrieve</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setCellWidth" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
          <parameter name="inUnitWidth" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getCellName" scope="prototype">
        <summary>Returns the cell name of a passed cell</summary>
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="canSort" scope="prototype">
        <summary>Determines if the grid can be sorted</summary>
        <return-description>Boolean
	True if grid can be sorted on the given column in the given direction</return-description>
        <parameters>
          <parameter name="inSortInfo" type="Integer" usage="required">
            <summary>Sort information, 1-based index of column on which to sort, positive for an ascending sort
	and negative for a descending sort</summary>
          </parameter>
        </parameters>
      </method>
      <method name="sort" scope="prototype"/>
      <method name="getSortAsc" scope="prototype">
        <summary>Returns true if grid is sorted in an ascending direction.</summary>
        <parameters>
          <parameter name="inSortInfo" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getSortIndex" scope="prototype">
        <summary>Returns the index of the column on which the grid is sorted</summary>
        <parameters>
          <parameter name="inSortInfo" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="setSortIndex" scope="prototype">
        <summary>Sort the grid on a column in a specified direction</summary>
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <summary>Column index on which to sort.</summary>
          </parameter>
          <parameter name="inAsc" type="Boolean" usage="required">
            <summary>If true, sort the grid in ascending order, otherwise in descending order</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setSortInfo" scope="prototype">
        <parameters>
          <parameter name="inSortInfo" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doKeyEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_dispatch" scope="prototype">
        <parameters>
          <parameter name="m" type="" usage="required"/>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchKeyEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dokeydown" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dodblclick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="docontextmenu" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderclick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doheaderdblclick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doheadercontextmenu" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doStartEdit" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyCellEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inFieldIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doCancelEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doApplyEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addRow" scope="prototype">
        <summary>Add a row to the grid.</summary>
      </method>
      <method name="removeSelectedRows" scope="prototype">
        <summary>Remove the selected rows from the grid.</summary>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
          <parameter name="ctor" type="" usage="required"/>
          <parameter name="cellFunc" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="for vendetta"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._Grid.domNode" type="">
    <properties>
      <property name="tabIndex" scope="prototype" type="String"/>
      <property name="onReveal" scope="prototype" type="Object"/>
      <property name="onSizeChange" scope="prototype" type="Object"/>
      <property name="parentNode" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._Grid.domNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._Grid.scroller">
    <properties>
      <property name="grid" scope="prototype" type="Object"/>
      <property name="renderRow" scope="prototype" type="Object"/>
      <property name="removeRow" scope="prototype" type="Object"/>
      <property name="windowHeight" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid._Grid.views">
    <properties>
      <property name="createView" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid._Grid.layout">
    <properties>
      <property name="structure" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid._Grid.messagesNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._Grid.messagesNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._Grid.viewsHeaderNode" type=""/>
  <object location="dojox.grid._Grid.viewsHeaderNode.style" type="">
    <properties>
      <property name="height" scope="prototype" type="String"/>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._Grid.viewsNode.style" type="">
    <properties>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._Grid.invalidated" type="Array">
    <properties>
      <property name="all" scope="prototype" type="Object"/>
      <property name="rowCount" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.__CellDef" type="Function" classlike="true" private="true">
    <properties>
      <property name="name" scope="instance" type="String">
        <summary>The text to use in the header of the grid for this cell.</summary>
      </property>
      <property name="value" scope="instance" type="String">
        <summary>If &amp;quot;get&amp;quot; is not specified, this is used as the data for the cell.
	defaultValue: String?
	If &amp;quot;get&amp;quot; and &amp;quot;value&amp;quot; aren't specified or if &amp;quot;get&amp;quot; returns an undefined
	value, this is used as the data for the cell.  &amp;quot;formatter&amp;quot; is not run
	on this if &amp;quot;get&amp;quot; returns an undefined value.</summary>
      </property>
      <property name="type" scope="instance" type="dojox.grid.cells._Base|Function">
        <summary>TODO</summary>
      </property>
      <property name="editable" scope="instance" type="Boolean">
        <summary>Whether this cell should be editable or not.</summary>
      </property>
      <property name="hidden" scope="instance" type="Boolean">
        <summary>If true, the cell will not be displayed.
	noresize: Boolean?
	If true, the cell will not be able to be resized.</summary>
      </property>
      <property name="width" scope="instance" type="Integer|String">
        <summary>A CSS size.  If it's an Integer, the width will be in em's.</summary>
      </property>
      <property name="colSpan" scope="instance" type="Integer">
        <summary>How many columns to span this cell.  Will not work in the first
	sub-row of cells.</summary>
      </property>
      <property name="rowSpan" scope="instance" type="Integer">
        <summary>How many sub-rows to span this cell.</summary>
      </property>
      <property name="styles" scope="instance" type="String">
        <summary>A string of styles to apply to both the header cell and main
	grid cells.  Must end in a ';'.</summary>
      </property>
      <property name="headerStyles" scope="instance" type="String">
        <summary>A string of styles to apply to just the header cell.  Must end
	in a ';'</summary>
      </property>
      <property name="cellStyles" scope="instance" type="String">
        <summary>A string of styles to apply to just the main grid cells.  Must
	end in a ';'</summary>
      </property>
      <property name="classes" scope="instance" type="String">
        <summary>A space separated list of classes to apply to both the header
	cell and the main grid cells.</summary>
      </property>
      <property name="headerClasses" scope="instance" type="String">
        <summary>A space separated list of classes to apply to just the header
	cell.</summary>
      </property>
      <property name="cellClasses" scope="instance" type="String">
        <summary>A space separated list of classes to apply to just the main
	grid cells.</summary>
      </property>
      <property name="attrs" scope="instance" type="String">
        <summary>A space separated string of attribute='value' pairs to add to
	the header cell element and main grid cell elements.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="get" scope="instance">
        <summary>function(rowIndex){} rowIndex is of type Integer.  This
	function will be called when a cell	requests data.  Returns the
	unformatted data for the cell.</summary>
      </method>
      <method name="formatter" scope="instance">
        <summary>function(data, rowIndex){} data is of type anything, rowIndex
	is of type Integer.  This function will be called after the cell
	has its data but before it passes it back to the grid to render.
	Returns the formatted version of the cell's data.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.__ViewDef" type="Function" classlike="true" private="true">
    <properties>
      <property name="noscroll" scope="instance" type="Boolean">
        <summary>If true, no scrollbars will be rendered without scrollbars.</summary>
      </property>
      <property name="width" scope="instance" type="Integer|String">
        <summary>A CSS size.  If it's an Integer, the width will be in em's. If
	&amp;quot;noscroll&amp;quot; is true, this value is ignored.</summary>
      </property>
      <property name="cells" scope="instance" type="dojox.grid.__CellDef[]|Array[dojox.grid.__CellDef[]]">
        <summary>The structure of the cells within this grid.</summary>
      </property>
      <property name="type" scope="instance" type="String">
        <summary>A string containing the constructor of a subclass of
	dojox.grid._View.  If this is not specified, dojox.grid._View
	is used.</summary>
      </property>
      <property name="defaultCell" scope="instance" type="dojox.grid.__CellDef">
        <summary>A cell definition with default values for all cells in this view.  If
	a property is defined in a cell definition in the &amp;quot;cells&amp;quot; array and
	this property, the cell definition's property will override this
	property's property.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onBeforeRow" scope="instance">
        <summary>function(rowIndex, cells){} rowIndex is of type Integer, cells
	is of type Array[dojox.grid.__CellDef[]].  This function is called
	before each row of data is rendered.  Before the header is
	rendered, rowIndex will be -1.  &amp;quot;cells&amp;quot; is a reference to the
	internal structure of this view's cells so any changes you make to
	it will persist between calls.</summary>
      </method>
      <method name="onAfterRow" scope="instance">
        <summary>function(rowIndex, cells, rowNode){} rowIndex is of type Integer, cells
	is of type Array[dojox.grid.__CellDef[]], rowNode is of type DOMNode.
	This function is called	after each row of data is rendered.  After the
	header is rendered, rowIndex will be -1.  &amp;quot;cells&amp;quot; is a reference to the
	internal structure of this view's cells so any changes you make to
	it will persist between calls.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._Layout" type="Function" classlike="true">
    <summary>Controls grid cell layout. Owned by grid and used internally.
	flat array of grid cells
	structured array of grid cells
	default cell width</summary>
    <properties>
      <property name="cells" scope="prototype" type="Array"/>
      <property name="structure" scope="prototype" type="Array"/>
      <property name="defaultWidth" scope="prototype" type="String"/>
      <property name="_defaultCellProps" scope="prototype" type="Object"/>
      <property name="fieldIndex" scope="prototype" type="Number"/>
      <property name="cellCount" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="moveColumn" scope="prototype">
        <parameters>
          <parameter name="sourceViewIndex" type="" usage="required"/>
          <parameter name="destViewIndex" type="" usage="required"/>
          <parameter name="cellIndex" type="" usage="required"/>
          <parameter name="targetIndex" type="" usage="required"/>
          <parameter name="before" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setColumnVisibility" scope="prototype">
        <parameters>
          <parameter name="columnIndex" type="" usage="required"/>
          <parameter name="visible" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addCellDef" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inCellIndex" type="" usage="required"/>
          <parameter name="inDef" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addRowDef" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inDef" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addRowsDef" scope="prototype">
        <parameters>
          <parameter name="inDef" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addViewDef" scope="prototype">
        <parameters>
          <parameter name="inDef" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setStructure" scope="prototype">
        <parameters>
          <parameter name="inStructure" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._Layout.grid" type="">
    <properties>
      <property name="sortInfo" scope="prototype" type=""/>
      <property name="rowSelector" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._RadioSelector" type="Function" classlike="true" superclass="dojox.grid._Selector" private="true">
    <mixins>
      <mixin scope="instance" location="dojox.grid._Selector"/>
    </mixins>
    <properties>
      <property name="inputType" scope="prototype" type="String"/>
      <property name="selectionMode" scope="prototype" type="String"/>
      <property name="_contentBuilderClass" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="renderHeader" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid._RowManager" type="Function" classlike="true">
    <properties>
      <property name="linesToEms" scope="prototype" type="Number"/>
      <property name="overRow" scope="prototype" type="Number"/>
      <property name="grid" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="prepareStylingRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="applyStyles" scope="prototype">
        <parameters>
          <parameter name="inRow" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setOverRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isOver" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._RowSelector" type="Function" classlike="true" superclass="dojox.grid._View">
    <summary>Custom grid view. If used in a grid structure, provides a small selectable region for grid rows.
	styling
	event handlers</summary>
    <mixins>
      <mixin scope="instance" location="dojox.grid._View"/>
    </mixins>
    <properties>
      <property name="defaultWidth" scope="prototype" type="String"/>
      <property name="noscroll" scope="prototype" type="Object"/>
      <property name="padBorderWidth" scope="prototype" type="Number"/>
      <property name="contentWidth" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="getWidth" scope="prototype"/>
      <method name="buildRowContent" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="prototype"/>
      <method name="updateRow" scope="prototype"/>
      <method name="resize" scope="prototype"/>
      <method name="adaptWidth" scope="prototype"/>
      <method name="doStyleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="domouseover" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._RowSelector.scrollboxNode.style" type="">
    <properties>
      <property name="overflow" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._RowSelector.headerNode.style" type="">
    <properties>
      <property name="visibility" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._Scroller" type="Function" classlike="true">
    <properties>
      <property name="rowCount" scope="prototype" type="Number"/>
      <property name="defaultRowHeight" scope="prototype" type="Number"/>
      <property name="keepRows" scope="prototype" type="Number"/>
      <property name="contentNode" scope="prototype" type="Object"/>
      <property name="defaultPageHeight" scope="prototype" type="Number"/>
      <property name="keepPages" scope="prototype" type="Number"/>
      <property name="pageCount" scope="prototype" type="Object"/>
      <property name="windowHeight" scope="prototype" type="Number"/>
      <property name="firstVisibleRow" scope="prototype" type="Object"/>
      <property name="lastVisibleRow" scope="prototype" type="Object"/>
      <property name="averageRowHeight" scope="prototype" type="Number"/>
      <property name="page" scope="prototype" type="Number"/>
      <property name="pageTop" scope="prototype" type="Number"/>
      <property name="rowsPerPage" scope="prototype" type=""/>
      <property name="contentNodes" scope="prototype" type=""/>
      <property name="colCount" scope="prototype" type=""/>
      <property name="pageNodes" scope="instance-prototype" type="Array"/>
      <property name="_invalidating" scope="prototype" type="bool"/>
      <property name="pageHeights" scope="instance-prototype" type="Array"/>
      <property name="height" scope="prototype" type="Number"/>
      <property name="pacifying" scope="prototype" type="bool"/>
      <property name="pacifyTicks" scope="prototype" type="Number"/>
      <property name="startPacifyTicks" scope="prototype" type="Object"/>
      <property name="offset" scope="prototype" type="Number"/>
      <property name="dummy" scope="prototype" type="Number"/>
      <property name="stack" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inContentNodes" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inContentNodes" type="" usage="required"/>
        </parameters>
      </method>
      <method name="init" scope="prototype">
        <parameters>
          <parameter name="inRowCount" type="" usage="required"/>
          <parameter name="inKeepRows" type="" usage="required"/>
          <parameter name="inRowsPerPage" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getPageCount" scope="prototype">
        <parameters>
          <parameter name="rowCount" type="" usage="required"/>
          <parameter name="rowsPerPage" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="setKeepInfo" scope="prototype">
        <parameters>
          <parameter name="inKeepRows" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setContentNodes" scope="prototype">
        <parameters>
          <parameter name="inNodes" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultNodes" scope="prototype"/>
      <method name="invalidate" scope="prototype"/>
      <method name="updateRowCount" scope="prototype">
        <parameters>
          <parameter name="inRowCount" type="" usage="required"/>
        </parameters>
      </method>
      <method name="pageExists" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="measurePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="positionPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
          <parameter name="inPos" type="" usage="required"/>
        </parameters>
      </method>
      <method name="repositionPages" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="installPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="preparePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
          <parameter name="inReuseNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="renderPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removePage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroyPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="pacify" scope="prototype">
        <parameters>
          <parameter name="inShouldPacify" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setPacifying" scope="prototype">
        <parameters>
          <parameter name="inPacifying" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startPacify" scope="prototype"/>
      <method name="doPacify" scope="prototype"/>
      <method name="endPacify" scope="prototype"/>
      <method name="resize" scope="prototype"/>
      <method name="calcLastPageHeight" scope="prototype"/>
      <method name="updateContentHeight" scope="prototype">
        <parameters>
          <parameter name="inDh" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updatePageHeight" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
          <parameter name="fromBuild" type="" usage="required"/>
        </parameters>
      </method>
      <method name="rowHeightChanged" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="invalidateNodes" scope="prototype"/>
      <method name="createPageNode" scope="prototype"/>
      <method name="getPageHeight" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="pushPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="popPage" scope="prototype"/>
      <method name="findPage" scope="prototype">
        <parameters>
          <parameter name="inTop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
          <parameter name="inReuseNode" type="" usage="required"/>
          <parameter name="inPos" type="" usage="required"/>
        </parameters>
      </method>
      <method name="needPage" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
          <parameter name="inPos" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onscroll" scope="prototype"/>
      <method name="scroll" scope="prototype">
        <parameters>
          <parameter name="inTop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getScrollBottom" scope="prototype">
        <parameters>
          <parameter name="inTop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="processNodeEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
          <parameter name="inNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="processEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inPageNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultPageNode" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="positionPageNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inPos" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getPageNodePosition" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="invalidatePageNode" scope="prototype">
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
          <parameter name="inNodes" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getPageRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLastPageRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstVisibleRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="" usage="required"/>
          <parameter name="inPageTop" type="" usage="required"/>
          <parameter name="inScrollTop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getLastVisibleRow" scope="prototype">
        <parameters>
          <parameter name="inPage" type="" usage="required"/>
          <parameter name="inBottom" type="" usage="required"/>
          <parameter name="inScrollBottom" type="" usage="required"/>
        </parameters>
      </method>
      <method name="findTopRow" scope="prototype">
        <parameters>
          <parameter name="inScrollTop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="findScrollTop" scope="prototype">
        <parameters>
          <parameter name="inRow" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._Scroller.scrollboxNode">
    <properties>
      <property name="scrollTop" scope="prototype" type="Number"/>
      <property name="onscroll" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid._Scroller.grid" type="">
    <properties>
      <property name="scrollTop" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._InputSelectorHeaderBuilder" type="Function" classlike="true" superclass="dojox.grid._HeaderBuilder.prototype" private="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="view" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._InputSelectorHeaderBuilder.generateHtml" type="Function" classlike="true">
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.grid._InputSelectorHeaderBuilder.generateHtml.view" type="">
    <properties>
      <property name="contentWidth" scope="instance" type="Number"/>
    </properties>
  </object>
  <object location="dojox.grid._InputSelectorHeaderBuilder.doclick" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._InputSelectorHeaderBuilder.doclick.view" type="">
    <properties>
      <property name="_selectionChanging" scope="instance" type="bool"/>
    </properties>
  </object>
  <object location="dojox.grid._SelectorContentBuilder" type="Function" classlike="true" superclass="dojox.grid._ContentBuilder.prototype" private="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="view" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getCellContent" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="findTarget" scope="prototype"/>
      <method name="domouseover" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="domouseout" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._SelectorContentBuilder.generateHtml" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inDataIndex" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._SelectorContentBuilder.generateHtml.view" type="">
    <properties>
      <property name="contentWidth" scope="instance" type="Number"/>
    </properties>
  </object>
  <object location="dojox.grid._SelectorContentBuilder.doclick" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._SelectorContentBuilder.doclick.view.grid.selection" type="">
    <properties>
      <property name="mode" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._InputSelectorContentBuilder" type="Function" classlike="true" superclass="dojox.grid._SelectorContentBuilder.prototype" private="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="view" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._InputSelectorContentBuilder.getCellContent" type="Function" classlike="true">
    <properties>
      <property name="view" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="rowIndex" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._Selector" type="Function" classlike="true" superclass="dojox.grid._View">
    <summary>Custom grid view. If used in a grid structure, provides a small selectable region for grid rows.
	styling
	event handlers</summary>
    <mixins>
      <mixin scope="instance" location="dojox.grid._View"/>
    </mixins>
    <properties>
      <property name="inputType" scope="prototype" type="String"/>
      <property name="selectionMode" scope="prototype" type="String"/>
      <property name="defaultWidth" scope="prototype" type="String"/>
      <property name="noscroll" scope="prototype" type="Object"/>
      <property name="padBorderWidth" scope="prototype" type="Number"/>
      <property name="_contentBuilderClass" scope="normal" type=""/>
      <property name="contentWidth" scope="prototype" type="Number"/>
      <property name="content" scope="prototype" type="Object"/>
      <property name="header" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="getWidth" scope="prototype"/>
      <method name="resize" scope="prototype"/>
      <method name="setStructure" scope="prototype">
        <parameters>
          <parameter name="s" type="" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="prototype"/>
      <method name="doStyleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onDeselected" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._Selector.grid.selection" type="">
    <properties>
      <property name="mode" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._Selector.scrollboxNode.style" type="">
    <properties>
      <property name="overflow" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._RadioSelector.headerNode.style" type="">
    <properties>
      <property name="visibility" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._CheckBoxSelector.headerNode.style" type="">
    <properties>
      <property name="visibility" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._CheckBoxSelector.grid" type="">
    <properties>
      <property name="rowCount" scope="prototype" type=""/>
      <property name="allItemsSelected" scope="prototype" type="bool"/>
    </properties>
  </object>
  <object location="dojox.grid._Selector.headerNodeContainer.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._Expando" type="Function" classlike="true" superclass="dijit._Widget">
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="open" scope="prototype" type="Object"/>
      <property name="toggleClass" scope="prototype" type="String"/>
      <property name="itemId" scope="prototype" type="String"/>
      <property name="cellIdx" scope="prototype" type="Number"/>
      <property name="rowNode" scope="prototype" type="Object"/>
      <property name="rowIdx" scope="prototype" type="Number"/>
      <property name="expandoCell" scope="prototype" type="Object"/>
      <property name="level" scope="prototype" type="Number"/>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="_initialized" scope="prototype" type="bool"/>
      <property name="domNode" scope="prototype" type=""/>
      <property name="_tableRow" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_toggleRows" scope="prototype">
        <parameters>
          <parameter name="toggleClass" type="" usage="required"/>
          <parameter name="open" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setOpen" scope="prototype">
        <parameters>
          <parameter name="open" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setOpen" scope="prototype">
        <parameters>
          <parameter name="open" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onToggle" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setRowNode" scope="prototype">
        <parameters>
          <parameter name="rowIdx" type="" usage="required"/>
          <parameter name="rowNode" type="" usage="required"/>
          <parameter name="view" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._Expando.view"/>
  <object location="dojox.grid._Expando.view.grid" type="">
    <properties>
      <property name="store" scope="prototype" type=""/>
      <property name="treeModel" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._Expando.expandoInner" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._TreeContentBuilder" type="Function" classlike="true" superclass="dojox.grid._ContentBuilder">
    <mixins>
      <mixin scope="instance" location="dojox.grid._ContentBuilder"/>
    </mixins>
    <properties>
      <property name="view" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="generateHtml" scope="prototype">
        <parameters>
          <parameter name="inDataIndex" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="findTarget" scope="prototype">
        <parameters>
          <parameter name="inSource" type="" usage="required"/>
          <parameter name="inTag" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="prototype">
        <parameters>
          <parameter name="inRowNode" type="" usage="required"/>
          <parameter name="inCellIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="decorateEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._TreeContentBuilder.view.structure.cells" type="">
    <properties>
      <property name="0" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._TreeContentBuilder.grid" type="">
    <properties>
      <property name="store" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._TreeView" type="Function" classlike="true" superclass="dojox.grid._View">
    <mixins>
      <mixin scope="instance" location="dojox.grid._View"/>
    </mixins>
    <properties>
      <property name="_contentBuilderClass" scope="normal" type=""/>
      <property name="_expandos" scope="prototype" type="Object"/>
      <property name="grid" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_onDndDrop" scope="prototype">
        <parameters>
          <parameter name="source" type="" usage="required"/>
          <parameter name="nodes" type="" usage="required"/>
          <parameter name="copy" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_cleanupExpandoCache" scope="prototype">
        <parameters>
          <parameter name="index" type="" usage="required"/>
          <parameter name="identity" type="" usage="required"/>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="onBeforeRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="cells" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="cells" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inCellIndex" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._View" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A collection of grid columns. A grid is comprised of a set of views that stack horizontally.
	Grid creates views automatically based on grid's layout structure.
	Users should typically not need to access individual views directly.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="defaultWidth" scope="prototype" type="String">
        <summary>Default width of the view</summary>
      </property>
      <property name="viewWidth" scope="prototype" type="String">
        <summary>Width for the view, in valid css unit</summary>
      </property>
      <property name="templatePath" scope="prototype" type="Object"/>
      <property name="themeable" scope="prototype" type="bool"/>
      <property name="classTag" scope="prototype" type="String"/>
      <property name="marginBottom" scope="prototype" type="Number"/>
      <property name="rowPad" scope="prototype" type="Number"/>
      <property name="_togglingColumn" scope="prototype" type="int">
        <summary>Width of the column being toggled (-1 for none)</summary>
      </property>
      <property name="_headerBuilderClass" scope="normal" type="Object">
        <summary>The class to use for our header builder</summary>
      </property>
      <property name="_contentBuilderClass" scope="normal" type="Object">
        <summary>The class to use for our content builder</summary>
      </property>
      <property name="rowNodes" scope="prototype" type="Object"/>
      <property name="content" scope="prototype" type="Object"/>
      <property name="header" scope="prototype" type="Object"/>
      <property name="structure" scope="prototype" type=""/>
      <property name="noscroll" scope="prototype" type=""/>
      <property name="simpleStructure" scope="prototype" type="Object"/>
      <property name="flexCells" scope="prototype" type="Object"/>
      <property name="bottomMarker" scope="prototype" type="Object"/>
      <property name="topMarker" scope="prototype" type="Object"/>
      <property name="arrowDim" scope="prototype" type="Object"/>
      <property name="_source_conn" scope="prototype" type="Object"/>
      <property name="_source_sub" scope="prototype" type="Object"/>
      <property name="_removingColumn" scope="prototype" type="bool"/>
      <property name="index" scope="prototype" type=""/>
      <property name="contentWidth" scope="prototype" type="Object"/>
      <property name="_hasHScroll" scope="prototype" type="bool"/>
      <property name="_hasVScroll" scope="prototype" type="bool"/>
      <property name="contentNode" scope="prototype" type=""/>
      <property name="lastTop" scope="prototype" type="Number"/>
      <property name="firstScroll" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
      <method name="focus" scope="prototype"/>
      <method name="setStructure" scope="prototype">
        <parameters>
          <parameter name="inStructure" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onBeforeRow" scope="prototype"/>
      <method name="_onAfterRow" scope="prototype"/>
      <method name="_cleanupRowWidgets" scope="prototype">
        <parameters>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="cells" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onAfterRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="cells" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="testFlexCells" scope="prototype"/>
      <method name="updateStructure" scope="prototype"/>
      <method name="getScrollbarWidth" scope="prototype">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="getColumnsWidth" scope="prototype">
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="setColumnsWidth" scope="prototype">
        <parameters>
          <parameter name="width" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getWidth" scope="prototype">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getContentWidth" scope="prototype">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="render" scope="prototype"/>
      <method name="_hide" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onDndDropBefore" scope="prototype">
        <parameters>
          <parameter name="source" type="" usage="required"/>
          <parameter name="nodes" type="" usage="required"/>
          <parameter name="copy" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onDndDrop" scope="prototype">
        <parameters>
          <parameter name="source" type="" usage="required"/>
          <parameter name="nodes" type="" usage="required"/>
          <parameter name="copy" type="" usage="required"/>
        </parameters>
      </method>
      <method name="renderHeader" scope="prototype"/>
      <method name="_getHeaderContent" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype"/>
      <method name="hasHScrollbar" scope="prototype">
        <parameters>
          <parameter name="reset" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="hasVScrollbar" scope="prototype">
        <parameters>
          <parameter name="reset" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="convertColPctToFixed" scope="prototype"/>
      <method name="adaptHeight" scope="prototype">
        <parameters>
          <parameter name="minusScroll" type="" usage="required"/>
        </parameters>
      </method>
      <method name="adaptWidth" scope="prototype"/>
      <method name="setSize" scope="prototype">
        <parameters>
          <parameter name="w" type="" usage="required"/>
          <parameter name="h" type="" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="buildRowContent" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getCellNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inCellIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getHeaderCellNode" scope="prototype">
        <parameters>
          <parameter name="inCellIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="styleRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="styleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doStyleRowNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inRowNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doscroll" scope="prototype">
        <parameters>
          <parameter name="inEvent" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="prototype">
        <parameters>
          <parameter name="inTop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doContentEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doHeaderEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchContentEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchHeaderEvent" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setColWidth" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
          <parameter name="inWidth" type="" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid._View.headerNodeContainer.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._View.scrollboxNode.style" type="">
    <properties>
      <property name="overflow" scope="prototype" type="String"/>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._View.headerContentNode.firstChild.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._View.grid.layout" type="">
    <properties>
      <property name="cells" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._View.source">
    <properties>
      <property name="_targetNode" scope="prototype" type=""/>
      <property name="_beforeTarget" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._View.grid.views" type="">
    <properties>
      <property name="views" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._View.grid" type="">
    <properties>
      <property name="initialWidth" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid._View.headerContentNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid._View.domNode" type="">
    <properties>
      <property name="clientHeight" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._View.contentNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._View.headerNode" type="">
    <properties>
      <property name="scrollLeft" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._View.domNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._View.headerNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._View.scrollboxNode" type="">
    <properties>
      <property name="scrollLeft" scope="prototype" type=""/>
      <property name="scrollTop" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._GridAvatar" type="Function" classlike="true" superclass="dojo.dnd.Avatar">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Avatar"/>
    </mixins>
    <properties>
      <property name="node" scope="prototype" type=""/>
      <property name="oldOffsetY" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="construct" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid._GridAvatar.manager" type="">
    <properties>
      <property name="source" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._ViewManager" type="Function" classlike="true">
    <summary>A collection of grid views. Owned by grid and used internally for managing grid views.</summary>
    <description>Grid creates views automatically based on grid's layout structure.
	Users should typically not need to access individual views or the views collection directly.</description>
    <properties>
      <property name="defaultWidth" scope="prototype" type="Number"/>
      <property name="grid" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype"/>
      <method name="render" scope="prototype"/>
      <method name="addView" scope="prototype">
        <parameters>
          <parameter name="inView" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroyViews" scope="prototype"/>
      <method name="getContentNodes" scope="prototype"/>
      <method name="forEach" scope="prototype">
        <parameters>
          <parameter name="inCallback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onEach" scope="prototype">
        <parameters>
          <parameter name="inMethod" type="" usage="required"/>
          <parameter name="inArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="normalizeHeaderNodeHeight" scope="prototype"/>
      <method name="normalizeRowNodeHeights" scope="prototype">
        <parameters>
          <parameter name="inRowNodes" type="" usage="required"/>
        </parameters>
      </method>
      <method name="resetHeaderNodeHeight" scope="prototype"/>
      <method name="renormalizeRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getViewWidth" scope="prototype">
        <parameters>
          <parameter name="inIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="measureHeader" scope="prototype"/>
      <method name="measureContent" scope="prototype"/>
      <method name="findClient" scope="prototype">
        <parameters>
          <parameter name="inAutoWidth" type="" usage="required"/>
        </parameters>
      </method>
      <method name="arrange" scope="prototype">
        <parameters>
          <parameter name="l" type="" usage="required"/>
          <parameter name="w" type="" usage="required"/>
        </parameters>
      </method>
      <method name="renderRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inNodes" type="" usage="required"/>
          <parameter name="skipRenorm" type="" usage="required"/>
        </parameters>
      </method>
      <method name="rowRemoved" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="skipRenorm" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateRowStyles" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="prototype">
        <parameters>
          <parameter name="inTop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstScrollingView" scope="prototype">
        <summary>Returns the first grid view with a scroll bar</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.grid._ViewManager.views" type="Array">
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid._DeferredTextWidget" type="Function" classlike="true" superclass="dijit._Widget">
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="deferred" scope="prototype" type="Object"/>
      <property name="_destroyOnRemove" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid.cells">
    <properties>
      <property name="_base" scope="normal" type="Object"/>
      <property name="dijit" scope="normal" type="Object"/>
      <property name="tree" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.cells._Base" type="Function" classlike="true">
    <summary>Respresents a grid cell and contains information about column options and methods
	for retrieving cell related information.
	Each column in a grid layout has a cell object and most events and many methods
	provide access to these objects.
	private</summary>
    <properties>
      <property name="styles" scope="prototype" type="String"/>
      <property name="classes" scope="prototype" type="String"/>
      <property name="editable" scope="prototype" type="bool"/>
      <property name="alwaysEditing" scope="prototype" type="bool"/>
      <property name="formatter" scope="prototype" type="Object"/>
      <property name="defaultValue" scope="prototype" type="String"/>
      <property name="value" scope="prototype" type="Object"/>
      <property name="hidden" scope="prototype" type="bool"/>
      <property name="noresize" scope="prototype" type="bool"/>
      <property name="draggable" scope="instance-prototype" type="Object"/>
      <property name="_valueProp" scope="prototype" type="String"/>
      <property name="_formatPending" scope="prototype" type="bool"/>
      <property name="unitWidth" scope="prototype" type=""/>
      <property name="_props" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inProps" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inProps" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_defaultFormat" scope="prototype">
        <parameters>
          <parameter name="inValue" type="" usage="required"/>
          <parameter name="callArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="prototype">
        <summary>provides the html for a given grid cell.</summary>
        <return-description>html for a given grid cell</return-description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
          <parameter name="inItem" type="" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="prototype">
        <summary>formats the cell for editing</summary>
        <return-description>string of html to place in grid cell</return-description>
        <parameters>
          <parameter name="inDatum" type="anything" usage="required">
            <summary>cell data to edit</summary>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getNode" scope="prototype">
        <summary>gets the dom node for a given grid cell.</summary>
        <return-description>dom node for a given grid cell</return-description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getHeaderNode" scope="prototype"/>
      <method name="getEditNode" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="canResize" scope="prototype"/>
      <method name="isFlex" scope="prototype"/>
      <method name="applyEdit" scope="prototype">
        <parameters>
          <parameter name="inValue" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="cancelEdit" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onEditBlur" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="registerOnBlur" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="needFormatNode" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="cancelFormatNode" scope="prototype"/>
      <method name="_formatNode" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <summary>format the editing dom node. Use when editor is a widget.</summary>
        <parameters>
          <parameter name="inNode" type="dom" usage="required">
            <summary>node
	dom node for the editor</summary>
          </parameter>
          <parameter name="inDatum" type="anything" usage="required">
            <summary>cell data to edit</summary>
          </parameter>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="dispatchEvent" scope="prototype">
        <parameters>
          <parameter name="m" type="" usage="required"/>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>returns value entered into editor</summary>
        <return-description>value of editor</return-description>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>set the value of the grid editor</summary>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
          <parameter name="inValue" type="anything" usage="required">
            <summary>value of editor</summary>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <summary>focus the grid editor</summary>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
          <parameter name="inNode" type="dom" usage="required">
            <summary>node
	editor node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="save" scope="prototype">
        <summary>save editor state</summary>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="restore" scope="prototype">
        <summary>restore editor state</summary>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_finish" scope="prototype">
        <summary>called when editing is completed to clean up editor</summary>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="apply" scope="prototype">
        <summary>apply edit from cell editor</summary>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="cancel" scope="prototype">
        <summary>cancel cell edit</summary>
        <parameters>
          <parameter name="inRowIndex" type="int" usage="required">
            <summary>grid row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cellDef" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells._Base.grid" type="">
    <properties>
      <property name="formatterScope" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.cells._Base.grid.edit" type="">
    <properties>
      <property name="info" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.cells.Cell" type="Function" classlike="true" superclass="dojox.grid.cells._Base">
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells._Base"/>
    </mixins>
    <properties>
      <property name="keyFilter" scope="instance-prototype" type="RegExp">
        <summary>optional regex for disallowing keypresses</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="formatEditing" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doKey" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cellDef" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.RowIndex" type="Function" classlike="true" superclass="dojox.grid.cells.Cell">
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells.Cell"/>
    </mixins>
    <properties>
      <property name="name" scope="prototype" type="String"/>
      <property name="editable" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method constructor="postscript" name="postscript" scope="prototype"/>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cellDef" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.Select" type="Function" classlike="true" superclass="dojox.grid.cells.Cell">
    <summary>grid cell that provides a standard select for editing</summary>
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells.Cell"/>
    </mixins>
    <properties>
      <property name="options" scope="prototype" type="Array">
        <summary>text of each item</summary>
      </property>
      <property name="values" scope="instance-prototype" type="Array">
        <summary>value for each item</summary>
      </property>
      <property name="returnIndex" scope="prototype" type="Integer">
        <summary>editor returns only the index of the selected option and not the value</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cell" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.AlwaysEdit" type="Function" classlike="true" superclass="dojox.grid.cells.Cell">
    <summary>grid cell that is always in an editable state, regardless of grid editing state</summary>
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells.Cell"/>
    </mixins>
    <properties>
      <property name="alwaysEditing" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_formatNode" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="applyStaticValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cell" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.AlwaysEdit.grid" type="">
    <properties>
      <property name="edit" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.cells.Bool" type="Function" classlike="true" superclass="dojox.grid.cells.AlwaysEdit">
    <summary>grid cell that provides a standard checkbox that is always on for editing</summary>
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells.AlwaysEdit"/>
    </mixins>
    <properties>
      <property name="_valueProp" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="formatEditing" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cell" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells._Widget" type="Function" classlike="true" superclass="dojox.grid.cells._Base">
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells._Base"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="instance" type="Object"/>
      <property name="widget" scope="instance-prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
        </parameters>
      </method>
      <method name="formatEditing" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="attachWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sizeWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_finish" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cell" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.ComboBox" type="Function" classlike="true" superclass="dojox.grid.cells._Widget">
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells._Widget"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="normal" type=""/>
      <property name="widget" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getWidgetProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="prototype"/>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cell" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.DateTextBox" type="Function" classlike="true" superclass="dojox.grid.cells._Widget">
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells._Widget"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getWidgetProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cell" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.CheckBox" type="Function" classlike="true" superclass="dojox.grid.cells._Widget">
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells._Widget"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getValue" scope="prototype"/>
      <method name="setValue" scope="prototype">
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sizeWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cell" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.Editor" type="Function" classlike="true" superclass="dojox.grid.cells._Widget">
    <mixins>
      <mixin scope="instance" location="dojox.grid.cells._Widget"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="normal" type=""/>
      <property name="content" scope="prototype" type=""/>
      <property name="widget" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getWidgetProps" scope="prototype">
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createWidget" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="formatNode" scope="prototype">
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="populateEditor" scope="prototype"/>
      <method name="markupFactory" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="cell" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.TreeCell"/>
  <object location="dojox.grid.cells.TreeCell.formatAggregate" type="Function" classlike="true">
    <properties>
      <property name="grid" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inItem" type="" usage="required"/>
          <parameter name="level" type="" usage="required"/>
          <parameter name="inRowIndexes" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.TreeCell.formatAggregate.grid.edit" type="">
    <properties>
      <property name="info" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.cells.TreeCell.formatIndexes" type="Function" classlike="true">
    <properties>
      <property name="grid" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inRowIndexes" type="" usage="required"/>
          <parameter name="inItem" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.TreeCell.formatIndexes.grid.edit" type="">
    <properties>
      <property name="info" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.cells.TreeCell.getOpenState" type="Function" classlike="true">
    <properties>
      <property name="openStates" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="itemId" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.TreeCell.getOpenState.grid" type="">
    <properties>
      <property name="store" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.cells.TreeCell.formatAtLevel" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inRowIndexes" type="" usage="required"/>
          <parameter name="inItem" type="" usage="required"/>
          <parameter name="level" type="" usage="required"/>
          <parameter name="summaryRow" type="" usage="required"/>
          <parameter name="toggleClass" type="" usage="required"/>
          <parameter name="cellClasses" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.TreeCell.formatAtLevel.grid" type="">
    <properties>
      <property name="store" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced">
    <properties>
      <property name="_Builder" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._BuilderMixin" type="Function" classlike="true">
    <summary>Common methods shared between dojox.grid.enhanced._HeaderBuilder and dojox.grid.enhanced._ContentBuilder</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="generateCellMarkup" scope="prototype">
        <summary>Overwritten, see dojox.grid._Builder.generateCellMarkup()
	Add special css classes when nested sorting is on</summary>
        <parameters>
          <parameter name="inCell" type="" usage="required"/>
          <parameter name="inMoreStyles" type="" usage="required"/>
          <parameter name="inMoreClasses" type="" usage="required"/>
          <parameter name="isHeader" type="" usage="required"/>
        </parameters>
      </method>
      <method name="domouseup" scope="prototype">
        <summary>Handler when there is a mouse up event either in header or grid content</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The mouse up event</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced._HeaderBuilder" type="Function" classlike="true" superclass="dojox.grid._HeaderBuilder">
    <summary>Extending dojox.grid._HeaderBuilder to overwrite some default behavior</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.grid.enhanced._BuilderMixin.prototype"/>
      <mixin scope="instance" location="dojox.grid._HeaderBuilder"/>
      <mixin scope="instance" location="dojox.grid.enhanced._BuilderMixin"/>
    </mixins>
    <properties>
      <property name="minColWidth" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getCellX" scope="prototype">
        <summary>Overwritten, see dojox.grid._HeaderBuilder.getCellX()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="decorateEvent" scope="prototype">
        <summary>Overwritten, see dojox.grid._HeaderBuilder.decorateEvent()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doclick" scope="prototype">
        <summary>Overwritten, see dojox.grid._HeaderBuilder.doclick()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="colResizeSetup" scope="prototype">
        <summary>Overwritten, see dojox.grid._HeaderBuilder.colResizeSetup()
	Set minimal column width for unfixed cells when nested sorting is on</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
          <parameter name="isMouse" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced._ContentBuilder" type="Function" classlike="true" superclass="dojox.grid._ContentBuilder">
    <summary>Extending dojox.grid._ContentBuilder to overwrite some default behavior</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.grid.enhanced._BuilderMixin.prototype"/>
      <mixin scope="instance" location="dojox.grid._ContentBuilder"/>
      <mixin scope="instance" location="dojox.grid.enhanced._BuilderMixin"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.grid.enhanced._Events" type="Function" classlike="true">
    <summary>Overwrite some default events of DataGrid</summary>
    <description>Methods are copied or replaced for overwriting, this might be refined once
	an overall plugin architecture is set up for DataGrid.</description>
    <properties>
      <property name="_events" scope="instance-prototype" type="Object">
        <summary>Method map cached from dojox.grid._Events().</summary>
      </property>
      <property name="headerCellActiveClass" scope="prototype" type="String">
        <summary>css class to apply to grid header cells when activated(mouse down)</summary>
      </property>
      <property name="cellActiveClass" scope="prototype" type="String">
        <summary>css class to apply to grid content cells when activated(mouse down)</summary>
      </property>
      <property name="rowActiveClass" scope="prototype" type="String">
        <summary>css class to apply to grid rows when activated(mouse down)</summary>
      </property>
      <property name="selectRegionHoverClass" scope="prototype" type="String">
        <summary>css class to apply to select regions in header cells when mouse over</summary>
      </property>
      <property name="inDNDKeySelectingColumnMode" scope="prototype" type="Object"/>
      <property name="inDNDKeySelectingRowMode" scope="prototype" type="Object"/>
      <property name="isDndSelectEnable" scope="prototype" type=""/>
      <property name="rowSelectCell" scope="prototype" type="Object"/>
      <property name="p" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onStyleRow" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onStyleRow()</summary>
        <parameters>
          <parameter name="inRow" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dokeyup" scope="prototype">
        <summary>Grid key up event handler.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Un-decorated event object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onKeyDown" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onKeyDown()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onMouseDown()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>New - Event fired when mouse is up inside grid.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object that contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseOutRow" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onMouseOutRow()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDownRow" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onMouseDownRow()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseOver" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onCellMouseOver()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseOut" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onCellMouseOut()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseDown" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onCellMouseDown()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCellMouseUp" scope="prototype">
        <summary>New - Event fired when mouse is up inside content cell.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object that contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCellClick" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onCellClick()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCellDblClick" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onCellDblClick()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRowClick" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onRowClick()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRowMouseOver" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onRowMouseOver()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRowMouseOut" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onRowMouseOut()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRowContextMenu" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onRowContextMenu()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSelectedRegionContextMenu" scope="prototype">
        <summary>New - Event fired when a selected region context menu is accessed via mouse right click.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid and info of selected
	regions(selection type - row|column, selected index - [...])</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOver" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onHeaderCellMouseOver()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseOut" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onHeaderCellMouseOut()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellMouseDown" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onHeaderCellMouseDown()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="always return for oncontextmenu event to only show menu"/>
        </return-types>
      </method>
      <method name="onHeaderCellMouseUp" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onHeaderCellMouseUp()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderCellClick" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onHeaderCellClick()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="ignore if under column selection"/>
        </return-types>
      </method>
      <method name="onHeaderContextMenu" scope="prototype">
        <summary>Overwritten, see dojox.grid._Events.onHeaderContextMenu()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced._Events.select" type="">
    <properties>
      <property name="keepState" scope="prototype" type="bool"/>
      <property name="extendSelect" scope="prototype" type="bool"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Events.focus" type="">
    <properties>
      <property name="focusView" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Events.select.drugSelectionStart" type="">
    <properties>
      <property name="colIndex" scope="prototype" type=""/>
      <property name="rowIndex" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Events._click" type="">
    <properties>
      <property name="0" scope="prototype" type=""/>
      <property name="1" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Plugin" type="Function" classlike="true">
    <summary>Singleton plugin manager</summary>
    <description>Plugin manager is responsible for
	1. Loading required plugins
	2. Handling collaboration and dependencies among plugins
	3. Overwriting some default behavior of DataGrid
	Note: Mixin and method caching are used for #3, this might be refined once
	an overall plugin architecture is set up for DataGrid.
	Some plugin dependencies:
	- DnD plugin depends on NestedSorting plugin
	- RowSelector should be used for DnD plugin.
	e.g. &lt;div dojoType="dojox.grid.EnhancedGrid"  plugins='{dnd: true, ...}}' rowSelector="20px" .../&gt;
	- "columnReordering" attribute won't work when either DnD or Indirect Selections plugin is on.</description>
    <properties>
      <property name="fixedCellNum" scope="prototype" type="Integer">
        <summary>Number of fixed cells(columns), e.g. cell(column) of indirect selection is fixed and can't be moved</summary>
      </property>
      <property name="rowSelectionChangedTopic" scope="prototype" type="String">
        <summary>Topic fired when row selection is changed</summary>
      </property>
      <property name="sortRowSelectionChangedTopic" scope="prototype" type="String">
        <summary>Topic only fired when row selection is changed by sorting.</summary>
      </property>
      <property name="rowMovedTopic" scope="prototype" type="String">
        <summary>Topic fired when selected rows are moved.</summary>
      </property>
      <property name="_colHeadNode" scope="prototype" type="Object"/>
      <property name="_colHeadFocusIdx" scope="prototype" type="Object"/>
      <property name="lastTop" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_parseProps" scope="prototype">
        <summary>Parse plugins properties</summary>
        <parameters>
          <parameter name="grid" type="Grid" usage="required">
            <summary>Grid this plugin manager belongs to</summary>
          </parameter>
        </parameters>
      </method>
      <method name="preInit" scope="prototype">
        <summary>Pre initialization, some plugins must be loaded before DataGrid.postCreate().
	See EnhancedGrid.postCreate()</summary>
      </method>
      <method name="postInit" scope="prototype">
        <summary>Post initialization, by default, plugins are loaded after DataGrid.postCreate().
	See EnhancedGrid.postCreate()</summary>
      </method>
      <method name="getPluginClazz" scope="prototype">
        <summary>Load target plugin which must be already required (dojo.require(..))</summary>
        <parameters>
          <parameter name="clazzStr" type="String" usage="required">
            <summary>Plugin class name</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isFixedCell" scope="prototype">
        <summary>See if target cell(column) is fixed or not.</summary>
        <parameters>
          <parameter name="cell" type="Object" usage="required">
            <summary>Target cell(column)
	return: Boolean
	True - fixed| False - not fixed</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getFixedCellNumber" scope="prototype">
        <summary>See if target cell(column) is fixed or not.
	return: Number
	True - fixed| False - not fixed</summary>
      </method>
      <method name="inSingleSelection" scope="prototype">
        <summary>See if Grid is in single selection mode
	return: Boolean
	True - in single selection mode | False - not in single selection mode</summary>
      </method>
      <method name="needUpdateRow" scope="prototype">
        <summary>See if needed to update row. See this.updateRow()
	return: Boolean
	True - need update row | False - don't update row</summary>
      </method>
      <method name="_bindFuncs" scope="prototype">
        <summary>Overwrite some default methods of DataGrid by method caching</summary>
      </method>
      <method name="setColumnsWidth" scope="prototype">
        <summary>Overwrite _View.setColumnsWidth(), &amp;quot;this&amp;quot; - _View scope
	Fix rtl issue in IE.</summary>
        <parameters>
          <parameter name="width" type="" usage="required"/>
        </parameters>
      </method>
      <method name="previousKey" scope="prototype">
        <summary>Overwrite _FocusManager.previousKey(), &amp;quot;this&amp;quot; - _FocusManager scope</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="prototype">
        <summary>Overwrite _FocusManager.nextKey(), &amp;quot;this&amp;quot; - _FocusManager scope</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="renderPage" scope="prototype">
        <summary>Overwrite _Scroller.renderPage(), &amp;quot;this&amp;quot; - _Scroller scope
	To add progress cursor when rendering the indirect selection cell(column) with checkbox</summary>
        <parameters>
          <parameter name="inPageIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateRow" scope="prototype">
        <summary>Overwrite _Scroller.renderPage(), &amp;quot;this&amp;quot; - _Grid scope</summary>
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getEditNode" scope="prototype">
        <summary>Overwrite dojox.grid.cells._Base.getEditNode, &amp;quot;this&amp;quot; - _Base scope</summary>
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sizeWidget" scope="prototype">
        <summary>Overwrite dojox.grid.cells._Widget.sizeWidget, &amp;quot;this&amp;quot; - _Widget scope</summary>
        <parameters>
          <parameter name="inNode" type="" usage="required"/>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setScrollTop" scope="prototype">
        <summary>Overwrite dojox.grid._View.setScrollTop, &amp;quot;this&amp;quot; - _View scope</summary>
        <parameters>
          <parameter name="inTop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getViewByCellIdx" scope="prototype">
        <summary>Find view that contains the cell with 'cellIdx'</summary>
        <parameters>
          <parameter name="cellIdx" type="Integer" usage="required">
            <summary>Index of target cell
	return: Object
	Matched view</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced._Plugin.grid" type="">
    <properties>
      <property name="rowSelector" scope="prototype" type="String"/>
      <property name="isDndSelectEnable" scope="prototype" type=""/>
      <property name="dndDisabledTypes" scope="prototype" type="Array"/>
      <property name="updateRow" scope="prototype" type=""/>
      <property name="lastRenderingRowIdx" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Plugin.grid.constructor.prototype" type="">
    <properties>
      <property name="startup" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Plugin.funcMap">
    <summary>Map for caching default DataGrid methods.</summary>
    <properties>
      <property name="nextKey" scope="prototype" type=""/>
      <property name="previousKey" scope="prototype" type=""/>
      <property name="renderPage" scope="prototype" type=""/>
      <property name="updateRow" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Plugin.grid.focus" type="">
    <properties>
      <property name="nextKey" scope="prototype" type=""/>
      <property name="previousKey" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Plugin.grid.scroller" type="">
    <properties>
      <property name="renderPage" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Plugin.headerContentNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Plugin.headerContentNode.parentNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Plugin.scrollboxNode" type="">
    <properties>
      <property name="scrollTop" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced._Plugin.grid.views" type="">
    <properties>
      <property name="views" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd"/>
  <object location="dojox.grid.enhanced.dnd._DndBuilder" type="Function" classlike="true">
    <summary>This class declaration is used to be mixed in to dojox.grid._Builder
	to enable the _Builder to handle mouse up event for DND feature</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="domouseup" scope="prototype">
        <summary>Handle when there is a mouse up event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The mouse up event</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndHeaderBuilder" type="Function" classlike="true">
    <summary>This class declaration is used to be mixed in to dojox.grid._HeadBuilder
	to enable the _HeadBuilder to handle mouse up event for DND feature</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="domouseup" scope="prototype">
        <summary>Handle when there is a mouse up event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The mouse up event</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndEvents" type="Function" classlike="true">
    <summary>This class declaration is used to be mixed in to dojox.grid._Event
	to enable the _Event to handle several events for DND feature</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="onMouseUp" scope="prototype">
        <summary>Event fired when mouse is up inside grid.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object that contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onMouseUpRow" scope="prototype">
        <summary>Event fired when mouse is up inside grid row</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object that contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onCellMouseUp" scope="prototype">
        <summary>Event fired when mouse is up in a cell.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRowHeaderMouseDown" scope="prototype">
        <summary>Handle when there is a mouse down event on row header (row bar),
	Call the dnd select to add the row to select</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The mouse down event
	blur column header focus</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="alwarys return for oncontextmenu event to only show menu"/>
        </return-types>
      </method>
      <method name="onRowHeaderMouseUp" scope="prototype">
        <summary>Handle when there is a mouse up event on row header (row bar),</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The mouse up event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseUp" scope="prototype">
        <summary>Event fired when mouse is up in a row.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndEvents.focus" type="">
    <properties>
      <property name="_colHeadNode" scope="prototype" type="Object"/>
      <property name="_colHeadFocusIdx" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndEvents.select" type="">
    <properties>
      <property name="keepState" scope="prototype" type=""/>
      <property name="extendSelect" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndFocusManager" type="Function" classlike="true">
    <summary>This class declaration is used to be mixed in to dojox.grid._FocusManager
	to enable  DND feature by changing some focus behavior in _FocusManager</summary>
    <properties>
      <property name="_rowBarFocusIdy" scope="prototype" type="Integer">
        <summary>The value of the ID, which is from the row node that is focused</summary>
      </property>
      <property name="rowIndex" scope="prototype" type=""/>
      <property name="_colHeadFocusIdx" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="isRowBar" scope="prototype">
        <summary>states whether currently navigating among row bar nodes.</summary>
        <return-description>true if focus is on a row bar node; false otherwise.</return-description>
      </method>
      <method name="getRowBarNode" scope="prototype">
        <summary>get a reference of a row bar DOM node which has the same idx value with inIdx</summary>
        <parameters>
          <parameter name="inIdx" type="Integer" usage="required">
            <summary>The idx value of the row bar DOM node that will be got</summary>
          </parameter>
        </parameters>
      </method>
      <method name="focusRowBar" scope="prototype">
        <summary>Move the focud to the first row bar node</summary>
      </method>
      <method name="focusRowBarNode" scope="prototype">
        <summary>move the focus to the row bar DOM node with the row index same as rowIndex</summary>
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required">
            <summary>The row index value of the row bar node that will be focused</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_blurRowBar" scope="prototype">
        <summary>blur the focus on the focused row bar node</summary>
      </method>
      <method name="focusNextRowBar" scope="prototype">
        <summary>move the focus to the next row bar node of the the current focused node</summary>
      </method>
      <method name="focusPrevRowBar" scope="prototype">
        <summary>move the focus to the previous row bar node of the the current focused node</summary>
      </method>
      <method name="getFocusedRowIndex" scope="prototype">
        <summary>get the index of the node which is focused
	return: Integer
	the index of the node which is focused</summary>
      </method>
      <method name="scrollRowBarIntoView" scope="prototype">
        <summary>scroll the row bar view to make the focused row bar show in the view</summary>
      </method>
      <method name="focusHeaderNode" scope="prototype">
        <summary>move the focus to col header</summary>
        <parameters>
          <parameter name="inHeaderNodeIdx" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndFocusManager._rowBarNode" private="true">
    <summary>reference to a row bar DOM node</summary>
    <properties>
      <property name="tabIndex" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndFocusManager.grid" type="">
    <properties>
      <property name="scroller" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndFocusManager.cell">
    <properties>
      <property name="view" scope="prototype" type=""/>
    </properties>
    <methods>
      <method name="getNode" scope="prototype">
        <parameters>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndGrid" type="Function" classlike="true" superclass="dojox.grid.enhanced.dnd._DndEvents">
    <summary>This class declaration is used to be mixed in to dojox.grid._Grid
	to enable DND feature in _Grid.</summary>
    <mixins>
      <mixin scope="instance" location="dojox.grid.enhanced.dnd._DndEvents"/>
    </mixins>
    <properties>
      <property name="select" scope="instance-prototype" type="_DndSelectingManager">
        <summary>handle the DND selecting operation</summary>
      </property>
      <property name="dndSelectable" scope="prototype" type="Boolean">
        <summary>whether the DND feature is enabled for the grid</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="dndManager" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>constructor, store the reference of the instance of_DndSelectingManager</summary>
        <parameters>
          <parameter name="dndManager" type="" usage="required"/>
        </parameters>
      </method>
      <method name="domousedown" scope="prototype">
        <summary>handle the mouse down event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>the mouse down event on grid</summary>
          </parameter>
        </parameters>
      </method>
      <method name="domouseup" scope="prototype">
        <summary>handle the mouse up event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>the mouse up event on grid</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMover" type="Function" classlike="true" superclass="dojo.dnd.Mover">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Mover"/>
    </mixins>
    <properties>
      <property name="marginBox" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onMouseMove" scope="prototype">
        <summary>Overwritten, see dojo.dnd.Mover.onMouseMove()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndBoxConstrainedMoveable" type="Function" classlike="true" superclass="dojo.dnd.move.boxConstrainedMoveable">
    <mixins>
      <mixin scope="instance" location="dojo.dnd.move.boxConstrainedMoveable"/>
    </mixins>
    <properties>
      <property name="movingType" scope="instance-prototype" type="String">
        <summary>Row moving - 'row' or column moving - 'col'</summary>
      </property>
      <property name="constraintBox" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstMove" scope="prototype">
        <summary>Overwritten, see dojo.dnd.move.constrainedMoveable.onFirstMove()</summary>
        <parameters>
          <parameter name="mover" type="dojo.dnd.Mover" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager" type="Function" classlike="true" superclass="dojox.grid.enhanced.dnd._DndSelectingManager">
    <summary>_DndMovingManager is used to enable grid DND moving feature</summary>
    <mixins>
      <mixin scope="instance" location="dojox.grid.enhanced.dnd._DndSelectingManager"/>
    </mixins>
    <properties>
      <property name="exceptRowsTo" scope="prototype" type="Integer">
        <summary>the value to which that rows, that should not be moved, with index from the -1</summary>
      </property>
      <property name="exceptColumnsTo" scope="instance-prototype" type="Integer">
        <summary>the value to which that columns, that should not be moved, with index from the -1</summary>
      </property>
      <property name="movers" scope="instance-prototype" type="Array">
        <summary>the list that keep the reference to all dnd movers for DND moving</summary>
      </property>
      <property name="scrollbarHeight" scope="prototype" type="Number"/>
      <property name="headerHeight" scope="prototype" type=""/>
      <property name="movingIgnored" scope="prototype" type="bool"/>
      <property name="srcIndexdelta" scope="prototype" type="Number"/>
      <property name="avaOnRowIndex" scope="prototype" type="Number"/>
      <property name="drugDestIndex" scope="prototype" type="Number"/>
      <property name="drugBefore" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>constructor, set the exceptColumnsTo value if the indirect selection feature is enabled</summary>
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getGridWidth" scope="prototype">
        <summary>get the width of the grid
	return: Integer
	the width of the grid</summary>
      </method>
      <method name="isColSelected" scope="prototype">
        <summary>whether the specified column is selected</summary>
        <parameters>
          <parameter name="inColIndex" type="Integer" usage="required">
            <summary>the index value of the column
	return: Boolean
	whether the specified column is selected</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getHScrollBarHeight" scope="prototype">
        <summary>get the horizontal sroll bar height
	return: Integer
	the horizontal sroll bar height</summary>
      </method>
      <method name="getExceptionalColOffsetWidth" scope="prototype">
        <summary>get the width of all un-movable columns
	return: Integer
	the width of all un-movable columns</summary>
      </method>
      <method name="getGridCoords" scope="prototype">
        <summary>get the coords values of the grid</summary>
        <parameters>
          <parameter name="noCache" type="Boolean" usage="required">
            <summary>force a realtime calculation
	return: Object
	the coords values of the grid</summary>
          </parameter>
        </parameters>
      </method>
      <method name="createAvatar" scope="prototype">
        <parameters>
          <parameter name="width" type="Integer" usage="required">
            <summary>width of avatar</summary>
          </parameter>
          <parameter name="height" type="Integer" usage="required">
            <summary>height of avatar</summary>
          </parameter>
          <parameter name="left" type="Integer" usage="required">
            <summary>left position of avatar</summary>
          </parameter>
          <parameter name="top" type="Integer" usage="required">
            <summary>top position of avatar</summary>
          </parameter>
          <parameter name="includeHScroll" type="Boolean" usage="required">
            <summary>whether to include the H-scroll height
	Return: Dom node
	the avatar DIV node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="handleESC" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>the keydown event</summary>
          </parameter>
          <parameter name="select" type="_DndSelectingManager" usage="required">
            <summary>the reference to the instance of _DndSelectingManager</summary>
          </parameter>
        </parameters>
      </method>
      <method name="cancelDND" scope="prototype"/>
      <method name="createCoverMover" scope="prototype">
        <parameters>
          <parameter name="width" type="" usage="required"/>
          <parameter name="height" type="" usage="required"/>
          <parameter name="left" type="" usage="required"/>
          <parameter name="top" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getBorderDiv" scope="prototype">
        <summary>get the border DIV that is used identify the moving position
	return: Object
	the border DIV that is used identify the moving position</summary>
      </method>
      <method name="setBorderDiv" scope="prototype">
        <summary>set the position and shape of the border DIV that is used identify the moving position</summary>
        <parameters>
          <parameter name="width" type="Integer" usage="required"/>
          <parameter name="height" type="Integer" usage="required"/>
          <parameter name="left" type="Integer" usage="required"/>
          <parameter name="top" type="Integer" usage="required">
            <summary>the position and shape of the border DIV</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeOtherMovers" scope="prototype">
        <summary>remove other movers than the specified one</summary>
        <parameters>
          <parameter name="id" type="Integer" usage="required">
            <summary>the id of the specified mover</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addColMovers" scope="prototype"/>
      <method name="addColMover" scope="prototype">
        <parameters>
          <parameter name="leadingBorderIdx" type="Integer" usage="required">
            <summary>the first column index for mover to cover</summary>
          </parameter>
          <parameter name="trailingBorderIdx" type="Integer" usage="required">
            <summary>the last column index for mover to cover
	console.debug(&amp;quot;add mover: &amp;quot; + this.lock + &amp;quot;  l=&amp;quot; + leadingBorderIdx);</summary>
          </parameter>
        </parameters>
      </method>
      <method name="normalizeColMoverCoords" scope="prototype">
        <parameters>
          <parameter name="leftPosition" type="Integer" usage="required">
            <summary>Left side x coordinate of column mover</summary>
          </parameter>
          <parameter name="rightPosition" type="Integer" usage="required">
            <summary>Right side x coordinate of column mover</summary>
          </parameter>
          <parameter name="leadingBorderIdx" type="Integer" usage="required">
            <summary>The leftmost column index for mover to cover</summary>
          </parameter>
          <parameter name="trailingBorderIdx" type="Integer" usage="required">
            <summary>The rightmost column index for mover to cover
	return:Object
	Normalized width and coordinates, e.g.{'w': 100, 'h': 200, 'l': 150, 'r': 250, 'colH': 50}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="moveColBorder" scope="prototype">
        <parameters>
          <parameter name="mover" type="Object" usage="required">
            <summary>the reference to the dnd mover</summary>
          </parameter>
          <parameter name="mousePos" type="Object" usage="required">
            <summary>the current position of the mover - {x:.., Y:..}</summary>
          </parameter>
          <parameter name="borderDIV" type="Object" usage="required">
            <summary>reference to the borderDIV</summary>
          </parameter>
        </parameters>
      </method>
      <method name="normalizeColBorderHeight" scope="prototype">
        <parameters>
          <parameter name="borderDiv" type="Dom" usage="required">
            <summary>node
	Mover border div dom node</summary>
          </parameter>
          <parameter name="colIdx" type="Integer" usage="required">
            <summary>Column index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="avataDivClick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startMoveCols" scope="prototype"/>
      <method name="changeCursorState" scope="prototype">
        <summary>change the cursor state</summary>
        <parameters>
          <parameter name="state" type="String" usage="required">
            <summary>the state that the cursor will be changed to</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addRowMovers" scope="prototype"/>
      <method name="addRowMover" scope="prototype">
        <parameters>
          <parameter name="from" type="the" usage="required">
            <summary>first row index for mover to cover</summary>
          </parameter>
          <parameter name="to" type="the" usage="required">
            <summary>last row index for mover to cover</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="row not loaded"/>
        </return-types>
      </method>
      <method name="moveRowBorder" scope="prototype">
        <summary>move the border DIV to specified position when moving row</summary>
        <parameters>
          <parameter name="mover" type="Object" usage="required">
            <summary>the reference to the dnd mover</summary>
          </parameter>
          <parameter name="leftTop" type="Object" usage="required">
            <summary>the leftTop position of the mover</summary>
          </parameter>
          <parameter name="borderDIV" type="Object" usage="required">
            <summary>reference to the borderDIV</summary>
          </parameter>
          <parameter name="mousePos" type="Object" usage="required">
            <summary>the current position of the mover - {x:.., Y:..}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="autoMoveToPreRow" scope="prototype">
        <summary>auto move the mover to the previous row of the current one</summary>
      </method>
      <method name="autoMoveBorderDivPre" scope="prototype">
        <summary>auto move the border DIV to the previous row of the current one</summary>
      </method>
      <method name="autoMoveToNextRow" scope="prototype">
        <summary>auto move the mover to the next row of the current one</summary>
      </method>
      <method name="autoMoveBorderDiv" scope="prototype"/>
      <method name="startMoveRows" scope="prototype">
        <summary>start to move the selected rows to target position</summary>
      </method>
      <method name="moveRows" scope="prototype">
        <summary>Only move visible rows to avoid performance issue especially
	when there are many disperse selected rows across not-rendered pages</summary>
        <parameters>
          <parameter name="start" type="Integer" usage="required">
            <summary>the first row of the selected area to move</summary>
          </parameter>
          <parameter name="end" type="Integer" usage="required">
            <summary>the first row of the selected area to move deltaRowAmount</summary>
          </parameter>
          <parameter name="pageInfo" type="Object" usage="required">
            <summary>{topPage: xx, bottomPage: xx, invalidPages: [xx,xx,...]}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="clearDrugDivs" scope="prototype">
        <summary>remove cover DIVs for dnd moving</summary>
      </method>
      <method name="setDrugCoverDivs" scope="prototype">
        <parameters>
          <parameter name="inColIndex" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getPageInfo" scope="prototype">
        <summary>Find pages that contain visible rows
	return: Object
	{topPage: xx, bottomPage: xx, invalidPages: [xx,xx,...]}</summary>
      </method>
      <method name="resetCellIdx" scope="prototype"/>
      <method name="publishRowMove" scope="prototype">
        <summary>publish a topic to notify the row movement</summary>
      </method>
      <method name="keyboardMove" scope="prototype">
        <summary>handle keyboard dnd</summary>
        <parameters>
          <parameter name="keyEvent" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.grid.rowSelectCell.view" type="">
    <properties>
      <property name="scrollboxNode" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.gridCoords">
    <properties>
      <property name="h" scope="prototype" type="Number"/>
      <property name="t" scope="prototype" type=""/>
      <property name="l" scope="prototype" type=""/>
      <property name="w" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.coverDIVs" type="Array">
    <summary>the list that keep the reference to all cover DIVs for DND moving</summary>
    <properties>
      <property name="hasRemovedOtherMovers" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.grid.views" type=""/>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.grid" type="">
    <properties>
      <property name="pluginMgr" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.grid.views.views" type=""/>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.drugSelectionStart" type="">
    <properties>
      <property name="colIndex" scope="prototype" type="Number"/>
      <property name="rowIndex" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.grid.select" type="">
    <properties>
      <property name="outRangeY" scope="prototype" type="bool"/>
      <property name="moveOutTop" scope="prototype" type="bool"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.grid.views.views.0" type="">
    <properties>
      <property name="rowNodes" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.grid.scroller" type="">
    <properties>
      <property name="rowsPerPage" scope="prototype" type=""/>
      <property name="stack" scope="prototype" type=""/>
      <property name="firstVisibleRow" scope="prototype" type=""/>
      <property name="lastVisibleRow" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndMovingManager.grid.scroller.pageNodes" type="">
    <properties>
      <property name="0" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndRowSelector" type="Function" classlike="true">
    <summary>This class declaration is used to be mixed in to dojox.grid._RowSelector
	to enable DND feature in _RowSelector.</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="domousedown" scope="prototype">
        <summary>Handle when there is a mouse down event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The mouse down event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="domouseup" scope="prototype">
        <summary>Handle when there is a mouse up event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The mouse up event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="dofocus" scope="prototype">
        <summary>Handle when there is a focus event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The focus event</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndSelectingManager" type="Function" classlike="true">
    <summary>_DndSelectingManager is used to enable grid DND selecting feature</summary>
    <properties>
      <property name="typeSelectingMode" scope="instance-prototype" type="Array"/>
      <property name="selectingDisabledTypes" scope="instance-prototype" type="Array"/>
      <property name="drugMode" scope="prototype" type="Object"/>
      <property name="keepState" scope="prototype" type="bool"/>
      <property name="extendSelect" scope="prototype" type="bool"/>
      <property name="headerNodes" scope="prototype" type="Object"/>
      <property name="selectedCells" scope="instance-prototype" type="Array"/>
      <property name="selectedColumns" scope="instance-prototype" type="Array"/>
      <property name="selectedClass" scope="prototype" type="String"/>
      <property name="autoScrollRate" scope="prototype" type="Number"/>
      <property name="firstOut" scope="prototype" type="bool"/>
      <property name="outRangeY" scope="prototype" type="Object"/>
      <property name="colChanged" scope="prototype" type="Object"/>
      <property name="lastDrugSelectionStart" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="dojox.Grid" usage="required">
            <summary>The dojox.Grid this editor should be attached to</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="dojox.Grid" usage="required">
            <summary>The dojox.Grid this editor should be attached to</summary>
          </parameter>
        </parameters>
      </method>
      <method name="extendGridForDnd" scope="prototype">
        <summary>Ectend the current class to enable the DND feature
	inclucing:
	dojox.Grid
	dojox._FocusManager
	dojox.Selection
	dojox._Builder
	dojox._HeaderBuilder
	dojox._RowSelector
	Change the funnelEvents of views, add mouseup and mouseover event</summary>
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="disableFeatures" scope="prototype">
        <summary>disable selecting features according to the configuration</summary>
      </method>
      <method name="cellClick" scope="prototype">
        <summary>handle the click event on cell, select the cell call this.addCellToSelection</summary>
        <parameters>
          <parameter name="inColIndex" type="Integer" usage="required">
            <summary>the Y position  of the cell that fired the click event</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>the Y position of the cell that fired the click event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="drugSelectCell" scope="prototype">
        <summary>Handle the Dnd selecting cell operation
	use this.grid.drugSelectionStart as the start point</summary>
        <parameters>
          <parameter name="inColumnIndex" type="The" usage="required">
            <summary>end point X position of the Dnd operation</summary>
          </parameter>
          <parameter name="inRowIndex" type="The" usage="required">
            <summary>end point Y position of the Dnd operation</summary>
          </parameter>
        </parameters>
      </method>
      <method name="drugSelectRow" scope="prototype">
        <summary>Handle dnd select rows
	call the dojox.grid.Selection to perform the operation</summary>
        <parameters>
          <parameter name="inRowIndex" type="the" usage="required">
            <summary>index of the row that fired mouseover event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="selectColumn" scope="prototype">
        <summary>Handle the header cell click event</summary>
        <parameters>
          <parameter name="columnIndex" type="the" usage="required">
            <summary>colIndex of the header cell that fired the click event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="drugSelectColumn" scope="prototype">
        <summary>Handle Dnd select operation</summary>
        <parameters>
          <parameter name="currentColumnIndex" type="the" usage="required">
            <summary>colIndex of the col that fired mouseover event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="disableSelecting" scope="prototype">
        <summary>set selecting feature of 'type' disabled in the disabled feature list</summary>
        <parameters>
          <parameter name="type" type="Sting" usage="required">
            <summary>the feature that will be disabled, should be 'cell', 'row', or 'col'</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isInSelectingMode" scope="prototype">
        <summary>whether the selecting manager is in 'type' selecting mode</summary>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <summary>the selecting mode type
	return: Boolean
	whether the selecting manager is in 'type' selecting mode</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setInSelectingMode" scope="prototype">
        <summary>set the selecting manager to 'type' selecting mode</summary>
        <parameters>
          <parameter name="type" type="String" usage="required">
            <summary>the selecting mode will be set, should be 'cell', 'row', or 'col'</summary>
          </parameter>
          <parameter name="isEnable" type="Boolean" usage="required">
            <summary>the 'type' selecting mode is 'isEnable'ed</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getSelectedRegionInfo" scope="prototype">
        <summary>Get the selected region info
	return: Array
	Array of selected index, might be index of rows | columns | cells</summary>
      </method>
      <method name="clearInSelectingMode" scope="prototype">
        <summary>clear all selecting mode</summary>
      </method>
      <method name="getHeaderNodes" scope="prototype">
        <summary>Util function
	Get  the header nodes list of the grid
	return:
	the header nodes list of the grid</summary>
      </method>
      <method name="_range" scope="prototype">
        <summary>fire a function for each item in a range</summary>
        <parameters>
          <parameter name="inFrom" type="" usage="required"/>
          <parameter name="inTo" type="" usage="required"/>
          <parameter name="func" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setDrugStartPoint" scope="prototype">
        <summary>set drug selecting start point
	also add mouse move and mouse up handler on the whole window to monitor whether the mouse move out of the grid when druging</summary>
        <parameters>
          <parameter name="inColIndex" type="Integer" usage="required">
            <summary>column index of the point</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>row index of the point</summary>
          </parameter>
        </parameters>
      </method>
      <method name="autoRowScrollDrug" scope="prototype">
        <summary>start auto scroll and select the next row</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="autoSelectNextRow" scope="prototype">
        <summary>auto scroll the grid to next row and select the row</summary>
      </method>
      <method name="autoCellScrollDrug" scope="prototype">
        <summary>start auto scroll the grid to next row
	reset the selected column range when mouse move to another column</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="autoSelectCellInNextRow" scope="prototype">
        <summary>auto scroll the grid to next row and select the cells</summary>
      </method>
      <method name="getAutoScrollRate" scope="prototype">
        <summary>get the auto scroll time rate
	return: Integer:
	the auto scroll time rate</summary>
      </method>
      <method name="resetStartPoint" scope="prototype">
        <summary>reset the DND selecting start point</summary>
      </method>
      <method name="restorLastDragPoint" scope="prototype">
        <summary>restore the DND selecting start point to last one</summary>
      </method>
      <method name="drugSelectColumnToMax" scope="prototype">
        <summary>select the column to the last one in the direction 'dir'</summary>
        <parameters>
          <parameter name="dir" type="String" usage="required">
            <summary>the direction to extend column selection</summary>
          </parameter>
        </parameters>
      </method>
      <method name="selectColumnRange" scope="prototype">
        <summary>select a range of columns</summary>
        <parameters>
          <parameter name="startIndex" type="the" usage="required">
            <summary>start col index of the range</summary>
          </parameter>
          <parameter name="endIndex" type="the" usage="required">
            <summary>end col index of the range</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addColumnToSelection" scope="prototype">
        <summary>add all the cells in a column to selection</summary>
        <parameters>
          <parameter name="columnIndex" type="the" usage="required">
            <summary>index of the col</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addColumnRangeToSelection" scope="prototype">
        <summary>Add a range of cells in the specified column to selection</summary>
        <parameters>
          <parameter name="columnIndex" type="the" usage="required">
            <summary>Column Index</summary>
          </parameter>
          <parameter name="from" type="the" usage="required">
            <summary>top cell of the range</summary>
          </parameter>
          <parameter name="to" type="the" usage="required">
            <summary>bottom cell of the range</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_rangCellsInColumn" scope="prototype">
        <summary>Add a range of cells in the specified column to selection</summary>
        <parameters>
          <parameter name="columnIndex" type="the" usage="required">
            <summary>Column Index</summary>
          </parameter>
          <parameter name="from" type="the" usage="required">
            <summary>top cell of the range</summary>
          </parameter>
          <parameter name="to" type="the" usage="required">
            <summary>bottom cell of the range</summary>
          </parameter>
          <parameter name="func" type="" usage="required"/>
        </parameters>
      </method>
      <method name="drugSelectRowToMax" scope="prototype">
        <summary>select the row to the last one in the direction 'dir'</summary>
        <parameters>
          <parameter name="dir" type="String" usage="required">
            <summary>the direction to extend row selection</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getCellNode" scope="prototype">
        <summary>As there's no reference of domNode for cell, get it manully</summary>
        <parameters>
          <parameter name="inCellIndex" type="Integer" usage="required">
            <summary>Offset of the cell in the row, stands for the X index of the cell in the grid
	inRowIndex : Integer
	Offset of the row in the grid, stands forthe Y index of the cell in the grid
	Description: Integer
	Get the DOM node for the cell in a give position
	Return: Object
	DOM node reference of the cell</summary>
          </parameter>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addCellToSelection" scope="prototype">
        <summary>add a cell to selection list and change it into selected state</summary>
        <parameters>
          <parameter name="cellNode" type="Object" usage="required">
            <summary>the cell node will be added to select</summary>
          </parameter>
          <parameter name="dndManager" type="_DndSelectionManager" usage="required">
            <summary>reference to the instance of _DndSelectionManager</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isColSelected" scope="prototype">
        <summary>wether the column in of index value &amp;quot;inColIndex&amp;quot; is selected</summary>
        <parameters>
          <parameter name="inColIndex" type="Integer" usage="required">
            <summary>the index value of the column
	return: Boolean
	wether the column in of index value &amp;quot;inColIndex&amp;quot; is selected</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isRowSelected" scope="prototype">
        <summary>wether the row in of index value &amp;quot;inRowIndex&amp;quot; is selected</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>the index value of the row
	return: Boolean
	wether the row in of index value &amp;quot;inRowIndex&amp;quot; is selected</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isContinuousSelection" scope="prototype">
        <summary>Whether a selection is continuous</summary>
        <parameters>
          <parameter name="selected" type="Array" usage="required">
            <summary>the selection states for columns or rows
	return: Boolean</summary>
          </parameter>
        </parameters>
      </method>
      <method name="cleanCellSelection" scope="prototype">
        <summary>change all the selected cell to unselected and umpty the selected-cell list</summary>
      </method>
      <method name="removeCellSelectedState" scope="prototype">
        <summary>change the cell style to un-selected</summary>
        <parameters>
          <parameter name="cell" type="the" usage="required">
            <summary>cell dom-node the style to be changed</summary>
          </parameter>
        </parameters>
      </method>
      <method name="cleanAll" scope="prototype">
        <summary>Clear all the selected cells, columns and rows
	row selection is reused from dojox.grid._Selection,
	so clear it by call the clear function of dojox.grid._Selection</summary>
      </method>
      <method name="refreshColumnSelection" scope="prototype">
        <summary>handle grid scroll, keep column selected state</summary>
      </method>
      <method name="inSelectedArea" scope="prototype">
        <summary>whether the specified point is in selected area</summary>
        <parameters>
          <parameter name="inColIndex" type="Integer" usage="required">
            <summary>the col index of the point</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>the row index of the point
	return: Boolean
	whether the specified point is in selected area</summary>
          </parameter>
        </parameters>
      </method>
      <method name="publishRowChange" scope="prototype">
        <summary>publish a topic to notify that row selection changed</summary>
      </method>
      <method name="getViewRowNodes" scope="prototype">
        <summary>Get view row nodes in array form</summary>
        <parameters>
          <parameter name="viewRowNodes" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFirstSelected" scope="prototype">
        <summary>Get the first selected row index
	return: Integer
	First selected row index</summary>
      </method>
      <method name="getLastSelected" scope="prototype">
        <summary>Get the last selected row index
	return: Integer
	Last selected row index</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndSelectingManager.drugSelectionStart">
    <properties>
      <property name="colIndex" scope="prototype" type="Number"/>
      <property name="rowIndex" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndSelectingManager.drugCurrentPoint">
    <properties>
      <property name="colIndex" scope="prototype" type=""/>
      <property name="columnIndex" scope="prototype" type=""/>
      <property name="rowIndex" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndSelectingManager.grid.select" type="">
    <properties>
      <property name="colChanged" scope="prototype" type="bool"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndSelectingManager.grid" type="">
    <properties>
      <property name="views" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.dnd._DndSelectingManager.grid.selection" type="">
    <properties>
      <property name="selected" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.plugins"/>
  <object location="dojox.grid.enhanced.plugins.DnD" type="Function" classlike="true" superclass="dojox.grid.enhanced.dnd._DndMovingManager">
    <summary>Provides dnd support for row(s) and column(s)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.grid.enhanced.dnd._DndMovingManager"/>
    </mixins>
    <examples>
      <example>&lt;div dojoType="dojox.grid.EnhancedGrid" plugins="{dnd: true}" ...&gt;&lt;/div&gt;</example>
    </examples>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.plugins.IndirectSelection" type="Function" classlike="true">
    <summary>Provides indirect selection feature - swipe selecting row(s)</summary>
    <examples>
      <example>&lt;div dojoType="dojox.grid.EnhancedGrid" plugins="{indirectSelection: true}" ...&gt;&lt;/div&gt;
	or &lt;div dojoType="dojox.grid.EnhancedGrid" plugins="{indirectSelection: {name: 'xxx', width:'30px', styles:'text-align: center;'}}" ...&gt;&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="cellCount" scope="prototype" type=""/>
      <property name="grid" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addRowSelectCell" scope="prototype">
        <summary>Add the indirect selection cell(mapped to a column of checkboxes) to grid layout structure</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells._SingleRowSelectorMixin" type="Function" classlike="true">
    <summary>Common attributes and functions to be mixed in for single selection</summary>
    <properties>
      <property name="alwaysEditing" scope="prototype" type="Boolean">
        <summary>Overwritten, see dojox.grid.cells._Widget
	True - always show the radio or checkbox widget</summary>
      </property>
      <property name="widgetMap" scope="prototype" type="Object">
        <summary>Cache all the radio or checkbox widgets</summary>
      </property>
      <property name="widget" scope="prototype" type="Object">
        <summary>The currently focused widget</summary>
      </property>
      <property name="isRowSelector" scope="prototype" type="Boolean">
        <summary>Marker of indirect selection cell(column)</summary>
      </property>
      <property name="defaultValue" scope="prototype" type="Boolean">
        <summary>Default value for radio or checkbox widget</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="formatEditing" scope="prototype">
        <summary>Overwritten, see dojox.grid.cells._Widget</summary>
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_formatNode" scope="prototype">
        <summary>Overwritten, see dojox.grid.cells._Base</summary>
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setValue" scope="prototype">
        <summary>Overwritten, see dojox.grid.cells._Widget
	Simpily return, no action</summary>
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
          <parameter name="inValue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <summary>Overwritten, see dojox.grid.cells._Base
	return widget value of row(inRowIndex) -  true | false</summary>
        <parameters>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fireSelectionChanged" scope="prototype">
        <summary>Publish rowSelectionChangedTopic when new row selection is made</summary>
      </method>
      <method name="_selectionChanged" scope="prototype">
        <summary>Subscriber of rowSelectionChangedTopic, update row selection accordingly</summary>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <summary>Object that fired the rowSelectionChangedTopic</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_toggleSingleRow" scope="prototype">
        <summary>toggle selection of a single row</summary>
        <parameters>
          <parameter name="idx" type="Integer" usage="required">
            <summary>Target row index</summary>
          </parameter>
          <parameter name="value" type="Boolean" usage="required">
            <summary>True - checked | False - unchecked</summary>
          </parameter>
        </parameters>
      </method>
      <method name="inIndirectSelectionMode" scope="prototype"/>
      <method name="toggleAllSelection" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.grid.cells._MultipleRowSelectorMixin" type="Function" classlike="true">
    <summary>Common attributes and functions to be mixed in for multiple selection</summary>
    <properties>
      <property name="swipeStartRowIndex" scope="prototype" type="Integer">
        <summary>Start row index for swipe selection</summary>
      </property>
      <property name="swipeMinRowIndex" scope="prototype" type="Integer">
        <summary>Max row index for swipe selection</summary>
      </property>
      <property name="swipeMaxRowIndex" scope="prototype" type="Number"/>
      <property name="toSelect" scope="prototype" type="Boolean">
        <summary>selection new state</summary>
      </property>
      <property name="lastClickRowIdx" scope="prototype" type="Integer">
        <summary>Row index for last click, used for range selection via Shift + click</summary>
      </property>
      <property name="toggleAllTrigerred" scope="prototype" type="Boolean">
        <summary>Whether toggle all has been triggered or not</summary>
      </property>
      <property name="_inDndSelection" scope="prototype" type="Boolean">
        <summary>Whether in DnD row selection progress or not</summary>
      </property>
      <property name="defaultValue" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="domousedown" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Mouse down event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="domousemove" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Mouse move event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onRowMouseOver" scope="prototype">
        <summary>Event fired when mouse moves over a data row.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, cell, and rowIndex</summary>
          </parameter>
        </parameters>
      </method>
      <method name="domouseup" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Mouse up event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="dokeyup" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Key up event</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_startSelection" scope="prototype">
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required">
            <summary>Index of the start row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_updateSelection" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event of the current row,</summary>
          </parameter>
          <parameter name="delta" type="Integer" usage="required">
            <summary>Row index delta, used for swipe selection via Shift + Cursor
	0: not via Shift + Cursor, -1 : Shift +  Up, 1 : Shift + Down</summary>
          </parameter>
        </parameters>
      </method>
      <method name="swipeSelectionByKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event of the current row,</summary>
          </parameter>
          <parameter name="delta" type="Integer" usage="required">
            <summary>Row index delta, used for swipe selection via Shift + Cursor
	-1 : Shift +  Up, 1 : Shift + Down</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_finisheSelect" scope="prototype"/>
      <method name="inIndirectSelectionMode" scope="prototype"/>
      <method name="toggleAllSelection" scope="prototype">
        <parameters>
          <parameter name="checked" type="Boolean" usage="required">
            <summary>True - select all, False - deselect all</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.DijitSingleRowSelector" type="Function" classlike="true" superclass="dojox.grid.cells._Widget">
    <summary>Indirect selection cell for single selection mode, using dijit.form.RadioButton</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.grid.cells._SingleRowSelectorMixin.prototype"/>
      <mixin scope="instance" location="dojox.grid.cells._Widget"/>
      <mixin scope="instance" location="dojox.grid.cells._SingleRowSelectorMixin"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="normal" type="Class">
        <summary>widget class that will be used for indirect selection cell(column)</summary>
      </property>
      <property name="widget" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="formatNode" scope="prototype">
        <summary>Overwritten, see dojox.grid.cells._Widget</summary>
        <parameters>
          <parameter name="inDatum" type="" usage="required"/>
          <parameter name="inRowIndex" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getDefaultValue" scope="prototype">
        <summary>Get defaulst value for a widget</summary>
        <parameters>
          <parameter name="widget" type="Object" usage="required">
            <summary>Target widget</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Row index of the widget
	return: Boolean
	True - checked | False - unchecked</summary>
          </parameter>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <summary>Set focus to the widget in the target row</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Target row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_focusEndingCell" scope="prototype">
        <summary>At the end of a swipe selection, set focus to the ending grid cell(inRowIndex,cellIndex)</summary>
        <parameters>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Row index</summary>
          </parameter>
          <parameter name="cellIndex" type="Integer" usage="required">
            <summary>Column index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_selectRow" scope="prototype">
        <summary>Select the target row</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event fired on the target row</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Target row index</summary>
          </parameter>
          <parameter name="preChange" type="Boolean" usage="required">
            <summary>Whether triggered before the selection state change of the target row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toggleRow" scope="prototype">
        <summary>toggle selection of a single row</summary>
        <parameters>
          <parameter name="idx" type="Integer" usage="required">
            <summary>Target row index</summary>
          </parameter>
          <parameter name="value" type="Boolean" usage="required">
            <summary>True - checked | False - unchecked</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setDisabled" scope="prototype">
        <summary>toggle 'disabled' | 'enabled' of the selector widget in row idx</summary>
        <parameters>
          <parameter name="idx" type="Integer" usage="required">
            <summary>Row index</summary>
          </parameter>
          <parameter name="disabled" type="Boolean" usage="required">
            <summary>True - disabled | False - enabled</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.DijitSingleRowSelector.widgetProps">
    <properties>
      <property name="name" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid.cells.DijitSingleRowSelector.grid" type="">
    <properties>
      <property name="indirectSelector" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.cells.DijitMultipleRowSelector" type="Function" classlike="true" superclass="dojox.grid.cells.DijitSingleRowSelector">
    <summary>Indirect selection cell for multiple or extended mode, using dijit.form.CheckBox</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.grid.cells._MultipleRowSelectorMixin.prototype"/>
      <mixin scope="instance" location="dojox.grid.cells.DijitSingleRowSelector"/>
      <mixin scope="instance" location="dojox.grid.cells._MultipleRowSelectorMixin"/>
    </mixins>
    <properties>
      <property name="widgetClass" scope="normal" type="Class">
        <summary>widget class that will be used for indirect selection cell(column)</summary>
      </property>
      <property name="lastClickRowIdx" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="_selectRow" scope="prototype">
        <summary>Select the target row or range or rows</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event fired on the target row</summary>
          </parameter>
          <parameter name="inRowIndex" type="Integer" usage="required">
            <summary>Target row index</summary>
          </parameter>
          <parameter name="preChange" type="Boolean" usage="required">
            <summary>Whether triggered before the selection state change of the target row</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toggleRow" scope="prototype">
        <summary>Overwritten</summary>
        <parameters>
          <parameter name="idx" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.cells.DijitMultipleRowSelector.grid" type="">
    <properties>
      <property name="indirectSelector" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.plugins.Menu" type="Function" classlike="true">
    <summary>Provides context menu support, including header menu, row menu, cell menu and selected region menu</summary>
    <examples>
      <example>&lt;div dojoType="dojox.grid.EnhancedGrid"
	plugins="{menus:{headerMenu:"headerMenuId", rowMenu:"rowMenuId", cellMenu:"cellMenuId",
	selectedRegionMenu:"selectedRegionMenuId"}}" ...&gt;
	&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="menuContainer" scope="prototype" type=""/>
      <property name="headerMenu" scope="prototype" type="Object"/>
      <property name="rowMenu" scope="prototype" type="Object"/>
      <property name="cellMenu" scope="prototype" type="Object"/>
      <property name="selectedRegionMenu" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_initMenus" scope="prototype">
        <summary>Initilize all the required menus</summary>
      </method>
      <method name="_getMenuWidget" scope="prototype">
        <summary>Fetch the required menu widget(should already been created)</summary>
        <parameters>
          <parameter name="menuId" type="String" usage="required">
            <summary>Id of the target menu widget
	return: Widget
	Target menu widget</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_bindDnDSelectEvent" scope="prototype">
        <summary>Hook callback to DnD, so othat appropriate menu will be shown on selected regions</summary>
      </method>
      <method name="_setRowMenuAttr" scope="prototype">
        <summary>Set row menu widget</summary>
        <parameters>
          <parameter name="menu" type="Widget" usage="required">
            <summary>- dijit.Menu
	Row menu widget</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setCellMenuAttr" scope="prototype">
        <summary>Set cell menu widget</summary>
        <parameters>
          <parameter name="menu" type="Widget" usage="required">
            <summary>- dijit.Menu
	Cell menu widget</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setRowCellMenuAttr" scope="prototype">
        <summary>Bind menus to Grid</summary>
        <parameters>
          <parameter name="menu" type="Widget" usage="required">
            <summary>- dijit.Menu
	Menu widget</summary>
          </parameter>
          <parameter name="menuType" type="String" usage="required">
            <summary>Menu type</summary>
          </parameter>
        </parameters>
      </method>
      <method name="showRowCellMenu" scope="prototype">
        <summary>Show row or cell menus</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Fired from dojox.grid.enhanced._Events.onRowContextMenu</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.plugins.NestedSorting" type="Function" classlike="true">
    <summary>Provides nested sorting feature</summary>
    <examples>
      <example>&lt;div dojoType="dojox.grid.EnhancedGrid" plugins="{nestedSorting: true}" ...&gt;&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="sortAttrs" scope="prototype" type="Array">
        <summary>Sorting attributes, e.g.[{attr: 'col1', asc: 1|-1|0, cell: cell, cellNode: node}, {...}, ...]</summary>
      </property>
      <property name="_unarySortCell" scope="prototype" type="Object">
        <summary>Cache for the current unary sort cell(the 1st column in sorting sequence)
	will be set as {cell: cell, cellNode: node}</summary>
      </property>
      <property name="_minColWidth" scope="prototype" type="Integer">
        <summary>Used for calculating min cell width, will be updated dynamically
	58</summary>
      </property>
      <property name="_widthDelta" scope="prototype" type="Integer">
        <summary>Min width delta
	18</summary>
      </property>
      <property name="_minColWidthUpdated" scope="prototype" type="Boolean">
        <summary>Flag to indicate whether the min col width has been updated</summary>
      </property>
      <property name="_sortTipMap" scope="prototype" type="Object">
        <summary>Cache the tip on/off status for each cell, e.g. {cellIndex: true|false}</summary>
      </property>
      <property name="_overResizeWidth" scope="prototype" type="Integer">
        <summary>Overwrite the default over resize width,
	so that the resize cursor is more obvious when leveraged with sorting hover tips</summary>
      </property>
      <property name="storeItemSelected" scope="prototype" type="String">
        <summary>Attribute used in data store to mark which row(s) are selected accross sortings</summary>
      </property>
      <property name="exceptionalSelectedItems" scope="prototype" type="Array">
        <summary>Cache data store items with exceptional selection state.
	Used to retain selection states accross sortings. User may first select/deselect all rows
	and then deselect/select certain rows, these later changed rows have a different state
	with the global selection state, that is exceptional selection state</summary>
      </property>
      <property name="dndRowConn" scope="prototype" type="Object"/>
      <property name="inSorting" scope="prototype" type="bool"/>
      <property name="toggleAllValue" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Mixin in all the properties and methods into DataGrid</summary>
        <parameters>
          <parameter name="inGrid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setSortIndex" scope="prototype">
        <summary>Sorting entry that overwrites parent(_Grid.js) when nested sorting is enabled
	Sort the grid on multiple columns in a nested sorting sequence</summary>
        <parameters>
          <parameter name="inIndex" type="Integer" usage="required">
            <summary>Column index on which to sort.</summary>
          </parameter>
          <parameter name="inAsc" type="Integer" usage="required">
            <summary>1:  sort the target column in ascending order
	-1: sort the target column in descending order
	0:  revert the target column back to unsorted state</summary>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_updateSortAttrs" scope="prototype">
        <summary>Update the sorting sequence</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
          <parameter name="inAsc" type="Integer" usage="required">
            <summary>1:  sort the target column in ascending order
	-1: sort the target column in descending order
	0:  revert the target column back to unsorted state</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getCellSortInfo" scope="prototype">
        <parameters>
          <parameter name="cell" type="Cell" usage="required">
            <summary>Target header cell
	return:
	Sort info e.g. {unarySortAsc: 1|-1|0, nestedSortAsc: 1|-1|0, sortPos:1|2...}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setCellSortInfo" scope="prototype">
        <summary>Update nested sorting sequence with the new state of target cell</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
          <parameter name="inAsc" type="Integer" usage="required">
            <summary>1:  sort the target column in ascending order
	-1: sort the target column in descending order
	0:  revert the target column back to unsorted state</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getDsSortAttrs" scope="prototype">
        <summary>Get the sorting attributes for Data Store
	return: Object
	Sorting attributes used by Data Store e.g. {attribute: 'xxx', descending: true|false}</summary>
      </method>
      <method name="_getNewSortState" scope="prototype">
        <parameters>
          <parameter name="si" type="int" usage="required">
            <summary>Integer Current sorting state
	return: Integer
	Next new sorting state</summary>
          </parameter>
        </parameters>
      </method>
      <method name="sortStateInt2Str" scope="prototype">
        <parameters>
          <parameter name="si" type="Integer" usage="required">
            <summary>Sorting state integer
	return: String
	Sort info string</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="'SortUp';"/>
          <return-type type="'SortDown';"/>
        </return-types>
      </method>
      <method name="clearSort" scope="prototype"/>
      <method name="_getNestedSortHeaderContent" scope="prototype">
        <parameters>
          <parameter name="inCell" type="Cell" usage="required">
            <summary>Header cell for rendering
	return: String
	InnerHTML for the header cell</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addHoverSortTip" scope="prototype">
        <summary>Add sorting tip for target cell</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addHoverUnarySortTip" scope="prototype">
        <summary>Add hover tip for unary sorting</summary>
        <parameters>
          <parameter name="elements" type="Object" usage="required">
            <summary>Json object contains all dom nodes of sort regions</summary>
          </parameter>
          <parameter name="cellSortInfo" type="Object" usage="required">
            <summary>Json object that contains detail sorting info</summary>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addHoverNestedSortTip" scope="prototype">
        <summary>Add hover tip for nested sorting</summary>
        <parameters>
          <parameter name="elements" type="Object" usage="required">
            <summary>Json object contains all dom nodes of sort regions</summary>
          </parameter>
          <parameter name="cellSortInfo" type="Object" usage="required">
            <summary>Json object that contains detail sorting info</summary>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_unarySortInFocus" scope="prototype">
        <summary>See if the unary sort node is in keyboard focus
	return: Boolean</summary>
      </method>
      <method name="_composeSortTip" scope="prototype">
        <summary>Get properties from nls bundle and compose appropriate sorting tips</summary>
        <parameters>
          <parameter name="state" type="String" usage="required">
            <summary>Sorting state</summary>
          </parameter>
          <parameter name="type" type="String" usage="required">
            <summary>Sorting type</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addTipInfo" scope="prototype">
        <summary>Add title tip to target node and also all the descendants</summary>
        <parameters>
          <parameter name="node" type="Dom" usage="required">
            <summary>node
	Target node</summary>
          </parameter>
          <parameter name="text" type="String" usage="required">
            <summary>Tip string</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addA11yInfo" scope="prototype">
        <summary>Add related class and a11y sorting arrow character</summary>
        <parameters>
          <parameter name="node" type="Dom" usage="required">
            <summary>node
	Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
          <parameter name="className" type="String" usage="required">
            <summary>CSS class name mapped to a11y sorting arrow character</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeHoverSortTip" scope="prototype">
        <summary>Remove sorting tip for target cell</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getUnaryNode" scope="prototype">
        <summary>Get the sort position DOM node of unary column (1st in the sort sequence)
	return: Dom node</summary>
      </method>
      <method name="_fixSelectRegion" scope="prototype">
        <summary>Resize or recover the selection region, so that content in header cell are not messed up.</summary>
        <parameters>
          <parameter name="selectRegion" type="Dom" usage="required">
            <summary>node
	Dom node of selection region</summary>
          </parameter>
        </parameters>
      </method>
      <method name="updateMinColWidth" scope="prototype">
        <summary>Calculate and update the min cell width. So that sort tip and partial caption are visible when resized.</summary>
        <parameters>
          <parameter name="nestedSortPos" type="Dom" usage="required">
            <summary>node
	Dom node of nested sorting position</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getMinColWidth" scope="prototype">
        <summary>Fetch the min column width</summary>
      </method>
      <method name="_initSelectCols" scope="prototype">
        <summary>Some initial works on the header cells, like event binding, resizing parameters etc.</summary>
      </method>
      <method name="_fixHeaderCellStyle" scope="prototype">
        <summary>Fix some style issues when header cells are created
	TBD, see if these can be fixed through CSS</summary>
        <parameters>
          <parameter name="selectRegions" type="Node" usage="required">
            <summary>list
	Node list of dom nodes for selection regions</summary>
          </parameter>
          <parameter name="cellView" type="View" usage="required">
            <summary>View that contains related cells</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_fixAllSelectRegion" scope="prototype">
        <summary>Fix rtl in IE</summary>
      </method>
      <method name="_toggleHighlight" scope="prototype">
        <summary>Toggle hover state for selection region, unary sort region (unarySortWrapper)
	and nested sort region (unarySortWrapper)</summary>
        <parameters>
          <parameter name="cellView" type="View" usage="required">
            <summary>View that contains related cell</summary>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
          <parameter name="allOff" type="Boolean" usage="required">
            <summary>True - to trun off all highlight | False - by default</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_removeActiveState" scope="prototype">
        <summary>Remove active state for the event target</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_toggleProgressTip" scope="prototype">
        <summary>Change the cursor to progress or vice versa</summary>
        <parameters>
          <parameter name="on" type="Boolean" usage="required">
            <summary>True - change to progress cursor, false - recover back to original style</summary>
          </parameter>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getSortEventInfo" scope="prototype">
        <summary>Get sort event type from the event</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.
	return; Object
	Sort event type e.g. {unarySortChoice: true|false, nestedSortChoice: true|false, selectChoice: true|false}</summary>
          </parameter>
        </parameters>
      </method>
      <method name="ignoreEvent" scope="prototype">
        <summary>See if the event should be ignored when nested sorting is enabled</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.
	return: Boolean
	True - ignore this event, false - don't ignore</summary>
          </parameter>
        </parameters>
      </method>
      <method name="doheaderclick" scope="prototype">
        <summary>Hanlder for events fired on column headers</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellSelectClick" scope="prototype">
        <summary>Event fired when selection region is clicked</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onHeaderCellSortClick" scope="prototype">
        <summary>Event fired when unary or nested sort region is clicked</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_sychronizeResize" scope="prototype">
        <summary>Each time mouse moved in view.headerNode, check if need to add or remove sort tip
	This is used so that when mouse moves in resize area, sort tip is turned off, when mouse
	moves out of resize area, sort tip is turned on if necessary. Sort tip is also off during resizing</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getCellElements" scope="prototype">
        <summary>Fetch all dom nodes related with sorting, using dojo.query()
	to search from top 'th' parent of the given node</summary>
        <parameters>
          <parameter name="node" type="Dom" usage="required">
            <summary>node
	Target node.
	return: Object
	Json object contains all dom nodes related with sorting</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getChoiceRegion" scope="prototype">
        <summary>Find an appropriate region node for the choice event</summary>
        <parameters>
          <parameter name="target" type="Dom" usage="required">
            <summary>Node
	Choice event target</summary>
          </parameter>
          <parameter name="choiceInfo" type="Object" usage="required">
            <summary>Choice info e.g. 'unarySortChoice' | 'nestedSortChoice' | 'selectChoice'
	return: Dom Node
	Appropriate choice region node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_inResize" scope="prototype">
        <summary>See if current view is in resizing state(including if the cursor is in resize area)</summary>
        <parameters>
          <parameter name="view" type="View" usage="required">
            <summary>Target view
	return: Boolean
	True - in resizing state, false - not in resizing state</summary>
          </parameter>
        </parameters>
      </method>
      <method name="retainLastRowSelection" scope="prototype">
        <summary>Retain selected rows before sorting</summary>
      </method>
      <method name="updateNewRowSelection" scope="prototype">
        <summary>Fired when row selection is changed, connected from DataGrid._onFetchComplete();</summary>
        <parameters>
          <parameter name="items" type="" usage="required"/>
          <parameter name="req" type="" usage="required"/>
        </parameters>
      </method>
      <method name="allSelectionToggled" scope="prototype">
        <summary>Fired when toggleAllSelection is triggered in indirect selection</summary>
        <parameters>
          <parameter name="checked" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_selectionChanged" scope="prototype">
        <summary>Subscriber of rowSelectionChangedTopic, update global row selection state accordingly</summary>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <summary>Object that fired the rowSelectionChangedTopic</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getStoreSelectedValue" scope="prototype">
        <summary>Get whether a give row is selected across sortings</summary>
        <parameters>
          <parameter name="rowIdx" type="Integer" usage="required">
            <summary>Target row index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="initAriaInfo" scope="prototype">
        <summary>Add ARIA attributes for A11Y</summary>
      </method>
      <method name="_setSortRegionWaiState" scope="prototype">
        <summary>Add ARIA Wai sate for sort regions</summary>
        <parameters>
          <parameter name="singleSort" type="" usage="required"/>
          <parameter name="cellIdx" type="" usage="required"/>
          <parameter name="field" type="" usage="required"/>
          <parameter name="sortPos" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_inPage" scope="prototype">
        <summary>See if the given row is in the current page</summary>
        <parameters>
          <parameter name="rowIndex" type="Integer" usage="required">
            <summary>Target row
	return: Boolean
	True - in the current page | False - not in the current page</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.plugins.NestedSorting._a11yText" private="true">
    <summary>Characters for sorting arrows, used for a11y high contrast mode</summary>
    <properties>
      <property name="dojoxGridDescending" scope="normal" type="String"/>
      <property name="dojoxGridAscending" scope="normal" type="String"/>
      <property name="dojoxGridAscendingTip" scope="normal" type="String"/>
      <property name="dojoxGridDescendingTip" scope="normal" type="String"/>
      <property name="dojoxGridUnsortedTip" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.plugins.NestedSorting.edit" type="">
    <properties>
      <property name="info" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.plugins._NestedSortingFocusManager" type="Function" classlike="true" superclass="dojox.grid._FocusManager">
    <summary>Provides keyboard focus support for nested sorting</summary>
    <mixins>
      <mixin scope="instance" location="dojox.grid._FocusManager"/>
    </mixins>
    <properties>
      <property name="cssMarkers" scope="prototype" type="Array">
        <summary>CSS class markers for select region, nested sort wrapper and unary sort wrapper</summary>
      </property>
      <property name="_colHeadNode" scope="prototype" type="Object"/>
      <property name="_colHeadFocusIdx" scope="prototype" type="Object"/>
      <property name="focusView" scope="prototype" type=""/>
      <property name="isNavCellRegion" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initColumnHeaders" scope="prototype">
        <summary>Bind onfocus and onblur hanlders to regions in each header cell node</summary>
      </method>
      <method name="focusHeader" scope="prototype">
        <summary>Overwritten, see _FocusManager.focusHeader()</summary>
        <parameters>
          <parameter name="leadingDir" type="Boolean" usage="required">
            <summary>If focus is switching to leading direction</summary>
          </parameter>
          <parameter name="delayed" type="Boolean" usage="required">
            <summary>If called from &amp;quot;this._delayedHeaderFocus()&amp;quot;</summary>
          </parameter>
          <parameter name="ignoreRegionPos" type="Boolean" usage="required">
            <summary>If always focus on the 1st region(select region) for each header cell node</summary>
          </parameter>
        </parameters>
      </method>
      <method name="focusSelectColEndingHeader" scope="prototype">
        <summary>Put focus on the ending column header cell for swipe column selecting(when DnD plugin is on).
	See dojox.grid.enhanced.dnd._DndBuilder.domouseup()</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object that contains reference to grid header or content</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_delayedHeaderFocus" scope="prototype">
        <summary>Overwritten, see _FocusManager._delayedHeaderFocus()
	this.needFocusSupport() &amp;amp;&amp;amp; this.isNavHeader() &amp;amp;&amp;amp; this.focusHeader(null, true);</summary>
      </method>
      <method name="_setActiveColHeader" scope="prototype">
        <summary>Overwritten, see _FocusManager._setActiveColHeader()</summary>
        <parameters>
          <parameter name="colHeaderNode" type="Node" usage="required"/>
          <parameter name="colFocusIdx" type="Integer" usage="required"/>
          <parameter name="prevColFocusIdx" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderFocus" scope="prototype">
        <summary>Overwritten, see _FocusManager.doColHeaderFocus()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="doColHeaderBlur" scope="prototype">
        <summary>Overwritten, see _FocusManager.doColHeaderBlur()</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFocusView" scope="prototype">
        <summary>Get the current focus view</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Event that triggers the current focus
	return: Object
	The current focus view</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_mockEvt" scope="prototype">
        <summary>Return a mocked decorated event for currently focused column header cell.</summary>
        <parameters>
          <parameter name="region" type="Dom" usage="required">
            <summary>node
	Target dom node
	return: Object
	Overwritten, see _FocusManager.doColHeaderBlur()</summary>
          </parameter>
        </parameters>
      </method>
      <method name="navHeader" scope="prototype">
        <summary>Navigate focus across column header cells or regions.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Un-decorated event object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="navHeaderNode" scope="prototype">
        <summary>Navigate focus across column header cells.</summary>
        <parameters>
          <parameter name="delta" type="Integer" usage="required">
            <summary>1 | 0 | -1, navigating direction</summary>
          </parameter>
          <parameter name="ignoreRegionPos" type="Boolean" usage="required">
            <summary>If always focus on the 1st region(select region) for each header cell node</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="simply ignore indirect selection column"/>
        </return-types>
      </method>
      <method name="navCellRegion" scope="prototype">
        <summary>Navigate focus across regions within a column header cell.</summary>
        <parameters>
          <parameter name="nextRegion" type="Dom" usage="required">
            <summary>node
	Next region node to be focused</summary>
          </parameter>
          <parameter name="newPos" type="Integer" usage="required">
            <summary>New region index</summary>
          </parameter>
        </parameters>
      </method>
      <method name="headerCellInFocus" scope="prototype">
        <summary>See if column header cell(with cellIndex) is now having focus</summary>
        <parameters>
          <parameter name="cellIndex" type="Integer" usage="required">
            <summary>Cell (column) index
	return: Boolean
	If the column header cell(with cellIndex) is now having focus.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="clearHeaderFocus" scope="prototype">
        <summary>Clear focus in column header cell</summary>
      </method>
      <method name="addSortFocus" scope="prototype">
        <summary>Add focus to sort region in column header cell by mouse click
	See NestedSorting.setSortIndex()</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>Decorated event object which contains reference to grid, target cell etc.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_addFocusBorder" scope="prototype">
        <summary>Add focus borders to node, use this instead of native CSS way to fix border wobbling issue</summary>
        <parameters>
          <parameter name="node" type="Dom" usage="required">
            <summary>node
	Target node to add focus borders</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_updateFocusBorder" scope="prototype">
        <summary>Update focus borders.</summary>
      </method>
      <method name="_removeFocusBorder" scope="prototype">
        <summary>Remove focus borders.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.grid.enhanced.plugins._NestedSortingFocusManager.lastHeaderFocus">
    <summary>Last header focus info</summary>
    <properties>
      <property name="cellNode" scope="prototype" type="Object"/>
      <property name="regionIdx" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.plugins._NestedSortingFocusManager.currentHeaderFocusEvt">
    <summary>Dummy event for current header focus</summary>
    <properties>
      <property name="target" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.plugins._NestedSortingFocusManager.grid" type="">
    <properties>
      <property name="sortAttrs" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.grid.enhanced.plugins._NestedSortingFocusManager._focusBorderBox" type="Dom" private="true">
    <summary>node
	Root of focus border divs</summary>
    <properties>
      <property name="className" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.help">
    <summary>TODOC</summary>
    <properties>
      <property name="_namespaces" scope="normal" type="Array"/>
      <property name="_rpc" scope="normal" type="Object"/>
      <property name="_attributes" scope="normal" type="Array"/>
      <property name="_toStrings" scope="normal" type="Object"/>
      <property name="_overrides" scope="normal" type="Array"/>
      <property name="_recursions" scope="normal" type="Array"/>
      <property name="_names" scope="normal" type="Object"/>
      <property name="_base" scope="normal" type="Object"/>
      <property name="console" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="locate" scope="normal">
        <summary>Search for dojo functionality that has something to do with the given string.</summary>
        <description>Search for locally available data; variable names and any cached
	documentation results for matches containing our search parameter
	searchFor
	The string to search for.</description>
        <parameters>
          <parameter name="searchFor" type="String" usage="required"/>
          <parameter name="searchIn" type="String|Object|String[]|Object[]" usage="required">
            <summary>The namespaces to search in. Defaults to dojox.help._namespaces</summary>
          </parameter>
          <parameter name="maxResults" type="Number" usage="required">
            <summary>The maximum number of results.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="refresh" scope="normal">
        <summary>Useful if you reset some values, and want to restore their
	help function</summary>
        <parameters>
          <parameter name="namespace" type="String" usage="optional">
            <summary>The string-representation of a namespace.</summary>
          </parameter>
          <parameter name="recursive" type="Boolean" usage="optional">
            <summary>Whether to recurse through the namespace.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="noConflict" scope="normal">
        <summary>Use this function when you want to resolve the problems
	created by including a dojox.help package.</summary>
        <parameters>
          <parameter name="item" type="Object" usage="optional">
            <summary>If you pass an item, only that item will be cleaned</summary>
          </parameter>
        </parameters>
      </method>
      <method name="init" scope="normal">
        <summary>Should be called by one of the implementations. Runs startup code</summary>
        <parameters>
          <parameter name="namespaces" type="String[]" usage="required">
            <summary>Any namespaces to add to the default (dojox.help._namespaces)</summary>
          </parameter>
          <parameter name="noConflict" type="Boolen" usage="optional">
            <summary>Whether to start in noConflict mode</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_noConflict" scope="normal">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_clean" scope="normal">
        <parameters>
          <parameter name="self" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_displayLocated" scope="normal">
        <summary>Stub function to be overridden in one of the dojox.help packages</summary>
        <parameters>
          <parameter name="located" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_displayHelp" scope="normal">
        <summary>Stub function to be overridden in one of the dojox.help packages</summary>
        <parameters>
          <parameter name="loading" type="" usage="required"/>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_addVersion" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_stripPrototype" scope="normal">
        <parameters>
          <parameter name="original" type="" usage="required"/>
        </parameters>
      </method>
      <method name="__toString" scope="normal"/>
      <method name="_recurse" scope="normal">
        <parameters>
          <parameter name="namespace" type="String" usage="optional"/>
          <parameter name="recursive" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="__recurse" scope="normal">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
          <parameter name="root" type="" usage="required"/>
          <parameter name="name" type="" usage="required"/>
          <parameter name="items" type="" usage="required"/>
          <parameter name="recursive" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_plainText" scope="normal">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.help._help" type="Function" classlike="true" private="true">
    <properties>
      <property name="__name__" scope="instance" type=""/>
      <property name="__searched__" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.help._parse" type="Function" classlike="true" private="true">
    <properties>
      <property name="__parameters__" scope="instance" type=""/>
      <property name="__source__" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.help._toString" type="Function" classlike="true" private="true">
    <properties>
      <property name="__parameters__" scope="instance" type="Array"/>
      <property name="__searching__" scope="instance" type="Object"/>
      <property name="__output__" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.highlight">
    <summary>A client-side syntax highlighting engine.</summary>
    <description>This project parses pre &gt; code nodes, and applies syntax highlighting for
	a wide variety of languages. Simply dojo.require() in all the
	dojox.highlight.languages you wish to include in your highlighingting,
	and customize colors in the highlight.css.
	It is provided as a dojo package, contributed under CLA
	by Ivan Sagalaev and is available originally from:
	http://softwaremaniacs.org/soft/highlight/en/</description>
    <properties>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="processString" scope="normal">
        <summary>highlight a string of text</summary>
        <return-description>Object containing:
	result - string of html with spans to apply formatting
	partialResult - if the formating failed: string of html
	up to the point of the failure, otherwise: undefined
	langName - the language used to do the formatting</return-description>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="lang" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="init" scope="normal">
        <summary>Highlight a passed node</summary>
        <description>Syntax highlight a passed DomNode or String ID of a DomNode</description>
        <examples>
          <example>	dojox.highlight.init("someId");</example>
        </examples>
        <parameters>
          <parameter name="node" type="String|DomNode" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="stop iterations"/>
          <return-type type="continue iterations"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.highlight.constants">
    <properties>
      <property name="IDENT_RE" scope="normal" type="String"/>
      <property name="UNDERSCORE_IDENT_RE" scope="normal" type="String"/>
      <property name="NUMBER_RE" scope="normal" type="String"/>
      <property name="C_NUMBER_RE" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.highlight.constants.APOS_STRING_MODE">
    <properties>
      <property name="className" scope="normal" type="String"/>
      <property name="begin" scope="normal" type="String"/>
      <property name="end" scope="normal" type="String"/>
      <property name="illegal" scope="normal" type="String"/>
      <property name="contains" scope="normal" type="Array"/>
      <property name="relevance" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.constants.QUOTE_STRING_MODE">
    <properties>
      <property name="className" scope="normal" type="String"/>
      <property name="begin" scope="normal" type="String"/>
      <property name="end" scope="normal" type="String"/>
      <property name="illegal" scope="normal" type="String"/>
      <property name="contains" scope="normal" type="Array"/>
      <property name="relevance" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.constants.BACKSLASH_ESCAPE">
    <properties>
      <property name="className" scope="normal" type="String"/>
      <property name="begin" scope="normal" type="String"/>
      <property name="end" scope="normal" type="String"/>
      <property name="relevance" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.constants.C_LINE_COMMENT_MODE">
    <properties>
      <property name="className" scope="normal" type="String"/>
      <property name="begin" scope="normal" type="String"/>
      <property name="end" scope="normal" type="String"/>
      <property name="relevance" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.constants.C_BLOCK_COMMENT_MODE">
    <properties>
      <property name="className" scope="normal" type="String"/>
      <property name="begin" scope="normal" type="String"/>
      <property name="end" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.highlight.constants.HASH_COMMENT_MODE">
    <properties>
      <property name="className" scope="normal" type="String"/>
      <property name="begin" scope="normal" type="String"/>
      <property name="end" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.highlight.constants.C_NUMBER_MODE">
    <properties>
      <property name="className" scope="normal" type="String"/>
      <property name="begin" scope="normal" type=""/>
      <property name="end" scope="normal" type="String"/>
      <property name="relevance" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.Code" type="Function" classlike="true">
    <summary>A Class object to allow for dojoType usage with the highlight engine. This is
	NOT a Widget in the conventional sense, and does not have any member functions for
	the instance. This is provided as a convenience. You likely should be calling
	&lt;code&gt;dojox.highlight.init&lt;/code&gt; directly.</summary>
    <examples>
      <example>	&lt;pre&gt;&lt;code dojoType="dojox.highlight.Code"&gt;for(var i in obj){ ... }&lt;/code&gt;&lt;/pre&gt;</example>
      <example>	var inst = new dojox.highlight.Code({}, "someId");</example>
    </examples>
    <properties>
      <property name="node" scope="instance" type="String|DomNode">
        <summary>A String ID or DomNode reference to use as the root node of this instance.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="Object" usage="optional">
            <summary>Unused. Pass 'null' or {}. Positional usage to allow &lt;code&gt;dojo.parser&lt;/code&gt; to instantiate
	this class as other Widgets would be.</summary>
          </parameter>
          <parameter name="node" type="String|DomNode" usage="required">
            <summary>A String ID or DomNode reference to use as the root node of this instance.</summary>
          </parameter>
          <parameter name="p" type="" usage="required"/>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.highlight.languages">
    <properties>
      <property name="_all" scope="normal" type="Object"/>
      <property name="_dynamic" scope="normal" type="Object"/>
      <property name="_static" scope="normal" type="Object"/>
      <property name="_www" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.cpp">
    <summary>C++ highlight definitions</summary>
    <properties>
      <property name="modes" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.cpp.defaultMode">
    <properties>
      <property name="lexems" scope="normal" type="Array"/>
      <property name="illegal" scope="normal" type="String"/>
      <property name="contains" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.cpp.defaultMode.keywords">
    <properties>
      <property name="false" scope="normal" type="Number"/>
      <property name="int" scope="normal" type="Number"/>
      <property name="float" scope="normal" type="Number"/>
      <property name="while" scope="normal" type="Number"/>
      <property name="private" scope="normal" type="Number"/>
      <property name="char" scope="normal" type="Number"/>
      <property name="catch" scope="normal" type="Number"/>
      <property name="export" scope="normal" type="Number"/>
      <property name="virtual" scope="normal" type="Number"/>
      <property name="operator" scope="normal" type="Number"/>
      <property name="sizeof" scope="normal" type="Number"/>
      <property name="dynamic_cast" scope="normal" type="Number"/>
      <property name="typedef" scope="normal" type="Number"/>
      <property name="const_cast" scope="normal" type="Number"/>
      <property name="const" scope="normal" type="Number"/>
      <property name="struct" scope="normal" type="Number"/>
      <property name="for" scope="normal" type="Number"/>
      <property name="static_cast" scope="normal" type="Number"/>
      <property name="union" scope="normal" type="Number"/>
      <property name="namespace" scope="normal" type="Number"/>
      <property name="unsigned" scope="normal" type="Number"/>
      <property name="long" scope="normal" type="Number"/>
      <property name="throw" scope="normal" type="Number"/>
      <property name="volatile" scope="normal" type="Number"/>
      <property name="static" scope="normal" type="Number"/>
      <property name="protected" scope="normal" type="Number"/>
      <property name="bool" scope="normal" type="Number"/>
      <property name="template" scope="normal" type="Number"/>
      <property name="mutable" scope="normal" type="Number"/>
      <property name="if" scope="normal" type="Number"/>
      <property name="public" scope="normal" type="Number"/>
      <property name="friend" scope="normal" type="Number"/>
      <property name="do" scope="normal" type="Number"/>
      <property name="return" scope="normal" type="Number"/>
      <property name="goto" scope="normal" type="Number"/>
      <property name="auto" scope="normal" type="Number"/>
      <property name="void" scope="normal" type="Number"/>
      <property name="enum" scope="normal" type="Number"/>
      <property name="else" scope="normal" type="Number"/>
      <property name="break" scope="normal" type="Number"/>
      <property name="new" scope="normal" type="Number"/>
      <property name="extern" scope="normal" type="Number"/>
      <property name="using" scope="normal" type="Number"/>
      <property name="true" scope="normal" type="Number"/>
      <property name="class" scope="normal" type="Number"/>
      <property name="asm" scope="normal" type="Number"/>
      <property name="case" scope="normal" type="Number"/>
      <property name="typeid" scope="normal" type="Number"/>
      <property name="short" scope="normal" type="Number"/>
      <property name="reinterpret_cast" scope="normal" type="Number"/>
      <property name="default" scope="normal" type="Number"/>
      <property name="double" scope="normal" type="Number"/>
      <property name="register" scope="normal" type="Number"/>
      <property name="explicit" scope="normal" type="Number"/>
      <property name="signed" scope="normal" type="Number"/>
      <property name="typename" scope="normal" type="Number"/>
      <property name="try" scope="normal" type="Number"/>
      <property name="this" scope="normal" type="Number"/>
      <property name="switch" scope="normal" type="Number"/>
      <property name="continue" scope="normal" type="Number"/>
      <property name="wchar_t" scope="normal" type="Number"/>
      <property name="inline" scope="normal" type="Number"/>
      <property name="delete" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.css">
    <properties>
      <property name="case_insensitive" scope="normal" type="Object"/>
      <property name="modes" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.css.defaultMode">
    <properties>
      <property name="contains" scope="normal" type="Array"/>
      <property name="lexems" scope="normal" type="Array"/>
      <property name="illegal" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.delphi">
    <properties>
      <property name="case_insensitive" scope="normal" type="Object"/>
      <property name="modes" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.delphi.defaultMode">
    <properties>
      <property name="lexems" scope="normal" type="Array"/>
      <property name="illegal" scope="normal" type="String"/>
      <property name="contains" scope="normal" type="Array"/>
      <property name="keywords" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.django">
    <properties>
      <property name="case_insensitive" scope="normal" type="Object"/>
      <property name="modes" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.django.defaultMode">
    <properties>
      <property name="contains" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.html">
    <properties>
      <property name="case_insensitive" scope="normal" type="Object"/>
      <property name="modes" scope="normal" type="Array"/>
      <property name="HTML_TAGS" scope="normal" type=""/>
      <property name="HTML_DOCTYPE" scope="normal" type=""/>
      <property name="HTML_ATTR" scope="normal" type=""/>
      <property name="HTML_VALUE" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.html.defaultMode">
    <properties>
      <property name="contains" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.javascript">
    <properties>
      <property name="modes" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.javascript.defaultMode">
    <properties>
      <property name="lexems" scope="normal" type="Array"/>
      <property name="contains" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.javascript.defaultMode.keywords"/>
  <object location="dojox.highlight.languages.javascript.defaultMode.keywords.keyword">
    <properties>
      <property name="in" scope="normal" type="Number"/>
      <property name="if" scope="normal" type="Number"/>
      <property name="for" scope="normal" type="Number"/>
      <property name="while" scope="normal" type="Number"/>
      <property name="finally" scope="normal" type="Number"/>
      <property name="var" scope="normal" type="Number"/>
      <property name="new" scope="normal" type="Number"/>
      <property name="function" scope="normal" type="Number"/>
      <property name="do" scope="normal" type="Number"/>
      <property name="return" scope="normal" type="Number"/>
      <property name="void" scope="normal" type="Number"/>
      <property name="else" scope="normal" type="Number"/>
      <property name="break" scope="normal" type="Number"/>
      <property name="catch" scope="normal" type="Number"/>
      <property name="instanceof" scope="normal" type="Number"/>
      <property name="with" scope="normal" type="Number"/>
      <property name="throw" scope="normal" type="Number"/>
      <property name="case" scope="normal" type="Number"/>
      <property name="default" scope="normal" type="Number"/>
      <property name="try" scope="normal" type="Number"/>
      <property name="this" scope="normal" type="Number"/>
      <property name="switch" scope="normal" type="Number"/>
      <property name="continue" scope="normal" type="Number"/>
      <property name="typeof" scope="normal" type="Number"/>
      <property name="delete" scope="normal" type="Number"/>
      <property name="const" scope="normal" type="Number"/>
      <property name="label" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.javascript.defaultMode.keywords.literal">
    <properties>
      <property name="true" scope="normal" type="Number"/>
      <property name="false" scope="normal" type="Number"/>
      <property name="null" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.pygments._html" private="true"/>
  <object location="dojox.highlight.languages.pygments._html.tags">
    <properties>
      <property name="code" scope="normal" type="Number"/>
      <property name="kbd" scope="normal" type="Number"/>
      <property name="font" scope="normal" type="Number"/>
      <property name="noscript" scope="normal" type="Number"/>
      <property name="style" scope="normal" type="Number"/>
      <property name="img" scope="normal" type="Number"/>
      <property name="title" scope="normal" type="Number"/>
      <property name="menu" scope="normal" type="Number"/>
      <property name="tt" scope="normal" type="Number"/>
      <property name="tr" scope="normal" type="Number"/>
      <property name="param" scope="normal" type="Number"/>
      <property name="li" scope="normal" type="Number"/>
      <property name="tfoot" scope="normal" type="Number"/>
      <property name="th" scope="normal" type="Number"/>
      <property name="input" scope="normal" type="Number"/>
      <property name="td" scope="normal" type="Number"/>
      <property name="dl" scope="normal" type="Number"/>
      <property name="blockquote" scope="normal" type="Number"/>
      <property name="fieldset" scope="normal" type="Number"/>
      <property name="big" scope="normal" type="Number"/>
      <property name="dd" scope="normal" type="Number"/>
      <property name="abbr" scope="normal" type="Number"/>
      <property name="optgroup" scope="normal" type="Number"/>
      <property name="dt" scope="normal" type="Number"/>
      <property name="button" scope="normal" type="Number"/>
      <property name="isindex" scope="normal" type="Number"/>
      <property name="p" scope="normal" type="Number"/>
      <property name="small" scope="normal" type="Number"/>
      <property name="div" scope="normal" type="Number"/>
      <property name="dir" scope="normal" type="Number"/>
      <property name="em" scope="normal" type="Number"/>
      <property name="frame" scope="normal" type="Number"/>
      <property name="meta" scope="normal" type="Number"/>
      <property name="sub" scope="normal" type="Number"/>
      <property name="bdo" scope="normal" type="Number"/>
      <property name="label" scope="normal" type="Number"/>
      <property name="acronym" scope="normal" type="Number"/>
      <property name="sup" scope="normal" type="Number"/>
      <property name="body" scope="normal" type="Number"/>
      <property name="xml" scope="normal" type="Number"/>
      <property name="basefont" scope="normal" type="Number"/>
      <property name="base" scope="normal" type="Number"/>
      <property name="br" scope="normal" type="Number"/>
      <property name="address" scope="normal" type="Number"/>
      <property name="strong" scope="normal" type="Number"/>
      <property name="legend" scope="normal" type="Number"/>
      <property name="ol" scope="normal" type="Number"/>
      <property name="script" scope="normal" type="Number"/>
      <property name="caption" scope="normal" type="Number"/>
      <property name="s" scope="normal" type="Number"/>
      <property name="col" scope="normal" type="Number"/>
      <property name="h2" scope="normal" type="Number"/>
      <property name="h3" scope="normal" type="Number"/>
      <property name="h1" scope="normal" type="Number"/>
      <property name="h6" scope="normal" type="Number"/>
      <property name="h4" scope="normal" type="Number"/>
      <property name="h5" scope="normal" type="Number"/>
      <property name="table" scope="normal" type="Number"/>
      <property name="select" scope="normal" type="Number"/>
      <property name="noframes" scope="normal" type="Number"/>
      <property name="span" scope="normal" type="Number"/>
      <property name="area" scope="normal" type="Number"/>
      <property name="dfn" scope="normal" type="Number"/>
      <property name="strike" scope="normal" type="Number"/>
      <property name="cite" scope="normal" type="Number"/>
      <property name="thead" scope="normal" type="Number"/>
      <property name="head" scope="normal" type="Number"/>
      <property name="option" scope="normal" type="Number"/>
      <property name="form" scope="normal" type="Number"/>
      <property name="hr" scope="normal" type="Number"/>
      <property name="var" scope="normal" type="Number"/>
      <property name="link" scope="normal" type="Number"/>
      <property name="b" scope="normal" type="Number"/>
      <property name="colgroup" scope="normal" type="Number"/>
      <property name="ul" scope="normal" type="Number"/>
      <property name="applet" scope="normal" type="Number"/>
      <property name="del" scope="normal" type="Number"/>
      <property name="iframe" scope="normal" type="Number"/>
      <property name="pre" scope="normal" type="Number"/>
      <property name="frameset" scope="normal" type="Number"/>
      <property name="ins" scope="normal" type="Number"/>
      <property name="tbody" scope="normal" type="Number"/>
      <property name="html" scope="normal" type="Number"/>
      <property name="samp" scope="normal" type="Number"/>
      <property name="map" scope="normal" type="Number"/>
      <property name="object" scope="normal" type="Number"/>
      <property name="a" scope="normal" type="Number"/>
      <property name="xmlns" scope="normal" type="Number"/>
      <property name="center" scope="normal" type="Number"/>
      <property name="textarea" scope="normal" type="Number"/>
      <property name="i" scope="normal" type="Number"/>
      <property name="q" scope="normal" type="Number"/>
      <property name="u" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.pygments">
    <properties>
      <property name="_www" scope="normal" type="Object"/>
      <property name="css" scope="normal" type="Object"/>
      <property name="html" scope="normal" type="Object"/>
      <property name="javascript" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.css.defaultMode.keywords">
    <properties>
      <property name="name tag" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.css.defaultMode.keywords.keyword">
    <properties>
      <property name="@media" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.javascript.defaultMode.keywords.keyword constant">
    <properties>
      <property name="true" scope="normal" type="Number"/>
      <property name="false" scope="normal" type="Number"/>
      <property name="null" scope="normal" type="Number"/>
      <property name="NaN" scope="normal" type="Number"/>
      <property name="Infinity" scope="normal" type="Number"/>
      <property name="undefined" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.javascript.defaultMode.keywords.name builtin">
    <properties>
      <property name="Array" scope="normal" type="Number"/>
      <property name="Boolean" scope="normal" type="Number"/>
      <property name="Date" scope="normal" type="Number"/>
      <property name="Error" scope="normal" type="Number"/>
      <property name="Function" scope="normal" type="Number"/>
      <property name="Math" scope="normal" type="Number"/>
      <property name="netscape" scope="normal" type="Number"/>
      <property name="Number" scope="normal" type="Number"/>
      <property name="Object" scope="normal" type="Number"/>
      <property name="Packages" scope="normal" type="Number"/>
      <property name="RegExp" scope="normal" type="Number"/>
      <property name="String" scope="normal" type="Number"/>
      <property name="sun" scope="normal" type="Number"/>
      <property name="decodeURI" scope="normal" type="Number"/>
      <property name="decodeURIComponent" scope="normal" type="Number"/>
      <property name="encodeURI" scope="normal" type="Number"/>
      <property name="encodeURIComponent" scope="normal" type="Number"/>
      <property name="eval" scope="normal" type="Number"/>
      <property name="isFinite" scope="normal" type="Number"/>
      <property name="isNaN" scope="normal" type="Number"/>
      <property name="parseFloat" scope="normal" type="Number"/>
      <property name="parseInt" scope="normal" type="Number"/>
      <property name="document" scope="normal" type="Number"/>
      <property name="window" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.javascript.defaultMode.keywords.name builtin pseudo">
    <properties>
      <property name="this" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.pygments.xml">
    <properties>
      <property name="a" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.xml">
    <properties>
      <property name="modes" scope="normal" type="Array"/>
      <property name="case_insensitive" scope="normal" type="Object"/>
      <property name="XML_COMMENT" scope="normal" type=""/>
      <property name="XML_ATTR" scope="normal" type=""/>
      <property name="XML_VALUE" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.xml.defaultMode">
    <properties>
      <property name="contains" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.python">
    <summary>Python highlight definitions</summary>
    <properties>
      <property name="modes" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.python.defaultMode">
    <properties>
      <property name="lexems" scope="normal" type="Array"/>
      <property name="illegal" scope="normal" type="String"/>
      <property name="contains" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.python.defaultMode.keywords">
    <properties>
      <property name="and" scope="normal" type="Number"/>
      <property name="elif" scope="normal" type="Number"/>
      <property name="is" scope="normal" type="Number"/>
      <property name="global" scope="normal" type="Number"/>
      <property name="as" scope="normal" type="Number"/>
      <property name="in" scope="normal" type="Number"/>
      <property name="if" scope="normal" type="Number"/>
      <property name="from" scope="normal" type="Number"/>
      <property name="raise" scope="normal" type="Number"/>
      <property name="for" scope="normal" type="Number"/>
      <property name="except" scope="normal" type="Number"/>
      <property name="finally" scope="normal" type="Number"/>
      <property name="print" scope="normal" type="Number"/>
      <property name="import" scope="normal" type="Number"/>
      <property name="pass" scope="normal" type="Number"/>
      <property name="None" scope="normal" type="Number"/>
      <property name="return" scope="normal" type="Number"/>
      <property name="exec" scope="normal" type="Number"/>
      <property name="else" scope="normal" type="Number"/>
      <property name="break" scope="normal" type="Number"/>
      <property name="not" scope="normal" type="Number"/>
      <property name="with" scope="normal" type="Number"/>
      <property name="class" scope="normal" type="Number"/>
      <property name="assert" scope="normal" type="Number"/>
      <property name="yield" scope="normal" type="Number"/>
      <property name="try" scope="normal" type="Number"/>
      <property name="while" scope="normal" type="Number"/>
      <property name="continue" scope="normal" type="Number"/>
      <property name="del" scope="normal" type="Number"/>
      <property name="or" scope="normal" type="Number"/>
      <property name="def" scope="normal" type="Number"/>
      <property name="lambda" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.sql">
    <summary>SQL highlight definitions</summary>
    <properties>
      <property name="case_insensitive" scope="normal" type="Object"/>
      <property name="modes" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.sql.defaultMode">
    <properties>
      <property name="lexems" scope="normal" type="Array"/>
      <property name="contains" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.sql.defaultMode.keywords">
    <properties>
      <property name="keyword" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.highlight.languages.sql.defaultMode.keywords.aggregate">
    <properties>
      <property name="count" scope="normal" type="Number"/>
      <property name="sum" scope="normal" type="Number"/>
      <property name="min" scope="normal" type="Number"/>
      <property name="max" scope="normal" type="Number"/>
      <property name="avg" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.html">
    <summary>TODOC</summary>
    <properties>
      <property name="_base" scope="normal" type="Object"/>
      <property name="ellipsis" scope="normal" type="Object"/>
      <property name="styles" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="_adjustCssPaths" scope="normal">
        <summary>adjusts relative paths in cssText to be relative to cssUrl
	a path is considered relative if it doesn't start with '/' and not contains ':'</summary>
        <description>Say we fetch a HTML page from level1/page.html
	It has some inline CSS:
	@import "css/page.css" tv, screen;
	...
	background-image: url(images/aplhaimage.png);
	as we fetched this HTML and therefore this CSS
	from level1/page.html, these paths needs to be adjusted to:
	@import 'level1/css/page.css' tv, screen;
	...
	background-image: url(level1/images/alphaimage.png);
	In IE it will also adjust relative paths in AlphaImageLoader()
	filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='images/alphaimage.png');
	will be adjusted to:
	filter:progid:DXImageTransform.Microsoft.AlphaImageLoader(src='level1/images/alphaimage.png');
	Please note that any relative paths in AlphaImageLoader in external css files wont work, as
	the paths in AlphaImageLoader is MUST be declared relative to the HTML page,
	not relative to the CSS file that declares it</description>
        <parameters>
          <parameter name="cssUrl" type="" usage="required"/>
          <parameter name="cssText" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_adjustHtmlPaths" scope="normal">
        <parameters>
          <parameter name="htmlUrl" type="" usage="required"/>
          <parameter name="cont" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_snarfStyles" scope="normal">
        <parameters>
          <parameter name="cssUrl" type="String" usage="required"/>
          <parameter name="cont" type="String" usage="required"/>
          <parameter name="styles" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="squelsh the &lt;style&gt; or &lt;link&gt;"/>
        </return-types>
      </method>
      <method name="_snarfScripts" scope="normal">
        <parameters>
          <parameter name="cont" type="" usage="required"/>
          <parameter name="byRef" type="" usage="required"/>
        </parameters>
      </method>
      <method name="evalInGlobal" scope="normal">
        <parameters>
          <parameter name="code" type="" usage="required"/>
          <parameter name="appendNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="set" scope="normal">
        <summary>inserts (replaces) the given content into the given node</summary>
        <examples>
          <example>A safe string/node/nodelist content replacement/injection with hooks for extension
	Example Usage:
	dojo.html.set(node, "some string");
	dojo.html.set(node, contentNode, {options});
	dojo.html.set(node, myNode.childNodes, {options});</example>
        </examples>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>the parent element that will receive the content</summary>
          </parameter>
          <parameter name="cont" type="String|DomNode|NodeList" usage="required">
            <summary>the content to be set on the parent element.
	This can be an html string, a node reference or a NodeList, dojo.NodeList, Array or other enumerable list of nodes</summary>
          </parameter>
          <parameter name="params" type="Object" usage="optional">
            <summary>Optional flags/properties to configure the content-setting. See dojo.html._ContentSetter</summary>
          </parameter>
        </parameters>
      </method>
      <method name="insertCssRule" scope="normal">
        <summary>Creates a style and attaches it to a dynamically created stylesheet
	arguments:</summary>
        <parameters>
          <parameter name="selector" type="String" usage="required">
            <summary>A fully qualified class name, as it would appear in
	a CSS dojo.doc. Start classes with periods, target
	nodes with '#'. Large selectors can also be created
	like:
	 &amp;quot;#myDiv.myClass span input&amp;quot;</summary>
          </parameter>
          <parameter name="declaration" type="String" usage="required">
            <summary>A single string that would make up a style block, not
	including the curly braces. Include semi-colons between
	statements. Do not use JavaScript style declarations
	in camel case, use as you would in a CSS dojo.doc:
	 &amp;quot;color:#ffoooo;font-size:12px;margin-left:5px;&amp;quot;</summary>
          </parameter>
          <parameter name="styleSheetName" type="String" usage="required">
            <summary>optional )
	Name of the dynamic style sheet this rule should be
	inserted into. If is not found by that name, it is
	created. If no name is passed, the name &amp;quot;default&amp;quot; is
	used.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="removeCssRule" scope="normal">
        <summary>Removes a cssRule base on the selector and declaration passed
	The declaration is needed for cases of dupe selectors</summary>
        <description>Only removes DYNAMICALLY created cssRules. If you
	created it with dojox.html.insertCssRule, it can be removed.</description>
        <parameters>
          <parameter name="selector" type="String" usage="required"/>
          <parameter name="declaration" type="String" usage="required"/>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getStyleSheet" scope="normal">
        <summary>Returns a style sheet based on the argument.
	Searches dynamic style sheets first. If no matches,
	searches document style sheets.
	argument: (optional)
	A title or an href to a style sheet. Title can be
	an attribute in a tag, or a dynamic style sheet
	reference. Href can be the name of the file.
	If no argument, the assumed created dynamic style
	sheet is used.</summary>
        <parameters>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="StyleSheet or false"/>
        </return-types>
      </method>
      <method name="getDynamicStyleSheet" scope="normal">
        <summary>Creates and returns a dynamically created style sheet
	used for dynamic styles
	argument:
	styleSheetName /* optional String
	The name given the style sheet so that multiple
	style sheets can be created and referenced. If
	no argument is given, the name &amp;quot;default&amp;quot; is used.</summary>
        <parameters>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="StyleSheet"/>
        </return-types>
      </method>
      <method name="enableStyleSheet" scope="normal">
        <summary>Enables the style sheet with the name passed in the
	argument. Deafults to the default style sheet.</summary>
        <parameters>
          <parameter name="styleSheetName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="disableStyleSheet" scope="normal">
        <summary>Disables the dynamic style sheet with the name passed in the
	argument. If no arg is passed, defaults to the default style sheet.</summary>
        <parameters>
          <parameter name="styleSheetName" type="" usage="required"/>
        </parameters>
      </method>
      <method name="activeStyleSheet" scope="normal">
        <summary>Getter/Setter</summary>
        <description>If passed a title, enables a that style sheet. All other
	toggle-able style sheets are disabled.
	If no argument is passed, returns currently enabled
	style sheet.</description>
        <parameters>
          <parameter name="title" type="?String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="StyleSheet or Boolean - FIXME - doesn't make a lot of sense"/>
        </return-types>
      </method>
      <method name="getPreferredStyleSheet" scope="normal"/>
      <method name="getToggledStyleSheets" scope="normal">
        <summary>Searches HTML for style sheets that are &amp;quot;toggle-able&amp;quot; -
	can be enabled and disabled. These would include sheets
	with the title attribute, as well as the REL attribute.</summary>
        <return-description>An array of all toggle-able style sheets
	TODO: 	Sets of style sheets could be grouped according to
	an ID and used in sets, much like different
	groups of radio buttons. It would not however be
	according to W3C spec</return-description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="getStyleSheets" scope="normal">
        <summary>Collects all the style sheets referenced in the HTML page,
	including any incuded via @import.</summary>
        <return-description>An hash map of all the style sheets.
	TODO: 	Does not recursively search for @imports, so it will
	only go one level deep.</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.html._ContentSetter" type="Function" classlike="true" superclass="dojo.html._ContentSetter">
    <mixins>
      <mixin scope="instance" location="dojo.html._ContentSetter"/>
    </mixins>
    <properties>
      <property name="adjustPaths" scope="prototype" type="Boolean">
        <summary>Adjust relative paths in html string content to point to this page
	Only useful if you grab content from a another folder than the current one</summary>
      </property>
      <property name="referencePath" scope="prototype" type="String"/>
      <property name="renderStyles" scope="prototype" type="bool"/>
      <property name="executeScripts" scope="prototype" type="bool"/>
      <property name="scriptHasHooks" scope="prototype" type="bool"/>
      <property name="scriptHookReplacement" scope="prototype" type="Object"/>
      <property name="_styleNodes" scope="prototype" type="Array"/>
      <property name="_styles" scope="prototype" type="Array"/>
      <property name="_code" scope="prototype" type=""/>
      <property name="content" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_renderStyles" scope="prototype">
        <parameters>
          <parameter name="styles" type="" usage="required"/>
        </parameters>
      </method>
      <method name="empty" scope="prototype"/>
      <method name="onBegin" scope="prototype"/>
      <method name="onEnd" scope="prototype"/>
      <method name="tearDown" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.html._ContentSetter.node" type="">
    <properties>
      <property name="ownerDocument" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.html.entities">
    <properties>
      <property name="html" scope="normal" type="Array"/>
      <property name="latin" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method name="encode" scope="normal">
        <summary>Function to obtain an entity encoding for a specified characer</summary>
        <parameters>
          <parameter name="str" type="string" usage="required">
            <summary>The string to process for possible entity encoding.</summary>
          </parameter>
          <parameter name="m" type="array" usage="optional">
            <summary>An optional list of character to entity name mappings (array of
	arrays).  If not provided, it uses the and latin entities as the
	set to map and escape.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="decode" scope="normal">
        <summary>Function to obtain an entity encoding for a specified characer</summary>
        <parameters>
          <parameter name="str" type="string" usage="required">
            <summary>The string to process for possible entity encoding to decode.</summary>
          </parameter>
          <parameter name="m" type="array" usage="optional">
            <summary>An optional list of character to entity name mappings (array of
	arrays).  If not provided, it uses the and latin entities as the
	set to map and unencode.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.html.format">
    <methods>
      <method name="prettyPrint" scope="normal">
        <summary>Function for providing a 'pretty print' version of HTML content from
	the provided string.  It's nor perfect by any means, but it does
	a 'reasonable job'.</summary>
        <parameters>
          <parameter name="html" type="String" usage="required">
            <summary>The string of HTML to try and generate a 'pretty' formatting.</summary>
          </parameter>
          <parameter name="indentBy" type="Integer" usage="optional">
            <summary>Optional input for the number of spaces to use when indenting.
	If not defined, zero, negative, or greater than 10, will just use tab
	as the indent.</summary>
          </parameter>
          <parameter name="maxLineLength" type="Integer" usage="optional">
            <summary>Optional input for the number of characters a text line should use in
	the document, not including the indent.</summary>
          </parameter>
          <parameter name="map" type="Array" usage="optional">
            <summary>Optional array of entity mapping characters to use when processing the
	HTML Text content.  By default it uses the default set used by the
	dojox.html.entities.encode function.</summary>
          </parameter>
          <parameter name="xhtml" type="boolean" usage="required">
            <summary>Optional parameter that declares that the returned HTML should try to be 'xhtml' compatible.
	This means normally unclosed tags are terminated with /&amp;gt; instead of &amp;gt;.  Example: &amp;lt;hr&amp;gt; -&amp;gt; &amp;lt;hr /&amp;gt;</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.html.metrics" type="">
    <properties>
      <property name="_fontResizeNode" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="getFontMeasurements" scope="normal">
        <return-types>
          <return-type type="object"/>
        </return-types>
      </method>
      <method name="getCachedFontMeasurements" scope="normal">
        <parameters>
          <parameter name="recalculate" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getTextBox" scope="normal">
        <parameters>
          <parameter name="text" type="String" usage="required"/>
          <parameter name="style" type="Object" usage="required"/>
          <parameter name="className" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="getScrollbar" scope="normal"/>
      <method name="initOnFontResize" scope="normal">
        <parameters>
          <parameter name="interval" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onFontResize" scope="normal"/>
      <method name="_fontresize" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.image">
    <summary>A collection of image related widgets</summary>
    <properties>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="preload" scope="normal">
        <summary>Preload a list of images in the dom.</summary>
        <return-description>Array
	An Array of DomNodes that have been cached.</return-description>
        <examples>
          <example>Load two images into cache:
		dojox.image.preload(["foo.png", "bar.gif"]);</example>
          <example>Using djConfig:
		var djConfig = {
			preloadImages:["bar.png", "baz.png", "http://example.com/icon.gif"]
		};</example>
        </examples>
        <parameters>
          <parameter name="urls" type="Array" usage="required">
            <summary>The list of urls to load. Can be any valid .src attribute.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.image.Badge" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A simple grid of Images that loops through thumbnails</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="children" scope="prototype" type="String">
        <summary>A CSS3 Selector that determines the node to become a child</summary>
      </property>
      <property name="rows" scope="prototype" type="Integer">
        <summary>Number of Rows to display</summary>
      </property>
      <property name="cols" scope="prototype" type="Integer">
        <summary>Number of Columns to display</summary>
      </property>
      <property name="cellSize" scope="prototype" type="Integer">
        <summary>Size in PX of each thumbnail</summary>
      </property>
      <property name="cellMargin" scope="prototype" type="Integer">
        <summary>Size in PX to adjust for cell margins</summary>
      </property>
      <property name="delay" scope="prototype" type="Integer">
        <summary>Time (in ms) to show the image before sizing down again</summary>
      </property>
      <property name="threads" scope="prototype" type="Integer">
        <summary>how many cycles will be going &amp;quot;simultaneously&amp;quot; (&amp;gt;2 not reccommended)</summary>
      </property>
      <property name="easing" scope="prototype" type="Function|String">
        <summary>An easing function to use when showing the node (does not apply to shrinking)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="_init" scope="prototype">
        <summary>Setup and layout the images</summary>
      </method>
      <method name="_getCell" scope="prototype">
        <summary>Return information about the position for a given node</summary>
        <parameters>
          <parameter name="n" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_getImage" scope="prototype">
        <summary>Returns the next image in the list, or the first one if not available</summary>
      </method>
      <method name="_enbiggen" scope="prototype">
        <summary>Show the passed node in the picker</summary>
        <parameters>
          <parameter name="e" type="Event|DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="_loadUnder" scope="prototype">
        <summary>figure out which three images are being covered, and
	determine if they need loaded or not</summary>
        <parameters>
          <parameter name="info" type="" usage="required"/>
          <parameter name="props" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_disenbiggen" scope="prototype">
        <summary>Hide the passed node (info.n), passing along properties
	received.</summary>
        <parameters>
          <parameter name="info" type="" usage="required"/>
          <parameter name="props" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_cycle" scope="prototype">
        <summary>Select an un-viewed image from the list, and show it</summary>
        <parameters>
          <parameter name="info" type="" usage="required"/>
          <parameter name="props" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.image.Badge._nl" private="true">
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.image.FlickrBadge" type="Function" classlike="true" superclass="dojox.image.Badge">
    <mixins>
      <mixin scope="instance" location="dojox.image.Badge"/>
    </mixins>
    <properties>
      <property name="children" scope="prototype" type="String"/>
      <property name="userid" scope="prototype" type="String">
        <summary>If you know your Flickr userid, you can set it to prevent a call to fetch the id</summary>
      </property>
      <property name="username" scope="prototype" type="String">
        <summary>Your Flickr username</summary>
      </property>
      <property name="setid" scope="prototype" type="String">
        <summary>The id of the set to display</summary>
      </property>
      <property name="tags" scope="prototype" type="String"/>
      <property name="searchText" scope="prototype" type="String">
        <summary>Free text search.  Photos who's title, description, or tags contain the text will be displayed</summary>
      </property>
      <property name="target" scope="prototype" type="String">
        <summary>Where to display the pictures when clicked on.  Valid values are the same as the target attribute
	of the A tag.</summary>
      </property>
      <property name="apikey" scope="prototype" type="String"/>
      <property name="_store" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.image.Gallery" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Gallery widget that wraps a dojox.image.ThumbnailPicker and dojox.image.SlideShow widget</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="imageHeight" scope="prototype" type="Number">
        <summary>Maximum height of an image in the SlideShow widget</summary>
      </property>
      <property name="imageWidth" scope="prototype" type="Number">
        <summary>Maximum width of an image in the SlideShow widget</summary>
      </property>
      <property name="pageSize" scope="normal" type="Number">
        <summary>The number of records to retrieve from the data store per request.</summary>
      </property>
      <property name="autoLoad" scope="prototype" type="Boolean">
        <summary>If true, images are loaded before the user views them. If false, an
	image is loaded when the user displays it.</summary>
      </property>
      <property name="linkAttr" scope="prototype" type="String">
        <summary>Defines the name of the attribute to request from the store to retrieve the
	URL to link to from an image, if any.</summary>
      </property>
      <property name="imageThumbAttr" scope="prototype" type="String">
        <summary>Defines the name of the attribute to request from the store to retrieve the
	URL to the thumbnail image.</summary>
      </property>
      <property name="imageLargeAttr" scope="prototype" type="String">
        <summary>Defines the name of the attribute to request from the store to retrieve the
	URL to the image.</summary>
      </property>
      <property name="titleAttr" scope="prototype" type="String">
        <summary>Defines the name of the attribute to request from the store to retrieve the
	title of the picture, if any.</summary>
      </property>
      <property name="slideshowInterval" scope="prototype" type="Integer">
        <summary>Time, in seconds, between image changes in the slide show.</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="widgetid" scope="prototype" type=""/>
      <property name="thumbPicker" scope="prototype" type="Object"/>
      <property name="slideShow" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Initializes the widget, creates the ThumbnailPicker and SlideShow widgets</summary>
      </method>
      <method name="setDataStore" scope="prototype">
        <summary>Sets the data store and request objects to read data from.</summary>
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <summary>implementation of the dojo.data.api.Read API. This accesses the image
	data.</summary>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <summary>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</summary>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <summary>An object defining the names of the item attributes to fetch from the
	data store.  The four attributes allowed are 'linkAttr', 'imageLargeAttr',
	'imageThumbAttr' and 'titleAttr'</summary>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <summary>Resets the widget to its initial state</summary>
      </method>
      <method name="showNextImage" scope="prototype">
        <summary>Changes the image being displayed in the SlideShow to the next
	image in the data store</summary>
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required">
            <summary>If true, a slideshow is active, otherwise the slideshow is inactive.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="toggleSlideshow" scope="prototype"/>
      <method name="toggleSlideShow" scope="prototype">
        <summary>Switches the slideshow mode on and off.</summary>
      </method>
      <method name="showImage" scope="prototype">
        <summary>Shows the image at index 'idx'.
	idx: Number
	The position of the image in the data store to display</summary>
        <parameters>
          <parameter name="index" type="" usage="required"/>
          <parameter name="callback" type="optional" usage="required">
            <summary>Function Optional callback function to call when the image has finished displaying.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_centerChildren" scope="prototype">
        <summary>Ensures that the ThumbnailPicker and the SlideShow widgets
	are centered.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.image.Lightbox" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A dojo-based Lightbox implementation.</summary>
    <description>An Elegant, keyboard accessible, markup and store capable Lightbox widget to show images
	in a modal dialog-esque format. Can show individual images as Modal dialog, or can group
	images with multiple entry points, all using a single "master" Dialog for visualization
	key controls:
	ESC - close
	Down Arrow / Rt Arrow / N - Next Image
	Up Arrow / Lf Arrow / P - Previous Image</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <examples>
      <example>	&lt;a href="image1.jpg" dojoType="dojox.image.Lightbox"&gt;show lightbox&lt;/a&gt;</example>
      <example>	&lt;a href="image2.jpg" dojoType="dojox.image.Lightbox" group="one"&gt;show group lightbox&lt;/a&gt;
		&lt;a href="image3.jpg" dojoType="dojox.image.Lightbox" group="one"&gt;show group lightbox&lt;/a&gt;</example>
      <example>	not implemented fully yet, though works with basic datastore access. need to manually call
		widget._attachedDialog.addImage(item,"fromStore") for each item in a store result set.
		&lt;div dojoType="dojox.image.Lightbox" group="fromStore" store="storeName"&gt;&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="group" scope="prototype" type="String">
        <summary>Grouping images in a page with similar tags will provide a 'slideshow' like grouping of images</summary>
      </property>
      <property name="title" scope="prototype" type="String">
        <summary>A string of text to be shown in the Lightbox beneath the image (empty if using a store)</summary>
      </property>
      <property name="href" scope="prototype" type="String"/>
      <property name="duration" scope="prototype" type="Integer">
        <summary>Generic time in MS to adjust the feel of widget. could possibly add various
	durations for the various actions (dialog fadein, sizeing, img fadein ...)</summary>
      </property>
      <property name="modal" scope="prototype" type="Boolean">
        <summary>If true, this Dialog instance will be truly modal and prevent closing until
	explicitly told to by calling hide() or clicking the (x) - Defaults to false
	to preserve previous behaviors. (aka: enable click-to-click on the underlay)</summary>
      </property>
      <property name="_allowPassthru" scope="prototype" type="Boolean">
        <summary>Privately set this to disable/enable natural link of anchor tags</summary>
      </property>
      <property name="_attachedDialog" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="_addSelf" scope="prototype">
        <summary>Add this instance to the master LightBoxDialog</summary>
      </method>
      <method name="_handleClick" scope="prototype">
        <summary>Handle the click on the link</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <summary>Show the Lightbox with this instance as the starting point</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Hide the Lightbox currently showing</summary>
      </method>
      <method name="disable" scope="prototype">
        <summary>Disables event clobbering and dialog, and follows natural link</summary>
      </method>
      <method name="enable" scope="prototype">
        <summary>Enables the dialog (prevents default link)</summary>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Stub fired when the image in the lightbox is clicked.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.image.LightboxDialog" type="Function" classlike="true" superclass="dijit.Dialog">
    <summary>The &amp;quot;dialog&amp;quot; shared  between any Lightbox instances on the page, publically available
	for programatic manipulation.</summary>
    <description>A widget that intercepts anchor links (typically around images)
	and displays a modal Dialog. this is the actual Dialog, which you can
	create and populate manually, though should use simple Lightbox's
	unless you need the direct access.
	There should only be one of these on a page, so all dojox.image.Lightbox's will us it
	(the first instance of a Lightbox to be show()'n will create me If i do not exist)</description>
    <mixins>
      <mixin scope="instance" location="dijit.Dialog"/>
    </mixins>
    <examples>
      <example>	// show a single image from a url
		var url = "http://dojotoolkit.org/logo.png";
		var dialog = new dojox.image.LightboxDialog().startup();
		dialog.show({ href: url, title:"My Remote Image"});</example>
    </examples>
    <properties>
      <property name="title" scope="prototype" type="String">
        <summary>The current title, read from object passed to show()</summary>
      </property>
      <property name="inGroup" scope="prototype" type="Array">
        <summary>Array of objects. this is populated by from the JSON object _groups, and
	should not be populate manually. it is a placeholder for the currently
	showing group of images in this master dialog</summary>
      </property>
      <property name="imgUrl" scope="normal" type="String">
        <summary>The src=&amp;quot;&amp;quot; attribute of our imageNode (can be null at statup)</summary>
      </property>
      <property name="errorMessage" scope="prototype" type="String">
        <summary>The text to display when an unreachable image is linked</summary>
      </property>
      <property name="adjust" scope="prototype" type="Boolean">
        <summary>If true, ensure the image always stays within the viewport
	more difficult than necessary to disable, but enabled by default
	seems sane in most use cases.</summary>
      </property>
      <property name="modal" scope="prototype" type="Boolean">
        <summary>If true, this Dialog instance will be truly modal and prevent closing until
	explicitly told to by calling hide() or clicking the (x) - Defaults to false
	to preserve previous behaviors. (aka: enable click-to-click on the underlay)</summary>
      </property>
      <property name="errorImg" scope="prototype" type="Url">
        <summary>Path to the image used when a 404 is encountered</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_animConnects" scope="prototype" type="Array"/>
      <property name="_vp" scope="prototype" type="Object"/>
      <property name="_lastGroup" scope="prototype" type=""/>
      <property name="_index" scope="prototype" type="Object"/>
      <property name="_imageReady" scope="prototype" type="bool"/>
      <property name="_lastTitleSize" scope="prototype" type=""/>
      <property name="_lastSize" scope="prototype" type=""/>
      <property name="_currentSize" scope="prototype" type=""/>
      <property name="_wasStyled" scope="prototype" type="Object"/>
      <property name="_showImageAnim" scope="prototype" type="Object"/>
      <property name="_loadingAnim" scope="prototype" type="Object"/>
      <property name="_showNavAnim" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>Add some extra event handlers, and startup our superclass.</summary>
        <return-description>dijit._Widget
	Perhaps the only `dijit._Widget` that returns itself to allow
	'chaining' or var referencing with .startup()</return-description>
      </method>
      <method name="show" scope="prototype">
        <summary>Show the Master Dialog. Starts the chain of events to show
	an image in the dialog, including showing the dialog if it is
	not already visible</summary>
        <parameters>
          <parameter name="groupData" type="Object" usage="required">
            <summary>needs href and title attributes. the values for this image.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_ready" scope="prototype">
        <summary>A function to trigger all 'real' showing of some src</summary>
        <parameters>
          <parameter name="src" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_nextImage" scope="prototype">
        <summary>Load next image in group</summary>
      </method>
      <method name="_prevImage" scope="prototype">
        <summary>Load previous image in group</summary>
      </method>
      <method name="_loadImage" scope="prototype">
        <summary>Do the prep work before we can show another image</summary>
      </method>
      <method name="_prepNodes" scope="prototype">
        <summary>A localized hook to accompany _loadImage</summary>
      </method>
      <method name="resizeTo" scope="prototype">
        <summary>Resize our dialog container, and fire _showImage</summary>
        <parameters>
          <parameter name="size" type="Object" usage="required"/>
          <parameter name="forceTitle" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_scaleToFit" scope="prototype">
        <summary>resize an image to fit within the bounds of the viewport</summary>
        <parameters>
          <parameter name="size" type="Object" usage="required">
            <summary>The 'size' object passed around for this image</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_setImageSize" scope="prototype">
        <summary>Reset the image size to some actual size.</summary>
        <parameters>
          <parameter name="size" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_size" scope="prototype"/>
      <method name="_position" scope="prototype">
        <summary>we want to know the viewport size any time it changes</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_showImage" scope="prototype">
        <summary>Fade in the image, and fire showNav</summary>
      </method>
      <method name="_showNav" scope="prototype">
        <summary>Fade in the footer, and setup our connections.</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Hide the Master Lightbox</summary>
      </method>
      <method name="addImage" scope="prototype">
        <summary>Add an image to this Master Lightbox</summary>
        <parameters>
          <parameter name="child" type="Object" usage="required">
            <summary>The image information to add.
	href: String - link to image (required)
	title: String - title to display</summary>
          </parameter>
          <parameter name="group" type="String" usage="optional">
            <summary>attach to group of similar tag or null for individual image instance</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_handleKey" scope="prototype">
        <summary>Handle keyboard navigation internally</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_makeAnims" scope="prototype">
        <summary>make and cleanup animation and animation connections</summary>
      </method>
      <method name="onClick" scope="prototype">
        <summary>a stub function, called with the currently displayed image as the only argument</summary>
        <parameters>
          <parameter name="groupData" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onImageClick" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.image.LightboxDialog._groups" private="true">
    <properties>
      <property name="XnoGroupX" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.image.LightboxDialog.imgNode" type="">
    <properties>
      <property name="height" scope="prototype" type=""/>
      <property name="width" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.image.LightboxNano" type="Function" classlike="true">
    <summary>A simple &amp;quot;nano&amp;quot; version of the lightbox.</summary>
    <description>Very lightweight lightbox which only displays a larger image.  There is
	no support for a caption or description.  The lightbox can be closed by
	clicking any where or pressing any key.  This widget is intended to be
	used on &lt;a&gt; and &lt;img&gt; tags.  Upon creation, if the domNode is &lt;img&gt; tag,
	then it is wrapped in an &lt;a&gt; tag, then a &lt;div class="enlarge"&gt; is placed
	inside the &lt;a&gt; and can be styled to display an icon that the original
	can be enlarged.</description>
    <examples>
      <example>	&lt;a dojoType="dojox.image.LightboxNano" href="/path/to/largeimage.jpg"&gt;&lt;img src="/path/to/thumbnail.jpg"&gt;&lt;/a&gt;</example>
      <example>	&lt;img dojoType="dojox.image.LightboxNano" src="/path/to/thumbnail.jpg" href="/path/to/largeimage.jpg"&gt;</example>
    </examples>
    <properties>
      <property name="href" scope="prototype" type="string">
        <summary>URL to the large image to show in the lightbox.</summary>
      </property>
      <property name="duration" scope="prototype" type="int">
        <summary>The delay in milliseconds of the LightboxNano open and close animation.</summary>
      </property>
      <property name="preloadDelay" scope="prototype" type="int">
        <summary>The delay in milliseconds after the LightboxNano is created before preloading the larger image.</summary>
      </property>
      <property name="_connects" scope="prototype" type="Array"/>
      <property name="_loadingNode" scope="prototype" type="bool"/>
      <property name="_node" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="p" type="Object" usage="optional"/>
          <parameter name="n" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initializes the DOM node and connect onload event</summary>
        <parameters>
          <parameter name="p" type="Object" usage="optional"/>
          <parameter name="n" type="DomNode" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroys the LightboxNano and it's DOM node</summary>
      </method>
      <method name="_createDiv" scope="prototype">
        <summary>Creates a div for the enlarge icon and loading indicator layers</summary>
        <parameters>
          <parameter name="cssClass" type="String" usage="required"/>
          <parameter name="refNode" type="DomNode" usage="required"/>
          <parameter name="display" type="boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="DomNode"/>
        </return-types>
      </method>
      <method name="_load" scope="prototype">
        <summary>Creates the large image and begins to show it</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_hideLoading" scope="prototype">
        <summary>Hides the animated loading indicator</summary>
      </method>
      <method name="_show" scope="prototype">
        <summary>The image is now loaded, calculate size and display</summary>
      </method>
      <method name="_sizeBg" scope="prototype">
        <summary>Resize the background to fill the page</summary>
      </method>
      <method name="_key" scope="prototype">
        <summary>A key was pressed, so hide the lightbox</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_coords" scope="prototype">
        <summary>Returns animation parameters with the start and end coords</summary>
        <parameters>
          <parameter name="s" type="Object" usage="required"/>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_hide" scope="prototype">
        <summary>Closes the lightbox</summary>
      </method>
      <method name="_reset" scope="prototype">
        <summary>Destroys the lightbox</summary>
      </method>
      <method name="_anim" scope="prototype">
        <summary>Creates the lightbox open/close and background fadein/out animations</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required"/>
          <parameter name="args" type="Object" usage="required"/>
          <parameter name="onEnd" type="Function" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Animation"/>
        </return-types>
      </method>
      <method name="show" scope="prototype">
        <summary>Shows this LightboxNano programatically. Allows passing a new href and
	a programatic origin.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="optional">
            <summary>An object with optional members of &lt;code&gt;href&lt;/code&gt; and &lt;code&gt;origin&lt;/code&gt;.
	&lt;code&gt;origin&lt;/code&gt; can be be a String|Id of a DomNode to use when
	animating the openeing of the image (the 'box' effect starts
	from this origin point. eg: { origin: e.target })
	If there's no origin, it will use the center of the viewport.
	The &lt;code&gt;href&lt;/code&gt; member is a string URL for the image to be
	displayed. Omiting either of these members will revert to
	the default href (which could be absent in some cases) and
	the original srcNodeRef for the widget.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.image.Magnifier" type="Function" classlike="true" superclass="dojox.image.MagnifierLite">
    <summary>Adds magnification on a portion of an image element, using &lt;code&gt;dojox.gfx&lt;/code&gt;</summary>
    <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	over-ride the _createGlass method to create your custom surface,
	being sure to create an img node on that surface.</description>
    <mixins>
      <mixin scope="instance" location="dojox.image.MagnifierLite"/>
    </mixins>
    <properties>
      <property name="glassNode" scope="prototype" type="Object"/>
      <property name="surfaceNode" scope="prototype" type="Object"/>
      <property name="surface" scope="prototype" type="Object"/>
      <property name="img" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_createGlass" scope="prototype">
        <summary>create the glassNode, and an img on a dojox.gfx surface</summary>
      </method>
      <method name="_placeGlass" scope="prototype">
        <summary>position the overlay centered under the cursor</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="prototype">
        <summary>set the image's offset in the clipping window relative to the mouse position</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.image.MagnifierLite" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Adds magnification on a portion of an image element</summary>
    <description>An unobtrusive way to add an unstyled overlay
	above the srcNode image element. The overlay/glass is a
	scaled version of the src image (so larger images sized down
	are clearer).
	The logic behind requiring the src image to be large is
	"it's going to be downloaded, anyway" so this method avoids
	having to make thumbnails and 2 http requests among other things.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="glassSize" scope="prototype" type="Int">
        <summary>the width and height of the bounding box</summary>
      </property>
      <property name="scale" scope="prototype" type="Decimal">
        <summary>the multiplier of the Mangification.</summary>
      </property>
      <property name="glassNode" scope="prototype" type="Object"/>
      <property name="surfaceNode" scope="prototype" type="Object"/>
      <property name="img" scope="prototype" type="Object"/>
      <property name="offset" scope="prototype" type="Object"/>
      <property name="_imageSize" scope="prototype" type="Object"/>
      <property name="_zoomSize" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_createGlass" scope="prototype">
        <summary>make img and glassNode elements as children of the body</summary>
      </method>
      <method name="_adjustScale" scope="prototype">
        <summary>update the calculations should this.scale change</summary>
      </method>
      <method name="_showGlass" scope="prototype">
        <summary>show the overlay</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_hideGlass" scope="prototype">
        <summary>hide the overlay</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_placeGlass" scope="prototype">
        <summary>position the overlay centered under the cursor</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setImage" scope="prototype">
        <summary>set the image's offset in the clipping window relative to the mouse position</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="finalize" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.image.SlideShow" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A Slideshow Widget</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="imageHeight" scope="prototype" type="Number">
        <summary>The maximum height of an image</summary>
      </property>
      <property name="imageWidth" scope="prototype" type="Number">
        <summary>The maximum width of an image.</summary>
      </property>
      <property name="title" scope="prototype" type="String">
        <summary>The initial title of the SlideShow</summary>
      </property>
      <property name="titleTemplate" scope="prototype" type="String">
        <summary>a way to customize the wording in the title. supported parameters to be populated are:
	${title} = the passed title of the image
	${current} = the current index of the image
	${total} = the total number of images in the SlideShow
	should add more?</summary>
      </property>
      <property name="noLink" scope="prototype" type="Boolean">
        <summary>Prevents the slideshow from putting an anchor link around the displayed image
	enables if true, though still will not link in absence of a url to link to</summary>
      </property>
      <property name="loop" scope="prototype" type="Boolean">
        <summary>true/false - make the slideshow loop</summary>
      </property>
      <property name="hasNav" scope="prototype" type="Boolean">
        <summary>toggle to enable/disable the visual navigation controls</summary>
      </property>
      <property name="images" scope="prototype" type="Array">
        <summary>Contains the DOM nodes that individual images are stored in when loaded or loading.</summary>
      </property>
      <property name="pageSize" scope="prototype" type="Number">
        <summary>The number of images to request each time.</summary>
      </property>
      <property name="autoLoad" scope="prototype" type="Boolean">
        <summary>If true, then images are preloaded, before the user navigates to view them.
	If false, an image is not loaded until the user views it.</summary>
      </property>
      <property name="autoStart" scope="prototype" type="Boolean">
        <summary>If true, the SlideShow begins playing immediately</summary>
      </property>
      <property name="fixedHeight" scope="prototype" type="Boolean">
        <summary>If true, the widget does not resize itself to fix the displayed image.</summary>
      </property>
      <property name="imageStore" scope="prototype" type="Object">
        <summary>Implementation of the dojo.data.api.Read API, which provides data on the images
	to be displayed.</summary>
      </property>
      <property name="linkAttr" scope="prototype" type="String">
        <summary>Defines the name of the attribute to request from the store to retrieve the
	URL to link to from an image, if any.</summary>
      </property>
      <property name="imageLargeAttr" scope="prototype" type="String">
        <summary>Defines the name of the attribute to request from the store to retrieve the
	URL to the image.</summary>
      </property>
      <property name="titleAttr" scope="prototype" type="String">
        <summary>Defines the name of the attribute to request from the store to retrieve the
	title of the picture, if any.</summary>
      </property>
      <property name="slideshowInterval" scope="prototype" type="Number">
        <summary>Time, in seconds, between image transitions during a slideshow.</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_imageCounter" scope="prototype" type="Number">
        <summary>A counter to keep track of which index image is to be loaded next</summary>
      </property>
      <property name="_tmpImage" scope="prototype" type="DomNode">
        <summary>The temporary image to show when a picture is loading.</summary>
      </property>
      <property name="_currentImage" scope="prototype" type=""/>
      <property name="isInitialized" scope="prototype" type="bool"/>
      <property name="imageIndex" scope="prototype" type="Number"/>
      <property name="_timerCancelled" scope="prototype" type="Object"/>
      <property name="_slideId" scope="prototype" type="Object"/>
      <property name="id" scope="prototype" type=""/>
      <property name="_navAnim" scope="prototype" type="Object"/>
      <property name="_navShowing" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Initilizes the widget, sets up listeners and shows the first image</summary>
      </method>
      <method name="setDataStore" scope="prototype">
        <summary>Sets the data store and request objects to read data from.</summary>
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <summary>implementation of the dojo.data.api.Read API. This accesses the image
	data.</summary>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <summary>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</summary>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <summary>An object defining the names of the item attributes to fetch from the
	data store.  The three attributes allowed are 'linkAttr', 'imageLargeAttr' and 'titleAttr'</summary>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <summary>Resets the widget to its initial state</summary>
        <description>Removes all previously loaded images, and clears all caches.</description>
      </method>
      <method name="isImageLoaded" scope="prototype">
        <summary>Returns true if image at the specified index is loaded, false otherwise.</summary>
        <parameters>
          <parameter name="index" type="The" usage="required">
            <summary>number index in the data store to check if it is loaded.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="moveImageLoadingPointer" scope="prototype">
        <summary>If 'autoload' is true, this tells the widget to start loading
	images from the specified pointer.</summary>
        <parameters>
          <parameter name="index" type="The" usage="required">
            <summary>number index in the data store to start loading images from.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Cleans up the widget when it is being destroyed</summary>
      </method>
      <method name="showNextImage" scope="prototype">
        <summary>Changes the image being displayed to the next image in the data store</summary>
        <parameters>
          <parameter name="inTimer" type="Boolean" usage="required">
            <summary>If true, a slideshow is active, otherwise the slideshow is inactive.</summary>
          </parameter>
          <parameter name="forceLoop" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toggleSlideShow" scope="prototype">
        <summary>Switches the slideshow mode on and off.</summary>
      </method>
      <method name="getShowTopicName" scope="prototype">
        <summary>Returns the topic id published to when an image is shown</summary>
        <description>The information published is: index, title and url</description>
      </method>
      <method name="getLoadTopicName" scope="prototype">
        <summary>Returns the topic id published to when an image finishes loading.</summary>
        <description>The information published is the index position of the image loaded.</description>
      </method>
      <method name="showImage" scope="prototype">
        <summary>Shows the image at index 'index'.</summary>
        <parameters>
          <parameter name="index" type="Number" usage="required">
            <summary>The position of the image in the data store to display</summary>
          </parameter>
          <parameter name="callback" type="Function" usage="optional">
            <summary>Optional callback function to call when the image has finished displaying.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_fitSize" scope="prototype">
        <summary>Fits the widget size to the size of the image being shown,
	or centers the image, depending on the value of 'fixedHeight'</summary>
        <parameters>
          <parameter name="force" type="Boolean" usage="required">
            <summary>If true, the widget is always resized, regardless of the value of 'fixedHeight'</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getTopPadding" scope="prototype">
        <summary>Returns the padding to place at the top of the image to center it vertically.</summary>
      </method>
      <method name="_loadNextImage" scope="prototype">
        <summary>Load the next unloaded image.</summary>
      </method>
      <method name="_loadImage" scope="prototype">
        <summary>Load image at specified index</summary>
        <description>This function loads the image at position 'index' into the
	internal cache of images.  This does not cause the image to be displayed.</description>
        <parameters>
          <parameter name="index" type="The" usage="required">
            <summary>position in the data store to load an image from.</summary>
          </parameter>
          <parameter name="callbackFn" type="An" usage="required">
            <summary>optional function to execute when the image has finished loading.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_stop" scope="prototype">
        <summary>Stops a running slide show.</summary>
      </method>
      <method name="_prev" scope="prototype">
        <summary>Show the previous image.
	FIXME: either pull code from showNext/prev, or call it here</summary>
      </method>
      <method name="_next" scope="prototype">
        <summary>Show the next image</summary>
      </method>
      <method name="_startTimer" scope="prototype">
        <summary>Starts a timeout to show the next image when a slide show is active</summary>
      </method>
      <method name="_calcNavDimensions" scope="prototype">
        <summary>Calculates the dimensions of the navigation controls</summary>
      </method>
      <method name="_setTitle" scope="prototype">
        <summary>Sets the title to the image being displayed</summary>
        <parameters>
          <parameter name="title" type="String" usage="required">
            <summary>The String title of the image</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_fitImage" scope="prototype">
        <summary>Ensures that the image width and height do not exceed the maximum.</summary>
        <parameters>
          <parameter name="img" type="Node" usage="required">
            <summary>The image DOM node to optionally resize</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_handleClick" scope="prototype">
        <summary>Performs navigation on the images based on users mouse clicks</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>An Event object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_showNav" scope="prototype">
        <summary>Shows the navigation controls</summary>
        <parameters>
          <parameter name="force" type="Boolean" usage="required">
            <summary>If true, the navigation controls are repositioned even if they are
	currently visible.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_hideNav" scope="prototype">
        <summary>Hides the navigation controls</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required">
            <summary>The DOM Event that triggered this function</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_overElement" scope="prototype">
        <summary>Returns whether the mouse is over the passed element.
	Element must be display:block (ie, not a &amp;lt;span&amp;gt;)</summary>
        <parameters>
          <parameter name="element" type="DomNode" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.image.SlideShow.outerNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.image.SlideShow._request" private="true">
    <summary>Implementation of the dojo.data.api.Request API, which defines the query
	parameters for accessing the store.</summary>
    <properties>
      <property name="start" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method name="onComplete" scope="prototype">
        <parameters>
          <parameter name="items" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.image.SlideShow.navPlay" type="">
    <properties>
      <property name="_size" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.image.SlideShow.navPrev" type="">
    <properties>
      <property name="_size" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.image.SlideShow.navNext" type="">
    <properties>
      <property name="_size" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.image.SlideShow.titleNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.image.ThumbnailPicker" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A scrolling Thumbnail Picker widget</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="imageStore" scope="prototype" type="Object">
        <summary>A data store that implements the dojo.data Read API.</summary>
      </property>
      <property name="size" scope="prototype" type="Number">
        <summary>Width or height in pixels, depending if horizontal or vertical.
	FIXME: use CSS?</summary>
      </property>
      <property name="thumbHeight" scope="prototype" type="Number">
        <summary>Default height of a thumbnail image
	FIXME: use CSS?</summary>
      </property>
      <property name="thumbWidth" scope="prototype" type="Number">
        <summary>Default width of an image
	FIXME: use CSS?</summary>
      </property>
      <property name="useLoadNotifier" scope="prototype" type="Boolean">
        <summary>Setting useLoadNotifier to true makes a colored DIV appear under each
	thumbnail image, which is used to display the loading status of each
	image in the data store.</summary>
      </property>
      <property name="useHyperlink" scope="prototype" type="boolean">
        <summary>Setting useHyperlink to true causes a click on a thumbnail to open a link.</summary>
      </property>
      <property name="hyperlinkTarget" scope="prototype" type="String">
        <summary>If hyperlinkTarget is set to &amp;quot;new&amp;quot;, clicking on a thumb will open a new window
	If it is set to anything else, clicking a thumbnail will open the url in the
	current window.</summary>
      </property>
      <property name="isClickable" scope="prototype" type="Boolean">
        <summary>When set to true, the cursor over a thumbnail changes.</summary>
      </property>
      <property name="isScrollable" scope="prototype" type="Boolean">
        <summary>When true, uses smoothScroll to move between pages</summary>
      </property>
      <property name="isHorizontal" scope="prototype" type="Boolean">
        <summary>If true, the thumbnails are displayed horizontally. Otherwise they are displayed
	vertically</summary>
      </property>
      <property name="autoLoad" scope="prototype" type="Boolean"/>
      <property name="linkAttr" scope="prototype" type="String">
        <summary>The attribute name for accessing the url from the data store</summary>
      </property>
      <property name="imageThumbAttr" scope="prototype" type="String">
        <summary>The attribute name for accessing the thumbnail image url from the data store</summary>
      </property>
      <property name="imageLargeAttr" scope="prototype" type="String">
        <summary>The attribute name for accessing the large image url from the data store</summary>
      </property>
      <property name="pageSize" scope="prototype" type="Number">
        <summary>The number of images to request each time.</summary>
      </property>
      <property name="titleAttr" scope="prototype" type="String">
        <summary>The attribute name for accessing the title from the data store</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_thumbs" scope="prototype" type="Array"/>
      <property name="_thumbIndex" scope="prototype" type="Number">
        <summary>The index of the first thumbnail shown</summary>
      </property>
      <property name="_maxPhotos" scope="prototype" type="Number">
        <summary>The total number of photos in the image store</summary>
      </property>
      <property name="_loadedImages" scope="prototype" type="Object">
        <summary>Stores the indices of images that have been marked as loaded using the
	markImageLoaded function.</summary>
      </property>
      <property name="widgetid" scope="prototype" type=""/>
      <property name="_scrollerSize" scope="prototype" type="Number"/>
      <property name="_sizeProperty" scope="prototype" type=""/>
      <property name="_totalSize" scope="prototype" type="Number"/>
      <property name="isInitialized" scope="prototype" type="bool"/>
      <property name="_offsetAttr" scope="prototype" type="String"/>
      <property name="_sizeAttr" scope="prototype" type="String"/>
      <property name="_scrollAttr" scope="prototype" type="String"/>
      <property name="_loadInProgress" scope="prototype" type="Object"/>
      <property name="_noImages" scope="prototype" type="bool"/>
      <property name="_loadingImages" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Initializes styles and listeners</summary>
      </method>
      <method name="init" scope="prototype">
        <summary>Creates DOM nodes for thumbnail images and initializes their listeners</summary>
      </method>
      <method name="getClickTopicName" scope="prototype">
        <summary>Returns the name of the dojo topic that can be
	subscribed to in order to receive notifications on
	which thumbnail was selected.</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getShowTopicName" scope="prototype">
        <summary>Returns the name of the dojo topic that can be
	subscribed to in order to receive notifications on
	which thumbnail is now visible</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="setDataStore" scope="prototype">
        <summary>Sets the data store and request objects to read data from.</summary>
        <parameters>
          <parameter name="dataStore" type="An" usage="required">
            <summary>implementation of the dojo.data.api.Read API. This accesses the image
	data.</summary>
          </parameter>
          <parameter name="request" type="An" usage="required">
            <summary>implementation of the dojo.data.api.Request API. This specifies the
	query and paging information to be used by the data store</summary>
          </parameter>
          <parameter name="paramNames" type="optional" usage="required">
            <summary>An object defining the names of the item attributes to fetch from the
	data store.  The four attributes allowed are 'linkAttr', 'imageLargeAttr',
	'imageThumbAttr' and 'titleAttr'</summary>
          </parameter>
        </parameters>
      </method>
      <method name="reset" scope="prototype">
        <summary>Resets the widget back to its original state.</summary>
      </method>
      <method name="isVisible" scope="prototype">
        <summary>Returns true if the image at the specified index is currently visible. False otherwise.</summary>
        <parameters>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="dim" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_next" scope="prototype">
        <summary>Displays the next page of images</summary>
      </method>
      <method name="_prev" scope="prototype">
        <summary>Displays the next page of images</summary>
      </method>
      <method name="_checkLoad" scope="prototype">
        <summary>Checks if an image is loaded.</summary>
        <parameters>
          <parameter name="img" type="" usage="required"/>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_showThumbs" scope="prototype">
        <summary>Displays thumbnail images, starting at position 'index'</summary>
        <parameters>
          <parameter name="index" type="Number" usage="required">
            <summary>The index of the first thumbnail</summary>
          </parameter>
        </parameters>
      </method>
      <method name="markImageLoaded" scope="prototype">
        <summary>Changes a visual cue to show the image is loaded</summary>
        <description>If 'useLoadNotifier' is set to true, then a visual cue is
	given to state whether the image is loaded or not.	Calling this function
	marks an image as loaded.</description>
        <parameters>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setThumbClass" scope="prototype">
        <summary>Adds a CSS class to a thumbnail, only if 'autoLoad' is true</summary>
        <parameters>
          <parameter name="thumb" type="DomNode" usage="required">
            <summary>The thumbnail DOM node to set the class on</summary>
          </parameter>
          <parameter name="className" type="String" usage="required">
            <summary>The CSS class to add to the DOM node.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_loadNextPage" scope="prototype">
        <summary>Loads the next page of thumbnail images</summary>
      </method>
      <method name="_loadImage" scope="prototype">
        <summary>Loads an image.</summary>
        <parameters>
          <parameter name="data" type="" usage="required"/>
          <parameter name="index" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateNavControls" scope="prototype">
        <summary>Updates the navigation controls to hide/show them when at
	the first or last images.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.image.ThumbnailPicker.request">
    <summary>A dojo.data Read API Request object.</summary>
    <properties>
      <property name="start" scope="prototype" type="Number"/>
      <property name="count" scope="prototype" type=""/>
      <property name="onComplete" scope="prototype" type="Object"/>
      <property name="onError" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.image.ThumbnailPicker.thumbScroller" type="">
    <properties>
      <property name="scrollLeft" scope="prototype" type=""/>
      <property name="scrollTop" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.io">
    <summary>Extensions to the Core dojo.io transports</summary>
    <methods>
      <method name="httpParse" scope="normal">
        <summary>Parses an HTTP stream for a message.</summary>
        <parameters>
          <parameter name="httpStream" type="String" usage="required">
            <summary>HTTP stream to parse</summary>
          </parameter>
          <parameter name="topHeaders" type="String" usage="optional">
            <summary>Extra header information to add to each HTTP request (kind of HTTP inheritance)</summary>
          </parameter>
          <parameter name="partial" type="Boolean" usage="optional">
            <summary>A true value indicates that the stream may not be finished, it may end arbitrarily in mid stream.
	The last XHR object will have a special property _lastIndex that indicates the how far along
	the httpStream could be successfully parsed into HTTP messages.
	return:
	Returns an array of XHR-like object for reading the headers for each message</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="the content is not finished"/>
        </return-types>
      </method>
      <method name="xhrMultiPart" scope="normal">
        <parameters>
          <parameter name="args" type="dojox.io.__xhrMultiArgs" usage="required"/>
        </parameters>
      </method>
      <method name="xhrScriptPlugin" scope="normal">
        <summary>Adds the script transport (JSONP) as an XHR plugin for the given site. See
	dojox.io.script for more information on the transport. Note, that JSONP
	is *not* a secure transport, by loading data from a third-party site using JSONP
	the site has full access to your JavaScript environment.</summary>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <summary>Url prefix of the site which can handle JSONP requests.</summary>
          </parameter>
          <parameter name="callbackParamName" type="String" usage="required"/>
          <parameter name="httpAdapter" type="Function" usage="optional">
            <summary>This allows for adapting HTTP requests that could not otherwise be
	sent with JSONP, so you can use a convention for headers and PUT/DELETE methods.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="xhrWindowNamePlugin" scope="normal">
        <summary>Adds the windowName transport as an XHR plugin for the given site. See
	dojox.io.windowName for more information on the transport.</summary>
        <parameters>
          <parameter name="url" type="String" usage="required">
            <summary>Url prefix of the site which can handle windowName requests.</summary>
          </parameter>
          <parameter name="httpAdapter" type="Function" usage="optional">
            <summary>This allows for adapting HTTP requests that could not otherwise be
	sent with window.name, so you can use a convention for headers and PUT/DELETE methods.</summary>
          </parameter>
          <parameter name="trusted" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.io.OAuth"/>
  <object location="dojox.io.OAuth.__AccessorArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="key" scope="instance" type="String">
        <summary>The key or token issued to either the consumer or by the OAuth service.</summary>
      </property>
      <property name="secret" scope="instance" type="String">
        <summary>The secret (shared secret for consumers, issued secret by OAuth service).</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="key" type="String" usage="required">
            <summary>The key or token issued to either the consumer or by the OAuth service.</summary>
          </parameter>
          <parameter name="secret" type="String" usage="required">
            <summary>The secret (shared secret for consumers, issued secret by OAuth service).</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.io.OAuth.__OAuthArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="consumer" scope="instance" type="dojox.io.OAuth.__AccessorArgs">
        <summary>The consumer information issued to your OpenAuth application.
	sig_method: String
	The method used to create the signature.  Should be PLAINTEXT or HMAC-SHA1.</summary>
      </property>
      <property name="token" scope="instance" type="dojox.io.OAuth.__AccessorArgs">
        <summary>The request token and secret issued by the OAuth service.  If not
	issued yet, this should be null.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="consumer" type="dojox.io.OAuth.__AccessorArgs" usage="required">
            <summary>The consumer information issued to your OpenAuth application.</summary>
          </parameter>
          <parameter name="sig_method" type="String" usage="required">
            <summary>The method used to create the signature.  Should be PLAINTEXT or HMAC-SHA1.</summary>
          </parameter>
          <parameter name="token" type="dojox.io.OAuth.__AccessorArgs" usage="optional">
            <summary>The request token and secret issued by the OAuth service.  If not
	issued yet, this should be null.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.io.proxy.xip">
    <summary>Object that implements the iframe handling for XMLHttpRequest
	IFrame Proxying.</summary>
    <description>Do not use this object directly. See the Dojo Book page
	on XMLHttpRequest IFrame Proxying:
	http://dojotoolkit.org/book/dojo-book-0-4/part-5-connecting-pieces/i-o/cross-domain-xmlhttprequest-using-iframe-proxy
	Usage of XHR IFrame Proxying does not work from local disk in Safari.</description>
    <properties>
      <property name="xipClientUrl" scope="normal" type="Object"/>
      <property name="urlLimit" scope="normal" type="Number"/>
      <property name="_callbackName" scope="normal" type="String"/>
      <property name="_state" scope="normal" type="Object"/>
      <property name="_stateIdCounter" scope="normal" type="Number"/>
      <property name="_isWebKit" scope="normal" type="bool"/>
      <property name="_xhrObjOld" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="_realSend" scope="normal">
        <summary>starts the actual xdomain request using the provided facade.</summary>
        <parameters>
          <parameter name="facade" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="receive" scope="normal">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
          <parameter name="urlEncodedData" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="frameLoaded" scope="normal">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="destroyState" scope="normal">
        <parameters>
          <parameter name="stateId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="createFacade" scope="normal"/>
      <method name="sendRequest" scope="normal">
        <parameters>
          <parameter name="stateId" type="" usage="required"/>
          <parameter name="encodedData" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestStart" scope="normal">
        <parameters>
          <parameter name="stateId" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendRequestPart" scope="normal">
        <parameters>
          <parameter name="stateId" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setServerUrl" scope="normal">
        <parameters>
          <parameter name="stateId" type="" usage="required"/>
          <parameter name="cmd" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="makeServerUrl" scope="normal">
        <parameters>
          <parameter name="stateId" type="" usage="required"/>
          <parameter name="cmd" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceivedEvent" scope="normal">
        <summary>HTML5 document messaging endpoint. Unpack the event to see
	if we want to use it.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fragmentReceived" scope="normal">
        <parameters>
          <parameter name="frag" type="" usage="required"/>
        </parameters>
      </method>
      <method name="unpackMessage" scope="normal">
        <parameters>
          <parameter name="encodedMessage" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.io.proxy.xip.XhrIframeFacade" type="Function" classlike="true">
    <summary>XMLHttpRequest facade object used by dojox.io.proxy.xip.</summary>
    <description>Do not use this object directly. See the Dojo Book page
	on XMLHttpRequest IFrame Proxying:
	http://dojotoolkit.org/book/dojo-book-0-4/part-5-connecting-pieces/i-o/cross-domain-xmlhttprequest-using-iframe-proxy</description>
    <properties>
      <property name="_requestHeaders" scope="instance" type="Object"/>
      <property name="_allResponseHeaders" scope="instance" type="Object"/>
      <property name="_responseHeaders" scope="instance" type="Object"/>
      <property name="_method" scope="instance" type="Object"/>
      <property name="_uri" scope="instance" type="Object"/>
      <property name="_bodyData" scope="instance" type="Object"/>
      <property name="responseText" scope="instance" type="Object"/>
      <property name="responseXML" scope="instance" type="Object"/>
      <property name="status" scope="instance" type="Object"/>
      <property name="statusText" scope="instance" type="Object"/>
      <property name="readyState" scope="instance" type="Number"/>
      <property name="_ifpServerUrl" scope="instance" type=""/>
      <property name="_stateId" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="ifpServerUrl" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setRequestHeader" scope="prototype">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="abort" scope="prototype"/>
      <method name="getAllResponseHeaders" scope="prototype">
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="getResponseHeader" scope="prototype">
        <parameters>
          <parameter name="header" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.io.proxy.xip.XhrIframeFacade.open" type="Function" classlike="true">
    <properties>
      <property name="_method" scope="instance" type=""/>
      <property name="_uri" scope="instance" type=""/>
      <property name="readyState" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="method" type="String" usage="required"/>
          <parameter name="uri" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.io.proxy.xip.XhrIframeFacade.send" type="Function" classlike="true">
    <properties>
      <property name="_bodyData" scope="instance" type=""/>
      <property name="_stateId" scope="instance" type="Object"/>
      <property name="readyState" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="stringData" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.io.proxy.xip.XhrIframeFacade._setResponseHeaders" type="Function" classlike="true" private="true">
    <properties>
      <property name="_allResponseHeaders" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="allHeaders" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.io.proxy"/>
  <object location="dojox.io.proxy.xip.send" type="Function" classlike="true">
    <summary>starts the xdomain request using the provided facade.
	This method first does some init work, then delegates to _realSend.</summary>
    <properties>
      <property name="fullXipClientUrl" scope="instance" type=""/>
      <property name="send" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="facade" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="window.location" type="">
    <properties>
      <property name="href" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.io.scriptFrame">
    <properties>
      <property name="_waiters" scope="normal" type="Object"/>
      <property name="_loadedIds" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="_getWaiters" scope="normal">
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_fixAttachUrl" scope="normal">
        <summary>fixes the URL so that</summary>
        <parameters>
          <parameter name="url" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_loaded" scope="normal">
        <summary>callback used when waiting for a frame to load (related to the usage of
	the frameId argument to dojo.io.script.get().</summary>
        <parameters>
          <parameter name="frameId" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.io.windowName">
    <properties>
      <property name="_frameNum" scope="normal" type="Number"/>
    </properties>
    <methods>
      <method name="send" scope="normal">
        <summary>Provides secure cross-domain request capability.
	Sends a request using an iframe (POST or GET) and reads the response through the
	frame's window.name.</summary>
        <description>In order to provide a windowname transport accessible resources/web services, a server
	should check for the presence of a parameter window.name=true and if a request includes
	such a parameter, it should respond to the request with an HTML
	document that sets it's window.name to the string that is to be
	delivered to the client. For example, if a client makes a window.name request like:
		http://othersite.com/greeting?windowname=true
	And server wants to respond to the client with "Hello", it should return an html page:
		&lt;html&gt;&lt;script type="text/javascript"&gt;
		window.name="Hello";
		&lt;/script&gt;&lt;/html&gt;
	One can provide XML or JSON data by simply quoting the data as a string, and parsing the data
	on the client.
	If you use the authorization window.name protocol, the requester should include an
	authElement element in the args, and a request will be created like:
		http://othersite.com/greeting?windowname=auth
	And the server can respond like this:
		&lt;html&gt;&lt;script type="text/javascript"&gt;
		var loc = window.name;
		authorizationButton.onclick = function(){
			window.name="Hello";
			location = loc;
		};
		&lt;/script&gt;&lt;/html&gt;
	When using windowName from a XD Dojo build, make sure to set the
	dojo.dojoBlankHtmlUrl property to a local URL.</description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <summary>The method to use to send the request, GET or POST</summary>
          </parameter>
          <parameter name="args" type="dojo.__IoArgs" usage="required">
            <summary>See dojo.xhr
	args.authElement: DOMNode?
	By providing an authElement, this indicates that windowName should use the
	authorized window.name protocol, relying on
	the loaded XD resource to return to the provided return URL on completion
	of authorization/authentication. The provided authElement will be used to place
	the iframe in, so the user can interact with the server resource for authentication
	and/or authorization to access the resource.
	args.onAuthLoad: Function?
	When using authorized access to resources, this function will be called when the
	authorization page has been loaded. (When authorization is actually completed,
	the deferred callback function is called with the result). The primary use for this
	is to make the authElement visible to the user once the resource has loaded
	(this can be preferable to showing the iframe while the resource is loading
	since it may not require authorization, it may simply return the resource).</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_send" scope="normal">
        <parameters>
          <parameter name="dfd" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
          <parameter name="authTarget" type="" usage="required"/>
          <parameter name="onAuthLoad" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.io.__xhrContentArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="name" scope="instance" type="String">
        <summary>Name of the form value.</summary>
      </property>
      <property name="content" scope="instance" type="String">
        <summary>The contents of the value.</summary>
      </property>
      <property name="filename" scope="instance" type="String">
        <summary>An optional filename to pass to the server, as defined by the boundary.</summary>
      </property>
      <property name="contentType" scope="instance" type="String">
        <summary>An optional content-type (MIME) to pass to the server, if value is being
	treated as a file.</summary>
      </property>
      <property name="charset" scope="instance" type="String">
        <summary>Optional charset to pass, for the server to interpret the file correctly.</summary>
      </property>
      <property name="contentTransferEncoding" scope="instance" type="String">
        <summary>Optional transfer encoding header value.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.io.__xhrMultiArgs" type="Function" classlike="true" private="true">
    <properties>
      <property name="url" scope="instance" type="String">
        <summary>URL to server endpoint.</summary>
      </property>
      <property name="content" scope="instance" type="Object">
        <summary>Contains properties with string values. These
	properties will be serialized using multi-part
	boundaries.</summary>
      </property>
      <property name="file" scope="instance" type="Object">
        <summary>Alias for &amp;quot;content&amp;quot;.  Provided for backwards compatibility.</summary>
      </property>
      <property name="timeout" scope="instance" type="Integer">
        <summary>Milliseconds to wait for the response. If this time
	passes, the then error callbacks are called.</summary>
      </property>
      <property name="form" scope="instance" type="DOMNode">
        <summary>DOM node for a form. Used to extract the form values
	and send to the server; each form value will be serialized
	using multi-part boundaries.</summary>
      </property>
      <property name="preventCache" scope="instance" type="Boolean">
        <summary>Default is false. If true, then a
	&amp;quot;dojo.preventCache&amp;quot; parameter is sent in the request
	with a value that changes with each request
	(timestamp). Useful only with GET-type requests.</summary>
      </property>
      <property name="handleAs" scope="instance" type="String">
        <summary>Acceptable values depend on the type of IO
	transport (see specific IO calls for more information).</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="load" scope="instance">
        <summary>function(response, ioArgs){}. response is an Object, ioArgs
	is of type dojo.__IoCallbackArgs. The load function will be
	called on a successful response.</summary>
      </method>
      <method name="error" scope="instance">
        <summary>function(response, ioArgs){}. response is an Object, ioArgs
	is of type dojo.__IoCallbackArgs. The error function will
	be called in an error case.</summary>
      </method>
      <method name="handle" scope="instance">
        <summary>function(response, ioArgs){}. response is an Object, ioArgs
	is of type dojo.__IoCallbackArgs. The handle function will
	be called in either the successful or error case.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.io.xhrPlugins">
    <methods>
      <method name="register" scope="normal">
        <summary>overrides the default xhr handler to implement a registry of
	xhr handlers</summary>
        <return-types>
          <return-type type="or check to see if we have the same path"/>
        </return-types>
      </method>
      <method name="addProxy" scope="normal">
        <summary>adds a server side proxy xhr handler for cross-site URLs</summary>
        <examples>
          <example>Define a proxy:
		dojox.io.xhrPlugins.addProxy("/proxy?url=");
	And then when you call:
		dojo.xhr("GET",{url:"http://othersite.com/file"});
	It would result in the request (to your origin server):
		GET /proxy?url=http%3A%2F%2Fothersite.com%2Ffile HTTP/1.1</example>
        </examples>
        <parameters>
          <parameter name="proxyUrl" type="This" usage="required">
            <summary>is URL to send the requests to.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addCrossSiteXhr" scope="normal">
        <summary>Adds W3C Cross site XHR or XDomainRequest handling for the given URL prefix</summary>
        <description>This can be used for servers that support W3C cross-site XHR. In order for
	a server to allow a client to make cross-site XHR requests,
	it should respond with the header like:
		Access-Control: allow &lt;*&gt;
	see: http://www.w3.org/TR/access-control/</description>
        <parameters>
          <parameter name="url" type="Requests" usage="required">
            <summary>that start with this URL will be considered for using
	cross-site XHR.</summary>
          </parameter>
          <parameter name="httpAdapter" type="This" usage="required">
            <summary>allows for adapting HTTP requests that could not otherwise be
	sent with XDR, so you can use a convention for headers and PUT/DELETE methods.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="fullHttpAdapter" scope="normal">
        <summary>Provides a HTTP adaption.</summary>
        <description>The following convention is used:
	method name -&gt; ?http-method=PUT
	Header -&gt; http-Header-Name=header-value
	X-Header -&gt; header_name=header-value</description>
        <examples>
          <example>dojox.io.xhrPlugins.addXdr("http://somesite.com", dojox.io.xhrPlugins.fullHttpAdapter);</example>
        </examples>
        <parameters>
          <parameter name="plainXhr" type="" usage="required"/>
          <parameter name="noRawBody" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.query.pseudos" type="">
    <mixins>
      <mixin scope="normal" location="inputPseudos"/>
    </mixins>
    <methods>
      <method name="has" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
      <method name="visible" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hidden" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
      <method name="selected" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
      <method name="checked" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
      <method name="disabled" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
      <method name="enabled" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
      <method name="input" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
      <method name="button" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
      <method name="header" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojo.global">
    <summary>Alias for the global scope
	(e.g. the window object in a browser).</summary>
    <description>Refer to 'dojo.global' rather than referring to window to ensure your
	code runs correctly in contexts other than web browsers (e.g. Rhino on a server).</description>
    <methods>
      <method name="$" scope="normal"/>
      <method name="jQuery" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.json">
    <methods>
      <method name="query" scope="normal">
        <summary>Performs a JSONQuery on the provided object and returns the results.
	If no object is provided (just a query), it returns a &amp;quot;compiled&amp;quot; function that evaluates objects
	according to the provided query.</summary>
        <description>JSONQuery provides a comprehensive set of data querying tools including filtering,
	recursive search, sorting, mapping, range selection, and powerful expressions with
	wildcard string comparisons and various operators. JSONQuery generally supersets
	JSONPath and provides syntax that matches and behaves like JavaScript where
	possible.
	JSONQuery evaluations begin with the provided object, which can referenced with
	$. From
	the starting object, various operators can be successively applied, each operating
	on the result of the last operation.
	Supported Operators:
	--------------------
	* .property - This will return the provided property of the object, behaving exactly
	like JavaScript.
	* [expression] - This returns the property name/index defined by the evaluation of
	the provided expression, behaving exactly like JavaScript.
	* [?expression] - This will perform a filter operation on an array, returning all the
	items in an array that match the provided expression. This operator does not
	need to be in brackets, you can simply use ?expression, but since it does not
	have any containment, no operators can be used afterwards when used
	without brackets.
	* [^?expression] - This will perform a distinct filter operation on an array. This behaves
	as [?expression] except that it will remove any duplicate values/objects from the
	result set.
	* [/expression], [\expression], [/expression, /expression] - This performs a sort
	operation on an array, with sort based on the provide expression. Multiple comma delimited sort
	expressions can be provided for multiple sort orders (first being highest priority). /
	indicates ascending order and \ indicates descending order
	* [=expression] - This performs a map operation on an array, creating a new array
	with each item being the evaluation of the expression for each item in the source array.
	* [start:end:step] - This performs an array slice/range operation, returning the elements
	from the optional start index to the optional end index, stepping by the optional step number.
	* [expr,expr] - This a union operator, returning an array of all the property/index values from
	the evaluation of the comma delimited expressions.
	* .* or [*] - This returns the values of all the properties of the current object.
	* $ - This is the root object, If a JSONQuery expression does not being with a $,
	it will be auto-inserted at the beginning.
	* @ - This is the current object in filter, sort, and map expressions. This is generally
	not necessary, names are auto-converted to property references of the current object
	in expressions.
	*	..property - Performs a recursive search for the given property name, returning
	an array of all values with such a property name in the current object and any subobjects
	* expr = expr - Performs a comparison (like JS's ==). When comparing to
	a string, the comparison string may contain wildcards * (matches any number of
	characters) and ? (matches any single character).
	* expr ~ expr - Performs a string comparison with case insensitivity.
	* ..[?expression] - This will perform a deep search filter operation on all the objects and
	subobjects of the current data. Rather than only searching an array, this will search
	property values, arrays, and their children.
	* $1,$2,$3, etc. - These are references to extra parameters passed to the query
	function or the evaluator function.
	* +, -, /, *, &amp;, |, %, (, ), &lt;, &gt;, &lt;=, &gt;=, != - These operators behave just as they do
	in JavaScript.
		dojox.json.query(queryString,object)
	and
		dojox.json.query(queryString)(object)
	always return identical results. The first one immediately evaluates, the second one returns a
	function that then evaluates the object.</description>
        <examples>
          <example>	dojox.json.query("foo",{foo:"bar"})
	This will return "bar".</example>
          <example>	evaluator = dojox.json.query("?foo='bar'&amp;rating&gt;3");
	This creates a function that finds all the objects in an array with a property
	foo that is equals to "bar" and with a rating property with a value greater
	than 3.
		evaluator([{foo:"bar",rating:4},{foo:"baz",rating:2}])
	This returns:
		{foo:"bar",rating:4}</example>
          <example>	evaluator = dojox.json.query("$[?price&lt;15.00][\rating][0:10]");
	This finds objects in array with a price less than 15.00 and sorts then
	by rating, highest rated first, and returns the first ten items in from this
	filtered and sorted list.</example>
        </examples>
        <parameters>
          <parameter name="query" type="String" usage="required">
            <summary>Query string</summary>
          </parameter>
          <parameter name="obj" type="Object" usage="optional">
            <summary>Target of the JSONQuery</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="we mark all the inner brackets as skippable"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.json.ref.resolveJson" type="Function" classlike="true">
    <summary>Indexes and resolves references in the JSON object.</summary>
    <description>A JSON Schema object that can be used to advise the handling of the JSON (defining ids, date properties, urls, etc)</description>
    <properties>
      <property name="refAttribute" scope="instance" type=""/>
      <property name="_addProp" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="root" type="Object" usage="required">
            <summary>The root object of the object graph to be processed</summary>
          </parameter>
          <parameter name="args" type="Object" usage="optional">
            <summary>with additional arguments:
	The *index* parameter.
	This is the index object (map) to use to store an index of all the objects.
	If you are using inter-message referencing, you must provide the same object for each call.
	The *defaultId* parameter.
	This is the default id to use for the root object (if it doesn't define it's own id)
	The *idPrefix* parameter.
	This the prefix to use for the ids as they enter the index. This allows multiple tables
	to use ids (that might otherwise collide) that enter the same global index.
	idPrefix should be in the form &amp;quot;/Service/&amp;quot;.  For example,
	if the idPrefix is &amp;quot;/Table/&amp;quot;, and object is encountered {id:&amp;quot;4&amp;quot;,...}, this would go in the
	index as &amp;quot;/Table/4&amp;quot;.
	The *idAttribute* parameter.
	This indicates what property is the identity property. This defaults to &amp;quot;id&amp;quot;
	The *assignAbsoluteIds* parameter.
	This indicates that the resolveJson should assign absolute ids (__id) as the objects are being parsed.
	The *schemas* parameter
	This provides a map of schemas, from which prototypes can be retrieved
	The *loader* parameter
	This is a function that is called added to the reference objects that can't be resolved (lazy objects)
	return:
	An object, the result of the processing</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.json.ref.toJson" type="Function" classlike="true">
    <summary>Create a JSON serialization of an object.
	This has support for referencing, including circular references, duplicate references, and out-of-message references
	id and path-based referencing is supported as well and is based on http://www.json.com/2007/10/19/json-referencing-proposal-and-library/.</summary>
    <properties>
      <property name="_useRefs" scope="instance" type=""/>
      <property name="_addProp" scope="instance" type=""/>
      <property name="refAttribute" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="it" type="Object" usage="required">
            <summary>an object to be serialized.</summary>
          </parameter>
          <parameter name="prettyPrint" type="Boolean" usage="optional">
            <summary>if true, we indent objects and arrays to make the output prettier.
	The variable dojo.toJsonIndentStr is used as the indent string
	-- to use something other than the default (tab),
	change that variable before calling dojo.toJson().</summary>
          </parameter>
          <parameter name="idPrefix" type="Object" usage="optional">
            <summary>The prefix that has been used for the absolute ids
	return:
	a String representing the serialized version of the passed object.</summary>
          </parameter>
          <parameter name="indexSubObjects" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="use the default serializer for primitives"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.json.schema">
    <methods>
      <method name="validate" scope="normal">
        <summary>To use the validator call this with an instance object and an optional schema object.
	If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
	that schema will be used to validate and the schema parameter is not necessary (if both exist,
	both validations will occur).</summary>
        <description>The validate method will return an object with two properties:
	valid: A boolean indicating if the instance is valid by the schema
	errors: An array of validation errors. If there are no errors, then an
	empty list will be returned. A validation error will have two properties:
	property: which indicates which property had the error
	message: which indicates what the error was</description>
        <parameters>
          <parameter name="instance" type="Any" usage="required">
            <summary>The instance value/object to validate</summary>
          </parameter>
          <parameter name="schema" type="Object" usage="required">
            <summary>The schema to use to validate</summary>
          </parameter>
        </parameters>
      </method>
      <method name="checkPropertyChange" scope="normal">
        <summary>The checkPropertyChange method will check to see if an value can legally be in property with the given schema
	This is slightly different than the validate method in that it will fail if the schema is readonly and it will
	not check for self-validation, it is assumed that the passed in value is already internally valid.
	The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
	information.</summary>
        <parameters>
          <parameter name="value" type="Any" usage="required">
            <summary>The new instance value/object to check</summary>
          </parameter>
          <parameter name="schema" type="Object" usage="required">
            <summary>The schema to use to validate
	return:
	see dojox.validate.jsonSchema.validate</summary>
          </parameter>
          <parameter name="property" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="mustBeValid" scope="normal">
        <summary>This checks to ensure that the result is valid and will throw an appropriate error message if it is not</summary>
        <parameters>
          <parameter name="result" type="the" usage="required">
            <summary>result returned from checkPropertyChange or validate</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_validate" scope="normal">
        <parameters>
          <parameter name="instance" type="Any" usage="required"/>
          <parameter name="schema" type="Object" usage="required"/>
          <parameter name="_changing" type="Boolean" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.jsonPath">
    <summary>A query system for JavaScript objects</summary>
    <properties>
      <property name="_regularExpressions" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="query" scope="normal">
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="expr" type="String" usage="required"/>
          <parameter name="arg" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.lang.aspect" type="">
    <methods>
      <method name="cflow" scope="normal">
        <summary>Returns true if the context stack contains a context for a given
	instance that satisfies a given method name criteria.</summary>
        <parameters>
          <parameter name="instance" type="Object" usage="required">
            <summary>An instance to be matched. If null, any context will be examined.
	Otherwise the context should belong to this instance.</summary>
          </parameter>
          <parameter name="method" type="String|RegExp|Array" usage="optional">
            <summary>An optional pattern to be matched against a method name. Can be a string,
	a RegExp object or an array of strings and RegExp objects.
	If it is omitted, any name will satisfy the criteria.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="counter" scope="normal">
        <summary>Returns an object, which can be used to count calls to methods.</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="memoizer" scope="normal">
        <summary>Returns an object, which can be used to count calls to methods.</summary>
        <parameters>
          <parameter name="keyMaker" type="Function" usage="optional">
            <summary>the function, which takes method's arguments and returns a key,
	which can be used to index the result.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="memoizerGuard" scope="normal">
        <summary>Invalidates the memoizer's cache (see dojox.lang.aspect.memoizer)
	after calling certain methods.</summary>
        <parameters>
          <parameter name="method" type="String|Array" usage="optional">
            <summary>Optional method's name to be guarded: only cache for
	this method will be invalidated on call. Can be a string
	or an array of method names. If omitted the whole cache
	will be invalidated.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="profiler" scope="normal">
        <summary>Returns an object, which can be used to time calls to methods.</summary>
        <parameters>
          <parameter name="title" type="String" usage="optional">
            <summary>The optional name of the profile section.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="timer" scope="normal">
        <summary>Returns an object, which can be used to time calls to methods.</summary>
        <parameters>
          <parameter name="name" type="String" usage="optional">
            <summary>The optional unique name of the timer.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="tracer" scope="normal">
        <summary>Returns an object, which can be used to trace calls with Firebug's console.
	Prints argument, a return value, or an exception.</summary>
        <parameters>
          <parameter name="grouping" type="Boolean" usage="required">
            <summary>The flag to group output. If true, indents embedded console messages.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="advise" scope="normal">
        <summary>Attach AOP-style advices to a method.</summary>
        <description>Attaches AOP-style advices to a method. Can attach several
	advices at once and operate on several methods of an object.
	The latter is achieved when a RegExp is specified as
	a method name, or an array of strings and regular expressions
	is used. In this case all functional methods that
	satisfy the RegExp condition are processed. This function
	returns a handle, which can be used to unadvise, or null,
	if advising has failed.
	This function is a convenience wrapper for
	dojox.lang.aspect.adviseRaw().</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <summary>A source object for the advised function. Cannot be a DOM node.
	If this object is a constructor, its prototype is advised.</summary>
          </parameter>
          <parameter name="method" type="String|RegExp|Array" usage="required">
            <summary>A string name of the function in obj. In case of RegExp all
	methods of obj matching the regular expression are advised.</summary>
          </parameter>
          <parameter name="advice" type="Object|Function|Array" usage="required">
            <summary>An object, which defines advises, or a function, which
	returns such object, or an array of previous items.
	The advice object can define following member functions:
	before, around, afterReturning, afterThrowing, after.
	If the function is supplied, it is called with a context
	object once per call to create a temporary advice object, which
	is destroyed after the processing. The temporary advice object
	can implement a destroy() method, if it wants to be called when
	not needed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="adviseRaw" scope="normal">
        <summary>Attach AOP-style advices to methods.</summary>
        <description>Attaches AOP-style advices to object's methods. Can attach several
	advices at once and operate on several methods of the object.
	The latter is achieved when a RegExp is specified as
	a method name. In this case all functional methods that
	satisfy the RegExp condition are processed. This function
	returns a handle, which can be used to unadvise, or null,
	if advising has failed.</description>
        <parameters>
          <parameter name="obj" type="Object" usage="required">
            <summary>A source object for the advised function.
	Cannot be a DOM node.</summary>
          </parameter>
          <parameter name="methods" type="Array" usage="required">
            <summary>An array of method names (strings) to be advised.</summary>
          </parameter>
          <parameter name="advices" type="Array" usage="required">
            <summary>An array of advices represented by objects or functions that
	return such objects on demand during the event processing.
	The advice object can define following member functions:
	before, around, afterReturning, afterThrowing, after.
	If the function is supplied, it is called with a context
	object once per call to create a temporary advice object, which
	is destroyed after the processing. The temporary advice object
	can implement a destroy() method, if it wants to be called when
	not needed.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="unadvise" scope="normal">
        <summary>Detach previously attached AOP-style advices.</summary>
        <parameters>
          <parameter name="handle" type="Object" usage="required">
            <summary>The object returned by dojox.lang.aspect.advise().</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getContext" scope="normal">
        <summary>Returns the context information for the advice in effect.</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getContextStack" scope="normal">
        <summary>Returns the context stack, which reflects executing advices
	up to this point. The array is ordered from oldest to newest.
	In order to get the active context use dojox.lang.aspect.getContext().</summary>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="proceed" scope="normal">
        <summary>Call the original function (or the next level around advice) in an around advice code.</summary>
        <description>Calls the original function (or the next level around advice).
	Accepts and passes on any number of arguments, and returns a value.
	This function is valid only in the content of around calls.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.lang.docs">
    <properties>
      <property name="_loadedDocs" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="init" scope="normal">
        <summary>Loads the documentation and applies it to the previously defined classes
	and any future defined classes</summary>
        <parameters>
          <parameter name="async" type="Boolean" usage="required">
            <summary>If true, the documentation will be loaded asynchronously</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.lang.functional">
    <summary>Functional language constructs, including currying and lambda.</summary>
    <properties>
      <property name="array" scope="normal" type="Object"/>
      <property name="arg" scope="normal" type="Object"/>
      <property name="fold" scope="normal" type="Object"/>
      <property name="object" scope="normal" type="Object"/>
      <property name="reversed" scope="normal" type="Object"/>
      <property name="scan" scope="normal" type="Object"/>
      <property name="sequence" scope="normal" type="Object"/>
      <property name="util" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="filter" scope="normal">
        <summary>creates a new array with all elements that pass the test
	implemented by the provided function.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="forEach" scope="normal">
        <summary>executes a provided function once per array element.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="map" scope="normal">
        <summary>creates a new array with the results of calling
	a provided function on every element in this array.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="every" scope="normal">
        <summary>tests whether all elements in the array pass the test
	implemented by the provided function.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="some" scope="normal">
        <summary>tests whether some element in the array passes the test
	implemented by the provided function.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="inlineLambda" scope="normal">
        <summary>Creates the inlined version of a string lambda.</summary>
        <parameters>
          <parameter name="lambda" type="String" usage="required">
            <summary>The String variable representing the lambda function.</summary>
          </parameter>
          <parameter name="init" type="String|Array" usage="required">
            <summary>Conveys how to initialize parameters. If it is a String, then the apply() method
	would be emulated treating &amp;quot;init&amp;quot; as a list of input parameters.
	It it is an Array, then the call() method is emulated treating array members
	as input parameters.</summary>
          </parameter>
          <parameter name="add2dict" type="Function" usage="optional">
            <summary>The optional function, which is used to record names of lambda parameters.
	If supplied, this function is called with a name of every parameter.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="binrec" scope="normal">
        <summary>Generates a function for the binary recursion pattern.
	All parameter functions are called in the context of &amp;quot;this&amp;quot; object.</summary>
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</summary>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</summary>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself.
	The returned value should be an array of two variable, which are used to call
	the generated function recursively twice in row starting from the first item.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts three parameters: two returned values from recursive steps, and
	the original array of parameters used with all other functions.
	The returned value will be returned as the value of the generated function.</summary>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="curry" scope="normal">
        <summary>curries a function until the arity is satisfied, at
	which point it returns the calculated value.</summary>
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="arity" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="partial" scope="normal">
        <summary>creates a function where some arguments are bound, and
	some arguments (marked as dojox.lang.functional.arg) are will be
	accepted by the final function in the order they are encountered.</summary>
        <description>This method is used to produce partially bound
	functions. If you want to change the order of arguments, use
	dojox.lang.functional.mixer() or dojox.lang.functional.flip().</description>
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="mixer" scope="normal">
        <summary>changes the order of arguments using an array of
	numbers mix --- i-th argument comes from mix[i]-th place
	of supplied arguments.</summary>
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="mix" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="flip" scope="normal">
        <summary>changes the order of arguments by reversing their
	order.</summary>
        <parameters>
          <parameter name="f" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="foldl" scope="normal">
        <summary>repeatedly applies a binary function to an array from left
	to right using a seed value as a starting point; returns the final
	value.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldl1" scope="normal">
        <summary>repeatedly applies a binary function to an array from left
	to right; returns the final value.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldr" scope="normal">
        <summary>repeatedly applies a binary function to an array from right
	to left using a seed value as a starting point; returns the final
	value.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="foldr1" scope="normal">
        <summary>repeatedly applies a binary function to an array from right
	to left; returns the final value.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="reduce" scope="normal">
        <summary>apply a function simultaneously against two values of the array
	(from left-to-right) as to reduce it to a single value.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="reduceRight" scope="normal">
        <summary>apply a function simultaneously against two values of the array
	(from right-to-left) as to reduce it to a single value.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="unfold" scope="normal">
        <summary>builds an array by unfolding a value</summary>
        <parameters>
          <parameter name="pr" type="Function|String|Array" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="g" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="rawLambda" scope="normal">
        <summary>builds a function from a snippet, or array (composing),
	returns an object describing the function; functions are
	passed through unmodified.</summary>
        <description>This method is to normalize a functional representation (a
	text snippet) to an object that contains an array of
	arguments, and a body , which is used to calculate the
	returning value.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="buildLambda" scope="normal">
        <summary>builds a function from a snippet, returns a string, which
	represents the function.</summary>
        <description>This method returns a textual representation of a function
	built from the snippet. It is meant to be evaled in the
	proper context, so local variables can be pulled from the
	environment.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="lambda" scope="normal">
        <summary>builds a function from a snippet, or array (composing),
	returns a function object; functions are passed through
	unmodified.</summary>
        <description>This method is used to normalize a functional
	representation (a text snippet, an array, or a function) to
	a function object.</description>
        <parameters>
          <parameter name="s" type="Function|String|Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="clearLambdaCache" scope="normal">
        <summary>clears internal cache of lambdas</summary>
      </method>
      <method name="linrec" scope="normal">
        <summary>Generates a function for the linear recursion pattern.
	All parameter functions are called in the context of &amp;quot;this&amp;quot; object.</summary>
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</summary>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</summary>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself.
	The returned value should be an array, which is used to call
	the generated function recursively.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts two parameters: the returned value from the recursive step, and
	the original array of parameters used with all other functions.
	The returned value will be returned as the value of the generated function.</summary>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="buildListcomp" scope="normal">
        <summary>builds a function from a text snippet, which represents a valid
	JS 1.7 list comprehension, returns a string, which represents the function.</summary>
        <description>This method returns a textual representation of a function
	built from the list comprehension text snippet (conformant to JS 1.7).
	It is meant to be evaled in the proper context, so local variable can be
	pulled from the environment.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="compileListcomp" scope="normal">
        <summary>builds a function from a text snippet, which represents a valid
	JS 1.7 list comprehension, returns a function object.</summary>
        <description>This method returns a function built from the list
	comprehension text snippet (conformant to JS 1.7). It is meant to be
	reused several times.</description>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="listcomp" scope="normal">
        <summary>executes the list comprehension building an array.</summary>
        <parameters>
          <parameter name="s" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="multirec" scope="normal">
        <summary>Generates a function for the multi-way recursion pattern.
	All parameter functions are called in the context of &amp;quot;this&amp;quot; object.</summary>
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</summary>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</summary>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself.
	The returned value should be an array, which is used to call
	the generated function recursively. Each member of the array should be
	an array of parameters. The length of it defines how many times
	the generated function is called recursively.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts two parameters: the array of returned values from recursive steps,
	and the original array of parameters used with all other functions.
	The returned value will be returned as the value of the generated function.</summary>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="numrec" scope="normal">
        <summary>Generates a function for the simplified numeric linear recursion pattern.
	All parameter functions are called in the context of &amp;quot;this&amp;quot; object.</summary>
        <description>This is a simplification of the linear recursion combinator:
	- the generated function takes one numeric parameter "x",
	- the "cond" is fixed and checks for 0.
	- the "before" is fixed and the generated function is called with "x - 1".
	- the "above is called with two parameters: the return from the generated
	function, and with "x".
	- as you can see the recursion is done by decreasing the parameter,
	and calling itself until it reaches 0.</description>
        <parameters>
          <parameter name="then" type="Object" usage="required">
            <summary>The value, which is used upon termination of the recursion.
	It will be returned as the value of the generated function.
	above:
	The lambda expression, which is called after the recursive step.
	It accepts two parameters: the returned value from the recursive step, and
	the original parameter. The returned value will be returned as the value of
	the generated function.</summary>
          </parameter>
          <parameter name="after" type="Function|String|Array" usage="required"/>
        </parameters>
      </method>
      <method name="keys" scope="normal">
        <summary>returns an array of all keys in the object</summary>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="values" scope="normal">
        <summary>returns an array of all values in the object</summary>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="filterIn" scope="normal">
        <summary>creates new object with all attributes that pass the test
	implemented by the provided function.</summary>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="forIn" scope="normal">
        <summary>iterates over all object attributes.</summary>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="mapIn" scope="normal">
        <summary>creates new object with the results of calling
	a provided function on every attribute in this object.</summary>
        <parameters>
          <parameter name="obj" type="Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="filterRev" scope="normal">
        <summary>creates a new array with all elements that pass the test
	implemented by the provided function.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="forEachRev" scope="normal">
        <summary>executes a provided function once per array element.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="mapRev" scope="normal">
        <summary>creates a new array with the results of calling
	a provided function on every element in this array.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="everyRev" scope="normal">
        <summary>tests whether all elements in the array pass the test
	implemented by the provided function.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="someRev" scope="normal">
        <summary>tests whether some element in the array passes the test
	implemented by the provided function.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="scanl" scope="normal">
        <summary>repeatedly applies a binary function to an array from left
	to right using a seed value as a starting point; returns an array
	of values produced by foldl() at that point.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scanl1" scope="normal">
        <summary>repeatedly applies a binary function to an array from left
	to right; returns an array of values produced by foldl1() at that
	point.</summary>
        <parameters>
          <parameter name="a" type="Array|String|Object" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scanr" scope="normal">
        <summary>repeatedly applies a binary function to an array from right
	to left using a seed value as a starting point; returns an array
	of values produced by foldr() at that point.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scanr1" scope="normal">
        <summary>repeatedly applies a binary function to an array from right
	to left; returns an array of values produced by foldr1() at that
	point.</summary>
        <parameters>
          <parameter name="a" type="Array|String" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="repeat" scope="normal">
        <summary>builds an array by repeatedly applying a unary function N times
	with a seed value Z. N should be greater than 0.</summary>
        <parameters>
          <parameter name="n" type="Number" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="until" scope="normal">
        <summary>builds an array by repeatedly applying a unary function with
	a seed value Z until the predicate is satisfied.</summary>
        <parameters>
          <parameter name="pr" type="Function|String|Array" usage="required"/>
          <parameter name="f" type="Function|String|Array" usage="required"/>
          <parameter name="z" type="Object" usage="required"/>
          <parameter name="o" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="tailrec" scope="normal">
        <summary>Generates a function for the tail recursion pattern. This is the simplified
	version of the linear recursive combinator without the &amp;quot;after&amp;quot; function,
	and with the modified &amp;quot;before&amp;quot; function. All parameter functions are called
	in the context of &amp;quot;this&amp;quot; object.</summary>
        <parameters>
          <parameter name="cond" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is used to detect the termination of recursion.
	It accepts the same parameter as the generated recursive function itself.
	This function should return &amp;quot;true&amp;quot;, if the recursion should be stopped,
	and the &amp;quot;then&amp;quot; part should be executed. Otherwise the recursion will proceed.</summary>
          </parameter>
          <parameter name="then" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is called upon termination of the recursion.
	It accepts the same parameters as the generated recursive function itself.
	The returned value will be returned as the value of the generated function.</summary>
          </parameter>
          <parameter name="before" type="Function|String|Array" usage="required">
            <summary>The lambda expression, which is called before the recursive step.
	It accepts the same parameter as the generated recursive function itself,
	and returns an array of arguments for the next recursive call of
	the generated function.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="zip" scope="normal">
        <summary>returns an array of arrays, where the i-th array
	contains the i-th element from each of the argument arrays.</summary>
        <description>This is the venerable zip combiner (for example,
	see Python documentation for general details). The returned
	array is truncated to match the length of the shortest input
	array.</description>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="unzip" scope="normal">
        <summary>similar to dojox.lang.functional.zip(), but takes
	a single array of arrays as the input.</summary>
        <description>This function is similar to dojox.lang.functional.zip()
	and can be used to unzip objects packed by
	dojox.lang.functional.zip(). It is here mostly to provide
	a short-cut for the different method signature.</description>
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="frame.style" type="">
    <properties>
      <property name="display" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="frame.contentWindow" type="">
    <properties>
      <property name="document" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.lang.oo">
    <methods>
      <method name="makeDecorator" scope="normal">
        <summary>creates new custom decorator creator</summary>
        <return-description>Function:
	new decorator constructor</return-description>
        <parameters>
          <parameter name="decorator" type="Function|Object:" usage="required">
            <summary>a function to handle the custom assignment,
	or an object with exec() method</summary>
          </parameter>
        </parameters>
      </method>
      <method name="filter" scope="normal">
        <summary>creates a simple filter object</summary>
        <return-description>new dojox.lang.oo.Filter object</return-description>
        <parameters>
          <parameter name="bag" type="Object:" usage="required">
            <summary>object to be filtered</summary>
          </parameter>
          <parameter name="map" type="Object:" usage="required">
            <summary>the dictionary for renaming/removing while copying</summary>
          </parameter>
        </parameters>
      </method>
      <method name="applyDecorator" scope="normal">
        <summary>applies a decorator unraveling all embedded decorators</summary>
        <return-description>Object:
	returns the final value of the property</return-description>
        <parameters>
          <parameter name="decorator" type="Function:" usage="required">
            <summary>top-level decorator to apply</summary>
          </parameter>
          <parameter name="name" type="String:" usage="required">
            <summary>name of the property</summary>
          </parameter>
          <parameter name="newValue" type="Object:" usage="required">
            <summary>new value of the property</summary>
          </parameter>
          <parameter name="oldValue" type="Object:" usage="required">
            <summary>old value of the property</summary>
          </parameter>
        </parameters>
      </method>
      <method name="__mixin" scope="normal">
        <summary>mixes in two objects processing decorators and filters</summary>
        <return-description>Object:
	target</return-description>
        <parameters>
          <parameter name="target" type="Object:" usage="required">
            <summary>target to receive new/updated properties</summary>
          </parameter>
          <parameter name="source" type="Object:" usage="required">
            <summary>source of properties
	defaults: dojox.lang.oo.__MixinDefaults?:
	default functions for various aspects of mixing</summary>
          </parameter>
          <parameter name="decorator" type="" usage="required"/>
          <parameter name="filter" type="" usage="required"/>
          <parameter name="mixer" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="mixin" scope="normal">
        <summary>mixes in two or more objects processing decorators and filters
	using defaults as a fallback</summary>
        <return-description>Object:
	target</return-description>
        <parameters>
          <parameter name="target" type="Object:" usage="required">
            <summary>target to receive new/updated properties</summary>
          </parameter>
          <parameter name="source" type="Object:" usage="one-or-more">
            <summary>source of properties, more than one source is allowed</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="rearrange" scope="normal">
        <summary>Process properties in place by removing and renaming them.</summary>
        <description>Properties of an object are to be renamed or removed specified
	by "map" argument. Only own properties of "map" are processed.</description>
        <return-description>Object:
	the original object</return-description>
        <examples>
          <example>	oo.rearrange(bag, {
			abc: "def",	// rename "abc" attribute to "def"
			ghi: null	// remove/hide "ghi" attribute
		});</example>
        </examples>
        <parameters>
          <parameter name="bag" type="Object:" usage="required">
            <summary>the object to be processed</summary>
          </parameter>
          <parameter name="map" type="Object:" usage="required">
            <summary>the dictionary for renaming (false value indicates removal of the named property)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.lang.oo.Decorator" type="Function" classlike="true">
    <summary>The base class for all decorators.</summary>
    <description>This object holds an original function or another decorator
	object, and implements a special mixin algorithm to be used
	by dojox.lang.oo.mixin.</description>
    <properties>
      <property name="value" scope="instance" type="Object:">
        <summary>a payload to be processed by the decorator.</summary>
      </property>
      <property name="decorator" scope="instance" type="Function|Object:">
        <summary>a function to handle the custom assignment, or an object with exec()
	method. The signature is:
	decorator(/*String*/ name, /*Function*/ newValue, /*Function*/ oldValue).</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="value" type="Object:" usage="required">
            <summary>a payload to be processed by the decorator.</summary>
          </parameter>
          <parameter name="decorator" type="Function|Object:" usage="required">
            <summary>a function to handle the custom assignment, or an object with exec()
	method. The signature is:
	decorator(/*String*/ name, /*Function*/ newValue, /*Function*/ oldValue).</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.lang.oo.Filter" type="Function" classlike="true">
    <summary>Filter to control mixing in objects by skipping
	properties and renaming them.</summary>
    <description>This object is used as a holder of an original object
	(whose properites are to be copied), and a filter
	function used while copying by dojox.lang.oo.mixin.</description>
    <properties>
      <property name="bag" scope="instance" type="Object:">
        <summary>object to be filtered</summary>
      </property>
      <property name="filter" scope="instance" type="Function|Object:">
        <summary>a function to handle the name filtering,
	or an object with exec() method</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="bag" type="Object:" usage="required">
            <summary>object to be filtered</summary>
          </parameter>
          <parameter name="filter" type="Function|Object:" usage="required">
            <summary>a function to handle the name filtering,
	or an object with exec() method</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.lang.oo.aop" type="">
    <properties>
      <property name="before" scope="normal" type="Object"/>
      <property name="around" scope="normal" type="Object"/>
      <property name="afterReturning" scope="normal" type="Object"/>
      <property name="afterThrowing" scope="normal" type="Object"/>
      <property name="after" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.lang.oo.general" type="">
    <properties>
      <property name="augment" scope="normal" type="Object"/>
      <property name="override" scope="normal" type="Object"/>
      <property name="shuffle" scope="normal" type="Object"/>
      <property name="wrap" scope="normal" type="Object"/>
      <property name="tap" scope="normal" type="Object"/>
      <property name="before" scope="normal" type="Object"/>
      <property name="after" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.lang.oo.__MixinDefaults" type="Function" classlike="true" private="true">
    <summary>a dict of default parameters for dojox.lang.oo._mixin</summary>
    <properties>
      <property name="decorator" scope="instance" type="Function:">
        <summary>a decorator function to be used in absence of other decorators</summary>
      </property>
      <property name="filter" scope="instance" type="Function:">
        <summary>a filter function to be used in absence of other filters</summary>
      </property>
      <property name="mixer" scope="instance" type="Function:">
        <summary>a mixer function to be used to mix in new properties</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="JSONSchema" type="">
    <properties>
      <property name="__defineGetter__" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.lang.utils" type="">
    <methods>
      <method name="coerceType" scope="normal">
        <parameters>
          <parameter name="target" type="" usage="required"/>
          <parameter name="source" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateWithObject" scope="normal">
        <summary>updates an existing object in place with properties from an &amp;quot;source&amp;quot; object.</summary>
        <parameters>
          <parameter name="target" type="Object:" usage="required">
            <summary>the &amp;quot;target&amp;quot; object to be updated</summary>
          </parameter>
          <parameter name="source" type="Object:" usage="required">
            <summary>the &amp;quot;source&amp;quot; object, whose properties will be used to source the existed object.</summary>
          </parameter>
          <parameter name="conv" type="Boolean:" usage="optional">
            <summary>force conversion to the original type</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="updateWithPattern" scope="normal">
        <summary>updates an existing object in place with properties from an &amp;quot;source&amp;quot; object.</summary>
        <parameters>
          <parameter name="target" type="Object:" usage="required">
            <summary>the &amp;quot;target&amp;quot; object to be updated</summary>
          </parameter>
          <parameter name="source" type="Object:" usage="required">
            <summary>the &amp;quot;source&amp;quot; object, whose properties will be used to source the existed object.</summary>
          </parameter>
          <parameter name="pattern" type="Array:" usage="required">
            <summary>an array of properties to be copied</summary>
          </parameter>
          <parameter name="conv" type="Boolean:" usage="optional">
            <summary>force conversion to the original type</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.layout">
    <summary>A collection of layout related Widgets</summary>
    <properties>
      <property name="BorderContainer" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.layout.ContentPane" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <summary>cleans content to make it less likely to generate DOM/JS errors.</summary>
    <description>useful if you send ContentPane a complete page, instead of a html fragment
	scans for
	* title Node, remove
	* DOCTYPE tag, remove</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
    </mixins>
    <properties>
      <property name="adjustPaths" scope="prototype" type="Boolean">
        <summary>Adjust relative paths in html string content to point to this page.
	Only useful if you grab content from a another folder then the current one</summary>
      </property>
      <property name="cleanContent" scope="prototype" type="Boolean"/>
      <property name="renderStyles" scope="prototype" type="Boolean">
        <summary>trigger/load styles in the content</summary>
      </property>
      <property name="executeScripts" scope="prototype" type="Boolean">
        <summary>Execute (eval) scripts that is found in the content</summary>
      </property>
      <property name="scriptHasHooks" scope="prototype" type="Boolean">
        <summary>replace keyword '_container_' in scripts with 'dijit.byId(this.id)'
	NOTE this name might change in the near future</summary>
      </property>
      <property name="ioMethod" scope="instance" type="dojo.xhrGet|dojo.xhrPost">
        <summary>reference to the method that should grab the content</summary>
      </property>
      <property name="ioArgs" scope="instance-prototype" type="Object">
        <summary>makes it possible to add custom args to xhrGet, like ioArgs.headers['X-myHeader'] = 'true'
	could put back _renderStyles by wrapping/aliasing dojox.html._ContentSetter.prototype._renderStyles</summary>
      </property>
      <property name="_contentSetter" scope="prototype" type="Object"/>
      <property name="_contentSetterParams" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="onExecError" scope="prototype">
        <summary>event callback, called on script error or on java handler error
	overide and return your own html string if you want a some text
	displayed within the ContentPane</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setContent" scope="prototype">
        <parameters>
          <parameter name="cont" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.DragPane" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Makes a pane's content dragable by/within it's surface</summary>
    <description>A small widget which takes a node with overflow:auto and
	allows dragging to position the content. Useful with images,
	or for just adding "something" to a overflow-able div.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="invert" scope="prototype" type="Boolean">
        <summary>Naturally, the behavior is to invert the axis of the drag.
	Setting invert:false will make the pane drag in the same
	direction as the mouse.</summary>
      </property>
      <property name="domNode" scope="prototype" type=""/>
      <property name="_x" scope="prototype" type=""/>
      <property name="_y" scope="prototype" type=""/>
      <property name="_mover" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_down" scope="prototype">
        <summary>mousedown handler, start the dragging</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_up" scope="prototype">
        <summary>mouseup handler, stop the dragging</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_move" scope="prototype">
        <summary>mousemove listener, offset the scroll amount by the delta
	since our last call.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.ExpandoPane" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <summary>An experimental collapsing-pane for dijit.layout.BorderContainer</summary>
    <description>Works just like a ContentPane inside of a borderContainer. Will expand/collapse on
	command, and supports having Layout Children as direct descendants</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="maxHeight" scope="prototype" type="String"/>
      <property name="maxWidth" scope="prototype" type="String"/>
      <property name="splitter" scope="prototype" type="bool"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="easeOut" scope="prototype" type="String|Function">
        <summary>easing function used to hide pane</summary>
      </property>
      <property name="easeIn" scope="prototype" type="String|Function">
        <summary>easing function use to show pane</summary>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <summary>duration to run show/hide animations</summary>
      </property>
      <property name="startExpanded" scope="prototype" type="Boolean">
        <summary>Does this widget start in an open (true) or closed (false) state</summary>
      </property>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="_animConnects" scope="prototype" type="Array"/>
      <property name="_isHorizontal" scope="prototype" type="Object"/>
      <property name="_container" scope="prototype" type="Object"/>
      <property name="_closedSize" scope="prototype" type=""/>
      <property name="_titleHeight" scope="prototype" type=""/>
      <property name="id" scope="prototype" type=""/>
      <property name="_currentSize" scope="prototype" type="Object"/>
      <property name="_showSize" scope="prototype" type=""/>
      <property name="_showing" scope="prototype" type="bool"/>
      <property name="_hasSizes" scope="prototype" type="Object"/>
      <property name="_showAnim" scope="prototype" type="Object"/>
      <property name="_hideAnim" scope="prototype" type="Object"/>
      <property name="_contentBox" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_startupSizes" scope="prototype"/>
      <method name="_afterResize" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setupAnims" scope="prototype">
        <summary>Create the show and hide animations</summary>
      </method>
      <method name="toggle" scope="prototype">
        <summary>Toggle this pane's visibility</summary>
      </method>
      <method name="_hideWrapper" scope="prototype">
        <summary>Set the Expando state to &amp;quot;closed&amp;quot;</summary>
      </method>
      <method name="_showEnd" scope="prototype">
        <summary>Common animation onEnd code - &amp;quot;unclose&amp;quot;</summary>
      </method>
      <method name="_hideEnd" scope="prototype">
        <summary>Callback for the hide animation - &amp;quot;close&amp;quot;</summary>
      </method>
      <method name="resize" scope="prototype">
        <summary>we aren't a layout widget, but need to act like one:</summary>
        <parameters>
          <parameter name="psize" type="Object" usage="optional">
            <summary>The size object optionally passed to us by our parent.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_trap" scope="prototype">
        <summary>Trap stray events</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.FloatingPane" type="Function" classlike="true" superclass="dojox.layout.ContentPane">
    <summary>A non-modal Floating window.</summary>
    <description>Makes a `dojox.layout.ContentPane` float and draggable by it's title [similar to TitlePane]
	and over-rides onClick to onDblClick for wipeIn/Out of containerNode
	provides minimize(dock) / show() and hide() methods, and resize [almost]</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dojox.layout.ContentPane"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="closable" scope="prototype" type="Boolean">
        <summary>Allow closure of this Node</summary>
      </property>
      <property name="dockable" scope="prototype" type="Boolean">
        <summary>Allow minimizing of pane if true</summary>
      </property>
      <property name="resizable" scope="prototype" type="Boolean">
        <summary>Allow resizing of pane true if true</summary>
      </property>
      <property name="maxable" scope="prototype" type="Boolean">
        <summary>Horrible param name for &amp;quot;Can you maximize this floating pane?&amp;quot;</summary>
      </property>
      <property name="resizeAxis" scope="prototype" type="String">
        <summary>One of: x | xy | y to limit pane's sizing direction</summary>
      </property>
      <property name="title" scope="prototype" type="String">
        <summary>Title to use in the header</summary>
      </property>
      <property name="dockTo" scope="prototype" type="DomNode">
        <summary>if empty, will create private layout.Dock that scrolls with viewport
	on bottom span of viewport.</summary>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <summary>Time is MS to spend toggling in/out node</summary>
      </property>
      <property name="iconSrc" scope="prototype" type="String">
        <summary>[not implemented yet] will be either icon in titlepane to left
	of Title, and/or icon show when docked in a fisheye-like dock
	or maybe dockIcon would be better?</summary>
      </property>
      <property name="contentClass" scope="prototype" type="String">
        <summary>The className to give to the inner node which has the content</summary>
      </property>
      <property name="_showAnim" scope="prototype" type="Object"/>
      <property name="_hideAnim" scope="prototype" type="Object"/>
      <property name="_dockNode" scope="prototype" type="Object"/>
      <property name="_restoreState" scope="prototype" type="Object"/>
      <property name="_allFPs" scope="prototype" type="Array"/>
      <property name="_startZ" scope="prototype" type="Number"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="attributeMap" scope="prototype" type="Object"/>
      <property name="bgIframe" scope="prototype" type="Object"/>
      <property name="_naturalState" scope="prototype" type="Object"/>
      <property name="_resizeHandle" scope="prototype" type="Object"/>
      <property name="_started" scope="prototype" type="Object"/>
      <property name="_maximized" scope="prototype" type="bool"/>
      <property name="_isDocked" scope="prototype" type="Object"/>
      <property name="_currentState" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="setTitle" scope="prototype">
        <summary>Update the Title bar with a new string</summary>
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <summary>Close and destroy this widget</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Close, but do not destroy this FloatingPane</summary>
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <summary>Show the FloatingPane</summary>
        <parameters>
          <parameter name="callback" type="Function" usage="optional"/>
        </parameters>
      </method>
      <method name="minimize" scope="prototype">
        <summary>Hide and dock the FloatingPane</summary>
      </method>
      <method name="maximize" scope="prototype">
        <summary>Make this FloatingPane full-screen (viewport)</summary>
      </method>
      <method name="_restore" scope="prototype"/>
      <method name="_dock" scope="prototype"/>
      <method name="resize" scope="prototype">
        <summary>Size the FloatingPane and place accordingly</summary>
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="bringToTop" scope="prototype">
        <summary>bring this FloatingPane above all other panes</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroy this FloatingPane completely</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.FloatingPane.dockNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.FloatingPane.closeNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.FloatingPane.maxNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.FloatingPane.restoreNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.FloatingPane.resizeHandle.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.FloatingPane.domNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
      <property name="position" scope="prototype" type="String"/>
      <property name="top" scope="prototype" type="String"/>
      <property name="left" scope="prototype" type="String"/>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.FloatingPane.canvas.style" type="">
    <properties>
      <property name="overflow" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.FloatingPane.containerNode.style" type="">
    <properties>
      <property name="overflow" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.FloatingPane.domNode" type=""/>
  <object location="dojox.layout.Dock" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget that attaches to a node and keeps track of incoming / outgoing FloatingPanes
	and handles layout</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="_docked" scope="prototype" type="Array"/>
      <property name="_inPositioning" scope="prototype" type="bool"/>
      <property name="autoPosition" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="addNode" scope="prototype">
        <summary>Instert a dockNode refernce into the dock</summary>
        <parameters>
          <parameter name="refNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="_positionDock" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout._DockNode" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>dojox.layout._DockNode is a private widget used to keep track of
	which pane is docked.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="title" scope="prototype" type="String">
        <summary>Shown in dock icon. should read parent iconSrc?</summary>
      </property>
      <property name="paneRef" scope="prototype" type="Widget">
        <summary>reference to the FloatingPane we reprasent in any given dock</summary>
      </property>
      <property name="templateString" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="restore" scope="prototype">
        <summary>remove this dock item from parent dock, and call show() on reffed floatingpane</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.GridContainer" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>The Grid Container is a container of child elements that are placed in a kind of grid.</summary>
    <description>It displays the child elements by column (ie: the childs widths are fixed by the column width of the grid but the childs heights are free).
	Each child is movable by drag and drop inside the Grid Container.
	The position of other children is automatically calculated when a child is moved</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="isContainer" scope="prototype" type="Object"/>
      <property name="isAutoOrganized" scope="prototype" type="Boolean:">
        <summary>Define auto organisation of children into the grid container.</summary>
      </property>
      <property name="isRightFixed" scope="prototype" type="Boolean">
        <summary>Define if the right border has a fixed size.</summary>
      </property>
      <property name="isLeftFixed" scope="prototype" type="Boolean">
        <summary>Define if the left border has a fixed size.</summary>
      </property>
      <property name="hasResizableColumns" scope="prototype" type="Boolean">
        <summary>Allow or not resizing of columns by a grip handle.</summary>
      </property>
      <property name="nbZones" scope="prototype" type="Integer">
        <summary>The number of dropped zones.</summary>
      </property>
      <property name="opacity" scope="prototype" type="Integer">
        <summary>Define the opacity of the DnD Avatar.</summary>
      </property>
      <property name="colWidths" scope="prototype" type="Array">
        <summary>The percentage widths of columns. If not set, then each column is the same percentage width.</summary>
      </property>
      <property name="minColWidth" scope="prototype" type="Integer">
        <summary>Minimum column width in percentage.</summary>
      </property>
      <property name="minChildWidth" scope="prototype" type="Integer">
        <summary>Minimun children with in pixel (only used for IE6 that doesn't handle min-width css property</summary>
      </property>
      <property name="acceptTypes" scope="instance-prototype" type="Array">
        <summary>The gridcontainer will only accept the children that fit to the types.
	In order to do that, the child must have a widgetType or a dndType attribute corresponding to the accepted type.</summary>
      </property>
      <property name="mode" scope="prototype" type="String">
        <summary>location to add columns, must be set to left or right(default)</summary>
      </property>
      <property name="allowAutoScroll" scope="prototype" type="Boolean">
        <summary>auto-scrolling enable inside the GridContainer</summary>
      </property>
      <property name="timeDisplayPopup" scope="prototype" type="Integer">
        <summary>display time of popup in miliseconds</summary>
      </property>
      <property name="isOffset" scope="prototype" type="Boolean">
        <summary>if true : Let the mouse to its original location when moving (allow to specify it proper offset)
	if false : Current behavior, mouse in the upper left corner of the widget</summary>
      </property>
      <property name="offsetDrag" scope="instance-prototype" type="Object">
        <summary>Allow to specify its own offset (x and y) only when Parameter isOffset is true</summary>
      </property>
      <property name="withHandles" scope="prototype" type="Boolean">
        <summary>Specify if there is a specific drag handle on widgets</summary>
      </property>
      <property name="handleClasses" scope="prototype" type="Array">
        <summary>Array of classes of nodes that will act as drag handles</summary>
      </property>
      <property name="_draggedWidget" scope="prototype" type="Object"/>
      <property name="_isResized" scope="prototype" type="Boolean">
        <summary>Determine if user can resizing the widget with the mouse.</summary>
      </property>
      <property name="_activeGrip" scope="prototype" type="Object"/>
      <property name="_a11yOn" scope="prototype" type="Object"/>
      <property name="_canDisplayPopup" scope="prototype" type="bool"/>
      <property name="dropHandler" scope="prototype" type="Object"/>
      <property name="_oldwidth" scope="prototype" type=""/>
      <property name="handleDndStart" scope="prototype" type="Array"/>
      <property name="onMouseOver" scope="prototype" type="Object"/>
      <property name="_x" scope="prototype" type="Object"/>
      <property name="initX" scope="prototype" type=""/>
      <property name="oldTabSize" scope="prototype" type=""/>
      <property name="currentColumn" scope="prototype" type=""/>
      <property name="currentColumnWidth" scope="prototype" type=""/>
      <property name="nextColumn" scope="prototype" type=""/>
      <property name="nextColumnWidth" scope="prototype" type=""/>
      <property name="currentMinCol" scope="prototype" type=""/>
      <property name="nextMinCol" scope="prototype" type=""/>
      <property name="connectResizeColumnMove" scope="prototype" type="Object"/>
      <property name="connectResizeColumnOff" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="destroy" scope="prototype">
        <summary>destroy GridContainer Component.</summary>
      </method>
      <method name="resize" scope="prototype"/>
      <method name="getZones" scope="prototype">
        <summary>return array of zone (domNode)</summary>
      </method>
      <method name="getNewChildren" scope="prototype"/>
      <method name="getChildren" scope="prototype">
        <summary>Returns array of children widgets.</summary>
        <description>Returns the widgets that are directly under columns.</description>
      </method>
      <method name="onResized" scope="prototype">
        <summary>Callback method to resize the GridContainer widget and columns</summary>
      </method>
      <method name="_organizeServices" scope="prototype">
        <summary>List all zones and insert service into columns.</summary>
      </method>
      <method name="_organizeServicesManually" scope="prototype">
        <summary>Organize Services by column property of widget.</summary>
      </method>
      <method name="_insertService" scope="prototype">
        <summary>Insert a service in a specific column of the GridContainer widget.</summary>
        <parameters>
          <parameter name="z" type="Integer" usage="required">
            <summary>zone Index (Column)</summary>
          </parameter>
          <parameter name="p" type="Integer" usage="required">
            <summary>rowIndex</summary>
          </parameter>
          <parameter name="service" type="Widget" usage="required">
            <summary>child to insert</summary>
          </parameter>
          <parameter name="first" type="Boolean" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="addService" scope="prototype">
        <parameters>
          <parameter name="service" type="Object" usage="required"/>
          <parameter name="z" type="Integer" usage="required"/>
          <parameter name="p" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="prototype">
        <summary>Add a service (child widget) in a specific column of the GridContainer widget.</summary>
        <parameters>
          <parameter name="service" type="Object" usage="required">
            <summary>widget to insert</summary>
          </parameter>
          <parameter name="z" type="Integer" usage="required">
            <summary>zone number (column)</summary>
          </parameter>
          <parameter name="p" type="Integer" usage="required">
            <summary>place in the zone (first = 0)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_createGrid" scope="prototype">
        <summary>Create all grid (zones and grip)</summary>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_disconnectDnd" scope="prototype">
        <summary>disconnect all events on insertNodes</summary>
      </method>
      <method name="_createZone" scope="prototype">
        <summary>Create a DnD column.</summary>
        <parameters>
          <parameter name="zone" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="plottedDnd Object"/>
        </return-types>
      </method>
      <method name="_createGrip" scope="prototype">
        <summary>Create a grip for a specific zone</summary>
        <parameters>
          <parameter name="dz" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_initPlaceGrips" scope="prototype">
        <summary>Initialize the position of a grip which will not change (top)</summary>
      </method>
      <method name="_placeGrips" scope="prototype">
        <summary>Define the position of a grip and place it on page.</summary>
      </method>
      <method name="_getZoneByIndex" scope="prototype">
        <summary>Return a DOM node containing a zone by given a index.</summary>
        <parameters>
          <parameter name="n" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="number"/>
        </return-types>
      </method>
      <method name="getIndexZone" scope="prototype">
        <summary>Return an integer by given a zone</summary>
        <parameters>
          <parameter name="zone" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="number"/>
        </return-types>
      </method>
      <method name="resizeColumnOn" scope="prototype">
        <summary>Connect events to listen the resize action.
	Change the type of width columns (% to px)
	Calculate the minwidth according to the children</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="resizeColumnMove" scope="prototype">
        <summary>Change columns size.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="resizeColumnOff" scope="prototype">
        <summary>Disconnect resize events.
	Change the type of width columns (px to %)</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="setColumns" scope="prototype">
        <summary>Set the number of columns</summary>
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_addColumn" scope="prototype">
        <summary>Add some columns</summary>
        <parameters>
          <parameter name="nbColumns" type="Integer" usage="required"/>
        </parameters>
      </method>
      <method name="_deleteColumn" scope="prototype">
        <summary>Remove some columns with indices passed as an array</summary>
        <parameters>
          <parameter name="indices" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_getColWidth" scope="prototype">
        <parameters>
          <parameter name="idx" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColumnsWidth" scope="prototype">
        <summary>Update the columns width.</summary>
      </method>
      <method name="_selectFocus" scope="prototype">
        <summary>Enable a11y into the GridContainer :
	- Possibility to move focus into the GridContainer (TAB, LEFT ARROW, RIGHT ARROW, UP ARROW, DOWN ARROW).
	- Possibility to move GridContainer's children (Drag and Drop) with keyboard. (SHIFT +	ARROW).
	If the type of widget is not draggable, a popup is displayed.</summary>
        <parameters>
          <parameter name="event" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_displayPopup" scope="prototype">
        <summary>display a popup when a widget type can not move</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.GridContainer.currentColumn.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.GridContainer.nextColumn.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.GridContainer._activeGrip.style" type="">
    <properties>
      <property name="left" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.GridContainer.gridContainerTable" type="">
    <properties>
      <property name="clientWidth" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.layout.GridContainer.grid">
    <properties>
      <property name="length" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.layout.RadioGroup" type="Function" classlike="true" superclass="dijit.layout.StackContainer">
    <summary>A Container that turns its Layout Children into a single Pane and transitions between states
	onHover of the button</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit.layout.StackContainer"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="duration" scope="prototype" type="Integer">
        <summary>used for Fade and Slide RadioGroup's, the duration to run the transition animation. does not affect anything
	in default RadioGroup</summary>
      </property>
      <property name="hasButtons" scope="prototype" type="Boolean">
        <summary>toggles internal button making on or off</summary>
      </property>
      <property name="buttonClass" scope="prototype" type="String">
        <summary>The full declared className of the Button widget to use for hasButtons</summary>
      </property>
      <property name="templateString" scope="prototype" type="String">
        <summary>the template for our container</summary>
      </property>
      <property name="_children" scope="prototype" type="Object"/>
      <property name="_buttons" scope="prototype" type=""/>
      <property name="_size" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>scan the container for children, and make &amp;quot;tab buttons&amp;quot; for them</summary>
      </method>
      <method name="_setupChild" scope="prototype">
        <summary>Creates a hover button for a child node of the RadioGroup</summary>
        <parameters>
          <parameter name="child" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="removeChild" scope="prototype">
        <parameters>
          <parameter name="child" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="prototype">
        <summary>called when StackContainer receives a selectChild call, used to transition the panes.</summary>
        <parameters>
          <parameter name="newWidget" type="dijit._Widget" usage="required"/>
          <parameter name="oldWidget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="prototype">
        <summary>show the selected child widget</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="prototype">
        <summary>hide the specified child widget</summary>
        <parameters>
          <parameter name="page" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.RadioGroupFade" type="Function" classlike="true" superclass="dojox.layout.RadioGroup">
    <summary>An extension on a stock RadioGroup, that fades the panes.</summary>
    <mixins>
      <mixin scope="instance" location="dojox.layout.RadioGroup"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="_hideChild" scope="prototype">
        <summary>hide the specified child widget</summary>
        <parameters>
          <parameter name="page" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_showChild" scope="prototype">
        <summary>show the specified child widget</summary>
        <parameters>
          <parameter name="page" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.RadioGroupSlide" type="Function" classlike="true" superclass="dojox.layout.RadioGroup">
    <summary>A Sliding Radio Group</summary>
    <description>An extension on a stock RadioGroup widget, sliding the pane
	into view from being hidden. The entry direction is randomized
	on each view</description>
    <mixins>
      <mixin scope="instance" location="dojox.layout.RadioGroup"/>
    </mixins>
    <properties>
      <property name="zTop" scope="prototype" type="Integer">
        <summary>A z-index to apply to the incoming pane</summary>
      </property>
      <property name="_anim" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="easing" scope="instance-prototype">
        <summary>A hook to override the default easing of the pane slides.</summary>
      </method>
      <method name="constructor" scope="prototype"/>
      <method name="_positionChild" scope="prototype">
        <summary>set the child out of view immediately after being hidden</summary>
        <parameters>
          <parameter name="page" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="FIXME: is there a real &quot;size&quot; floating around always?"/>
        </return-types>
      </method>
      <method name="_showChild" scope="prototype">
        <summary>Slide in the selected child widget</summary>
        <parameters>
          <parameter name="page" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_hideChild" scope="prototype">
        <summary>reset the position of the hidden pane out of sight</summary>
        <parameters>
          <parameter name="page" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout._RadioButton" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>The Buttons for a RadioGroup</summary>
    <description>A private widget used to manipulate the StackContainer (RadioGroup*). Don't create directly.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="label" scope="prototype" type="String">
        <summary>the Text Label of the button</summary>
      </property>
      <property name="page" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>start listening to mouseOver</summary>
      </method>
      <method name="_onMouse" scope="prototype">
        <summary>set the selected child on hover, and set our hover state class</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_clearSelected" scope="prototype">
        <summary>remove hover state class from sibling Buttons. This is easier (and more reliable)
	than setting up an additional connection to onMouseOut</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.ResizeHandle" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A dragable handle used to resize an attached node.</summary>
    <description>The handle on the bottom-right corner of FloatingPane or other widgets that allows
	the widget to be resized.
	Typically not used directly.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="targetId" scope="prototype" type="String">
        <summary>id of the Widget OR DomNode that I will size</summary>
      </property>
      <property name="targetContainer" scope="prototype" type="DomNode">
        <summary>over-ride targetId and attch this handle directly to a reference of a DomNode</summary>
      </property>
      <property name="resizeAxis" scope="prototype" type="String">
        <summary>one of: x|y|xy limit resizing to a single axis, default to xy ...</summary>
      </property>
      <property name="activeResize" scope="prototype" type="Boolean">
        <summary>if true, node will size realtime with mouse movement,
	if false, node will create virtual node, and only resize target on mouseUp</summary>
      </property>
      <property name="activeResizeClass" scope="prototype" type="String">
        <summary>css class applied to virtual resize node.</summary>
      </property>
      <property name="animateSizing" scope="prototype" type="Boolean">
        <summary>only applicable if activeResize = false. onMouseup, animate the node to the
	new size</summary>
      </property>
      <property name="animateMethod" scope="prototype" type="String">
        <summary>one of &amp;quot;chain&amp;quot; or &amp;quot;combine&amp;quot; ... visual effect only. combine will &amp;quot;scale&amp;quot;
	node to size, &amp;quot;chain&amp;quot; will alter width, then height</summary>
      </property>
      <property name="animateDuration" scope="prototype" type="Integer">
        <summary>time in MS to run sizing animation. if animateMethod=&amp;quot;chain&amp;quot;, total animation
	playtime is 2*animateDuration</summary>
      </property>
      <property name="minHeight" scope="prototype" type="Integer">
        <summary>smallest height in px resized node can be</summary>
      </property>
      <property name="minWidth" scope="prototype" type="Integer">
        <summary>smallest width in px resize node can be</summary>
      </property>
      <property name="constrainMax" scope="prototype" type="Boolean">
        <summary>Toggle if this widget cares about the maxHeight and maxWidth
	parameters.</summary>
      </property>
      <property name="maxHeight" scope="prototype" type="Integer">
        <summary>Largest height size in px the resize node can become.</summary>
      </property>
      <property name="maxWidth" scope="prototype" type="Integer">
        <summary>Largest width size in px the reize node can become.</summary>
      </property>
      <property name="fixedAspect" scope="prototype" type="Boolean">
        <summary>Toggle to enable this widget to maintain the aspect
	ratio of the attached node.</summary>
      </property>
      <property name="intermediateChanges" scope="prototype" type="Boolean">
        <summary>Toggle to enable/disable this widget from firing onResize
	events at every step of a resize. If &lt;code&gt;activeResize&lt;/code&gt; is true,
	and this is false, onResize only fires _after_ the drop
	operation. Animated resizing is not affected by this setting.</summary>
      </property>
      <property name="startTopic" scope="prototype" type="String">
        <summary>The name of the topic this resizehandle publishes when resize is starting</summary>
      </property>
      <property name="endTopic" scope="prototype" type="String">
        <summary>The name of the topic this resizehandle publishes when resize is complete</summary>
      </property>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="_resizeHelper" scope="prototype" type="Object"/>
      <property name="minSize" scope="prototype" type="Object"/>
      <property name="maxSize" scope="prototype" type="Object"/>
      <property name="_resizeX" scope="prototype" type="Object"/>
      <property name="_resizeY" scope="prototype" type="Object"/>
      <property name="targetWidget" scope="prototype" type="Object"/>
      <property name="targetDomNode" scope="prototype" type=""/>
      <property name="_isSizing" scope="prototype" type="bool"/>
      <property name="startPoint" scope="prototype" type="Object"/>
      <property name="startSize" scope="prototype" type="Object"/>
      <property name="_aspect" scope="prototype" type="Object"/>
      <property name="_pconnects" scope="prototype" type="Array"/>
      <property name="_activeResizeLastEvent" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>setup our one major listener upon creation</summary>
      </method>
      <method name="_beginSizing" scope="prototype">
        <summary>setup movement listeners and calculate initial size</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSizing" scope="prototype">
        <summary>called when moving the ResizeHandle ... determines
	new size based on settings/position and sets styles.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_getNewCoords" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_checkConstraints" scope="prototype">
        <summary>filter through the various possible constaint possibilities.</summary>
        <parameters>
          <parameter name="newW" type="" usage="required"/>
          <parameter name="newH" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_changeSizing" scope="prototype">
        <summary>apply sizing information based on information in (e) to attached node</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_endSizing" scope="prototype">
        <summary>disconnect listenrs and cleanup sizing</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onResize" scope="prototype">
        <summary>Stub fired when sizing is done. Fired once
	after resize, or often when &lt;code&gt;intermediateChanges&lt;/code&gt; is
	set to true.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout._ResizeHelper" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A global private resize helper shared between any
	&lt;code&gt;dojox.layout.ResizeHandle&lt;/code&gt; with activeSizing off.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="show" scope="prototype">
        <summary>show helper to start resizing</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>hide helper after resizing is complete</summary>
      </method>
      <method name="resize" scope="prototype">
        <summary>size the widget and place accordingly</summary>
        <parameters>
          <parameter name="dim" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.RotatorContainer" type="Function" classlike="true" superclass="dijit.layout.StackContainer">
    <summary>Extends a StackContainer to automatically transition between children
	and display navigation in the form of tabs or a pager.</summary>
    <description>The RotatorContainer cycles through the children with a transition.
	published topics:
	[widgetId]-update - Notifies pager(s) that a child has changed.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused
	/*int*/ current     - current selected child
	/*int*/ total       - total number of children</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit.layout.StackContainer"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dojox.layout.RotatorContainer" id="myRotator" showTabs="true" autoStart="true" transitionDelay="5000"&gt;
			&lt;div id="pane1" dojoType="dijit.layout.ContentPane" title="1"&gt;
				Pane 1!
			&lt;/div&gt;
			&lt;div id="pane2" dojoType="dijit.layout.ContentPane" title="2"&gt;
				Pane 2!
			&lt;/div&gt;
			&lt;div id="pane3" dojoType="dijit.layout.ContentPane" title="3" transitionDelay="10000"&gt;
				Pane 3 with overrided transitionDelay!
			&lt;/div&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="showTabs" scope="prototype" type="Boolean">
        <summary>Sets the display of the tabs.  The tabs are actually a StackController.
	The child's title is used for the tab's label.</summary>
      </property>
      <property name="transitionDelay" scope="prototype" type="int">
        <summary>The delay in milliseconds before transitioning to the next child.</summary>
      </property>
      <property name="transition" scope="prototype" type="String">
        <summary>The type of transition to perform when switching children.
	A null transition will transition instantly.</summary>
      </property>
      <property name="transitionDuration" scope="prototype" type="int">
        <summary>The duration of the transition in milliseconds.</summary>
      </property>
      <property name="autoStart" scope="prototype" type="Boolean">
        <summary>Starts the timer to transition children upon creation.</summary>
      </property>
      <property name="suspendOnHover" scope="prototype" type="Boolean">
        <summary>Pause the rotator when the mouse hovers over it.</summary>
      </property>
      <property name="pauseOnManualChange" scope="prototype" type="Boolean">
        <summary>Pause the rotator when the tab is changed or the pager's next/previous
	buttons are clicked.</summary>
      </property>
      <property name="reverse" scope="prototype" type="Boolean">
        <summary>Causes the rotator to rotate in reverse order.</summary>
      </property>
      <property name="pagerId" scope="prototype" type="String">
        <summary>ID the pager widget.</summary>
      </property>
      <property name="cycles" scope="prototype" type="int">
        <summary>Number of cycles before pausing.</summary>
      </property>
      <property name="pagerClass" scope="prototype" type="String">
        <summary>The declared Class of the Pager used for this Widget</summary>
      </property>
      <property name="id" scope="prototype" type="String"/>
      <property name="tabNode" scope="prototype" type=""/>
      <property name="_stackController" scope="prototype" type=""/>
      <property name="_subscriptions" scope="prototype" type="Array"/>
      <property name="_over" scope="prototype" type="bool"/>
      <property name="_timer" scope="prototype" type="Object"/>
      <property name="_playing" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Initializes the DOM nodes, tabs, and transition stuff.</summary>
      </method>
      <method name="startup" scope="prototype">
        <summary>Initializes the pagers.</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Unsubscribe to all of our topics</summary>
      </method>
      <method name="_setShowTabsAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="anything" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePager" scope="prototype">
        <summary>Notify the pager's current and total numbers.</summary>
      </method>
      <method name="_onMouseOver" scope="prototype">
        <summary>Triggered when the mouse is moved over the rotator container.</summary>
      </method>
      <method name="_onMouseOut" scope="prototype">
        <summary>Triggered when the mouse is moved off the rotator container.</summary>
      </method>
      <method name="_resetTimer" scope="prototype">
        <summary>Resets the timer used to start the next transition.</summary>
      </method>
      <method name="_cycle" scope="prototype">
        <summary>Cycles to the next/previous child.</summary>
        <parameters>
          <parameter name="next" type="boolean" usage="required">
            <summary>or int</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_manualChange" scope="prototype">
        <summary>This function is only called when a manual change occurs in which
	case we may need to stop playing and we need to reset the cycle counter</summary>
      </method>
      <method name="_play" scope="prototype">
        <summary>Schedules the next transition.</summary>
        <parameters>
          <parameter name="skip" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_pause" scope="prototype">
        <summary>Clears the transition timer and pauses the rotator.</summary>
      </method>
      <method name="_state" scope="prototype">
        <summary>Fired when the play/pause pager button is toggled.</summary>
        <parameters>
          <parameter name="playing" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_transition" scope="prototype">
        <summary>Dispatches the appropriate transition.</summary>
        <parameters>
          <parameter name="next" type="dijit._Widget" usage="required"/>
          <parameter name="prev" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_transitionEnd" scope="prototype"/>
      <method name="_fade" scope="prototype">
        <summary>Crossfades two children.</summary>
        <parameters>
          <parameter name="next" type="dijit._Widget" usage="required"/>
          <parameter name="prev" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="_styleNode" scope="prototype">
        <summary>Helper function to style the children.</summary>
        <parameters>
          <parameter name="node" type="DOMnode" usage="required"/>
          <parameter name="opacity" type="number" usage="required"/>
          <parameter name="zIndex" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.RotatorPager" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Defines controls used to manipulate a RotatorContainer</summary>
    <description>A pager can be defined one of two ways:
	* Externally of the RotatorContainer's template and tell the
	RotatorPager the rotatorId of the RotatorContainer
	* As a direct descendant of the RotatorContainer (i.e. inside the
	RotatorContainer's template)
	The pager can contain the following components:
	* Previous button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "previous"
	* Next button
	- Must be a dijit.form.Button
	- dojoAttachPoint must be named "next"
	* Play/Pause toggle button
	- Must be a dijit.form.ToggleButton
	- dojoAttachPoint must be named "playPause"
	- Use iconClass to specify toggled state
	* Current child #
	- dojoAttachPoint must be named "current"
	* Total # of children
	- dojoAttachPoint must be named "total"
	You can choose to exclude specific controls as well as add elements
	for styling.
	Should you need a pager, but don't want to use Dijit buttons, you can
	write your own pager widget and just wire it into the topics.  The
	topic names are prefixed with the widget ID of the RotatorContainer.
	Notifications are received from and sent to the RotatorContainer as
	well as other RotatorPagers.
	published topics:
	[widgetId]-cycle - Notify that the next or previous button was pressed.
	Parameters:
	/*boolean*/ next - true if next, false if previous
	[widgetId]-state - Notify that the play/pause button was toggled.
	Parameters:
	/*boolean*/ playing - true if playing, false if paused</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <examples>
      <example>A pager with the current/total children and previous/next buttons.
		&lt;div dojoType="dojox.layout.RotatorPager" rotatorId="myRotator"&gt;
			&lt;button dojoType="dijit.form.Button" dojoAttachPoint="previous"&gt;Prev&lt;/button&gt;
			&lt;span dojoAttachPoint="current"&gt;&lt;/span&gt; / &lt;span dojoAttachPoint="total"&gt;&lt;/span&gt;
			&lt;button dojoType="dijit.form.Button" dojoAttachPoint="next"&gt;Next&lt;/button&gt;
		&lt;/div&gt;</example>
      <example>A pager with only a play/pause toggle button.
		&lt;div dojoType="dojox.layout.RotatorPager" rotatorId="myRotator"&gt;
			&lt;button dojoType="dijit.form.ToggleButton" dojoAttachPoint="playPause"&gt;&lt;/button&gt;
		&lt;/div&gt;</example>
      <example>A pager styled with iconClass.
		&lt;div dojoType="dojox.layout.RotatorPager" class="rotatorIcons" rotatorId="myRotator"&gt;
			&lt;button dojoType="dijit.form.Button" iconClass="previous" dojoAttachPoint="previous"&gt;Prev&lt;/button&gt;
			&lt;button dojoType="dijit.form.ToggleButton" iconClass="playPause" dojoAttachPoint="playPause"&gt;&lt;/button&gt;
			&lt;button dojoType="dijit.form.Button" iconClass="next" dojoAttachPoint="next"&gt;Next&lt;/button&gt;
			&lt;span dojoAttachPoint="current"&gt;&lt;/span&gt; / &lt;span dojoAttachPoint="total"&gt;&lt;/span&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="rotatorId" scope="prototype" type="int">
        <summary>The ID of the rotator this pager is tied to.
	Only required if defined outside of the RotatorContainer's container.</summary>
      </property>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="_subscriptions" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="destroy" scope="prototype">
        <summary>Unsubscribe to all of our topics</summary>
      </method>
      <method name="_state" scope="prototype">
        <summary>Updates the display of the play/pause button</summary>
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_update" scope="prototype">
        <summary>Updates the pager's play/pause button, current child, and total number of children.</summary>
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
          <parameter name="current" type="int" usage="required"/>
          <parameter name="total" type="int" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.RotatorPager.current" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.layout.RotatorPager.total" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.layout.ScrollPane" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <summary>A pane that &amp;quot;scrolls&amp;quot; its content based on the mouse poisition inside</summary>
    <description>A sizable container that takes it's content's natural size and creates
	a scroll effect based on the relative mouse position. It is an interesting
	way to display lists of data, or blocks of content, within a confined
	space.
	Horizontal scrolling is supported. Combination scrolling is not.
	FIXME: need to adust the _line somehow, it stops scrolling</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dojox.layout.ScrollPane" style="width:150px height:300px;"&gt;
			&lt;!-- any height content --&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="_line" scope="prototype" type="dojo._Line">
        <summary>storage for our top and bottom most scrollpoints</summary>
      </property>
      <property name="_lo" scope="prototype" type="the">
        <summary>height of the visible pane</summary>
      </property>
      <property name="_offset" scope="prototype" type="Number"/>
      <property name="orientation" scope="prototype" type="String">
        <summary>either &amp;quot;horizontal&amp;quot; or &amp;quot;vertical&amp;quot; for scroll orientation.</summary>
      </property>
      <property name="autoHide" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_dir" scope="prototype" type="String"/>
      <property name="_vertical" scope="prototype" type="bool"/>
      <property name="_size" scope="prototype" type="Object"/>
      <property name="_helpLine" scope="prototype" type="Object"/>
      <property name="_showAnim" scope="prototype" type="Object"/>
      <property name="_hideAnim" scope="prototype" type="Object"/>
      <property name="_edge" scope="prototype" type="String"/>
      <property name="_scroll" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="resize" scope="prototype">
        <summary>calculates required sizes. Call this if you add/remove content manually, or reload the content.</summary>
        <parameters>
          <parameter name="size" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_set" scope="prototype">
        <parameters>
          <parameter name="n" type="Float" usage="required"/>
        </parameters>
      </method>
      <method name="_calc" scope="prototype">
        <summary>calculate the relative offset of the cursor over the node, and call _set</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_enter" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_leave" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.ScrollPane.helper.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.TableContainer" type="Function" classlike="true" superclass="dijit.layout._LayoutWidget">
    <summary>A container that lays out its child widgets in a table layout.</summary>
    <description>The TableContainer lays out child widgets in a Table layout.
	Each widget can specify a "label" or a "title" parameter.
	This label is displayed either above or to the left of
	a widget depending on whether the "orientation" attribute
	is "horiz" or "vert", for horizontal and vertical respectively.
	The number of columns is configured using the "cols" attribute.
	The width of labels can be configured using the "labelWidth" parameter.</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout._LayoutWidget"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dojox.layout.TableContainer" orientation="vert" cols="3&gt;
			&lt;div dojoType="dijit.form.TextInput" value="John" label="First Name:"&gt;&lt;/div&gt;
			&lt;div dojoType="dijit.form.CheckBox" label="Is Student?:"&gt;&lt;/div&gt;
			&lt;div dojoType="dojox.form.DateTextBox" label="Date Of Birth:"&gt;&lt;/div&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="cols" scope="prototype" type="Number"/>
      <property name="labelWidth" scope="prototype" type="Number|String">
        <summary>Defines the width of a label.  If the value is a number, it is
	treated as a pixel value.  The other valid value is a percentage,
	e.g. &amp;quot;50%&amp;quot;</summary>
      </property>
      <property name="showLabels" scope="prototype" type="Boolean">
        <summary>True if labels should be displayed, false otherwise.</summary>
      </property>
      <property name="orientation" scope="prototype" type="String">
        <summary>Either &amp;quot;horiz&amp;quot; or &amp;quot;vert&amp;quot; for label orientation.</summary>
      </property>
      <property name="spacing" scope="prototype" type="Number">
        <summary>The cell spacing to apply to the table.</summary>
      </property>
      <property name="customClass" scope="prototype" type="String">
        <summary>A CSS class that will be applied to child elements.  For example, if
	the class is &amp;quot;myClass&amp;quot;, the table will have &amp;quot;myClass-table&amp;quot; applied to it,
	each label TD will have &amp;quot;myClass-labelCell&amp;quot; applied, and each
	widget TD will have &amp;quot;myClass-valueCell&amp;quot; applied.</summary>
      </property>
      <property name="_children" scope="prototype" type="Array"/>
      <property name="_initialized" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="resize" scope="prototype">
        <summary>Resizes all children.  This widget itself
	does not resize, as it takes up 100% of the
	available width.</summary>
      </method>
      <method name="layout" scope="prototype">
        <summary>Lays out the child widgets.</summary>
      </method>
      <method name="_setSpacingAttr" scope="prototype">
        <summary>Sets the spacing attribute.</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.TableContainer.table" type="">
    <properties>
      <property name="cellspacing" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.layout.ToggleSplitter" type="Function" classlike="true" superclass="dijit.layout._Splitter">
    <summary>A draggable and toggle-to-close/open spacer between two items in a BorderContainer</summary>
    <description>Extends the dijit.layout._Splitter to add a toggling behavior
	on double-click</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout._Splitter"/>
    </mixins>
    <properties>
      <property name="container" scope="prototype" type="Object"/>
      <property name="region" scope="prototype" type="Object"/>
      <property name="open" scope="prototype" type="Boolean">
        <summary>the initial and current state of the splitter (and its attached pane)</summary>
      </property>
      <property name="closedThreshold" scope="prototype" type="Integer">
        <summary>how small the attached pane can be before its considered closed</summary>
      </property>
      <property name="openSize" scope="prototype" type="String">
        <summary>the css height/width value to apply by default when the attached pane is open</summary>
      </property>
      <property name="_closedSize" scope="prototype" type="String">
        <summary>the css height/width value to apply by default when the attached pane is closed</summary>
      </property>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="_started" scope="prototype" type="Object"/>
      <property name="_openStyleProps" scope="prototype" type="Object"/>
      <property name="_startPosn" scope="prototype" type="Number"/>
      <property name="_onUpHandle" scope="prototype" type="Object"/>
      <property name="_onMoveHandle" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_onMouseUp" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onPrelimMouseMove" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onMouseDown" scope="prototype">
        <summary>handle mousedown events from the domNode</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_handleOnChange" scope="prototype"/>
      <method name="_getStyleProps" scope="prototype">
        <summary>create an object with the style property name: values
	that will need to be applied to the child pane render the given state</summary>
        <parameters>
          <parameter name="paneNode" type="" usage="required"/>
          <parameter name="open" type="" usage="required"/>
          <parameter name="paneStyle" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setStateClass" scope="prototype"/>
      <method name="_setOpenAttr" scope="prototype">
        <summary>setter for the open property</summary>
        <parameters>
          <parameter name="value" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="onOpen" scope="prototype"/>
      <method name="onClose" scope="prototype"/>
      <method name="_toggleMe" scope="prototype">
        <summary>event handle, toggle the open state</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.ToggleSplitter.child">
    <properties>
      <property name="domNode" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.layout.dnd">
    <properties>
      <property name="handdleIE" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method name="_setGcDndHandle" scope="normal">
        <parameters>
          <parameter name="service" type="" usage="required"/>
          <parameter name="withHandles" type="" usage="required"/>
          <parameter name="handleClasses" type="" usage="required"/>
          <parameter name="first" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.dnd.Avatar" type="Function" classlike="true" superclass="dojo.dnd.Avatar">
    <summary>An Object, which represents the object being moved in a GridContainer</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Avatar"/>
    </mixins>
    <properties>
      <property name="node" scope="prototype" type=""/>
      <property name="opacity" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="manager" type="" usage="required"/>
          <parameter name="opacity" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="manager" type="" usage="required"/>
          <parameter name="opacity" type="" usage="required"/>
        </parameters>
      </method>
      <method name="construct" scope="prototype">
        <summary>A constructor function. it is separate so it can be (dynamically)
	overwritten in case of need.</summary>
      </method>
      <method name="update" scope="prototype">
        <summary>Updates the avatar to reflect the current DnD state.</summary>
      </method>
      <method name="_generateText" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.layout.dnd.Avatar.manager" type="">
    <properties>
      <property name="source" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.layout.dnd.PlottedDnd" type="Function" classlike="true" superclass="dojo.dnd.Source">
    <summary>dnd source handling plotted zone to show the dropping area</summary>
    <mixins>
      <mixin scope="instance" location="dojo.dnd.Source"/>
    </mixins>
    <properties>
      <property name="GC_OFFSET_X" scope="normal" type=""/>
      <property name="GC_OFFSET_Y" scope="normal" type=""/>
      <property name="firstIndicator" scope="prototype" type="bool"/>
      <property name="dndNodes" scope="prototype" type=""/>
      <property name="selection" scope="prototype" type="Object"/>
      <property name="anchor" scope="prototype" type="Object"/>
      <property name="containerSource" scope="prototype" type="bool"/>
      <property name="targetAnchor" scope="prototype" type="Object"/>
      <property name="targetBox" scope="prototype" type="Object"/>
      <property name="before" scope="prototype" type="Object"/>
      <property name="_over" scope="instance-prototype" type="bool"/>
      <property name="dropObject" scope="prototype" type="Object"/>
      <property name="dom" scope="instance-prototype" type=""/>
      <property name="autoScrollActive" scope="prototype" type="bool"/>
      <property name="_timer" scope="instance-prototype" type="Object"/>
      <property name="childBoxes" scope="instance" type="Object"/>
      <property name="dropIndicator" scope="instance" type="Object"/>
      <property name="withHandles" scope="instance" type=""/>
      <property name="handleClasses" scope="instance" type=""/>
      <property name="opacity" scope="instance" type=""/>
      <property name="allowAutoScroll" scope="instance" type=""/>
      <property name="singular" scope="instance" type="Object"/>
      <property name="skipForm" scope="instance" type="Object"/>
      <property name="defaultHandleClass" scope="instance" type="String"/>
      <property name="isDropped" scope="instance" type="bool"/>
      <property name="isOffset" scope="instance" type=""/>
      <property name="hideSource" scope="instance" type=""/>
      <property name="_drop" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="params" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_calculateCoords" scope="prototype">
        <summary>Calculate each position of children</summary>
        <parameters>
          <parameter name="height" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_legalMouseDown" scope="prototype">
        <summary>Checks if user clicked on &amp;quot;approved&amp;quot; items.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="setDndItemSelectable" scope="prototype">
        <summary>set an item as selectable</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="isSelectable" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="getDraggedWidget" scope="prototype">
        <summary>Return one or more widget selected during the drag.</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="isAccepted" scope="prototype">
        <summary>test if this node can be accepted</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="onDndStart" scope="prototype">
        <summary>Called to initiate the DnD operation.</summary>
        <parameters>
          <parameter name="source" type="Object" usage="required"/>
          <parameter name="nodes" type="Array" usage="required"/>
          <parameter name="copy" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="onDndCancel" scope="prototype">
        <summary>Called to cancel the DnD operation.</summary>
      </method>
      <method name="onDndDrop" scope="prototype">
        <summary>Called to finish the DnD operation</summary>
        <parameters>
          <parameter name="source" type="" usage="required"/>
          <parameter name="nodes" type="" usage="required"/>
          <parameter name="copy" type="" usage="required"/>
          <parameter name="target" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <summary>Event processor for onmousedown.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <summary>Event processor for onmouseup.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <summary>Event processor for onmousemove</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_markTargetAnchor" scope="prototype">
        <summary>Assigns a class to the current target anchor based on &amp;quot;before&amp;quot; status</summary>
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_unmarkTargetAnchor" scope="prototype">
        <summary>Removes a class of the current target anchor based on &amp;quot;before&amp;quot; status.</summary>
      </method>
      <method name="setIndicatorPosition" scope="prototype">
        <summary>set the position of the drop indicator</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onOverEvent" scope="prototype"/>
      <method name="onOutEvent" scope="prototype"/>
      <method name="deleteDashedZone" scope="prototype">
        <summary>hide the dashed zone</summary>
      </method>
      <method name="insertDashedZone" scope="prototype">
        <summary>Insert the dashed zone at the right place</summary>
        <parameters>
          <parameter name="before" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="insertNodes" scope="prototype">
        <summary>Inserts new data items (see Dojo Container's insertNodes method for details).</summary>
        <parameters>
          <parameter name="addSelected" type="Boolean" usage="required"/>
          <parameter name="data" type="Array" usage="required"/>
          <parameter name="before" type="Boolean" usage="required"/>
          <parameter name="anchor" type="Node" usage="required"/>
        </parameters>
      </method>
      <method name="_checkAutoScroll" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollUp" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_autoScrollDown" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_stopAutoScroll" scope="prototype"/>
      <method name="_sumAncestorProperties" scope="prototype">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="prop" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="integer"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.layout.dnd.PlottedDnd._drop.style" type="">
    <properties>
      <property name="height" scope="prototype" type="String"/>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.layout.dnd.PlottedDnd.current" type="">
    <properties>
      <property name="coords" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.layout.dnd.PlottedDnd.offsetDrag">
    <properties>
      <property name="x" scope="prototype" type="Number"/>
      <property name="y" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.layout.dnd.DropIndicator" type="Function" classlike="true">
    <summary>An empty widget to show at the user the drop zone of the widget.</summary>
    <properties>
      <property name="node" scope="prototype" type="Object"/>
      <property name="tag" scope="instance" type="String"/>
      <property name="style" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="cn" type="String" usage="required"/>
          <parameter name="tag" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="cn" type="String" usage="required"/>
          <parameter name="tag" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="isInserted" scope="prototype"/>
      <method name="create" scope="prototype"/>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="document.body" type="">
    <methods>
      <method name="onselectstart" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.layout.ext-dijit.layout">
    <properties>
      <property name="StackContainer-touch" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.layout.ext-dijit"/>
  <object location="dojox.math.BigInteger.prototype" type="">
    <properties>
      <property name="_chunkSize" scope="normal" type=""/>
      <property name="_toRadix" scope="normal" type=""/>
      <property name="_fromRadix" scope="normal" type=""/>
      <property name="_fromNumber" scope="normal" type=""/>
      <property name="_bitwiseTo" scope="normal" type=""/>
      <property name="_changeBit" scope="normal" type=""/>
      <property name="_addTo" scope="normal" type=""/>
      <property name="_dMultiply" scope="normal" type=""/>
      <property name="_dAddOffset" scope="normal" type=""/>
      <property name="_multiplyLowerTo" scope="normal" type=""/>
      <property name="_multiplyUpperTo" scope="normal" type=""/>
      <property name="_modInt" scope="normal" type=""/>
      <property name="_millerRabin" scope="normal" type=""/>
      <property name="clone" scope="normal" type=""/>
      <property name="intValue" scope="normal" type=""/>
      <property name="byteValue" scope="normal" type=""/>
      <property name="shortValue" scope="normal" type=""/>
      <property name="signum" scope="normal" type=""/>
      <property name="toByteArray" scope="normal" type=""/>
      <property name="equals" scope="normal" type=""/>
      <property name="min" scope="normal" type=""/>
      <property name="max" scope="normal" type=""/>
      <property name="and" scope="normal" type=""/>
      <property name="or" scope="normal" type=""/>
      <property name="xor" scope="normal" type=""/>
      <property name="andNot" scope="normal" type=""/>
      <property name="not" scope="normal" type=""/>
      <property name="shiftLeft" scope="normal" type=""/>
      <property name="shiftRight" scope="normal" type=""/>
      <property name="getLowestSetBit" scope="normal" type=""/>
      <property name="bitCount" scope="normal" type=""/>
      <property name="testBit" scope="normal" type=""/>
      <property name="setBit" scope="normal" type=""/>
      <property name="clearBit" scope="normal" type=""/>
      <property name="flipBit" scope="normal" type=""/>
      <property name="add" scope="normal" type=""/>
      <property name="subtract" scope="normal" type=""/>
      <property name="multiply" scope="normal" type=""/>
      <property name="divide" scope="normal" type=""/>
      <property name="remainder" scope="normal" type=""/>
      <property name="divideAndRemainder" scope="normal" type=""/>
      <property name="modPow" scope="normal" type=""/>
      <property name="modInverse" scope="normal" type=""/>
      <property name="pow" scope="normal" type=""/>
      <property name="gcd" scope="normal" type=""/>
      <property name="isProbablePrime" scope="normal" type=""/>
    </properties>
  </object>
  <object location="NullExp" type="">
    <properties>
      <property name="convert" scope="normal" type=""/>
      <property name="revert" scope="normal" type=""/>
      <property name="mulTo" scope="normal" type=""/>
      <property name="sqrTo" scope="normal" type=""/>
    </properties>
  </object>
  <object location="Barrett" type="">
    <properties>
      <property name="convert" scope="normal" type=""/>
      <property name="revert" scope="normal" type=""/>
      <property name="reduce" scope="normal" type=""/>
      <property name="mulTo" scope="normal" type=""/>
      <property name="sqrTo" scope="normal" type=""/>
    </properties>
  </object>
  <object location="Classic.prototype" type="">
    <properties>
      <property name="convert" scope="normal" type=""/>
      <property name="revert" scope="normal" type=""/>
      <property name="reduce" scope="normal" type=""/>
      <property name="mulTo" scope="normal" type=""/>
      <property name="sqrTo" scope="normal" type=""/>
    </properties>
  </object>
  <object location="Montgomery.prototype" type="">
    <properties>
      <property name="convert" scope="normal" type=""/>
      <property name="revert" scope="normal" type=""/>
      <property name="reduce" scope="normal" type=""/>
      <property name="mulTo" scope="normal" type=""/>
      <property name="sqrTo" scope="normal" type=""/>
    </properties>
  </object>
  <object location="BigInteger.prototype" type="">
    <properties>
      <property name="_DB" scope="normal" type=""/>
      <property name="_copyTo" scope="normal" type=""/>
      <property name="_fromInt" scope="normal" type=""/>
      <property name="_fromString" scope="normal" type=""/>
      <property name="_clamp" scope="normal" type=""/>
      <property name="_dlShiftTo" scope="normal" type=""/>
      <property name="_drShiftTo" scope="normal" type=""/>
      <property name="_lShiftTo" scope="normal" type=""/>
      <property name="_rShiftTo" scope="normal" type=""/>
      <property name="_subTo" scope="normal" type=""/>
      <property name="_multiplyTo" scope="normal" type=""/>
      <property name="_squareTo" scope="normal" type=""/>
      <property name="_divRemTo" scope="normal" type=""/>
      <property name="_invDigit" scope="normal" type=""/>
      <property name="_isEven" scope="normal" type=""/>
      <property name="_exp" scope="normal" type=""/>
      <property name="toString" scope="normal" type=""/>
      <property name="negate" scope="normal" type=""/>
      <property name="abs" scope="normal" type=""/>
      <property name="compareTo" scope="normal" type=""/>
      <property name="bitLength" scope="normal" type=""/>
      <property name="mod" scope="normal" type=""/>
      <property name="modPowInt" scope="normal" type=""/>
    </properties>
  </object>
  <object location="BigInteger" type="Function" classlike="true">
    <properties>
      <property name="_DM" scope="prototype" type="Number"/>
      <property name="_DV" scope="prototype" type="bool"/>
      <property name="_FV" scope="prototype" type="Object"/>
      <property name="_F1" scope="prototype" type="Number"/>
      <property name="_F2" scope="prototype" type="Number"/>
      <property name="am" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.math.curves">
    <methods>
      <method name="Arc" scope="normal">
        <parameters>
          <parameter name="start" type="" usage="required"/>
          <parameter name="end" type="" usage="required"/>
          <parameter name="ccw" type="" usage="required"/>
        </parameters>
      </method>
      <method name="Circle" scope="normal">
        <parameters>
          <parameter name="center" type="" usage="required"/>
          <parameter name="radius" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.math.curves.Line" type="Function" classlike="true">
    <properties>
      <property name="start" scope="instance" type=""/>
      <property name="end" scope="instance" type=""/>
      <property name="dimensions" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="start" type="" usage="required"/>
          <parameter name="end" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.math.curves.Bezier" type="Function" classlike="true">
    <properties>
      <property name="p" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="pnts" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="step" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.math.curves.CatmullRom" type="Function" classlike="true">
    <properties>
      <property name="c" scope="instance" type="Number"/>
      <property name="p" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="pnts" type="" usage="required"/>
          <parameter name="c" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="step" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.math.curves.CenteredArc" type="Function" classlike="true">
    <properties>
      <property name="center" scope="instance" type=""/>
      <property name="radius" scope="instance" type=""/>
      <property name="start" scope="instance" type="Number"/>
      <property name="end" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="center" type="" usage="required"/>
          <parameter name="radius" type="" usage="required"/>
          <parameter name="start" type="" usage="required"/>
          <parameter name="end" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.math.curves.Path" type="Function" classlike="true">
    <methods>
      <method constructor="constructor"/>
      <method name="add" scope="instance">
        <parameters>
          <parameter name="curve" type="" usage="required"/>
          <parameter name="weight" type="" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="instance">
        <parameters>
          <parameter name="curve" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeAll" scope="instance"/>
      <method name="getValue" scope="instance">
        <parameters>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.math.matrix">
    <properties>
      <property name="iDF" scope="normal" type="Number"/>
      <property name="ALMOST_ZERO" scope="normal" type="Number"/>
    </properties>
    <methods>
      <method name="multiply" scope="normal">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="b" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="product" scope="normal">
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="sum" scope="normal">
        <return-types>
          <return-type type="Number"/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="inverse" scope="normal">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="determinant" scope="normal">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="create" scope="normal">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
          <parameter name="value" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="ones" scope="normal">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="zeros" scope="normal">
        <parameters>
          <parameter name="a" type="Number" usage="required"/>
          <parameter name="b" type="Number" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="identity" scope="normal">
        <parameters>
          <parameter name="size" type="Number" usage="required"/>
          <parameter name="scale" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="adjoint" scope="normal">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="transpose" scope="normal">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="format" scope="normal">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="points" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="copy" scope="normal">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="scale" scope="normal">
        <parameters>
          <parameter name="a" type="Array" usage="required"/>
          <parameter name="factor" type="Number" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.math.matrix.upperTriangle" type="Function" classlike="true">
    <properties>
      <property name="iDF" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="m" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.math.random.Secure" type="Function" classlike="true">
    <summary>Super simple implementation of a random number generator,
	which relies on Math.random().</summary>
    <properties>
      <property name="state" scope="prototype" type="Object"/>
      <property name="pool" scope="instance-prototype" type="Object"/>
      <property name="pptr" scope="instance-prototype" type="Number"/>
      <property name="prng" scope="instance" type="Function:">
        <summary>function that returns an instance of PRNG (pseudorandom number generator)
	with two methods: init(array) and next(). It should have a property &amp;quot;size&amp;quot;
	to indicate the required pool size.
	noEvents: Boolean?:
	if false or absent, onclick and onkeypress event will be used to add
	&amp;quot;randomness&amp;quot;, otherwise events will not be used.</summary>
      </property>
      <property name="h" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="prng" type="Function:" usage="required">
            <summary>function that returns an instance of PRNG (pseudorandom number generator)
	with two methods: init(array) and next(). It should have a property &amp;quot;size&amp;quot;
	to indicate the required pool size.</summary>
          </parameter>
          <parameter name="noEvents" type="Boolean:" usage="optional">
            <summary>if false or absent, onclick and onkeypress event will be used to add
	&amp;quot;randomness&amp;quot;, otherwise events will not be used.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Intializes an instance of a secure random generator.</summary>
        <parameters>
          <parameter name="prng" type="Function:" usage="required">
            <summary>function that returns an instance of PRNG (pseudorandom number generator)
	with two methods: init(array) and next(). It should have a property &amp;quot;size&amp;quot;
	to indicate the required pool size.</summary>
          </parameter>
          <parameter name="noEvents" type="Boolean:" usage="optional">
            <summary>if false or absent, onclick and onkeypress event will be used to add
	&amp;quot;randomness&amp;quot;, otherwise events will not be used.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Disconnects events, if any, preparing the object for GC.</summary>
      </method>
      <method name="nextBytes" scope="prototype">
        <summary>Fills in an array of bytes with random numbers</summary>
        <parameters>
          <parameter name="byteArray" type="Array" usage="required">
            <summary>Array: array to be filled in with random numbers, only existing
	elements will be filled.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="seedTime" scope="prototype">
        <summary>Mix in the current time (w/milliseconds) into the pool</summary>
      </method>
      <method name="_seed_int" scope="prototype">
        <summary>Mix in a 32-bit integer into the pool</summary>
        <parameters>
          <parameter name="x" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="Arcfour" type="Function" classlike="true">
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="Arcfour.init" type="Function" classlike="true">
    <summary>Initialize arcfour context</summary>
    <properties>
      <property name="S" scope="instance" type=""/>
      <property name="i" scope="instance" type="Number"/>
      <property name="j" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="key" type="Array:" usage="required">
            <summary>an array of ints, each from [0..255]</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="Arcfour.next" type="Function" classlike="true">
    <properties>
      <property name="S" scope="instance" type=""/>
      <property name="i" scope="instance" type="bool"/>
      <property name="j" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.math.stats" type="">
    <methods>
      <method name="sd" scope="normal">
        <summary>Returns the standard deviation of the passed arguments.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="variance" scope="normal">
        <summary>Find the variance in the passed array of numbers.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="bestFit" scope="normal">
        <summary>Calculate the slope and intercept in a linear fashion.  An array
	of objects is expected; optionally you can pass in the property
	names for &amp;quot;x&amp;quot; and &amp;quot;y&amp;quot;, else x/y is used as the default.  If you
	pass an array of numbers, it will be mapped to a set of {x,y} objects
	where x = the array index.</summary>
        <parameters>
          <parameter name="a" type="Object[]" usage="required">
            <summary>|| Number[]</summary>
          </parameter>
          <parameter name="xProp" type="String" usage="optional"/>
          <parameter name="yProp" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="forecast" scope="normal">
        <summary>Using the bestFit algorithm above, find y for the given x.</summary>
        <parameters>
          <parameter name="a" type="Object[]" usage="required">
            <summary>|| Number[]</summary>
          </parameter>
          <parameter name="x" type="Number" usage="required"/>
          <parameter name="xProp" type="String" usage="optional"/>
          <parameter name="yProp" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="mean" scope="normal">
        <summary>Returns the mean value in the passed array.
	If type is passed, it will return the result of one of the given mean formulae.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
          <parameter name="type" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="geometricMean" scope="normal">
        <summary>Returns the geometric mean of the numbers in the passed array.
	Will through an error if any number in the array is negative.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="harmonicMean" scope="normal">
        <summary>Returns the harmonic mean of the numbers in the passed array.
	Will throw an error if any member &amp;lt;= 0.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="rms" scope="normal">
        <summary>Returns the root-mean-square (RMS) value of the given array of numbers.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
      </method>
      <method name="min" scope="normal">
        <summary>Returns the min value in the passed array.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="max" scope="normal">
        <summary>Returns the max value in the passed array.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="median" scope="normal">
        <summary>Returns the value closest to the middle from a sorted version of the passed array.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="mode" scope="normal">
        <summary>Returns the mode from the passed array (number that appears the most often).
	This is not the most efficient method, since it requires a double scan, but
	is ensures accuracy.</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="sum" scope="normal">
        <summary>Return the sum of all the numbers in the passed array.  Does
	not check to make sure values within a are NaN (should simply
	return NaN).</summary>
        <parameters>
          <parameter name="a" type="Number[]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="approxLin" scope="normal">
        <summary>Returns a linearly approximated value from an array using
	a normalized float position value.</summary>
        <return-description>Number</return-description>
        <parameters>
          <parameter name="a" type="Number[]:" usage="required">
            <summary>a sorted numeric array to be used for the approximation.</summary>
          </parameter>
          <parameter name="pos" type="Number:" usage="required">
            <summary>a position number from 0 to 1. If outside of this range it
	will be clamped.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Number"/>
        </return-types>
      </method>
      <method name="summary" scope="normal">
        <summary>Returns a non-parametric collection of summary statistics:
	the classic five-number summary extended to the Bowley's
	seven-figure summary.</summary>
        <return-description>Object</return-description>
        <parameters>
          <parameter name="a" type="Number[]:" usage="required">
            <summary>a numeric array to be appraised.</summary>
          </parameter>
          <parameter name="alreadySorted" type="Boolean:" usage="optional">
            <summary>a Boolean flag to indicated that the array is already sorted.
	This is an optional flag purely to improve the performance.
	If skipped, the array will be assumed unsorted.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="sort it properly"/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.validate">
    <summary>Additional input validation methods</summary>
    <properties>
      <property name="creditCard" scope="normal" type="Object">
        <summary>Module provides validation functions for Credit Cards, using account number
	rules in conjunction with the Luhn algorigthm, with a plugable card info database.</summary>
      </property>
      <property name="_isInRangeCache" scope="normal" type="Object"/>
      <property name="_base" scope="normal" type="Object"/>
      <property name="isbn" scope="normal" type="Object"/>
      <property name="isEmailAddressList" scope="normal" type=""/>
      <property name="web" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="isText" scope="normal">
        <summary>Checks if a string has non whitespace characters.
	Parameters allow you to constrain the length.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>A string</summary>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <summary>length: Number, minlength: Number, maxlength: Number}
	flags.length  If set, checks if there are exactly flags.length number of characters.
	flags.minlength  If set, checks if there are at least flags.minlength number of characters.
	flags.maxlength  If set, checks if there are at most flags.maxlength number of characters.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isInRange" scope="normal">
        <summary>Validates whether a string denoting a number
	is between a max and min.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>A string</summary>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <summary>max:Number, min:Number, decimal:String}
	flags.max  A number, which the value must be less than or equal to for the validation to be true.
	flags.min  A number, which the value must be greater than or equal to for the validation to be true.
	flags.decimal  The character used for the decimal point.  Default is &amp;quot;.&amp;quot;.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isNumberFormat" scope="normal">
        <summary>Validates any sort of number based format</summary>
        <description>Validates any sort of number based format. Use it for phone numbers,
	social security numbers, zip-codes, etc. The value can be validated
	against one format or one of multiple formats.
	Format Definition
		 #        Stands for a digit, 0-9.
		 ?        Stands for an optional digit, 0-9 or nothing.
	All other characters must appear literally in the expression.</description>
        <examples>
          <example>  "(###) ###-####"       -&gt;   (510) 542-9742
		"(###) ###-#### x#???" -&gt;   (510) 542-9742 x153
		"###-##-####"          -&gt;   506-82-1089       i.e. social security number
		"#####-####"           -&gt;   98225-1649        i.e. zip code</example>
          <example> // returns true:
	 dojox.validate.isNumberFormat("123-45", { format:"###-##" });</example>
          <example>Check Multiple formats:
		dojox.validate.isNumberFormat("123-45", {
			format:["### ##","###-##","## ###"]
		});</example>
        </examples>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>A string</summary>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <summary>FIXME: make pseudo-object for this
	format: String
	flags.format  A string or an Array of strings for multiple formats.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidLuhn" scope="normal">
        <summary>Validate a String value against the Luhn algorithm.</summary>
        <description>Validate a String value against the Luhn algorithm to verify
	its integrity.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="check" scope="normal">
        <summary>validates user input of an HTML form based on input profile</summary>
        <description>returns an object that contains several methods summarizing the results of the validation</description>
        <parameters>
          <parameter name="form" type="HTMLFormElement" usage="required">
            <summary>form to be validated</summary>
          </parameter>
          <parameter name="profile" type="Object" usage="required">
            <summary>specifies how the form fields are to be validated
	{trim:Array, uppercase:Array, lowercase:Array, ucfirst:Array, digit:Array,
	required:Array, dependencies:Object, constraints:Object, confirm:Object}</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="evaluateConstraint" scope="normal">
        <summary>Evaluates dojo.validate.check() constraints that are specified as array
	arguments</summary>
        <description>The arrays are expected to be in the format of:
	constraints:{</description>
        <parameters>
          <parameter name="profile" type="The" usage="required">
            <summary>dojo.validate.check() profile that this evaluation is against.</summary>
          </parameter>
          <parameter name="constraint" type="Array" usage="required">
            <summary>The single [] array of function and arguments for the function.</summary>
          </parameter>
          <parameter name="fieldName" type="The" usage="required">
            <summary>form dom name of the field being validated.</summary>
          </parameter>
          <parameter name="elem" type="The" usage="required">
            <summary>form element field.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidCreditCard" scope="normal">
        <summary>Validate a credit card number by type with Luhn checking.</summary>
        <description>Checks if a credit card type matches the # scheme in a passed value, and if
	the Luhn checksum is accurate (unless its an Enroute card, in which case
	the checkSum is skipped), returning a Boolean to check against.</description>
        <examples>
          <example>	if(dojox.validate.isValidCreditCard("12345", "mc")){
			console.log('inconceivable');
		}</example>
        </examples>
        <parameters>
          <parameter name="value" type="String|Int" usage="required">
            <summary>A Value (credit card number) to validate</summary>
          </parameter>
          <parameter name="ccType" type="String" usage="required">
            <summary>A credit-card abbreviation.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isValidCreditCardNumber" scope="normal">
        <summary>Checks if value matches the pattern for that card or any card types if none is specified</summary>
        <parameters>
          <parameter name="value" type="String|Int" usage="required">
            <summary>CC #, white spaces and dashes are ignored</summary>
          </parameter>
          <parameter name="ccType" type="String" usage="optional">
            <summary>One of the abbreviation values in &lt;code&gt;dojox.validate._cardInfo&lt;/code&gt; --
	if Omitted, function returns a &lt;code&gt;|&lt;/code&gt; delimited string of matching card types,
	or false if no matches found.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isValidCvv" scope="normal">
        <summary>Validate the security code (CCV) for a passed credit-card type.</summary>
        <parameters>
          <parameter name="value" type="String|Int" usage="required"/>
          <parameter name="ccType" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isValidIsbn" scope="normal">
        <summary>Validate ISBN-10 or ISBN-13 based on the length of value</summary>
        <return-description>Boolean</return-description>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>An ISBN to validate</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isIpAddress" scope="normal">
        <summary>Validates an IP address</summary>
        <description>Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	Supports 2 formats for Ipv6.
	value  A string.
	flags  An object.  All flags are boolean with default = true.
	flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	Case insensitive.  Zero padding allowed.
	flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isUrl" scope="normal">
        <summary>Checks if a string could be a valid URL</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>A string</summary>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <summary>An object
	flags.scheme  Can be true, false, or [true, false].
	This means: required, not allowed, or either.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isEmailAddress" scope="normal">
        <summary>Checks if a string could be a valid email address</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>A string</summary>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <summary>An object
	flags.allowCruft  Allow address like &amp;lt;mailto:foo@yahoo.com&amp;gt;.  Default is false.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.
	flags in regexp.tld can be applied.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getEmailAddressList" scope="normal">
        <summary>Check if value is an email address list. If an empty list
	is returned, the value didn't pass the test or it was empty.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>A string</summary>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <summary>An object (same as dojo.validate.isEmailAddressList)</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.robot">
    <summary>TODOC</summary>
    <properties>
      <property name="recorder" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.rpc.Client">
    <properties>
      <property name="clientId" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.rpc.JsonRest">
    <properties>
      <property name="serviceClass" scope="normal" type=""/>
      <property name="conflictDateHeader" scope="normal" type="String"/>
      <property name="services" scope="normal" type="Object"/>
      <property name="schemas" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="commit" scope="normal">
        <summary>Saves the dirty data using REST Ajax methods</summary>
        <parameters>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getDirtyObjects" scope="normal"/>
      <method name="revert" scope="normal">
        <summary>Reverts all the changes made to JSON/REST data</summary>
        <parameters>
          <parameter name="service" type="" usage="required"/>
        </parameters>
      </method>
      <method name="changing" scope="normal">
        <summary>adds an object to the list of dirty objects.  This object
	contains a reference to the object itself as well as a
	cloned and trimmed version of old object for use with
	revert.</summary>
        <parameters>
          <parameter name="object" type="" usage="required"/>
          <parameter name="_deleting" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deleteObject" scope="normal">
        <summary>deletes an object</summary>
        <parameters>
          <parameter name="object" type="object" usage="required">
            <summary>to delete</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getConstructor" scope="normal">
        <summary>Creates or gets a constructor for objects from this service</summary>
        <parameters>
          <parameter name="service" type="Function|String" usage="required"/>
          <parameter name="schema" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="normal">
        <summary>Fetches a resource by an absolute path/id and returns a dojo.Deferred.</summary>
        <parameters>
          <parameter name="absoluteId" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getIdAttribute" scope="normal">
        <summary>Return the ids attribute used by this service (based on it's schema).
	Defaults to &amp;quot;id&amp;quot;, if not other id is defined</summary>
        <parameters>
          <parameter name="service" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getServiceAndId" scope="normal">
        <summary>Returns the REST service and the local id for the given absolute id. The result
	is returned as an object with a service property and an id property</summary>
        <parameters>
          <parameter name="absoluteId" type="String" usage="required">
            <summary>This is the absolute id of the object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="registerService" scope="normal">
        <summary>Registers a service for as a JsonRest service, mapping it to a path and schema</summary>
        <parameters>
          <parameter name="service" type="Function" usage="required">
            <summary>This is the service to register</summary>
          </parameter>
          <parameter name="servicePath" type="String" usage="required">
            <summary>This is the path that is used for all the ids for the objects returned by service</summary>
          </parameter>
          <parameter name="schema" type="Object" usage="optional">
            <summary>This is a JSON Schema object to associate with objects returned by this service</summary>
          </parameter>
        </parameters>
      </method>
      <method name="byId" scope="normal">
        <parameters>
          <parameter name="service" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="query" scope="normal">
        <parameters>
          <parameter name="service" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_loader" scope="normal">
        <parameters>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isDirty" scope="normal">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.rpc.JsonRest.sendToServer" type="Function" classlike="true">
    <properties>
      <property name="conflictDateHeader" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="actions" type="" usage="required"/>
          <parameter name="kwArgs" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.rpc.OfflineRest">
    <properties>
      <property name="sync" scope="normal" type=""/>
      <property name="sendChanges" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="turnOffAutoSync" scope="normal"/>
      <method name="downloadChanges" scope="normal"/>
      <method name="addStore" scope="normal">
        <summary>Adds a store to the monitored store for local storage</summary>
        <parameters>
          <parameter name="store" type="data-store" usage="required">
            <summary>Store to add</summary>
          </parameter>
          <parameter name="baseQuery" type="query" usage="optional">
            <summary>This is the base query to should be used to load the items for
	the store. Generally you want to load all the items that should be
	available when offline.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.rpc.Service" type="Function" classlike="true">
    <summary>Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
	as a definition for the service</summary>
    <description>dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
	dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
	a "No match found" error.</description>
    <properties>
      <property name="_smd" scope="prototype" type=""/>
      <property name="_options" scope="instance" type="Object"/>
      <property name="_requestId" scope="instance" type="Number"/>
      <property name="_nextId" scope="normal" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="smd" type="object" usage="required">
            <summary>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</summary>
          </parameter>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Take a string as a url to retrieve an smd or an object that is an smd or partial smd to use
	as a definition for the service</summary>
        <description>dojox.rpc.Service must be loaded prior to any plugin services like dojox.rpc.Rest
	dojox.rpc.JsonRpc in order for them to register themselves, otherwise you get
	a "No match found" error.</description>
        <parameters>
          <parameter name="smd" type="object" usage="required">
            <summary>Takes a number of properties as kwArgs for defining the service.  It also
	accepts a string.  When passed a string, it is treated as a url from
	which it should synchronously retrieve an smd file.  Otherwise it is a kwArgs
	object.  It accepts serviceUrl, to manually define a url for the rpc service
	allowing the rpc system to be used without an smd definition. strictArgChecks
	forces the system to verify that the # of arguments provided in a call
	matches those defined in the smd.  smdString allows a developer to pass
	a jsonString directly, which will be converted into an object or alternatively
	smdObject is accepts an smdObject directly.</summary>
          </parameter>
          <parameter name="options" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_generateService" scope="prototype">
        <parameters>
          <parameter name="serviceName" type="" usage="required"/>
          <parameter name="method" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getRequest" scope="prototype">
        <parameters>
          <parameter name="method" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_executeMethod" scope="prototype">
        <parameters>
          <parameter name="method" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.secure">
    <summary>TODOC</summary>
    <properties>
      <property name="badProps" scope="normal" type="RegExp"/>
    </properties>
    <methods>
      <method name="DOM" scope="normal">
        <parameters>
          <parameter name="element" type="" usage="required"/>
        </parameters>
      </method>
      <method name="unwrap" scope="normal">
        <parameters>
          <parameter name="result" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sandbox" scope="normal">
        <summary>Creates a secure sandbox from which scripts and HTML can be loaded that
	will only be able to access the provided element and it's descendants, the
	rest of the DOM and JS environment will not be accessible to the sandboxed
	scripts and HTML.</summary>
        <description>This function will create and return a sandbox object (see dojox.secure.__Sandbox)
	for the provided element.</description>
        <parameters>
          <parameter name="element" type="The" usage="required">
            <summary>DOM element to use as the container for the sandbox</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dojox.secure.__Sandbox"/>
        </return-types>
      </method>
      <method name="_safeDojoFunctions" scope="normal">
        <parameters>
          <parameter name="element" type="" usage="required"/>
          <parameter name="wrap" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="wrap the NodeList"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="wrap" type="">
    <properties>
      <property name="safeHTML" scope="normal" type=""/>
      <property name="safeCSS" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.secure.capability">
    <properties>
      <property name="keywords" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.secure.capability.validate" type="Function" classlike="true">
    <summary>pass in the text of a script. If it passes and it can be eval'ed, it should be safe.
	Note that this does not do full syntax checking, it relies on eval to reject invalid scripts.
	There are also known false rejections:
	Nesting vars inside blocks will not declare the variable for the outer block
	Named functions are not treated as declaration so they are generally not allowed unless the name is declared with a var.
	Var declaration that involve multiple comma delimited variable assignments are not accepted</summary>
    <properties>
      <property name="keywords" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="script" type="string" usage="required">
            <summary>the script to execute</summary>
          </parameter>
          <parameter name="safeLibraries" type="Array" usage="required">
            <summary>The safe libraries that can be called (the functions can not be access/modified by the untrusted code, only called)</summary>
          </parameter>
          <parameter name="safeGlobals" type="Object" usage="required">
            <summary>These globals can be freely interacted with by the untrusted code</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="comments are replaced with a space, strings and regex are replaced with a single safe token (0)"/>
          <return-type type="replace literal keys with 0: and replace properties with the innocuous ~"/>
          <return-type type="turn into a known safe call"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch">
    <summary>TODOC</summary>
    <properties>
      <property name="tools" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="registerTool" scope="normal">
        <parameters>
          <parameter name="type" type="" usage="required"/>
          <parameter name="fn" type="" usage="required"/>
        </parameters>
      </method>
      <method name="makeToolbar" scope="normal">
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="figure" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Anchor" type="Function" classlike="true">
    <properties>
      <property name="annotation" scope="instance" type=""/>
      <property name="id" scope="instance" type=""/>
      <property name="_key" scope="instance" type="String"/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="isControl" scope="instance" type=""/>
      <property name="count" scope="normal" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="an" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
          <parameter name="isControl" type="" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="instance"/>
      <method name="beginEdit" scope="instance"/>
      <method name="endEdit" scope="instance"/>
      <method name="zoom" scope="instance">
        <parameters>
          <parameter name="pct" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setBinding" scope="instance">
        <parameters>
          <parameter name="pt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setUndo" scope="instance"/>
      <method name="enable" scope="instance"/>
      <method name="disable" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.sketch.AnnotationTool" type="Function" classlike="true" superclass="dojox.sketch._Plugin">
    <mixins>
      <mixin scope="instance" location="dojox.sketch._Plugin"/>
    </mixins>
    <properties>
      <property name="_omd" scope="prototype" type="bool"/>
      <property name="_cshape" scope="prototype" type="Object"/>
      <property name="figure" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onMouseDown" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
          <parameter name="rect" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_create" scope="prototype">
        <parameters>
          <parameter name="start" type="" usage="required"/>
          <parameter name="end" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Annotation" type="Function" classlike="true">
    <properties>
      <property name="id" scope="instance" type=""/>
      <property name="_key" scope="instance" type=""/>
      <property name="figure" scope="instance" type=""/>
      <property name="mode" scope="instance" type=""/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="boundingBox" scope="instance" type="Object"/>
      <property name="hasAnchors" scope="instance" type="Object"/>
      <property name="anchors" scope="instance" type="Object"/>
      <property name="_properties" scope="instance" type="Object"/>
      <property name="constructor" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="figure" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="normal"/>
      <method name="getType" scope="normal"/>
      <method name="onRemove" scope="normal">
        <parameters>
          <parameter name="noundo" type="" usage="required"/>
        </parameters>
      </method>
      <method name="property" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="value" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="onPropertyChange" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="oldvalue" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCreate" scope="normal"/>
      <method name="onDblClick" scope="normal">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="initialize" scope="normal"/>
      <method name="destroy" scope="normal"/>
      <method name="draw" scope="normal"/>
      <method name="apply" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="normal"/>
      <method name="getBBox" scope="normal"/>
      <method name="setBinding" scope="normal">
        <parameters>
          <parameter name="pt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getTextBox" scope="normal">
        <parameters>
          <parameter name="zoomfactor" type="" usage="required"/>
        </parameters>
      </method>
      <method name="zoom" scope="normal">
        <parameters>
          <parameter name="pct" type="" usage="required"/>
        </parameters>
      </method>
      <method name="writeCommonAttrs" scope="normal"/>
      <method name="register" scope="normal">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="toolclass" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Annotation.beginEdit" type="Function" classlike="true">
    <properties>
      <property name="_type" scope="instance" type="Object"/>
      <property name="_prevState" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Annotation.endEdit" type="Function" classlike="true">
    <properties>
      <property name="_type" scope="instance" type="String"/>
      <property name="_prevState" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.Annotation.calculate">
    <methods>
      <method name="slope" scope="normal">
        <parameters>
          <parameter name="p1" type="" usage="required"/>
          <parameter name="p2" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dx" scope="normal">
        <parameters>
          <parameter name="p1" type="" usage="required"/>
          <parameter name="p2" type="" usage="required"/>
          <parameter name="dy" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dy" scope="normal">
        <parameters>
          <parameter name="p1" type="" usage="required"/>
          <parameter name="p2" type="" usage="required"/>
          <parameter name="dx" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Annotation.drawBBox" type="Function" classlike="true">
    <properties>
      <property name="boundingBox" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.Annotation.setMode" type="Function" classlike="true">
    <properties>
      <property name="mode" scope="instance" type=""/>
      <property name="boundingBox" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="m" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Annotation.readCommonAttrs" type="Function" classlike="true">
    <properties>
      <property name="_properties" scope="instance" type="Object"/>
      <property name="data" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Annotation.readCommonAttrs.transform" type="">
    <properties>
      <property name="dx" scope="instance" type="Object"/>
      <property name="dy" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.Annotation.Modes">
    <properties>
      <property name="View" scope="normal" type="Number"/>
      <property name="Edit" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation" type="Function" classlike="true">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textYOffset" scope="instance" type="Number"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="startRotation" scope="instance" type="Number"/>
      <property name="endRotation" scope="instance" type="Number"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="constructor" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="figure" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="normal"/>
      <method name="getType" scope="normal"/>
      <method name="getBBox" scope="normal"/>
      <method name="serialize" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.anchors" type="">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation._rot" type="Function" classlike="true" private="true">
    <properties>
      <property name="startRotation" scope="instance" type="Object"/>
      <property name="endRotation" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation._pos" type="Function" classlike="true" private="true">
    <properties>
      <property name="textOffset" scope="instance" type=""/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.apply" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.apply.start" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.apply.control" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.apply.end" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.initialize" type="Function" classlike="true">
    <properties>
      <property name="endRotation" scope="instance" type=""/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.destroy" type="Function" classlike="true">
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="startArrowGroup" scope="instance" type="Object"/>
      <property name="startArrow" scope="instance" type="Object"/>
      <property name="endArrowGroup" scope="instance" type="Object"/>
      <property name="endArrow" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.draw" type="Function" classlike="true">
    <properties>
      <property name="endRotation" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.zoom" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="pct" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.DoubleArrowAnnotation.zoom.figure" type="">
    <properties>
      <property name="zoomFactor" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.Figure" type="Function" classlike="true">
    <properties>
      <property name="annCounter" scope="instance" type="Number"/>
      <property name="shapes" scope="instance" type="Array"/>
      <property name="image" scope="instance" type="Object"/>
      <property name="imageSrc" scope="instance" type="Object"/>
      <property name="size" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="node" scope="instance" type="Object"/>
      <property name="zoomFactor" scope="instance" type="Number"/>
      <property name="tools" scope="instance" type="Object"/>
      <property name="obj" scope="instance" type="Object"/>
      <property name="selected" scope="instance" type="Array"/>
      <property name="_c" scope="instance" type="Object"/>
      <property name="_ctr" scope="instance" type="Object"/>
      <property name="_lp" scope="instance" type="Object"/>
      <property name="_action" scope="instance" type="Object"/>
      <property name="_prevState" scope="instance" type="Object"/>
      <property name="_startPoint" scope="instance" type="Object"/>
      <property name="_ctool" scope="instance" type="Object"/>
      <property name="_start" scope="instance" type="Object"/>
      <property name="_end" scope="instance" type="Object"/>
      <property name="_absEnd" scope="instance" type="Object"/>
      <property name="_cshape" scope="instance" type="Object"/>
      <property name="gridSize" scope="normal" type="Number"/>
      <property name="getValue" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="mixin" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hasSelections" scope="instance"/>
      <method name="isSelected" scope="instance">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="select" scope="instance">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="deselect" scope="instance">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clearSelections" scope="instance"/>
      <method name="replaceSelection" scope="instance">
        <parameters>
          <parameter name="n" type="" usage="required"/>
          <parameter name="o" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_dblclick" scope="instance">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_keydown" scope="instance">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_md" scope="instance">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_mm" scope="instance">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_mu" scope="instance">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_calCol" scope="normal">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_delete" scope="normal">
        <parameters>
          <parameter name="arr" type="" usage="required"/>
          <parameter name="noundo" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onDblClickShape" scope="normal">
        <parameters>
          <parameter name="shape" type="" usage="required"/>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCreateShape" scope="normal">
        <parameters>
          <parameter name="shape" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onBeforeCreateShape" scope="normal">
        <parameters>
          <parameter name="shape" type="" usage="required"/>
        </parameters>
      </method>
      <method name="nextKey" scope="normal"/>
      <method name="draw" scope="normal"/>
      <method name="getFit" scope="normal"/>
      <method name="_add" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_remove" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_get" scope="normal">
        <parameters>
          <parameter name="key" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_keyFromEvt" scope="normal">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_fromEvt" scope="normal">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="normal">
        <parameters>
          <parameter name="annotation" type="" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="normal">
        <parameters>
          <parameter name="annotation" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="normal">
        <parameters>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="convert" scope="normal">
        <parameters>
          <parameter name="ann" type="" usage="required"/>
          <parameter name="t" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onLoad" scope="normal"/>
      <method name="onClick" scope="normal"/>
      <method name="_loadAnnotation" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onUndo" scope="normal"/>
      <method name="onBeforeUndo" scope="normal"/>
      <method name="onRedo" scope="normal"/>
      <method name="onBeforeRedo" scope="normal"/>
      <method name="undo" scope="normal"/>
      <method name="redo" scope="normal"/>
      <method name="serialize" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.sketch.Figure.initUndoStack" type="Function" classlike="true">
    <properties>
      <property name="history" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.Figure.setTool" type="Function" classlike="true">
    <properties>
      <property name="_ctool" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="t" type="dojox.sketch._Plugin" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Figure.initialize" type="Function" classlike="true">
    <properties>
      <property name="node" scope="instance" type=""/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="image" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Figure.destroy" type="Function" classlike="true">
    <properties>
      <property name="_cons" scope="instance" type="Array"/>
      <property name="group" scope="instance" type="Object"/>
      <property name="surface" scope="instance" type="Object"/>
      <property name="obj" scope="instance" type="Object"/>
      <property name="shapes" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="isLoading" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Figure.zoom" type="Function" classlike="true">
    <properties>
      <property name="zoomFactor" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="pct" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Figure.unzoom" type="Function" classlike="true">
    <properties>
      <property name="zoomFactor" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.Figure.setValue" type="Function" classlike="true">
    <properties>
      <property name="node" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="text" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Figure.load" type="Function" classlike="true">
    <properties>
      <property name="size" scope="instance" type="Object"/>
      <property name="imageSize" scope="instance" type="Object"/>
      <property name="imageSrc" scope="instance" type="Object"/>
      <property name="_loadDeferred" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
          <parameter name="n" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.LeadAnnotation" type="Function" classlike="true">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textYOffset" scope="instance" type="Number"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="constructor" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="figure" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="normal"/>
      <method name="getType" scope="normal"/>
      <method name="getBBox" scope="normal"/>
      <method name="draw" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.sketch.LeadAnnotation.anchors" type="">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.LeadAnnotation._pos" type="Function" classlike="true" private="true">
    <properties>
      <property name="textOffset" scope="instance" type=""/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.LeadAnnotation.apply" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.LeadAnnotation.apply.start" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.LeadAnnotation.apply.control" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.LeadAnnotation.apply.end" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.LeadAnnotation.initialize" type="Function" classlike="true">
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.LeadAnnotation.destroy" type="Function" classlike="true">
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.PreexistingAnnotation" type="Function" classlike="true">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="radius" scope="instance" type="Number"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="constructor" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="figure" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="normal"/>
      <method name="getType" scope="normal"/>
      <method name="getBBox" scope="normal"/>
      <method name="draw" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="zoom" scope="normal">
        <parameters>
          <parameter name="pct" type="" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.sketch.PreexistingAnnotation.anchors" type="">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.PreexistingAnnotation._pos" type="Function" classlike="true" private="true">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.PreexistingAnnotation.apply" type="Function" classlike="true">
    <properties>
      <property name="radius" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.PreexistingAnnotation.apply.start" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.PreexistingAnnotation.apply.end" type="">
    <properties>
      <property name="x" scope="instance" type="String"/>
      <property name="y" scope="instance" type="String"/>
    </properties>
  </object>
  <object location="dojox.sketch.PreexistingAnnotation.initialize" type="Function" classlike="true">
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.PreexistingAnnotation.destroy" type="Function" classlike="true">
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="rectShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation" type="Function" classlike="true">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
      <property name="textPosition" scope="instance" type="Object"/>
      <property name="textOffset" scope="instance" type="Number"/>
      <property name="textYOffset" scope="instance" type="Number"/>
      <property name="rotation" scope="instance" type="Number"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="constructor" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="figure" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="normal"/>
      <method name="getType" scope="normal"/>
      <method name="getBBox" scope="normal"/>
      <method name="serialize" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.anchors" type="">
    <properties>
      <property name="start" scope="instance" type="Object"/>
      <property name="control" scope="instance" type="Object"/>
      <property name="end" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation._rot" type="Function" classlike="true" private="true">
    <properties>
      <property name="rotation" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation._pos" type="Function" classlike="true" private="true">
    <properties>
      <property name="textOffset" scope="instance" type=""/>
      <property name="textAlign" scope="instance" type="String"/>
      <property name="textPosition" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.apply" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.apply.start" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.apply.control" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.apply.end" type="">
    <properties>
      <property name="x" scope="instance" type="Object"/>
      <property name="y" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.initialize" type="Function" classlike="true">
    <properties>
      <property name="rotation" scope="instance" type=""/>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.destroy" type="Function" classlike="true">
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="pathShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="arrowheadGroup" scope="instance" type="Object"/>
      <property name="arrowhead" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.draw" type="Function" classlike="true">
    <properties>
      <property name="rotation" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.zoom" type="Function" classlike="true">
    <properties>
      <property name="_curPct" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="pct" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.SingleArrowAnnotation.zoom.figure" type="">
    <properties>
      <property name="zoomFactor" scope="instance" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.Slider" type="Function" classlike="true" superclass="dojox.sketch._Plugin">
    <mixins>
      <mixin scope="instance" location="dojox.sketch._Plugin"/>
    </mixins>
    <properties>
      <property name="slider" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_initButton" scope="prototype"/>
      <method name="_zoomToFit" scope="prototype"/>
      <method name="_setZoom" scope="prototype">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
      <method name="setToolbar" scope="prototype">
        <parameters>
          <parameter name="t" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Slider.slider._movable.node" type="">
    <properties>
      <property name="title" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.sketch.ButtonGroup" type="Function" classlike="true">
    <properties>
      <property name="_children" scope="instance-prototype" type="Array"/>
      <property name="_childMaps" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="add" scope="prototype">
        <parameters>
          <parameter name="plugin" type="_Plugin" usage="required"/>
        </parameters>
      </method>
      <method name="_resetGroup" scope="prototype">
        <parameters>
          <parameter name="p" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.Toolbar" type="Function" classlike="true" superclass="dijit.Toolbar">
    <mixins>
      <mixin scope="instance" location="dijit.Toolbar"/>
    </mixins>
    <properties>
      <property name="figure" scope="prototype" type="Object"/>
      <property name="plugins" scope="prototype" type="Array"/>
      <property name="shapeGroup" scope="prototype" type=""/>
      <property name="_plugins" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="setFigure" scope="prototype">
        <parameters>
          <parameter name="f" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="addGroupItem" scope="prototype">
        <parameters>
          <parameter name="item" type="_Plugin" usage="required"/>
          <parameter name="group" type="" usage="required"/>
        </parameters>
      </method>
      <method name="reset" scope="prototype"/>
      <method name="_setShape" scope="prototype">
        <parameters>
          <parameter name="s" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.UnderlineAnnotationTool" type="Function" classlike="true" superclass="dojox.sketch.AnnotationTool">
    <mixins>
      <mixin scope="instance" location="dojox.sketch.AnnotationTool"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="onMouseDown" scope="prototype"/>
      <method name="onMouseUp" scope="prototype"/>
      <method name="onMouseMove" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.sketch.UnderlineAnnotationTool.figure" type="">
    <properties>
      <property name="_end" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.sketch.UnderlineAnnotation" type="Function" classlike="true">
    <properties>
      <property name="transform" scope="instance" type="Object"/>
      <property name="start" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
      <property name="constructor" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="figure" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="type" scope="normal"/>
      <method name="getType" scope="normal"/>
      <method name="apply" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="normal">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
      <method name="zoom" scope="normal">
        <parameters>
          <parameter name="pct" type="" usage="required"/>
        </parameters>
      </method>
      <method name="serialize" scope="normal"/>
    </methods>
  </object>
  <object location="dojox.sketch.UnderlineAnnotation.initialize" type="Function" classlike="true">
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="obj" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sketch.UnderlineAnnotation.destroy" type="Function" classlike="true">
    <properties>
      <property name="shape" scope="instance" type="Object"/>
      <property name="lineShape" scope="instance" type="Object"/>
      <property name="labelShape" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.UnderlineAnnotation.getBBox" type="Function" classlike="true">
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sketch.UnderlineAnnotation.getBBox.figure" type="">
    <properties>
      <property name="zoomFactor" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.sketch.UndoStack" type="Function" classlike="true">
    <properties>
      <property name="_undoedSteps" scope="instance-prototype" type="Array"/>
      <property name="figure" scope="instance" type=""/>
      <property name="_steps" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="figure" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="figure" type="" usage="required"/>
        </parameters>
      </method>
      <method name="apply" scope="prototype">
        <parameters>
          <parameter name="state" type="" usage="required"/>
          <parameter name="from" type="" usage="required"/>
          <parameter name="to" type="" usage="required"/>
        </parameters>
      </method>
      <method name="add" scope="prototype">
        <parameters>
          <parameter name="cmd" type="String" usage="required"/>
          <parameter name="ann" type="ta.Annotation" usage="optional"/>
          <parameter name="before" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype"/>
      <method name="undo" scope="prototype"/>
      <method name="redo" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.sketch.CommandTypes">
    <properties>
      <property name="Create" scope="normal" type="String"/>
      <property name="Move" scope="normal" type="String"/>
      <property name="Modify" scope="normal" type="String"/>
      <property name="Delete" scope="normal" type="String"/>
      <property name="Convert" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.sketch._Plugin" type="Function" classlike="true">
    <properties>
      <property name="figure" scope="prototype" type="Object"/>
      <property name="iconClassPrefix" scope="prototype" type="String"/>
      <property name="itemGroup" scope="prototype" type="String"/>
      <property name="button" scope="prototype" type="Object"/>
      <property name="queryCommand" scope="prototype" type="Object"/>
      <property name="shape" scope="prototype" type="String"/>
      <property name="useDefaultCommand" scope="prototype" type="Object"/>
      <property name="buttonClass" scope="normal" type=""/>
      <property name="_connects" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="args" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="_initButton" scope="prototype"/>
      <method name="attr" scope="prototype">
        <parameters>
          <parameter name="name" type="" usage="required"/>
          <parameter name="value" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="onActivate" scope="prototype"/>
      <method name="activate" scope="prototype">
        <parameters>
          <parameter name="e" type="?" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseDown" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseMove" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseUp" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <parameters>
          <parameter name="f" type="" usage="required"/>
        </parameters>
      </method>
      <method name="connect" scope="prototype">
        <parameters>
          <parameter name="o" type="" usage="required"/>
          <parameter name="f" type="" usage="required"/>
          <parameter name="tf" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setFigure" scope="prototype">
        <parameters>
          <parameter name="figure" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="setToolbar" scope="prototype">
        <parameters>
          <parameter name="toolbar" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sql">
    <summary>If true, then we print out any SQL that is executed
	to the debug window</summary>
    <description>There are four ways to call this:
	1) Straight SQL: dojox.sql("SELECT * FROM FOOBAR");
	2) SQL with parameters: dojox.sql("INSERT INTO FOOBAR VALUES (?)", someParam)
	3) Encrypting particular values:
	dojox.sql("INSERT INTO FOOBAR VALUES (ENCRYPT(?))", someParam, "somePassword", callback)
	4) Decrypting particular values:
	dojox.sql("SELECT DECRYPT(SOMECOL1), DECRYPT(SOMECOL2) FROM
	FOOBAR WHERE SOMECOL3 = ?", someParam,
	"somePassword", callback)
	For encryption and decryption the last two values should be the the password for
	encryption/decryption, and the callback function that gets the result set.
	Note: We only support ENCRYPT(?) statements, and
	and DECRYPT(*) statements for now -- you can not have a literal string
	inside of these, such as ENCRYPT('foobar')
	Note: If you have multiple columns to encrypt and decrypt, you can use the following
	convenience form to not have to type ENCRYPT(?)/DECRYPT(*) many times:
	dojox.sql("INSERT INTO FOOBAR VALUES (ENCRYPT(?, ?, ?))",
	someParam1, someParam2, someParam3,
	"somePassword", callback)
	dojox.sql("SELECT DECRYPT(SOMECOL1, SOMECOL2) FROM
	FOOBAR WHERE SOMECOL3 = ?", someParam,
	"somePassword", callback)</description>
    <mixins>
      <mixin scope="normal" location="dojox.sql"/>
    </mixins>
    <properties>
      <property name="dbName" scope="normal" type="Object"/>
      <property name="debug" scope="normal" type=""/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="_printDebugSQL" scope="normal">
        <parameters>
          <parameter name="sql" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_normalizeResults" scope="normal">
        <parameters>
          <parameter name="rs" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_needsEncrypt" scope="normal">
        <parameters>
          <parameter name="sql" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_needsDecrypt" scope="normal">
        <parameters>
          <parameter name="sql" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sql.open" type="Function" classlike="true">
    <properties>
      <property name="dbName" scope="instance" type="Object"/>
      <property name="_dbOpen" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="dbName" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sql.close" type="Function" classlike="true">
    <properties>
      <property name="dbName" scope="instance" type=""/>
      <property name="_dbOpen" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="dbName" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sql._exec" type="Function" classlike="true" private="true">
    <properties>
      <property name="_autoClose" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="params" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="encrypted results will arrive asynchronously"/>
          <return-type type="decrypted results will arrive asynchronously"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.sql._initDb" type="Function" classlike="true" private="true">
    <properties>
      <property name="db" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sql._SQLCrypto" type="Function" classlike="true">
    <summary>A private class encapsulating any cryptography that must be done
	on a SQL statement. We instantiate this class and have it hold
	it's state so that we can potentially have several encryption
	operations happening at the same time by different SQL statements.</summary>
    <properties>
      <property name="_totalCrypto" scope="prototype" type="Number"/>
      <property name="_finishedCrypto" scope="prototype" type="Number"/>
      <property name="_finishedSpawningCrypto" scope="prototype" type="Object"/>
      <property name="_finalArgs" scope="prototype" type=""/>
      <property name="_finalResultSet" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="action" type="" usage="required"/>
          <parameter name="sql" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="action" type="" usage="required"/>
          <parameter name="sql" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_execEncryptSQL" scope="prototype">
        <parameters>
          <parameter name="sql" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_execDecryptSQL" scope="prototype">
        <parameters>
          <parameter name="sql" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_encrypt" scope="prototype">
        <parameters>
          <parameter name="sql" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
          <parameter name="encryptColumns" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_decrypt" scope="prototype">
        <parameters>
          <parameter name="resultSet" type="" usage="required"/>
          <parameter name="needsDecrypt" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_stripCryptoSQL" scope="prototype">
        <parameters>
          <parameter name="sql" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_flagEncryptedArgs" scope="prototype">
        <parameters>
          <parameter name="sql" type="" usage="required"/>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_determineDecryptedColumns" scope="prototype">
        <parameters>
          <parameter name="sql" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_decryptSingleColumn" scope="prototype">
        <parameters>
          <parameter name="columnName" type="" usage="required"/>
          <parameter name="columnValue" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="currentRowIndex" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sql._crypto" type="" private="true">
    <summary>dojox.sql cryptography code</summary>
    <description>Taken from http://www.movable-type.co.uk/scripts/aes.html by
	Chris Veness (CLA signed); adapted for Dojo and Google Gears Worker Pool
	by Brad Neuberg, bkn3@columbia.edu</description>
    <properties>
      <property name="_POOL_SIZE" scope="normal" type="Size">
        <summary>of worker pool to create to help with crypto</summary>
      </property>
    </properties>
    <methods>
      <method name="encrypt" scope="normal">
        <summary>Use Corrected Block TEA to encrypt plaintext using password
	(note plaintext &amp;amp; password must be strings not string objects).
	Results will be returned to the 'callback' asychronously.</summary>
        <parameters>
          <parameter name="plaintext" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="decrypt" scope="normal">
        <summary>Use Corrected Block TEA to decrypt ciphertext using password
	(note ciphertext &amp;amp; password must be strings not string objects).
	Results will be returned to the 'callback' asychronously.</summary>
        <parameters>
          <parameter name="ciphertext" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_workerHandler" scope="normal">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="sender" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sql._crypto._initWorkerPool" type="Function" classlike="true" private="true">
    <properties>
      <property name="_unemployed" scope="instance" type="Array"/>
      <property name="_employed" scope="instance" type="Object"/>
      <property name="_handleMessage" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.sql._crypto._initWorkerPool._manager" private="true">
    <methods>
      <method name="onmessage" scope="instance">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="sender" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.sql._crypto._assignWork" type="Function" classlike="true" private="true">
    <properties>
      <property name="_handleMessage" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="callback" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.storage">
    <summary>Objects for mass storage within the browser.  For when cookies just aren't enough.</summary>
    <properties>
      <property name="_common" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.storage.AirDBStorageProvider" type="Function" classlike="true" superclass="dojox.storage.Provider">
    <mixins>
      <mixin scope="instance" location="dojox.storage.Provider"/>
    </mixins>
    <properties>
      <property name="DATABASE_FILE" scope="prototype" type="String"/>
      <property name="TABLE_NAME" scope="prototype" type="String"/>
      <property name="initialized" scope="prototype" type="Object"/>
      <property name="_db" scope="prototype" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="prototype" type="Object"/>
      <property name="_statusHandler" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="initialize" scope="prototype"/>
      <method name="_sql" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="params" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_beginTransaction" scope="prototype"/>
      <method name="_commitTransaction" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="values" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.storage.AirEncryptedLocalStorageProvider" type="Function" classlike="true" superclass="dojox.storage.Provider">
    <mixins>
      <mixin scope="instance" location="dojox.storage.Provider"/>
    </mixins>
    <properties>
      <property name="DEFAULT_NAMESPACE" scope="prototype" type="Object"/>
      <property name="_statusHandler" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="initialize" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="_getItem" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setItem" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_removeItem" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
        </parameters>
      </method>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="values" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.storage.AirFileStorageProvider" type="Function" classlike="true" superclass="dojox.storage.Provider">
    <mixins>
      <mixin scope="instance" location="dojox.storage.Provider"/>
    </mixins>
    <properties>
      <property name="initialized" scope="prototype" type="Object"/>
      <property name="_storagePath" scope="prototype" type="String"/>
      <property name="DEFAULT_NAMESPACE" scope="prototype" type="Object"/>
      <property name="_statusHandler" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="initialize" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="values" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.storage.FlashStorageProvider" type="Function" classlike="true" superclass="dojox.storage.Provider">
    <mixins>
      <mixin scope="instance" location="dojox.storage.Provider"/>
    </mixins>
    <properties>
      <property name="initialized" scope="prototype" type="Object"/>
      <property name="_available" scope="prototype" type="bool"/>
      <property name="_statusHandler" scope="prototype" type="Object"/>
      <property name="_flashReady" scope="prototype" type="bool"/>
      <property name="_pageReady" scope="prototype" type="bool"/>
      <property name="_allNamespaces" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="initialize" scope="prototype"/>
      <method name="setFlushDelay" scope="prototype">
        <parameters>
          <parameter name="newDelay" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getFlushDelay" scope="prototype"/>
      <method name="flush" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="values" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="_destringify" scope="prototype">
        <parameters>
          <parameter name="results" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
      <method name="getResourceList" scope="prototype"/>
      <method name="_loaded" scope="prototype"/>
      <method name="_onStatus" scope="prototype">
        <parameters>
          <parameter name="statusResult" type="" usage="required"/>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.storage.GearsStorageProvider" type="Function" classlike="true" superclass="dojox.storage.Provider">
    <summary>Storage provider that uses the features of Google Gears
	to store data (it is saved into the local SQL database
	provided by Gears, using dojox.sql)</summary>
    <description>You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableGearsStorage: true };
	Authors of this storage provider-
	Brad Neuberg, bkn3@columbia.edu
	instance methods and properties</description>
    <mixins>
      <mixin scope="instance" location="dojox.storage.Provider"/>
    </mixins>
    <properties>
      <property name="TABLE_NAME" scope="prototype" type="String"/>
      <property name="initialized" scope="prototype" type="Object"/>
      <property name="_available" scope="prototype" type="Object"/>
      <property name="_storageReady" scope="prototype" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="prototype" type="Object"/>
      <property name="_statusHandler" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="initialize" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="putMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="values" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
      <method name="_initStorage" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.storage.Provider" type="Function" classlike="true">
    <summary>A singleton for working with dojox.storage.</summary>
    <description>dojox.storage exposes the current available storage provider on this
	platform. It gives you methods such as dojox.storage.put(),
	dojox.storage.get(), etc.
	For more details on dojox.storage, see the primary documentation
	page at
	http://manual.dojotoolkit.org/storage.html
	Note for storage provider developers who are creating subclasses-
	This is the base class for all storage providers Specific kinds of
	Storage Providers should subclass this and implement these methods.
	You should avoid initialization in storage provider subclass's
	constructor; instead, perform initialization in your initialize()
	method.</description>
    <properties>
      <property name="SUCCESS" scope="prototype" type="String">
        <summary>Flag that indicates a put() call to a
	storage provider was succesful.</summary>
      </property>
      <property name="FAILED" scope="prototype" type="String">
        <summary>Flag that indicates a put() call to
	a storage provider failed.</summary>
      </property>
      <property name="PENDING" scope="prototype" type="String">
        <summary>Flag that indicates a put() call to a
	storage provider is pending user approval.</summary>
      </property>
      <property name="SIZE_NOT_AVAILABLE" scope="prototype" type="String">
        <summary>Returned by getMaximumSize() if this storage provider can not determine
	the maximum amount of data it can support.</summary>
      </property>
      <property name="SIZE_NO_LIMIT" scope="prototype" type="String">
        <summary>Returned by getMaximumSize() if this storage provider has no theoretical
	limit on the amount of data it can store.</summary>
      </property>
      <property name="DEFAULT_NAMESPACE" scope="prototype" type="String">
        <summary>The namespace for all storage operations. This is useful if several
	applications want access to the storage system from the same domain but
	want different storage silos.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="onHideSettingsUI" scope="prototype">
        <summary>If a function is assigned to this property, then when the settings
	provider's UI is closed this function is called. Useful, for example,
	if the user has just cleared out all storage for this provider using
	the settings UI, and you want to update your UI.</summary>
      </method>
      <method name="initialize" scope="prototype">
        <summary>Allows this storage provider to initialize itself. This is
	called after the page has finished loading, so you can not do
	document.writes(). Storage Provider subclasses should initialize
	themselves inside of here rather than in their function
	constructor.</summary>
      </method>
      <method name="isAvailable" scope="prototype">
        <summary>Returns whether this storage provider is available on this
	platform.</summary>
      </method>
      <method name="put" scope="prototype">
        <summary>Puts a key and value into this storage system.</summary>
        <description>Example-
	var resultsHandler = function(status, key, message, namespace){
	alert("status="+status+", key="+key+", message="+message);
	};
	dojox.storage.put("test", "hello world", resultsHandler);
	Arguments:
	status - The status of the put operation, given by
	dojox.storage.FAILED, dojox.storage.SUCCEEDED, or
	dojox.storage.PENDING
	key - The key that was used for the put
	message - An optional message if there was an error or things failed.
	namespace - The namespace of the key. This comes at the end since
	it was added later.
	Important note: if you are using Dojo Storage in conjunction with
	Dojo Offline, then you don't need to provide
	a resultsHandler; this is because for Dojo Offline we
	use Google Gears to persist data, which has unlimited data
	once the user has given permission. If you are using Dojo
	Storage apart from Dojo Offline, then under the covers hidden
	Flash might be used, which is both asychronous and which might
	get denied; in this case you must provide a resultsHandler.</description>
        <parameters>
          <parameter name="key" type="string" usage="required">
            <summary>A string key to use when retrieving this value in the future.</summary>
          </parameter>
          <parameter name="value" type="object" usage="required">
            <summary>A value to store; this can be any JavaScript type.</summary>
          </parameter>
          <parameter name="resultsHandler" type="function" usage="required">
            <summary>A callback function that will receive three arguments. The
	first argument is one of three values: dojox.storage.SUCCESS,
	dojox.storage.FAILED, or dojox.storage.PENDING; these values
	determine how the put request went. In some storage systems
	users can deny a storage request, resulting in a
	dojox.storage.FAILED, while in other storage systems a storage
	request must wait for user approval, resulting in a
	dojox.storage.PENDING status until the request is either
	approved or denied, resulting in another call back with
	dojox.storage.SUCCESS.
	The second argument in the call back is the key name that was being stored.
	The third argument in the call back is an optional message that
	details possible error messages that might have occurred during
	the storage process.</summary>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <summary>Optional string namespace that this value will be placed into;
	if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE</summary>
          </parameter>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <summary>Gets the value with the given key. Returns null if this key is
	not in the storage system.</summary>
        <parameters>
          <parameter name="key" type="string" usage="required">
            <summary>A string key to get the value of.</summary>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <summary>Optional string namespace that this value will be retrieved from;
	if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
	return: Returns any JavaScript object type; null if the key is not present</summary>
          </parameter>
        </parameters>
      </method>
      <method name="hasKey" scope="prototype">
        <summary>Determines whether the storage has the given key.</summary>
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getKeys" scope="prototype">
        <summary>Enumerates all of the available keys in this storage system.
	return: Array of available keys</summary>
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <summary>Completely clears this storage system of all of it's values and
	keys. If 'namespace' is provided just clears the keys in that
	namespace.</summary>
        <parameters>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <summary>Removes the given key from this storage system.</summary>
        <parameters>
          <parameter name="key" type="string" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="isPermanent" scope="prototype">
        <summary>Returns whether this storage provider's values are persisted
	when this platform is shutdown.</summary>
      </method>
      <method name="getMaximumSize" scope="prototype">
        <summary>The maximum storage allowed by this provider</summary>
        <return-description>Returns the maximum storage size
	supported by this provider, in
	thousands of bytes (i.e., if it
	returns 60 then this means that 60K
	of storage is supported).
	If this provider can not determine
	it's maximum size, then
	dojox.storage.SIZE_NOT_AVAILABLE is
	returned; if there is no theoretical
	limit on the amount of storage
	this provider can return, then
	dojox.storage.SIZE_NO_LIMIT is
	returned</return-description>
      </method>
      <method name="putMultiple" scope="prototype">
        <summary>Puts multiple keys and values into this storage system.</summary>
        <description>Example-
	var resultsHandler = function(status, key, message){
	alert("status="+status+", key="+key+", message="+message);
	};
	dojox.storage.put(["test"], ["hello world"], resultsHandler);
	Important note: if you are using Dojo Storage in conjunction with
	Dojo Offline, then you don't need to provide
	a resultsHandler; this is because for Dojo Offline we
	use Google Gears to persist data, which has unlimited data
	once the user has given permission. If you are using Dojo
	Storage apart from Dojo Offline, then under the covers hidden
	Flash might be used, which is both asychronous and which might
	get denied; in this case you must provide a resultsHandler.</description>
        <parameters>
          <parameter name="keys" type="array" usage="required">
            <summary>An array of string keys to use when retrieving this value in the future,
	one per value to be stored</summary>
          </parameter>
          <parameter name="values" type="array" usage="required">
            <summary>An array of values to store; this can be any JavaScript type, though the
	performance of plain strings is considerably better</summary>
          </parameter>
          <parameter name="resultsHandler" type="function" usage="required">
            <summary>A callback function that will receive three arguments. The
	first argument is one of three values: dojox.storage.SUCCESS,
	dojox.storage.FAILED, or dojox.storage.PENDING; these values
	determine how the put request went. In some storage systems
	users can deny a storage request, resulting in a
	dojox.storage.FAILED, while in other storage systems a storage
	request must wait for user approval, resulting in a
	dojox.storage.PENDING status until the request is either
	approved or denied, resulting in another call back with
	dojox.storage.SUCCESS.
	The second argument in the call back is the key name that was being stored.
	The third argument in the call back is an optional message that
	details possible error messages that might have occurred during
	the storage process.</summary>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <summary>Optional string namespace that this value will be placed into;
	if left off, the value will be placed into dojox.storage.DEFAULT_NAMESPACE</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getMultiple" scope="prototype">
        <summary>Gets the valuse corresponding to each of the given keys.
	Returns a null array element for each given key that is
	not in the storage system.</summary>
        <parameters>
          <parameter name="keys" type="array" usage="required">
            <summary>An array of string keys to get the value of.</summary>
          </parameter>
          <parameter name="namespace" type="string" usage="optional">
            <summary>Optional string namespace that this value will be retrieved from;
	if left off, the value will be retrieved from dojox.storage.DEFAULT_NAMESPACE
	return: Returns any JavaScript object type; null if the key is not present</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeMultiple" scope="prototype">
        <summary>Removes the given keys from this storage system.</summary>
        <parameters>
          <parameter name="keys" type="array" usage="required"/>
          <parameter name="namespace" type="string" usage="optional"/>
        </parameters>
      </method>
      <method name="isValidKeyArray" scope="prototype">
        <parameters>
          <parameter name="keys" type="" usage="required"/>
        </parameters>
      </method>
      <method name="hasSettingsUI" scope="prototype">
        <summary>Determines whether this provider has a settings UI.</summary>
      </method>
      <method name="showSettingsUI" scope="prototype">
        <summary>If this provider has a settings UI, determined
	by calling hasSettingsUI(), it is shown.</summary>
      </method>
      <method name="hideSettingsUI" scope="prototype">
        <summary>If this provider has a settings UI, hides it.</summary>
      </method>
      <method name="isValidKey" scope="prototype">
        <summary>Subclasses can call this to ensure that the key given is valid
	in a consistent way across different storage providers. We use
	the lowest common denominator for key values allowed: only
	letters, numbers, and underscores are allowed. No spaces.</summary>
        <parameters>
          <parameter name="keyName" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getResourceList" scope="prototype">
        <summary>Returns a list of URLs that this
	storage provider might depend on.</summary>
        <description>This method returns a list of URLs that this
	storage provider depends on to do its work.
	This list is used by the Dojo Offline Toolkit
	to cache these resources to ensure the machinery
	used by this storage provider is available offline.
	What is returned is an array of URLs.
	Note that Dojo Offline uses Gears as its native
	storage provider, and does not support using other
	kinds of storage providers while offline anymore.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.storage.WhatWGStorageProvider" type="Function" classlike="true" superclass="dojox.storage.Provider">
    <summary>Storage provider that uses WHAT Working Group features in Firefox 2
	to achieve permanent storage.</summary>
    <description>The WHAT WG storage API is documented at
	http://www.whatwg.org/specs/web-apps/current-work/#scs-client-side
	You can disable this storage provider with the following djConfig
	variable:
	var djConfig = { disableWhatWGStorage: true };
	Authors of this storage provider-
	JB Boisseau, jb.boisseau@eutech-ssii.com
	Brad Neuberg, bkn3@columbia.edu</description>
    <mixins>
      <mixin scope="instance" location="dojox.storage.Provider"/>
    </mixins>
    <properties>
      <property name="initialized" scope="prototype" type="Object"/>
      <property name="_domain" scope="prototype" type="Object"/>
      <property name="_available" scope="prototype" type="Object"/>
      <property name="_statusHandler" scope="prototype" type="Object"/>
      <property name="_allNamespaces" scope="prototype" type="Object"/>
      <property name="_storageEventListener" scope="prototype" type="Object"/>
      <property name="DEFAULT_NAMESPACE" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="initialize" scope="prototype"/>
      <method name="isAvailable" scope="prototype"/>
      <method name="put" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="value" type="" usage="required"/>
          <parameter name="resultsHandler" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getNamespaces" scope="prototype"/>
      <method name="getKeys" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype">
        <parameters>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isPermanent" scope="prototype"/>
      <method name="getMaximumSize" scope="prototype"/>
      <method name="hasSettingsUI" scope="prototype"/>
      <method name="showSettingsUI" scope="prototype"/>
      <method name="hideSettingsUI" scope="prototype"/>
      <method name="getFullKey" scope="prototype">
        <parameters>
          <parameter name="key" type="" usage="required"/>
          <parameter name="namespace" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.storage.manager" type="Function" classlike="true">
    <summary>A singleton class in charge of the dojox.storage system</summary>
    <description>Initializes the storage systems and figures out the best available
	storage options on this platform.</description>
    <properties>
      <property name="currentProvider" scope="instance" type="Object">
        <summary>The storage provider that was automagically chosen to do storage
	on this platform, such as dojox.storage.FlashStorageProvider.</summary>
      </property>
      <property name="available" scope="instance" type="Object"/>
      <property name="providers" scope="instance" type="Array"/>
      <property name="_initialized" scope="instance" type="Object"/>
      <property name="_onLoadListeners" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="initialize" scope="instance">
        <summary>Initializes the storage system and autodetects the best storage
	provider we can provide on this platform</summary>
      </method>
      <method name="register" scope="instance">
        <summary>Registers the existence of a new storage provider; used by
	subclasses to inform the manager of their existence. The
	storage manager will select storage providers based on
	their ordering, so the order in which you call this method
	matters.</summary>
        <parameters>
          <parameter name="name" type="string" usage="required">
            <summary>The full class name of this provider, such as
	&amp;quot;dojox.storage.FlashStorageProvider&amp;quot;.</summary>
          </parameter>
          <parameter name="instance" type="Object" usage="required">
            <summary>An instance of this provider, which we will use to call
	isAvailable() on.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="setProvider" scope="instance">
        <summary>Instructs the storageManager to use the given storage class for
	all storage requests.</summary>
        <description>Example-
	dojox.storage.setProvider(
	dojox.storage.IEStorageProvider)</description>
        <parameters>
          <parameter name="storageClass" type="" usage="required"/>
        </parameters>
      </method>
      <method name="autodetect" scope="instance">
        <summary>Autodetects the best possible persistent storage provider
	available on this platform.</summary>
      </method>
      <method name="isAvailable" scope="instance">
        <summary>Returns whether any storage options are available.</summary>
      </method>
      <method name="addOnLoad" scope="instance">
        <summary>Adds an onload listener to know when Dojo Offline can be used.</summary>
        <description>Adds a listener to know when Dojo Offline can be used. This
	ensures that the Dojo Offline framework is loaded and that the
	local dojox.storage system is ready to be used. This method is
	useful if you don't want to have a dependency on Dojo Events
	when using dojox.storage.</description>
        <parameters>
          <parameter name="func" type="Function" usage="required">
            <summary>A function to call when Dojo Offline is ready to go</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeOnLoad" scope="instance">
        <summary>Removes the given onLoad listener</summary>
        <parameters>
          <parameter name="func" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isInitialized" scope="instance">
        <summary>Returns whether the storage system is initialized and ready to
	be used.</summary>
      </method>
      <method name="supportsProvider" scope="instance">
        <summary>Determines if this platform supports the given storage provider.</summary>
        <description>Example-
	dojox.storage.manager.supportsProvider(
	"dojox.storage.InternetExplorerStorageProvider");</description>
        <parameters>
          <parameter name="storageClass" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="getProvider" scope="instance">
        <summary>Gets the current provider</summary>
      </method>
      <method name="loaded" scope="instance">
        <summary>The storage provider should call this method when it is loaded
	and ready to be used. Clients who will use the provider will
	connect to this method to know when they can use the storage
	system. You can either use dojo.connect to connect to this
	function, or can use dojox.storage.manager.addOnLoad() to add
	a listener that does not depend on the dojo.event package.</summary>
        <description>Example 1-
	if(dojox.storage.manager.isInitialized() == false){
	dojo.connect(dojox.storage.manager, "loaded", TestStorage, "initialize");
	}else{
	dojo.connect(dojo, "loaded", TestStorage, "initialize");
	}
	Example 2-
	dojox.storage.manager.addOnLoad(someFunction);</description>
      </method>
      <method name="_fireLoaded" scope="instance"/>
      <method name="getResourceList" scope="instance">
        <summary>Returns a list of whatever resources are necessary for storage
	providers to work.</summary>
        <description>This will return all files needed by all storage providers for
	this particular environment type. For example, if we are in the
	browser environment, then this will return the hidden SWF files
	needed by the FlashStorageProvider, even if we don't need them
	for the particular browser we are working within. This is meant
	to faciliate Dojo Offline, which must retrieve all resources we
	need offline into the offline cache -- we retrieve everything
	needed, in case another browser that requires different storage
	mechanisms hits the local offline cache. For example, if we
	were to sync against Dojo Offline on Firefox 2, then we would
	not grab the FlashStorageProvider resources needed for Safari.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.string.BidiComplex">
    <methods>
      <method name="attachInput" scope="normal">
        <summary>Attach key listeners to the INPUT field to accomodate dynamic complex BiDi expressions</summary>
        <parameters>
          <parameter name="field" type="DOMNode" usage="required">
            <summary>INPUT DOM node</summary>
          </parameter>
          <parameter name="pattern" type="String" usage="required">
            <summary>Complex Expression Pattern type. One of &amp;quot;FILE_PATH&amp;quot;, &amp;quot;URL&amp;quot;, &amp;quot;EMAIL&amp;quot;, &amp;quot;XPATH&amp;quot;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="createDisplayString" scope="normal">
        <summary>Create the display string by adding the Unicode direction Markers</summary>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="pattern" type="String" usage="required">
            <summary>Complex Expression Pattern type. One of &amp;quot;FILE_PATH&amp;quot;, &amp;quot;URL&amp;quot;, &amp;quot;EMAIL&amp;quot;, &amp;quot;XPATH&amp;quot;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="stripSpecialCharacters" scope="normal">
        <summary>removes all Unicode directional markers from the string</summary>
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_ceKeyDown" scope="normal">
        <parameters>
          <parameter name="event" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_ceKeyUp" scope="normal">
        <parameters>
          <parameter name="event" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_processCopy" scope="normal">
        <summary>This function strips the unicode directional controls when the text copied to the Clipboard</summary>
        <parameters>
          <parameter name="elem" type="" usage="required"/>
          <parameter name="text" type="" usage="required"/>
          <parameter name="isReverse" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_ceCopyText" scope="normal">
        <parameters>
          <parameter name="elem" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_ceCutText" scope="normal">
        <parameters>
          <parameter name="elem" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getCaretPos" scope="normal">
        <parameters>
          <parameter name="event" type="" usage="required"/>
          <parameter name="elem" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setSelectedRange" scope="normal">
        <parameters>
          <parameter name="elem" type="" usage="required"/>
          <parameter name="selectionStart" type="" usage="required"/>
          <parameter name="selectionEnd" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_parse" scope="normal">
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="pattern" type="String" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.string">
    <summary>A collection of various objects for advanced string manipulation, including a Builder and a tokenizer.</summary>
    <methods>
      <method name="tokenize" scope="normal">
        <summary>Split a string by a regular expression with the ability to capture the delimeters</summary>
        <parameters>
          <parameter name="str" type="String" usage="required"/>
          <parameter name="re" type="RegExp" usage="required"/>
          <parameter name="parseDelim" type="Function" usage="optional">
            <summary>Each group (excluding the 0 group) is passed as a parameter. If the function returns
	a value, it's added to the list of tokens.</summary>
          </parameter>
          <parameter name="instance" type="Object" usage="optional">
            <summary>Used as the &amp;quot;this&amp;quot; instance when calling parseDelim</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.string.Builder" type="Function" classlike="true">
    <summary>A fast buffer for creating large strings.</summary>
    <properties>
      <property name="length" scope="instance" type="Number">
        <summary>The current length of the internal string.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="str" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="append" scope="instance">
        <summary>Append all arguments to the end of the buffer</summary>
        <parameters>
          <parameter name="s" type="String" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="concat" scope="instance">
        <summary>Alias for append.</summary>
        <parameters>
          <parameter name="s" type="String" usage="one-or-more"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="appendArray" scope="instance">
        <summary>Append an array of items to the internal buffer.</summary>
        <parameters>
          <parameter name="strings" type="Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="clear" scope="instance">
        <summary>Remove all characters from the buffer.</summary>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="replace" scope="instance">
        <summary>Replace instances of one string with another in the buffer.</summary>
        <parameters>
          <parameter name="oldStr" type="String" usage="required"/>
          <parameter name="newStr" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="remove" scope="instance">
        <summary>Remove len characters starting at index start.  If len
	is not provided, the end of the string is assumed.</summary>
        <parameters>
          <parameter name="start" type="Number" usage="required"/>
          <parameter name="len" type="Number" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="insert" scope="instance">
        <summary>Insert string str starting at index.</summary>
        <parameters>
          <parameter name="index" type="Number" usage="required"/>
          <parameter name="str" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.string.Builder"/>
        </return-types>
      </method>
      <method name="toString" scope="instance">
        <summary>Return the string representation of the internal buffer.</summary>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.string.sprintf" type="Function"/>
  <object location="dojox.string.sprintf.Formatter" type="Function" classlike="true">
    <properties>
      <property name="_re" scope="prototype" type="RegExp"/>
      <property name="_zeros10" scope="prototype" type="String"/>
      <property name="_spaces10" scope="prototype" type="String"/>
      <property name="_mapped" scope="instance" type="bool"/>
      <property name="_format" scope="instance" type=""/>
      <property name="_tokens" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="format" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="format" scope="prototype">
        <parameters>
          <parameter name="filler" type="mixed" usage="one-or-more"/>
        </parameters>
      </method>
      <method name="formatInt" scope="prototype">
        <parameters>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="formatDouble" scope="prototype">
        <parameters>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="zeroPad" scope="prototype">
        <parameters>
          <parameter name="token" type="" usage="required"/>
          <parameter name="length" type="Int" usage="required"/>
        </parameters>
      </method>
      <method name="fitField" scope="prototype">
        <parameters>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
      <method name="spacePad" scope="prototype">
        <parameters>
          <parameter name="token" type="" usage="required"/>
          <parameter name="length" type="Int" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.string.sprintf.Formatter._parseDelim" type="Function" classlike="true" private="true">
    <properties>
      <property name="_mapped" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="mapping" type="" usage="required"/>
          <parameter name="intmapping" type="" usage="required"/>
          <parameter name="flags" type="" usage="required"/>
          <parameter name="minWidth" type="" usage="required"/>
          <parameter name="period" type="" usage="required"/>
          <parameter name="precision" type="" usage="required"/>
          <parameter name="specifier" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers" private="true"/>
  <object location="dojox.string.sprintf.Formatter._specifiers.b">
    <properties>
      <property name="base" scope="normal" type="Number"/>
      <property name="isInt" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.o">
    <properties>
      <property name="base" scope="normal" type="Number"/>
      <property name="isInt" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.x">
    <properties>
      <property name="base" scope="normal" type="Number"/>
      <property name="isInt" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.X">
    <properties>
      <property name="extend" scope="normal" type="Array"/>
      <property name="toUpper" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.d">
    <properties>
      <property name="base" scope="normal" type="Number"/>
      <property name="isInt" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.i">
    <properties>
      <property name="extend" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.u">
    <properties>
      <property name="extend" scope="normal" type="Array"/>
      <property name="isUnsigned" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.c">
    <methods>
      <method name="setArg" scope="normal">
        <parameters>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.s">
    <methods>
      <method name="setMaxWidth" scope="normal">
        <parameters>
          <parameter name="token" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.e">
    <properties>
      <property name="isDouble" scope="normal" type="Object"/>
      <property name="doubleNotation" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.E">
    <properties>
      <property name="extend" scope="normal" type="Array"/>
      <property name="toUpper" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.f">
    <properties>
      <property name="isDouble" scope="normal" type="Object"/>
      <property name="doubleNotation" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.F">
    <properties>
      <property name="extend" scope="normal" type="Array"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.g">
    <properties>
      <property name="isDouble" scope="normal" type="Object"/>
      <property name="doubleNotation" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.string.sprintf.Formatter._specifiers.G">
    <properties>
      <property name="extend" scope="normal" type="Array"/>
      <property name="toUpper" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.testing">
    <summary>TODOC</summary>
  </object>
  <object location="dojox.testing.DocTest" type="Function" classlike="true">
    <summary>This class executes doctests.</summary>
    <description>DocTests are tests that are defined inside the comment.
	A doctest looks as if it was copied from the shell (which it mostly is).
	A doctest is executed when the following conditions match:
	1) all lines are comments
	2) the line always starts with spaces/tabs followed by "//"
	and at least one space
	3) the line(s) of the test to execute starts with "&gt;&gt;&gt;"
	preceeded by what is described in 2)
	4) the first line after 3) starting without "&gt;&gt;&gt;" is the exptected result.
	preceeded by what is described in 2)
	5) the test sequence is terminated by an empty line, or the next
	test in the following line, or a new line that does not start as described in 2)
	(simple said: is not a comment)
	preceeded by what is described in 2)
	I.e. the following is a simple doctest, that will actually also be run
	if you run this class against this file here:
	&gt;&gt;&gt; 1+1 // A simple test case. Terminated by an empty line
	2
	&gt;&gt;&gt; 1==2
	false
	&gt;&gt;&gt; "a"+"b" // Also without the empty line before, this is a new test.
	"ab"
	&gt;&gt;&gt; var anything = "anything" // Multiple commands for one test.
	&gt;&gt;&gt; "something"==anything
	false
	DocTests are great for inline documenting a class or method, they also
	are very helpful in understanding what the class/method actually does.
	They don't make sense everywhere, but sometimes they are really handy.</description>
    <properties>
      <property name="errors" scope="prototype" type="Array"/>
      <property name="tests" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="getTests" scope="prototype">
        <summary>Extract the tests from the given module or string.
	examples:
	&amp;gt;&amp;gt;&amp;gt; dojo.isArray(new dojox.testing.DocTest().getTests(&amp;quot;dojox.testing.DocTest&amp;quot;)) // Use the module name to extract the tests from.
	true</summary>
        <parameters>
          <parameter name="moduleName" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="getTestsFromString" scope="prototype">
        <parameters>
          <parameter name="data" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_getTestsFromString" scope="prototype">
        <summary>Parse the given string for tests.</summary>
        <parameters>
          <parameter name="data" type="String" usage="required"/>
          <parameter name="insideComments" type="Boolean" usage="required">
            <summary>Boolean, if false &amp;quot;data&amp;quot; contains only the pure tests, comments already stripped.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="run" scope="prototype">
        <summary>Run the doctests in the module given.</summary>
        <examples>
          <example>doctest = new dojox.testing.DocTest();
	doctest.run("dojox.testing.DocTest");
	doctest.errors should finally be an empty array.
	// The above is not a doctest, because it just would
	//	execute itself in a never ending loop.
	&gt;&gt;&gt; true==true // Test a new line terminating the test.
	true
	&gt;&gt;&gt; true==true // Test a new test terminating the test.
	true
	&gt;&gt;&gt; true==true // Test a "not a comment"-line, especially an empty line terminating the test.
	true</example>
        </examples>
        <parameters>
          <parameter name="moduleName" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_run" scope="prototype">
        <summary>Each element in the array contains the test in the first element,
	and the expected result in the second element.</summary>
        <parameters>
          <parameter name="tests" type="Array" usage="required">
            <summary>Make sure that the types are compared properly. There used to be
	the bug that a return value false was compared to &amp;quot;false&amp;quot; which
	made the test fail. This is fixed and should be verified by the
	following tests.
	&amp;gt;&amp;gt;&amp;gt; false
	false
	&amp;gt;&amp;gt;&amp;gt; &amp;quot;false&amp;quot;
	&amp;quot;false&amp;quot;
	&amp;gt;&amp;gt;&amp;gt; true
	true
	&amp;gt;&amp;gt;&amp;gt; 1
	1
	&amp;gt;&amp;gt;&amp;gt; &amp;quot;s&amp;quot;
	&amp;quot;s&amp;quot;
	&amp;gt;&amp;gt;&amp;gt; dojo.toJson({one:1})
	&amp;quot;{&amp;quot;one&amp;quot;:1}&amp;quot;</summary>
          </parameter>
        </parameters>
      </method>
      <method name="runTest" scope="prototype">
        <parameters>
          <parameter name="commands" type="" usage="required"/>
          <parameter name="expected" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.timing">
    <summary>A set of objects to perform advanced time-based tasks, including a basic Timer.</summary>
    <properties>
      <property name="ThreadPool" scope="normal" type="Object"/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.timing.Sequence" type="Function" classlike="true">
    <summary>This class provides functionality to really sequentialize
	function calls. You need to provide a list of functions and
	some parameters for each (like: pauseBefore) and they will
	be run one after another. This can be very useful for slideshows
	or alike things.</summary>
    <description>This array will contain the sequence defines resolved, so that
	ie. repeat:10 will result in 10 elements in the sequence, so
	the repeat handling is easier and we don't need to handle that
	many extra cases. Also the doneFunction, if given is added at the
	end of the resolved-sequences.</description>
    <properties>
      <property name="_defsResolved" scope="instance-prototype" type="Array">
        <summary>The resolved sequence, for easier handling.</summary>
      </property>
      <property name="_goOnPause" scope="prototype" type="Integer">
        <summary>The pause to wait before really going on.</summary>
      </property>
      <property name="_running" scope="prototype" type="bool"/>
      <property name="_curId" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="go" scope="prototype">
        <summary>Run the passed sequence definition</summary>
        <parameters>
          <parameter name="defs" type="Array" usage="required">
            <summary>The sequence of actions</summary>
          </parameter>
          <parameter name="doneFunction" type="Function|Array" usage="optional">
            <summary>The function to call when done</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_go" scope="prototype">
        <summary>Execute one task of this._defsResolved.</summary>
      </method>
      <method name="goOn" scope="prototype">
        <summary>This method just provides a hook from the outside, so that
	an interrupted sequence can be continued.</summary>
      </method>
      <method name="stop" scope="prototype">
        <summary>Stop the currently running sequence.</summary>
        <description>This can only interrupt the sequence not the last function that
	had been started. If the last function was i.e. a slideshow
	that is handled inside a function that you have given as
	one sequence item it cant be stopped, since it is not controlled
	by this object here. In this case it would be smarter to
	run the slideshow using a sequence object so you can also stop
	it using this method.</description>
      </method>
    </methods>
  </object>
  <object location="dojox.timing.Streamer" type="Function" classlike="true">
    <properties>
      <property name="interval" scope="instance" type="the">
        <summary>interval in ms at which the output function is fired.
	minimum: the minimum number of elements in the internal queue.</summary>
      </property>
      <property name="minimumSize" scope="instance" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="input" type="function" usage="required">
            <summary>the function executed when the internal queue reaches minimumSize</summary>
          </parameter>
          <parameter name="output" type="function" usage="required">
            <summary>the function executed on internal tick</summary>
          </parameter>
          <parameter name="interval" type="int" usage="required">
            <summary>the interval in ms at which the output function is fired.</summary>
          </parameter>
          <parameter name="minimum" type="int" usage="required">
            <summary>the minimum number of elements in the internal queue.</summary>
          </parameter>
          <parameter name="initialData" type="array" usage="required"/>
        </parameters>
      </method>
      <method name="inputFunction" scope="instance"/>
      <method name="outputFunction" scope="instance"/>
      <method name="setInterval" scope="instance">
        <parameters>
          <parameter name="ms" type="int" usage="required"/>
        </parameters>
      </method>
      <method name="onTick" scope="instance">
        <parameters>
          <parameter name="obj" type="dojox.timing.Streamer" usage="required"/>
        </parameters>
      </method>
      <method name="start" scope="instance"/>
      <method name="onStart" scope="instance"/>
      <method name="stop" scope="instance"/>
      <method name="onStop" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.timing.threadStates">
    <properties>
      <property name="UNSTARTED" scope="normal" type="String"/>
      <property name="STOPPED" scope="normal" type="String"/>
      <property name="PENDING" scope="normal" type="String"/>
      <property name="RUNNING" scope="normal" type="String"/>
      <property name="SUSPENDED" scope="normal" type="String"/>
      <property name="WAITING" scope="normal" type="String"/>
      <property name="COMPLETE" scope="normal" type="String"/>
      <property name="ERROR" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.timing.threadPriorities">
    <properties>
      <property name="LOWEST" scope="normal" type="Number"/>
      <property name="BELOWNORMAL" scope="normal" type="Number"/>
      <property name="NORMAL" scope="normal" type="Number"/>
      <property name="ABOVENORMAL" scope="normal" type="Number"/>
      <property name="HIGHEST" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.timing.Thread" type="Function" classlike="true">
    <properties>
      <property name="state" scope="instance" type=""/>
      <property name="priority" scope="instance" type="Object"/>
      <property name="lastError" scope="instance" type="Object"/>
      <property name="func" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="fn" type="Function" usage="required"/>
          <parameter name="priority" type="dojox.timing.threadPriorities" usage="optional"/>
        </parameters>
      </method>
      <method name="invoke" scope="instance"/>
    </methods>
  </object>
  <object location="dojox.timing.Timer" type="Function" classlike="true">
    <summary>Timer object executes an &amp;quot;onTick()&amp;quot; method repeatedly at a specified interval.
	repeatedly at a given interval.</summary>
    <properties>
      <property name="timer" scope="instance" type="Object"/>
      <property name="isRunning" scope="instance" type="bool"/>
      <property name="interval" scope="instance" type="Interval">
        <summary>between function calls, in milliseconds.</summary>
      </property>
      <property name="onStart" scope="instance" type="Object"/>
      <property name="onStop" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="interval" type="int" usage="required">
            <summary>Interval between function calls, in milliseconds.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onTick" scope="prototype">
        <summary>Method called every time the interval passes.  Override to do something useful.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.timing.Timer.setInterval" type="Function" classlike="true">
    <summary>Reset the interval of a timer, whether running or not.</summary>
    <properties>
      <property name="interval" scope="instance" type="New">
        <summary>interval, in milliseconds.</summary>
      </property>
      <property name="timer" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="interval" type="New" usage="required">
            <summary>interval, in milliseconds.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.timing.Timer.start" type="Function" classlike="true">
    <summary>Start the timer ticking.</summary>
    <description>Calls the "onStart()" handler, if defined.
	Note that the onTick() function is not called right away,
	only after first interval passes.</description>
    <properties>
      <property name="isRunning" scope="instance" type="Object"/>
      <property name="timer" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.timing.Timer.stop" type="Function" classlike="true">
    <summary>Stop the timer.</summary>
    <description>Calls the "onStop()" handler, if defined.</description>
    <properties>
      <property name="isRunning" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.timing.doLater" type="Function">
    <summary>Check if a parameter is ready, and if not,
	&amp;quot;do later&amp;quot;. doLater will ping the parameter
	until it evaluates to something (truthy).
	It thens calls the caller with original
	arguments, using the supplied context or
	window.</summary>
    <description>dojox.timing.doLater(conditional) is testing if the call
	should be done later. So it returns
	true if the param is false.
	arguments:</description>
    <examples>
      <example> setTimeout(function(){
	 		if(dojox.timing.doLater(app.ready)){return;}
	 		console.log("Code is ready! anonymous.function SUCCESS")
	 	},700);</example>
    </examples>
  </object>
  <object location="dojox.timing.doLater.caller" type="">
    <properties>
      <property name="arguments" scope="normal" type=""/>
    </properties>
  </object>
  <object location="dojox.uuid">
    <summary>Universally Unique Identifier (UUID) implementations, including an implementation of UUID 2</summary>
    <properties>
      <property name="NIL_UUID" scope="normal" type="String"/>
      <property name="_ourVariantLookupTable" scope="normal" type=""/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="assert" scope="normal">
        <summary>Throws an exception if the assertion fails.</summary>
        <description>If the asserted condition is true, this method does nothing. If the
	condition is false, we throw an error with a error message.</description>
        <parameters>
          <parameter name="booleanValue" type="Boolean" usage="required">
            <summary>Must be true for the assertion to succeed.</summary>
          </parameter>
          <parameter name="message" type="String" usage="optional">
            <summary>A string describing the assertion.
	throws: Throws an Error if 'booleanValue' is false.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="generateNilUuid" scope="normal">
        <summary>This function returns the Nil UUID: &amp;quot;00000000-0000-0000-0000-000000000000&amp;quot;.</summary>
        <description>The Nil UUID is described in section 4.1.7 of
	RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.1.7
	examples:
	var string = dojox.uuid.generateNilUuid();</description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="isValid" scope="normal">
        <summary>Returns true if the UUID was initialized with a valid value.</summary>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="getVariant" scope="normal">
        <summary>Returns a variant code that indicates what type of UUID this is.
	Returns one of the enumerated dojox.uuid.variant values.</summary>
        <examples>
          <example>var variant = dojox.uuid.getVariant("3b12f1df-5232-4804-897e-917bf397618a");
	dojox.uuid.assert(variant == dojox.uuid.variant.DCE);</example>
          <example>"3b12f1df-5232-4804-897e-917bf397618a"
	^
	(variant "10__" == DCE)</example>
        </examples>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.variant"/>
        </return-types>
      </method>
      <method name="getVersion" scope="normal">
        <summary>Returns a version number that indicates what type of UUID this is.
	Returns one of the enumerated dojox.uuid.version values.</summary>
        <examples>
          <example>var version = dojox.uuid.getVersion("b4308fb0-86cd-11da-a72b-0800200c9a66");
	dojox.uuid.assert(version == dojox.uuid.version.TIME_BASED);</example>
        </examples>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojox.uuid.version"/>
        </return-types>
      </method>
      <method name="getNode" scope="normal">
        <summary>If this is a version 1 UUID (a time-based UUID), getNode() returns a
	12-character string with the &amp;quot;node&amp;quot; or &amp;quot;pseudonode&amp;quot; portion of the UUID,
	which is the rightmost 12 characters.</summary>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="String (a 12-character string, which will look something like &quot;917bf397618a&quot;)"/>
        </return-types>
      </method>
      <method name="getTimestamp" scope="normal">
        <summary>If this is a version 1 UUID (a time-based UUID), this method returns
	the timestamp value encoded in the UUID.  The caller can ask for the
	timestamp to be returned either as a JavaScript Date object or as a
	15-character string of hex digits.</summary>
        <return-description>Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
	examples:
	var uuidString = "b4308fb0-86cd-11da-a72b-0800200c9a66";
	var date, string, hexString;
	date   = dojox.uuid.getTimestamp(uuidString);         // returns a JavaScript Date
	date   = dojox.uuid.getTimestamp(uuidString, Date);     //
	string = dojox.uuid.getTimestamp(uuidString, String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
	hexString = dojox.uuid.getTimestamp(uuidString, "hex"); // "1da86cdb4308fb0"</return-description>
        <parameters>
          <parameter name="uuidString" type="String" usage="required"/>
          <parameter name="returnType" type="String" usage="optional">
            <summary>Any of these five values: &amp;quot;string&amp;quot;, String, &amp;quot;hex&amp;quot;, &amp;quot;date&amp;quot;, Date</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String (e.g. &quot;Mon, 16 Jan 2006 20:21:41 GMT&quot;)"/>
          <return-type type="String (e.g. &quot;1da86cdb4308fb0&quot;)"/>
          <return-type type="Date"/>
        </return-types>
      </method>
      <method name="generateRandomUuid" scope="normal">
        <summary>This function generates random UUIDs, meaning &amp;quot;version 4&amp;quot; UUIDs.</summary>
        <description>A typical generated value would be something like this:
	"3b12f1df-5232-4804-897e-917bf397618a"
	For more information about random UUIDs, see sections 4.4 and
	4.5 of RFC 4122: http://tools.ietf.org/html/rfc4122#section-4.4
	This generator function is designed to be small and fast,
	but not necessarily good.
	Small: This generator has a small footprint. Once comments are
	stripped, it's only about 25 lines of code, and it doesn't
	dojo.require() any other modules.
	Fast: This generator can generate lots of new UUIDs fairly quickly
	(at least, more quickly than the other dojo UUID generators).
	Not necessarily good: We use Math.random() as our source
	of randomness, which may or may not provide much randomness.
	examples:
	var string = dojox.uuid.generateRandomUuid();</description>
        <return-types>
          <return-type type="for example: &quot;3B12F1DF&quot;"/>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.uuid.Uuid" type="Function" classlike="true">
    <summary>This is the constructor for the Uuid class.  The Uuid class offers
	methods for inspecting existing UUIDs.</summary>
    <properties>
      <property name="_uuidString" scope="instance" type="Object"/>
      <property name="_ourGenerator" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="input" type="String" usage="optional">
            <summary>A 36-character string that conforms to the UUID spec.
	examples:
	var uuid;
	uuid = new dojox.uuid.Uuid(&amp;quot;3b12f1df-5232-4804-897e-917bf397618a&amp;quot;);
	uuid = new dojox.uuid.Uuid(); // &amp;quot;00000000-0000-0000-0000-000000000000&amp;quot;
	uuid = new dojox.uuid.Uuid(dojox.uuid.generateRandomUuid());
	uuid = new dojox.uuid.Uuid(dojox.uuid.generateTimeBasedUuid());
	dojox.uuid.Uuid.setGenerator(dojox.uuid.generateRandomUuid);
	uuid = new dojox.uuid.Uuid();
	dojox.uuid.assert(!uuid.isEqual(dojox.uuid.NIL_UUID));</summary>
          </parameter>
        </parameters>
      </method>
      <method name="compare" scope="normal">
        <summary>Compares this UUID to another UUID, and returns 0, 1, or -1.</summary>
        <description>This implementation is intended to match the sample implementation
	in IETF RFC 4122: http://www.ietf.org/rfc/rfc4122.txt</description>
        <parameters>
          <parameter name="uuidOne" type="dojox.uuid.Uuid" usage="required">
            <summary>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</summary>
          </parameter>
          <parameter name="uuidTwo" type="dojox.uuid.Uuid" usage="required">
            <summary>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</summary>
          </parameter>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required">
            <summary>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="integer"/>
          <return-type type="integer (either 0, 1, or -1)"/>
        </return-types>
      </method>
      <method name="setGenerator" scope="normal">
        <summary>Sets the default generator, which will be used by the
	&amp;quot;new dojox.uuid.Uuid()&amp;quot; constructor if no parameters
	are passed in.</summary>
        <parameters>
          <parameter name="generator" type="Function" usage="optional">
            <summary>A UUID generator function, such as dojox.uuid.generateTimeBasedUuid.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getGenerator" scope="normal">
        <summary>Returns the default generator.  See setGenerator().</summary>
        <return-types>
          <return-type type="generator (A UUID generator, such as dojox.uuid.TimeBasedGenerator)."/>
        </return-types>
      </method>
      <method name="toString" scope="normal">
        <summary>This method returns a standard 36-character string representing
	the UUID, such as &amp;quot;3b12f1df-5232-4804-897e-917bf397618a&amp;quot;.</summary>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
      <method name="isEqual" scope="normal">
        <summary>Returns true if this UUID is equal to the otherUuid, or false otherwise.</summary>
        <parameters>
          <parameter name="otherUuid" type="dojox.uuid.Uuid" usage="required">
            <summary>Any object that has toString() method that returns a 36-character string that conforms to the UUID spec.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="isValid" scope="normal">
        <summary>Returns true if the UUID was initialized with a valid value.</summary>
      </method>
      <method name="getVariant" scope="normal">
        <summary>Returns a variant code that indicates what type of UUID this is.
	Returns one of the enumerated dojox.uuid.variant values.</summary>
        <examples>
          <example>var uuid = new dojox.uuid.Uuid("3b12f1df-5232-4804-897e-917bf397618a");
	var variant = uuid.getVariant();
	dojox.uuid.assert(variant == dojox.uuid.variant.DCE);</example>
          <example>"3b12f1df-5232-4804-897e-917bf397618a"
	^
	(variant "10__" == DCE)</example>
        </examples>
      </method>
    </methods>
  </object>
  <object location="dojox.uuid.Uuid.getVersion" type="Function" classlike="true">
    <summary>Returns a version number that indicates what type of UUID this is.
	Returns one of the enumerated dojox.uuid.version values.</summary>
    <examples>
      <example>var uuid = new dojox.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
	var version = uuid.getVersion();
	dojox.uuid.assert(version == dojox.uuid.version.TIME_BASED);</example>
    </examples>
    <properties>
      <property name="_versionNumber" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <return-types>
          <return-type type="dojox.uuid.version"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.uuid.Uuid.getNode" type="Function" classlike="true">
    <summary>If this is a version 1 UUID (a time-based UUID), getNode() returns a
	12-character string with the &amp;quot;node&amp;quot; or &amp;quot;pseudonode&amp;quot; portion of the UUID,
	which is the rightmost 12 characters.</summary>
    <properties>
      <property name="_nodeString" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <return-types>
          <return-type type="String (a 12-character string, which will look something like &quot;917bf397618a&quot;)"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.uuid.Uuid.getTimestamp" type="Function" classlike="true">
    <summary>If this is a version 1 UUID (a time-based UUID), this method returns
	the timestamp value encoded in the UUID.  The caller can ask for the
	timestamp to be returned either as a JavaScript Date object or as a
	15-character string of hex digits.</summary>
    <properties>
      <property name="_timestampAsHexString" scope="instance" type="Object"/>
      <property name="_timestampAsDate" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <return-description>Returns the timestamp value as a JavaScript Date object or a 15-character string of hex digits.
	examples:
	var uuid = new dojox.uuid.Uuid("b4308fb0-86cd-11da-a72b-0800200c9a66");
	var date, string, hexString;
	date   = uuid.getTimestamp();         // returns a JavaScript Date
	date   = uuid.getTimestamp(Date);     //
	string = uuid.getTimestamp(String);   // "Mon, 16 Jan 2006 20:21:41 GMT"
	hexString = uuid.getTimestamp("hex"); // "1da86cdb4308fb0"</return-description>
        <parameters>
          <parameter name="returnType" type="String" usage="optional">
            <summary>Any of these five values: &amp;quot;string&amp;quot;, String, &amp;quot;hex&amp;quot;, &amp;quot;date&amp;quot;, Date</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String (e.g. &quot;Mon, 16 Jan 2006 20:21:41 GMT&quot;)"/>
          <return-type type="String (e.g. &quot;1da86cdb4308fb0&quot;)"/>
          <return-type type="Date"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.uuid.version">
    <properties>
      <property name="UNKNOWN" scope="normal" type="Number"/>
      <property name="TIME_BASED" scope="normal" type="Number"/>
      <property name="DCE_SECURITY" scope="normal" type="Number"/>
      <property name="NAME_BASED_MD5" scope="normal" type="Number"/>
      <property name="RANDOM" scope="normal" type="Number"/>
      <property name="NAME_BASED_SHA1" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.uuid.variant">
    <properties>
      <property name="NCS" scope="normal" type="String"/>
      <property name="DCE" scope="normal" type="String"/>
      <property name="MICROSOFT" scope="normal" type="String"/>
      <property name="UNKNOWN" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.uuid.generateTimeBasedUuid" type="Function">
    <summary>This function generates time-based UUIDs, meaning &amp;quot;version 1&amp;quot; UUIDs.</summary>
    <description>For more info, see
	http://www.webdav.org/specs/draft-leach-uuids-guids-01.txt
	http://www.infonuovo.com/dma/csdocs/sketch/instidid.htm
	http://kruithof.xs4all.nl/uuid/uuidgen
	http://www.opengroup.org/onlinepubs/009629399/apdxa.htm#tagcjh_20
	http://jakarta.apache.org/commons/sandbox/id/apidocs/org/apache/commons/id/uuid/clock/Clock.html</description>
    <properties>
      <property name="_generator" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="isValidNode" scope="normal">
        <parameters>
          <parameter name="node" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="getNode" scope="normal">
        <summary>Returns the 'node' value that will be included in generated UUIDs.</summary>
        <return-types>
          <return-type type="String (a 12-character hex string representing a pseudoNode or hardwareNode)"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.uuid.generateTimeBasedUuid.setNode" type="Function" classlike="true">
    <summary>Sets the 'node' value that will be included in generated UUIDs.</summary>
    <properties>
      <property name="_uniformNode" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="String" usage="optional">
            <summary>A 12-character hex string representing a pseudoNode or hardwareNode.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.validate.br">
    <methods>
      <method name="isValidCnpj" scope="normal">
        <summary>Validates a CNPJ/CGC number</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>The CNPJ/CGC number in ##.###.###/####-##, ########/####-##,
	############-## or ############## format</summary>
          </parameter>
        </parameters>
      </method>
      <method name="computeCnpjDv" scope="normal">
        <summary>Generate the DV code (checksum part) for a Cnpj number</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>The CGC number in ##.###.###/#### or ############ format</summary>
          </parameter>
        </parameters>
      </method>
      <method name="isValidCpf" scope="normal">
        <summary>Validates a CPF number</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>The CPF number in #########-## or ###########,
	format</summary>
          </parameter>
        </parameters>
      </method>
      <method name="computeCpfDv" scope="normal">
        <summary>Generate the DV code (checksum part) for a CPF number</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>The CPF number in ######### format</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.validate.ca">
    <summary>Module which includes Canadian-specific methods for dojox.validate</summary>
    <methods>
      <method name="isPhoneNumber" scope="normal">
        <summary>Validates Canadian 10-digit phone number for several common formats</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isProvince" scope="normal">
        <summary>Validates Canadian province abbreviations (2 characters)</summary>
        <parameters>
          <parameter name="value" type="String[2]" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isSocialInsuranceNumber" scope="normal">
        <summary>Validates Canadian 9 digit social insurance number for several
	common formats</summary>
        <description>Validates Canadian 9 digit social insurance number for several
	common formats. This routine only pattern matches and does not
	use the Luhn Algorithm to validate number.</description>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isPostalCode" scope="normal">
        <summary>Validates Canadian 6 digit postal code</summary>
        <description>Validates Canadian 6 digit postal code.
	Canadian postal codes are in the format ANA NAN,
	where A is a letter and N is a digit, with a space
	separating the third and fourth characters.</description>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.validate._cardInfo" private="true">
    <summary>A dictionary list of credit card abbreviations</summary>
    <description>A hash of valid CC abbreviations and regular expressions</description>
    <examples>
      <example>Define your own card, gift-card, whatever. Starts with 7,
	is 15 total length.
	 dojo.mixin(dojox.validate._cardInfo, {
	 	"my":"7[0-9]{14}"
	 });</example>
    </examples>
    <properties>
      <property name="mc" scope="normal" type="Mastercard"/>
      <property name="ec" scope="normal" type="Eurocard"/>
      <property name="vi" scope="normal" type="Visa"/>
      <property name="ax" scope="normal" type="American">
        <summary>Express</summary>
      </property>
      <property name="dc" scope="normal" type="Diners">
        <summary>Club</summary>
      </property>
      <property name="bl" scope="normal" type="Carte">
        <summary>Blanch</summary>
      </property>
      <property name="di" scope="normal" type="Discover"/>
      <property name="jcb" scope="normal" type="JCB"/>
      <property name="er" scope="normal" type="Enroute"/>
    </properties>
  </object>
  <object location="dojox.validate.regexp">
    <properties>
      <property name="emailAddressList" scope="normal" type=""/>
    </properties>
    <methods>
      <method name="ipAddress" scope="normal">
        <summary>Builds a RE that matches an IP Address</summary>
        <description>Supports 5 formats for IPv4: dotted decimal, dotted hex, dotted octal, decimal and hexadecimal.
	Supports 2 formats for Ipv6.
	flags  An object.  All flags are boolean with default = true.
	flags.allowDottedDecimal  Example, 207.142.131.235.  No zero padding.
	flags.allowDottedHex  Example, 0x18.0x11.0x9b.0x28.  Case insensitive.  Zero padding allowed.
	flags.allowDottedOctal  Example, 0030.0021.0233.0050.  Zero padding allowed.
	flags.allowDecimal  Example, 3482223595.  A decimal number between 0-4294967295.
	flags.allowHex  Example, 0xCF8E83EB.  Hexadecimal number between 0x0-0xFFFFFFFF.
	Case insensitive.  Zero padding allowed.
	flags.allowIPv6   IPv6 address written as eight groups of four hexadecimal digits.
	FIXME: ipv6 can be written multiple ways IIRC
	flags.allowHybrid   IPv6 address written as six groups of four hexadecimal digits
	followed by the usual 4 dotted decimal digit notation of IPv4. x:x:x:x:x:x:d.d.d.d</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="host" scope="normal">
        <summary>Builds a RE that matches a host</summary>
        <description>A host is a named host (A-z0-9_- but not starting with -), a domain name or an IP address, possibly followed by a port number.</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <summary>An object.
	flags.allowNamed Allow a named host for local networks. Default is false.
	flags.allowIP  Allow an IP address for hostname.  Default is true.
	flags.allowLocal  Allow the host to be &amp;quot;localhost&amp;quot;.  Default is false.
	flags.allowPort  Allow a port number to be present.  Default is true.
	flags in regexp.ipAddress can be applied.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="url" scope="normal">
        <summary>Builds a regular expression that matches a URL</summary>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <summary>An object
	flags.scheme  Can be true, false, or [true, false].
	This means: required, not allowed, or match either one.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="&quot;; } return &quot;&quot;; }"/>
        </return-types>
      </method>
      <method name="emailAddress" scope="normal">
        <summary>Builds a regular expression that matches an email address</summary>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <summary>An object
	flags.allowCruft  Allow address like &amp;lt;mailto:foo@yahoo.com&amp;gt;.  Default is false.
	flags in regexp.host can be applied.
	flags in regexp.ipAddress can be applied.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="numberFormat" scope="normal">
        <summary>Builds a regular expression to match any sort of number based format</summary>
        <description>Use this method for phone numbers, social security numbers, zip-codes, etc.
	The RE can match one format or one of multiple formats.
	Format
	#        Stands for a digit, 0-9.
	?        Stands for an optional digit, 0-9 or nothing.
	All other characters must appear literally in the expression.
	Example
	"(###) ###-####"       -&gt;   (510) 542-9742
	"(###) ###-#### x#???" -&gt;   (510) 542-9742 x153
	"###-##-####"          -&gt;   506-82-1089       i.e. social security number
	"#####-####"           -&gt;   98225-1649        i.e. zip code</description>
        <parameters>
          <parameter name="flags" type="Object" usage="optional">
            <summary>An object
	flags.format  A string or an Array of strings for multiple formats.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.validate.regexp.ca">
    <methods>
      <method name="postalCode" scope="normal">
        <summary>String regular Express to match Canadain Postal Codes</summary>
      </method>
      <method name="province" scope="normal">
        <summary>a regular expression to match Canadian Province Abbreviations</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.validate.regexp.us">
    <methods>
      <method name="state" scope="normal">
        <summary>A regular expression to match US state and territory abbreviations
	flags  An object.
	flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
	flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.</summary>
        <parameters>
          <parameter name="flags" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.validate.us">
    <methods>
      <method name="isState" scope="normal">
        <summary>Validates US state and territory abbreviations.</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>A two character string</summary>
          </parameter>
          <parameter name="flags" type="Object" usage="optional">
            <summary>An object
	flags.allowTerritories  Allow Guam, Puerto Rico, etc.  Default is true.
	flags.allowMilitary  Allow military 'states', e.g. Armed Forces Europe (AE).  Default is true.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isPhoneNumber" scope="normal">
        <summary>Validates 10 US digit phone number for several common formats</summary>
        <parameters>
          <parameter name="value" type="String" usage="required">
            <summary>The telephone number string</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isSocialSecurityNumber" scope="normal">
        <summary>Validates social security number</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="isZipCode" scope="normal">
        <summary>Validates U.S. zip-code</summary>
        <parameters>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge"/>
  <object location="dojox.widget.gauge.AnalogLineIndicator" type="Function" classlike="true" superclass="dojox.widget.gauge._Indicator">
    <mixins>
      <mixin scope="instance" location="dojox.widget.gauge._Indicator"/>
    </mixins>
    <properties>
      <property name="text" scope="prototype" type="Object"/>
      <property name="color" scope="prototype" type="String"/>
      <property name="length" scope="prototype" type="Object"/>
      <property name="width" scope="prototype" type="Number"/>
      <property name="offset" scope="prototype" type="Number"/>
      <property name="highlight" scope="prototype" type="String"/>
      <property name="shapes" scope="prototype" type="Object"/>
      <property name="currentValue" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getShapes" scope="prototype">
        <summary>Private function for generating the shapes for this indicator. An indicator that behaves the
	same might override this one and simply replace the shapes (such as ArrowIndicator).</summary>
      </method>
      <method name="draw" scope="prototype">
        <summary>Override of dojox.widget.gauge._Indicator.draw</summary>
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <summary>Indicates if the drawing should not be animated (vs. the default of doing an animation)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_move" scope="prototype">
        <summary>Moves this indicator (since it's already been drawn once)</summary>
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <summary>Indicates if the drawing should not be animated (vs. the default of doing an animation)</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge.AnalogLineIndicator._gauge" type="">
    <properties>
      <property name="max" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget">
    <summary>A collection of un-categorized widgets, or code not requiring its own package.</summary>
    <description>These are standalone widgets with varying levels of stability. Some are useful,
	some were created for demonstration purposes, and learning tools. The each maintain
	their own .css file (typically dojox/widget/WidgetName/WidgetName.css)</description>
    <properties>
      <property name="CalendarFx" scope="normal" type="Object"/>
      <property name="CalendarViews" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.AnalogGauge" type="Function" classlike="true" superclass="dojox.widget.gauge._Gauge">
    <summary>a gauge built using the dojox.gfx package.</summary>
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.AnalogGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div	dojoType="dojox.widget.AnalogGauge"
	id="testGauge"
	width="300"
	height="200"
	cx=150
	cy=175
	radius=125
	image="gaugeOverlay.png"
	imageOverlay="false"
	imageWidth="280"
	imageHeight="155"
	imageX="12"
	imageY="38"&gt;
	&lt;/div&gt;</description>
    <mixins>
      <mixin scope="instance" location="dojox.widget.gauge._Gauge"/>
    </mixins>
    <properties>
      <property name="startAngle" scope="prototype" type="Number">
        <summary>angle (in degrees) for start of gauge (default is -90)</summary>
      </property>
      <property name="endAngle" scope="prototype" type="Number">
        <summary>angle (in degrees) for end of gauge (default is 90)</summary>
      </property>
      <property name="cx" scope="prototype" type="Number">
        <summary>center of gauge x coordinate (default is gauge width / 2)</summary>
      </property>
      <property name="cy" scope="prototype" type="Number">
        <summary>center of gauge x coordinate (default is gauge height / 2)</summary>
      </property>
      <property name="radius" scope="prototype" type="Number">
        <summary>radius of gauge (default is smaller of cx-25 or cy-25)</summary>
      </property>
      <property name="_defaultIndicator" scope="normal" type="override">
        <summary>of dojox.widget._Gauge._defaultIndicator</summary>
      </property>
      <property name="_oppositeMiddle" scope="prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="_getAngle" scope="prototype">
        <summary>This is a helper function used to determine the angle that represents
	a given value on the gauge</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <summary>A value to be converted to an angle for this gauage.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueForAngle" scope="prototype">
        <summary>This is a helper function used to determie the value represented by a
	given angle on the gauge</summary>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <summary>A angle to be converted to a value for this gauge.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getRadians" scope="prototype">
        <summary>This is a helper function than converts degrees to radians</summary>
        <parameters>
          <parameter name="angle" type="Number" usage="required">
            <summary>An angle, in degrees, to be converted to radians.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getDegrees" scope="prototype">
        <summary>This is a helper function that converts radians to degrees</summary>
        <parameters>
          <parameter name="radians" type="Number" usage="required">
            <summary>An angle, in radians, to be converted to degrees.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <summary>This function is used to draw (or redraw) the gauge.</summary>
        <description>Draws the gauge by drawing the surface, the ranges, and the indicators.</description>
      </method>
      <method name="drawRange" scope="prototype">
        <summary>This function is used to draw (or redraw) a range</summary>
        <description>Draws a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required">
            <summary>A range is a dojox.widget.gauge.Range or an object
	with similar parameters (low, high, hover, etc.).</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getRangeUnderMouse" scope="prototype">
        <summary>Determines which range the mouse is currently over</summary>
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <summary>The event object as received by the mouse handling functions below.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_dragIndicator" scope="prototype">
        <summary>Handles the dragging of an indicator, including moving/re-drawing
	get angle for mouse position</summary>
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.AutoRotator" type="Function" classlike="true" superclass="dojox.widget.Rotator">
    <summary>A rotator that automatically transitions between child nodes.</summary>
    <description>Adds automatic rotating to the dojox.widget.Rotator.  The
	AutoRotator has parameters that control how user input can
	affect the rotator including a suspend when hovering over the
	rotator and pausing when the user manually advances to another
	pane.</description>
    <mixins>
      <mixin scope="instance" location="dojox.widget.Rotator"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="dojox.widget.AutoRotator" duration="3000"&gt;
			&lt;div&gt;
				Pane 1!
			&lt;/div&gt;
			&lt;div duration="5000"&gt;
				Pane 2 with an overrided duration!
			&lt;/div&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="suspendOnHover" scope="prototype" type="boolean">
        <summary>Pause the rotator when the mouse hovers over it.</summary>
      </property>
      <property name="duration" scope="prototype" type="int">
        <summary>The time in milliseconds before transitioning to the next pane.  The
	default value is 4000 (4 seconds).</summary>
      </property>
      <property name="autoStart" scope="prototype" type="boolean">
        <summary>Starts the timer to transition children upon creation.</summary>
      </property>
      <property name="pauseOnManualChange" scope="prototype" type="boolean">
        <summary>Pause the rotator when the pane is changed or a controller's next or
	previous buttons are clicked.</summary>
      </property>
      <property name="cycles" scope="prototype" type="int">
        <summary>Number of cycles before pausing.</summary>
      </property>
      <property name="random" scope="prototype" type="boolean">
        <summary>Determines if the panes should cycle randomly.</summary>
      </property>
      <property name="reverse" scope="prototype" type="boolean">
        <summary>Causes the rotator to rotate in reverse order.</summary>
      </property>
      <property name="playing" scope="prototype" type="bool"/>
      <property name="_resumeDuration" scope="prototype" type="Number"/>
      <property name="_endTime" scope="prototype" type="String"/>
      <property name="_timer" scope="prototype" type="Object"/>
      <property name="_suspended" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>Initializes the timer and connect to the rotator.</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Disconnect the AutoRotator's events.</summary>
      </method>
      <method name="play" scope="prototype">
        <summary>Sets the state to &amp;quot;playing&amp;quot; and schedules the next cycle to run.</summary>
        <parameters>
          <parameter name="skipCycleDecrement" type="boolean" usage="optional"/>
          <parameter name="skipDuration" type="boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="pause" scope="prototype">
        <summary>Sets the state to &amp;quot;not playing&amp;quot; and clears the cycle timer.</summary>
      </method>
      <method name="_now" scope="prototype">
        <summary>Helper function to return the current system time in milliseconds.</summary>
      </method>
      <method name="_resetTimer" scope="prototype">
        <summary>Resets the timer used to schedule the next transition.</summary>
      </method>
      <method name="_cycle" scope="prototype">
        <summary>Cycles the rotator to the next/previous pane.</summary>
        <parameters>
          <parameter name="manual" type="boolean|int" usage="optional"/>
        </parameters>
      </method>
      <method name="onManualChange" scope="prototype">
        <summary>Override the Rotator's onManualChange so we can pause.</summary>
        <parameters>
          <parameter name="action" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge.BarLineIndicator" type="Function" classlike="true" superclass="dojox.widget.gauge._Indicator">
    <mixins>
      <mixin scope="instance" location="dojox.widget.gauge._Indicator"/>
    </mixins>
    <properties>
      <property name="width" scope="prototype" type="Number"/>
      <property name="shapes" scope="prototype" type="Object"/>
      <property name="text" scope="prototype" type="Object"/>
      <property name="color" scope="prototype" type="String"/>
      <property name="length" scope="prototype" type="Object"/>
      <property name="offset" scope="prototype" type="Number"/>
      <property name="highlight" scope="prototype" type="String"/>
      <property name="highlight2" scope="prototype" type="String"/>
      <property name="currentValue" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getShapes" scope="prototype">
        <summary>Private function for generating the shapes for this indicator. An indicator that behaves the
	same might override this one and simply replace the shapes (such as BarIndicator).</summary>
      </method>
      <method name="draw" scope="prototype">
        <summary>Override of dojox.widget.gauge._Indicator.draw</summary>
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <summary>Indicates if the drawing should not be animated (vs. the default of doing an animation)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_move" scope="prototype">
        <summary>Moves this indicator (since it's already been drawn once)</summary>
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <summary>Indicates if the drawing should not be animated (vs. the default of doing an animation)</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge.BarLineIndicator._gauge" type="">
    <properties>
      <property name="max" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.BarGauge" type="Function" classlike="true" superclass="dojox.widget.gauge._Gauge">
    <summary>a bar graph built using the dojox.gfx package.</summary>
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a bar graph component, used to display numerical data in a familiar format.
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.BarGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div 	dojoType="dojox.widget.BarGauge"
	id="testBarGauge"
	barGaugeHeight="55"
	dataY="25"
	dataHeight="25"
	dataWidth="225"&gt;
	&lt;/div&gt;</description>
    <mixins>
      <mixin scope="instance" location="dojox.widget.gauge._Gauge"/>
    </mixins>
    <properties>
      <property name="dataX" scope="prototype" type="Number">
        <summary>x position of data area (default 5)</summary>
      </property>
      <property name="dataY" scope="prototype" type="Number">
        <summary>y position of data area (default 5)</summary>
      </property>
      <property name="dataWidth" scope="prototype" type="Number">
        <summary>width of data area (default is bar graph width - 10)</summary>
      </property>
      <property name="dataHeight" scope="prototype" type="Number">
        <summary>height of data area (default is bar graph width - 10)</summary>
      </property>
      <property name="_defaultIndicator" scope="normal" type="override">
        <summary>of dojox.widget._Gauge._defaultIndicator</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="_getPosition" scope="prototype">
        <summary>This is a helper function used to determine the position that represents
	a given value on the bar graph</summary>
        <parameters>
          <parameter name="value" type="Number" usage="required">
            <summary>A value to be converted to a position for this bar graph.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValueForPosition" scope="prototype">
        <summary>This is a helper function used to determine the value represented by
	a position on the bar graph</summary>
        <parameters>
          <parameter name="pos" type="Number" usage="required">
            <summary>A position to be converted to a value.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <summary>This function is used to draw (or redraw) the bar graph</summary>
        <description>Draws the bar graph by drawing the surface, the ranges, and the indicators.</description>
      </method>
      <method name="drawRange" scope="prototype">
        <summary>This function is used to draw (or redraw) a range</summary>
        <description>Draws a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required">
            <summary>A range is either a dojox.widget.gauge.Range or an object
	with similar parameters (low, high, hover, etc.).</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getRangeUnderMouse" scope="prototype">
        <summary>Determines which range the mouse is currently over</summary>
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <summary>The event object as received by the mouse handling functions below.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_dragIndicator" scope="prototype">
        <summary>Handles the dragging of an indicator, including moving/re-drawing
	get new value based on mouse position</summary>
        <parameters>
          <parameter name="widget" type="Object" usage="required"/>
          <parameter name="event" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._CalendarBase" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>The Root class for all _Calendar extensions</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template to be used to construct the widget.</summary>
      </property>
      <property name="_views" scope="instance-prototype" type="Array">
        <summary>The list of mixin views available on this calendar.</summary>
      </property>
      <property name="useFx" scope="prototype" type="Boolean">
        <summary>Specifies if visual effects should be applied to the widget.
	The default behavior of the widget does not contain any effects.
	The dojox.widget.CalendarFx package is needed for these.</summary>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Boolean">
        <summary>This widget is a container of other widgets, so this is true.</summary>
      </property>
      <property name="value" scope="prototype" type="Date">
        <summary>The currently selected Date</summary>
      </property>
      <property name="footerFormat" scope="prototype" type="String">
        <summary>The date format of the date displayed in the footer.	Can be
	'short', 'medium', and 'long'</summary>
      </property>
      <property name="displayMonth" scope="prototype" type="Object"/>
      <property name="_currentChild" scope="prototype" type="Number"/>
      <property name="_internalValue" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype">
        <summary>Instantiates the mixin views</summary>
      </method>
      <method name="addFx" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="fromNode" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>Set the current date and update the UI.	If the date is disabled, the selection will
	not change, but the display will change to the corresponding month.</summary>
        <parameters>
          <parameter name="value" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="isDisabledDate" scope="prototype">
        <summary>May be overridden to disable certain dates in the calendar e.g. &lt;code&gt;isDisabledDate=dojo.date.locale.isWeekend&lt;/code&gt;</summary>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
      </method>
      <method name="onValueSelected" scope="prototype">
        <summary>A date cell was selected. It may be the same as the previous value.</summary>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="_onDateSelected" scope="prototype">
        <parameters>
          <parameter name="date" type="" usage="required"/>
          <parameter name="formattedValue" type="" usage="required"/>
          <parameter name="force" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onChange" scope="prototype">
        <summary>Called only when the selected date has changed</summary>
        <parameters>
          <parameter name="date" type="Date" usage="required"/>
        </parameters>
      </method>
      <method name="onHeaderClick" scope="prototype">
        <summary>Transitions to the next view.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="goToToday" scope="prototype"/>
      <method name="_transitionVert" scope="prototype">
        <summary>Animates the views to show one and hide another, in a
	vertical direction.
	If 'direction' is 1, then the views slide upwards.
	If 'direction' is -1, the views slide downwards.</summary>
        <parameters>
          <parameter name="direction" type="Number" usage="required"/>
        </parameters>
      </method>
      <method name="_updateTitleStyle" scope="prototype"/>
      <method name="_slideTable" scope="prototype">
        <summary>Animates the horizontal sliding of a table.</summary>
        <parameters>
          <parameter name="widget" type="String" usage="required"/>
          <parameter name="direction" type="Number" usage="required"/>
          <parameter name="callback" type="Function" usage="required"/>
        </parameters>
      </method>
      <method name="_addView" scope="prototype">
        <parameters>
          <parameter name="view" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getClassForDate" scope="prototype">
        <summary>May be overridden to return CSS classes to associate with the date entry for the given dateObject,
	for example to indicate a holiday in specified locale.</summary>
        <parameters>
          <parameter name="dateObject" type="Date" usage="required"/>
          <parameter name="locale" type="String" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_adjustDisplay" scope="prototype">
        <summary>This function overrides the base function defined in dijit.Calendar.
	It changes the displayed years, months and days depending on the inputs.</summary>
        <parameters>
          <parameter name="part" type="String" usage="required"/>
          <parameter name="amount" type="int" usage="required"/>
          <parameter name="noSlide" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._CalendarBase.constraints">
    <properties>
      <property name="min" scope="prototype" type="Object"/>
      <property name="max" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget._CalendarBase.footer" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget._CalendarBase._children" private="true">
    <properties>
      <property name="0" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget._CalendarView" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Base implementation for all view mixins.
	All calendar views should extend this widget.</summary>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="headerClass" scope="prototype" type="String"/>
      <property name="useHeader" scope="prototype" type="Object"/>
      <property name="header" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="cloneClass" scope="prototype">
        <summary>Clones all nodes with the class 'clazz' in a widget</summary>
        <parameters>
          <parameter name="clazz" type="" usage="required"/>
          <parameter name="n" type="" usage="required"/>
          <parameter name="before" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setText" scope="prototype">
        <summary>Sets the text inside a node</summary>
        <parameters>
          <parameter name="node" type="" usage="required"/>
          <parameter name="text" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getHeader" scope="prototype">
        <summary>Returns the header node of a view. If none exists,
	an empty DIV is created and returned.</summary>
      </method>
      <method name="onValueSelected" scope="prototype">
        <parameters>
          <parameter name="date" type="" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="prototype">
        <summary>Adds or subtracts values from a date.
	The unit, e.g. &amp;quot;day&amp;quot;, &amp;quot;month&amp;quot; or &amp;quot;year&amp;quot;, is
	specified in the &amp;quot;datePart&amp;quot; property of the
	calendar view mixin.</summary>
        <parameters>
          <parameter name="date" type="" usage="required"/>
          <parameter name="amount" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onDisplay" scope="prototype">
        <summary>Stub function that can be used to tell a view when it is shown.</summary>
      </method>
      <method name="onBeforeDisplay" scope="prototype">
        <summary>Stub function that can be used to tell a view it is about to be shown.</summary>
      </method>
      <method name="onBeforeUnDisplay" scope="prototype">
        <summary>Stub function that can be used to tell
	a view when it is no longer shown.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._CalendarDay" type="Function" classlike="true">
    <summary>Mixin for the dojox.widget.Calendar which provides
	the standard day-view. A single month is shown at a time.</summary>
    <properties>
      <property name="parent" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.widget._CalendarDayView" type="Function" classlike="true" superclass="dojox.widget._CalendarView">
    <summary>View class for the dojox.widget.Calendar.
	Adds a view showing every day of a single month to the calendar.
	This should not be mixed in directly with dojox.widget._CalendarBase.
	Instead, use dojox.widget._CalendarDay</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarView"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template to be used to construct the widget.</summary>
      </property>
      <property name="datePart" scope="prototype" type="String">
        <summary>Specifies how much to increment the displayed date when the user
	clicks the array button to increment of decrement the view.</summary>
      </property>
      <property name="dayWidth" scope="prototype" type="String">
        <summary>Specifies the type of day name to display.	&amp;quot;narrow&amp;quot; causes just one letter to be shown.</summary>
      </property>
      <property name="_addedFx" scope="prototype" type="Object"/>
      <property name="_lastDate" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Constructs the calendar view.</summary>
      </method>
      <method name="onDisplay" scope="prototype"/>
      <method name="_onDayClick" scope="prototype">
        <summary>Executed when a day value is clicked.</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_populateDays" scope="prototype">
        <summary>Fills the days of the current month.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._CalendarMonthYear" type="Function" classlike="true">
    <summary>Mixin class for adding a view listing all 12
	months of the year to the dojox.widget._CalendarBase</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>Adds a dojox.widget._CalendarMonthView view to the calendar widget.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._CalendarMonthYearView" type="Function" classlike="true" superclass="dojox.widget._CalendarView">
    <summary>A Calendar view listing the 12 months of the year</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarView"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template to be used to construct the widget.</summary>
      </property>
      <property name="datePart" scope="prototype" type="String">
        <summary>Specifies how much to increment the displayed date when the user
	clicks the array button to increment of decrement the view.</summary>
      </property>
      <property name="displayedYears" scope="prototype" type="Number">
        <summary>The number of years to display at once.</summary>
      </property>
      <property name="useHeader" scope="prototype" type="bool"/>
      <property name="monthContainer" scope="prototype" type=""/>
      <property name="yearContainer" scope="prototype" type=""/>
      <property name="_decBtn" scope="prototype" type=""/>
      <property name="_incBtn" scope="prototype" type=""/>
      <property name="_cachedDate" scope="prototype" type="Object"/>
      <property name="_monthNames" scope="prototype" type="Object"/>
      <property name="_displayedYear" scope="prototype" type=""/>
      <property name="_year" scope="prototype" type="Object"/>
      <property name="_month" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getHeader" scope="prototype"/>
      <method name="_getMonthNames" scope="prototype">
        <summary>Returns localized month names</summary>
        <parameters>
          <parameter name="format" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_populateMonths" scope="prototype">
        <summary>Populate the month names using the localized values.</summary>
      </method>
      <method name="_populateYears" scope="prototype">
        <summary>Fills the list of years with a range of 12 numbers, with the current year
	being the 6th number.</summary>
        <parameters>
          <parameter name="year" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSelectedYear" scope="prototype"/>
      <method name="_updateSelectedMonth" scope="prototype"/>
      <method name="_updateSelectedNode" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="filter" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Handles clicks on month names</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onOk" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onCancel" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Calendar2Pane" type="Function" classlike="true" superclass="dojox.widget._CalendarBase">
    <summary>A Calendar withtwo panes, the second one
	containing both month and year</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.widget._CalendarDay.prototype"/>
      <mixin scope="prototype" location="dojox.widget._CalendarMonthYear.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarBase"/>
      <mixin scope="instance" location="dojox.widget._CalendarDay"/>
      <mixin scope="instance" location="dojox.widget._CalendarMonthYear"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.widget.Calendar" type="Function" classlike="true" superclass="dojox.widget._CalendarBase">
    <summary>The standard Calendar. It includes day and month/year views.
	No visual effects are included.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.widget._CalendarDay.prototype"/>
      <mixin scope="prototype" location="dojox.widget._CalendarMonthYear.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarBase"/>
      <mixin scope="instance" location="dojox.widget._CalendarDay"/>
      <mixin scope="instance" location="dojox.widget._CalendarMonthYear"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.widget.DailyCalendar" type="Function" classlike="true" superclass="dojox.widget._CalendarBase">
    <summary>A calendar withonly a daily view.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.widget._CalendarDay.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarBase"/>
      <mixin scope="instance" location="dojox.widget._CalendarDay"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.widget.MonthAndYearlyCalendar" type="Function" classlike="true" superclass="dojox.widget._CalendarBase">
    <summary>A calendar withonly a daily view.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.widget._CalendarMonthYear.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarBase"/>
      <mixin scope="instance" location="dojox.widget._CalendarMonthYear"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.widget._FisheyeFX" type="Function" classlike="true">
    <methods>
      <method constructor="constructor"/>
      <method name="addFx" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="fromNode" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.CalendarFisheye" type="Function" classlike="true" superclass="dojox.widget.Calendar">
    <summary>The standard Calendar. It includes day, month and year views.
	FisheyeLite effects are included.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.widget._FisheyeFX.prototype"/>
      <mixin scope="instance" location="dojox.widget.Calendar"/>
      <mixin scope="instance" location="dojox.widget._FisheyeFX"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.widget._CalendarMonth" type="Function" classlike="true">
    <summary>Mixin class for adding a view listing all 12 months of the year to the
	dojox.widget._CalendarBase</summary>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>Adds a dojox.widget._CalendarMonthView view to the calendar widget.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._CalendarMonthView" type="Function" classlike="true" superclass="dojox.widget._CalendarView">
    <summary>A Calendar view listing the 12 months of the year</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarView"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template to be used to construct the widget.</summary>
      </property>
      <property name="datePart" scope="prototype" type="String">
        <summary>Specifies how much to increment the displayed date when the user
	clicks the array button to increment of decrement the view.</summary>
      </property>
      <property name="headerClass" scope="prototype" type="String">
        <summary>Specifies the CSS class to apply to the header node for this view.</summary>
      </property>
      <property name="_getMonthNames" scope="normal" type=""/>
      <property name="_populateMonths" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Constructs the view</summary>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Handles clicks on month names</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._CalendarMonthView.header" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget._CalendarYear" type="Function" classlike="true">
    <summary>Mixin class for adding a view listing 12 years to the
	dojox.widget._CalendarBase</summary>
    <properties>
      <property name="parent" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>Adds a dojox.widget._CalendarYearView view to the
	dojo.widget._CalendarBase widget.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._CalendarYearView" type="Function" classlike="true" superclass="dojox.widget._CalendarView">
    <summary>A Calendar view listing 12 years</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarView"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template to be used to construct the widget.</summary>
      </property>
      <property name="displayedYears" scope="prototype" type="Number"/>
      <property name="_populateYears" scope="normal" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Constructs the view</summary>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="adjustDate" scope="prototype">
        <summary>Adjusts the value of a date. It moves it by 12 years each time.</summary>
        <parameters>
          <parameter name="date" type="" usage="required"/>
          <parameter name="amount" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>Handles clicks on year values.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Calendar3Pane" type="Function" classlike="true" superclass="dojox.widget._CalendarBase">
    <summary>The Calendar includes day, month and year views.
	No visual effects are included.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.widget._CalendarDay.prototype"/>
      <mixin scope="prototype" location="dojox.widget._CalendarMonth.prototype"/>
      <mixin scope="prototype" location="dojox.widget._CalendarYear.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarBase"/>
      <mixin scope="instance" location="dojox.widget._CalendarDay"/>
      <mixin scope="instance" location="dojox.widget._CalendarMonth"/>
      <mixin scope="instance" location="dojox.widget._CalendarYear"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.widget.MonthlyCalendar" type="Function" classlike="true" superclass="dojox.widget._CalendarBase">
    <summary>A calendar with only a month view.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.widget._CalendarMonth.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarBase"/>
      <mixin scope="instance" location="dojox.widget._CalendarMonth"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.widget.YearlyCalendar" type="Function" classlike="true" superclass="dojox.widget._CalendarBase">
    <summary>A calendar with only a year view.</summary>
    <mixins>
      <mixin scope="prototype" location="dojox.widget._CalendarYear.prototype"/>
      <mixin scope="instance" location="dojox.widget._CalendarBase"/>
      <mixin scope="instance" location="dojox.widget._CalendarYear"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.widget.ColorPicker" type="Function" classlike="true" superclass="dijit.form._FormWidget">
    <summary>a HSV color picker - similar to Photoshop picker</summary>
    <description>Provides an interactive HSV ColorPicker similar to
	PhotoShop's color selction tool. This is an enhanced
	version of the default dijit.ColorPalette, though provides
	no accessibility.</description>
    <mixins>
      <mixin scope="instance" location="dijit.form._FormWidget"/>
    </mixins>
    <examples>
      <example>	var picker = new dojox.widget.ColorPicker({
			// a couple of example toggles:
			animatePoint:false,
			showHsv: false,
			webSafe: false,
			showRgb: false
		});</example>
      <example> 	&lt;!-- markup: --&gt;
	 	&lt;div dojoType="dojox.widget.ColorPicker"&gt;&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="showRgb" scope="prototype" type="Boolean">
        <summary>show/update RGB input nodes</summary>
      </property>
      <property name="showHsv" scope="prototype" type="Boolean">
        <summary>show/update HSV input nodes</summary>
      </property>
      <property name="showHex" scope="prototype" type="Boolean">
        <summary>show/update Hex value field</summary>
      </property>
      <property name="webSafe" scope="prototype" type="Boolean">
        <summary>deprecated? or just use a toggle to show/hide that node, too?</summary>
      </property>
      <property name="animatePoint" scope="prototype" type="Boolean">
        <summary>toggle to use slideTo (true) or just place the cursor (false) on click</summary>
      </property>
      <property name="slideDuration" scope="prototype" type="Integer">
        <summary>time in ms picker node will slide to next location (non-dragging) when animatePoint=true</summary>
      </property>
      <property name="liveUpdate" scope="prototype" type="Boolean">
        <summary>Set to true to fire onChange in an indeterminate way</summary>
      </property>
      <property name="PICKER_HUE_H" scope="prototype" type="int">
        <summary>Height of the hue picker, used to calculate positions</summary>
      </property>
      <property name="PICKER_SAT_VAL_H" scope="prototype" type="int">
        <summary>Height of the 2d picker, used to calculate positions</summary>
      </property>
      <property name="PICKER_SAT_VAL_W" scope="prototype" type="int">
        <summary>Width of the 2d picker, used to calculate positions</summary>
      </property>
      <property name="value" scope="prototype" type="String">
        <summary>Default color for this component. Only hex values are accepted as incoming/returned
	values. Adjust this value with &lt;code&gt;.attr&lt;/code&gt;, eg: dijit.byId(&amp;quot;myPicker&amp;quot;).attr(&amp;quot;value&amp;quot;, &amp;quot;#ededed&amp;quot;);
	to cause the points to adjust and the values to reflect the current color.
	don't change to d.moduleUrl, build won't intern it.</summary>
      </property>
      <property name="_underlay" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_offset" scope="prototype" type="Number"/>
      <property name="_shift" scope="prototype" type="Object"/>
      <property name="_mover" scope="prototype" type="Object"/>
      <property name="_hueMover" scope="prototype" type="Object"/>
      <property name="_started" scope="prototype" type="Object"/>
      <property name="_timer" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_setValueAttr" scope="prototype">
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setColor" scope="prototype">
        <summary>Set a color on a picker. Usually used to set
	initial color as an alternative to passing defaultColor option
	to the constructor.</summary>
        <parameters>
          <parameter name="color" type="String" usage="required"/>
          <parameter name="force" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setTimer" scope="prototype">
        <parameters>
          <parameter name="mover" type="d.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="_clearTimer" scope="prototype">
        <parameters>
          <parameter name="mover" type="d.dnd.Mover" usage="required"/>
        </parameters>
      </method>
      <method name="_setHue" scope="prototype">
        <summary>sets a natural color background for the
	underlay image against closest hue value (full saturation)</summary>
        <parameters>
          <parameter name="h" type="Decimal" usage="required">
            <summary>0..360</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_updateColor" scope="prototype">
        <summary>update the previewNode color, and input values [optional]</summary>
      </method>
      <method name="_colorInputChange" scope="prototype">
        <summary>updates picker position and inputs
	according to rgb, hex or hsv input changes</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValue" scope="prototype">
        <summary>updates the value of the widget
	can cancel reverse onChange by specifying second param</summary>
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
          <parameter name="fireChange" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_updatePickerLocations" scope="prototype">
        <summary>update handles on the pickers acording to color values</summary>
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
        </parameters>
      </method>
      <method name="_updateColorInputs" scope="prototype">
        <summary>updates color inputs that were changed through other inputs
	or by clicking on the picker</summary>
        <parameters>
          <parameter name="col" type="dojox.color.Color" usage="required"/>
        </parameters>
      </method>
      <method name="_setHuePoint" scope="prototype">
        <summary>set the hue picker handle on relative y coordinates</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setPoint" scope="prototype">
        <summary>set our picker point based on relative x/y coordinates
	evt.preventDefault();</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.ColorPicker.colorUnderlay.style" type="">
    <properties>
      <property name="filter" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.colorUnderlay" type="">
    <properties>
      <property name="src" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.rgbNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.hsvNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.hexNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.safePreviewNode.style" type="">
    <properties>
      <property name="visibility" scope="prototype" type="String"/>
      <property name="backgroundColor" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker._shift.picker" type="">
    <properties>
      <property name="x" scope="prototype" type=""/>
      <property name="y" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.valueNode" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.Rval" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.Gval" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.Bval" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.Hval" type="">
    <properties>
      <property name="value" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.Sval" type="">
    <properties>
      <property name="value" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.Vval" type="">
    <properties>
      <property name="value" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.hexCode" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.ColorPicker.previewNode.style" type="">
    <properties>
      <property name="backgroundColor" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.DataPresentation" type="Function" classlike="true">
    <summary>DataPresentation
	A widget that connects to a data store in a simple manner,
	and also provides some additional convenience mechanisms
	for connecting to common data sources without needing to
	explicitly construct a Dojo data store. The widget can then
	present the data in several forms: as a graphical chart,
	as a tabular grid, or as display panels presenting meta-data
	(title, creation information, etc) from the data. The
	widget can also create and manage several of these forms
	in one simple construction.
	Note: this is a first experimental draft and any/all details
	are subject to substantial change in later drafts.</summary>
    <examples>
      <example>var pres = new dojox.data.DataPresentation("myChartNode", {</example>
    </examples>
    <properties>
      <property name="type" scope="prototype" type="String">
        <summary>the type of presentation to be applied at the DOM attach point.
	This can be 'chart', 'legend', 'grid', 'title', 'footer'. The
	default type is 'chart'.</summary>
      </property>
      <property name="chartType" scope="prototype" type="String">
        <summary>the type of chart to display. This can be 'clusteredbars',
	'areas', 'stackedcolumns', 'stackedbars', 'stackedareas',
	'lines', 'hybrid'. The default type is 'bar'.</summary>
      </property>
      <property name="reverse" scope="prototype" type="Boolean">
        <summary>true if the chart independant axis should be reversed.</summary>
      </property>
      <property name="animate" scope="prototype" type="Object">
        <summary>if an object is supplied, then the chart bars or columns will animate
	into place. If the object contains a field 'duration' then the value
	supplied is the duration of the animation in milliseconds, otherwise
	a default duration is used. A boolean value true can alternatively be
	supplied to enable animation with the default duration.
	The default is null (no animation).</summary>
      </property>
      <property name="labelMod" scope="prototype" type="Integer">
        <summary>the frequency of label annotations to be included on the
	independent axis. 1=every label. The default is 1.</summary>
      </property>
      <property name="legendVertical" scope="prototype" type="Boolean">
        <summary>true if the legend should be rendered vertically. The default
	is false (legend rendered horizontally).
	theme: String|Theme
	a theme to use for the chart, or the name of a theme.
	chartNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	chart presentation of the data. Supply only when a chart is
	required and the type is not 'chart'; when the type is
	'chart' this property will be set to the widget attach point.
	legendNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	chart legend for the data. Supply only when a legend is
	required and the type is not 'legend'; when the type is
	'legend' this property will be set to the widget attach point.
	gridNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	grid presentation of the data. Supply only when a grid is
	required and the type is not 'grid'; when the type is
	'grid' this property will be set to the widget attach point.
	titleNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	title for the data. Supply only when a title is
	required and the type is not 'title'; when the type is
	'title' this property will be set to the widget attach point.
	footerNode: String|DomNode
	an optional DOM node or the id of a DOM node to receive a
	footer presentation of the data. Supply only when a footer is
	required and the type is not 'footer'; when the type is
	'footer' this property will be set to the widget attach point.
	chartWidget: Object
	the chart widget, if any
	legendWidget: Object
	the legend widget, if any
	gridWidget: Object
	the grid widget, if any</summary>
      </property>
      <property name="url" scope="prototype" type="Object"/>
      <property name="refreshInterval" scope="prototype" type="Object"/>
      <property name="refreshIntervalPending" scope="prototype" type="Object"/>
      <property name="data" scope="prototype" type="Object"/>
      <property name="preparedstore" scope="prototype" type="Object"/>
      <property name="query" scope="prototype" type="Object"/>
      <property name="queryOptions" scope="prototype" type="Object"/>
      <property name="chartWidget" scope="prototype" type="Object"/>
      <property name="legendWidget" scope="prototype" type="Object"/>
      <property name="gridWidget" scope="prototype" type="Object"/>
      <property name="domNode" scope="instance" type="Object"/>
      <property name="theme" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>The node to attach the data presentation to.
	kwArgs:	Object
	store: Object
	optional data store (see above)
	url: Object
	optional URL to fetch data from (see above)</summary>
          </parameter>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Set up properties and initialize.
	arguments:</summary>
        <parameters>
          <parameter name="node" type="DomNode" usage="required">
            <summary>The node to attach the data presentation to.
	kwArgs:	Object
	store: Object
	optional data store (see above)
	url: Object
	optional URL to fetch data from (see above)</summary>
          </parameter>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setURL" scope="prototype">
        <summary>Sets the URL to fetch data from, and an optional
	refresh interval in milliseconds (0=no refresh)</summary>
        <parameters>
          <parameter name="url" type="String" usage="optional"/>
          <parameter name="refreshInterval" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="setData" scope="prototype">
        <summary>Sets the data to be presented, and an optional
	refresh interval in milliseconds (0=no refresh)</summary>
        <parameters>
          <parameter name="data" type="Object" usage="optional"/>
          <parameter name="refreshInterval" type="Number" usage="optional"/>
        </parameters>
      </method>
      <method name="refresh" scope="prototype">
        <summary>If a URL or data has been supplied, refreshes the
	presented data from the URL or data. If a refresh
	interval is also set, the periodic refresh is
	restarted. If a URL or data was not supplied, this
	method has no effect.</summary>
      </method>
      <method name="cancelRefresh" scope="prototype">
        <summary>Cancels any and all outstanding data refreshes</summary>
      </method>
      <method name="setStore" scope="prototype">
        <parameters>
          <parameter name="store" type="Object" usage="optional"/>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="queryOptions" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="setPreparedStore" scope="prototype">
        <summary>Sets the store and query.</summary>
        <parameters>
          <parameter name="store" type="Object" usage="optional"/>
          <parameter name="query" type="String" usage="optional"/>
          <parameter name="queryOptions" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="getChartWidget" scope="prototype">
        <summary>Returns the chart widget (if any) created if the type
	is &amp;quot;chart&amp;quot; or the &amp;quot;chartNode&amp;quot; property was supplied.</summary>
      </method>
      <method name="getGridWidget" scope="prototype">
        <summary>Returns the grid widget (if any) created if the type
	is &amp;quot;grid&amp;quot; or the &amp;quot;gridNode&amp;quot; property was supplied.</summary>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroys the widget and all components and resources.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.DataPresentation.chartNode">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.DataPresentation.legendNode">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.DataPresentation.gridNode">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.DataPresentation.titleNode">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.DataPresentation.footerNode">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.Dialog" type="Function" classlike="true" superclass="dojox.layout.ContentPane">
    <summary>A Lightbox-like Modal-dialog for HTML Content</summary>
    <description>An HTML-capable Dialog widget with advanced sizing
	options, animated show/hide and other useful options.
	This Dialog is also very easy to apply custom styles to.
	It works identically to a `dijit.Dialog` with several
	additional parameters.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._DialogBase.prototype"/>
      <mixin scope="instance" location="dojox.layout.ContentPane"/>
      <mixin scope="instance" location="dijit._DialogBase"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="sizeToViewport" scope="prototype" type="Boolean">
        <summary>If true, fix the size of the dialog to the Viewport based on
	viewportPadding value rather than the calculated or natural
	stlye. If false, base the size on a passed dimension attribute.
	Eitherway, the viewportPadding value is used if the the content
	extends beyond the viewport size for whatever reason.</summary>
      </property>
      <property name="viewportPadding" scope="prototype" type="Integer">
        <summary>If sizeToViewport=&amp;quot;true&amp;quot;, this is the amount of padding in pixels to leave
	between the dialog border and the viewport edge.
	This value is also used when sizeToViewport=&amp;quot;false&amp;quot; and dimensions exceeded
	by dialog content to ensure dialog does not go outside viewport boundary</summary>
      </property>
      <property name="dimensions" scope="instance-prototype" type="Array">
        <summary>A two-element array of [widht,height] to animate the Dialog to if sizeToViewport=&amp;quot;false&amp;quot;
	Defaults to [300,300]</summary>
      </property>
      <property name="easing" scope="instance-prototype" type="Function|String">
        <summary>An easing function to apply to the sizing animation.</summary>
      </property>
      <property name="sizeDuration" scope="normal" type="Integer">
        <summary>Time (in ms) to use in the Animation for sizing.</summary>
      </property>
      <property name="sizeMethod" scope="prototype" type="String">
        <summary>To be passed to dojox.fx.sizeTo, one of &amp;quot;chain&amp;quot; or &amp;quot;combine&amp;quot; to effect
	the animation sequence.</summary>
      </property>
      <property name="showTitle" scope="prototype" type="Boolean">
        <summary>Toogle to show or hide the Title area. Can only be set at startup.</summary>
      </property>
      <property name="draggable" scope="prototype" type="Boolean">
        <summary>Make the pane draggable. Differs from dijit.Dialog by setting default to false
	simply over-ride the default from dijit.Dialog</summary>
      </property>
      <property name="modal" scope="prototype" type="Boolean">
        <summary>If true, this Dialog instance will be truly modal and prevent closing until
	explicitly told to by calling hide() - Defaults to false to preserve previous
	behaviors.</summary>
      </property>
      <property name="_navIn" scope="prototype" type="Object"/>
      <property name="_navOut" scope="prototype" type="Object"/>
      <property name="_vp" scope="prototype" type="Object"/>
      <property name="containerNode" scope="prototype" type=""/>
      <property name="_sizing" scope="prototype" type="Object"/>
      <property name="_sizingConnect" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setup" scope="prototype">
        <summary>Piggyback on dijit.Dialog's _setup for load-time options, deferred to</summary>
      </method>
      <method name="layout" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setSize" scope="prototype">
        <summary>cache and set our desired end position</summary>
      </method>
      <method name="show" scope="prototype"/>
      <method name="_handleNav" scope="prototype">
        <summary>Handle's showing or hiding the close icon</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_position" scope="prototype">
        <return-types>
          <return-type type="prevent content: from firing this anim #8914"/>
        </return-types>
      </method>
      <method name="_showContent" scope="prototype">
        <summary>Show the inner container after sizing animation</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Dialog._displaysize" private="true">
    <properties>
      <property name="w" scope="prototype" type=""/>
      <property name="h" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.DocTester" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget to run DocTests inside an HTML page.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="doctests" scope="prototype" type="Object"/>
      <property name="tests" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_fillContent" scope="prototype">
        <summary>Overridden from _Templates.js, which actually just takes care of filling the containerNode.</summary>
        <parameters>
          <parameter name="source" type="DomNode" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="runTests" scope="prototype"/>
      <method name="reset" scope="prototype">
        <summary>Reset the DocTester visuals and enable the &amp;quot;Run tests&amp;quot; button again.</summary>
      </method>
      <method name="_unescapeHtml" scope="prototype">
        <summary>Adds escape sequences for special characters in XML: &amp;amp;&amp;lt;&amp;gt;&amp;quot;'</summary>
        <parameters>
          <parameter name="str" type="string" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="string"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.DocTester.containerNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.DocTester.numTestsNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.DocTester.numTestsNokNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.DocTester.numTestsOkNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.DynamicTooltip" type="Function" classlike="true" superclass="dijit.Tooltip">
    <summary>Extention of dijit.Tooltip providing content set via XHR
	request via href param</summary>
    <mixins>
      <mixin scope="instance" location="dijit.Tooltip"/>
    </mixins>
    <properties>
      <property name="hasLoaded" scope="prototype" type="Boolean">
        <summary>false if the contents are yet to be loaded from the HTTP request</summary>
      </property>
      <property name="href" scope="prototype" type="String">
        <summary>location from where to fetch the contents</summary>
      </property>
      <property name="label" scope="prototype" type="String">
        <summary>contents to diplay in the tooltip. Initialized to a loading icon.</summary>
      </property>
      <property name="preventCache" scope="prototype" type="Boolean">
        <summary>Cache content retreived externally</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="_setLoadingLabel" scope="prototype">
        <summary>Changes the tooltip label / contents to loading message, only if
	there's an href param, otherwise acts as normal tooltip</summary>
      </method>
      <method name="_setHrefAttr" scope="prototype">
        <summary>Hook so attr(&amp;quot;href&amp;quot;, ...) works.</summary>
        <description>resets so next show loads new href</description>
        <parameters>
          <parameter name="href" type="String|Uri" usage="required">
            <summary>url to the content you want to show, must be within the same domain as your mainpage</summary>
          </parameter>
        </parameters>
      </method>
      <method name="loadContent" scope="prototype">
        <summary>Download contents of href via XHR and display</summary>
        <description>1. checks if content already loaded
	2. if not, sends XHR to download new data</description>
      </method>
      <method name="refresh" scope="prototype">
        <summary>Allows re-download of contents of href and display
	Useful with preventCache = true</summary>
      </method>
      <method name="open" scope="prototype">
        <summary>Display the tooltip; usually not called directly.</summary>
        <parameters>
          <parameter name="target" type="DomNode" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.DynamicTooltip._connectNodes" type="">
    <properties>
      <property name="0" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.FeedPortlet" type="Function" classlike="true" superclass="dojox.widget.Portlet">
    <summary>A Portlet that loads a XML feed.</summary>
    <description>The feed is displayed as
	an unordered list of links.	When a link is hovered over
	by the mouse, it displays a summary in a tooltip.</description>
    <mixins>
      <mixin scope="instance" location="dojox.widget.Portlet"/>
    </mixins>
    <properties>
      <property name="local" scope="prototype" type="Boolean">
        <summary>Specifies whether the feed is to be loaded from the same domain as the
	page, or a remote domain.	If local is true, then the feed must be an
	Atom feed.	If it is false, it can be an Atom or RSS feed.</summary>
      </property>
      <property name="maxResults" scope="prototype" type="Number">
        <summary>The number of results to display from the feed.</summary>
      </property>
      <property name="url" scope="prototype" type="String">
        <summary>The URL of the feed to load.	If this is different to the domain
	of the HTML page, local should be set to false.</summary>
      </property>
      <property name="openNew" scope="prototype" type="Boolean">
        <summary>If true, when a link is clicked it will open in a new window.
	If false, it will not.</summary>
      </property>
      <property name="showFeedTitle" scope="prototype" type="Object"/>
      <property name="store" scope="prototype" type=""/>
      <property name="_resultList" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="onFeedError" scope="prototype">
        <summary>Called when a feed fails to load successfully.</summary>
      </method>
      <method name="addChild" scope="prototype">
        <parameters>
          <parameter name="child" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getTitle" scope="prototype">
        <summary>Gets the title of a feed item.</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getLink" scope="prototype">
        <summary>Gets the href link of a feed item.</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_getContent" scope="prototype">
        <summary>Gets the summary of a feed item.</summary>
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setUrlAttr" scope="prototype">
        <summary>Sets the URL to load.</summary>
        <parameters>
          <parameter name="url" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype">
        <summary>Loads the widget.</summary>
      </method>
      <method name="load" scope="prototype">
        <summary>Loads the feed.</summary>
      </method>
      <method name="generateResults" scope="prototype">
        <summary>Generates a list of hyperlinks and displays a tooltip
	containing a summary when the mouse hovers over them.</summary>
        <parameters>
          <parameter name="items" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.FeedPortlet.containerNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.ExpandableFeedPortlet" type="Function" classlike="true" superclass="dojox.widget.FeedPortlet">
    <summary>A FeedPortlet that uses an list of expandable links to display
	a feed.	An icon is placed to the left of each item
	which, when clicked, toggles the visible state
	of the item summary.</summary>
    <mixins>
      <mixin scope="instance" location="dojox.widget.FeedPortlet"/>
    </mixins>
    <properties>
      <property name="onlyOpenOne" scope="prototype" type="Boolean">
        <summary>If true, only a single item can be expanded at any given time.</summary>
      </property>
      <property name="store" scope="prototype" type=""/>
      <property name="_resultList" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="generateResults" scope="prototype">
        <summary>Generates a list of items, and places an icon beside them that
	can be used to show or hide a summary of that item.</summary>
        <parameters>
          <parameter name="items" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.PortletFeedSettings" type="Function" classlike="true" superclass="dojox.widget.PortletSettings">
    <summary>A Settings widget designed to be used with a dojox.widget.FeedPortlet</summary>
    <description>It provides form items that the user can use to change the URL
	for a feed to load into the FeedPortlet.
	There are two forms that it can take.	&lt;br&gt;
	The first is to display a text field, with Load and Cancel buttons,
	which is prepopulated with the enclosing FeedPortlet's URL.
	If a &lt;select&gt; DOM node is used as the source node for this widget,
	it displays a list of predefined URLs that the user can select from
	to load into the enclosing FeedPortlet.</description>
    <mixins>
      <mixin scope="instance" location="dojox.widget.PortletSettings"/>
    </mixins>
    <examples>
      <example>&lt;div dojoType="dojox.widget.PortletFeedSettings"&gt;&lt;/div&gt;</example>
      <example>&lt;select dojoType="dojox.widget.PortletFeedSettings"&gt;
	&lt;option&gt;http://www.dojotoolkit.org/aggregator/rss&lt;/option&gt;
	&lt;option&gt;http://dojocampus.org/content/category/podcast/feed/&lt;/option&gt;
	&lt;/select&gt;</example>
    </examples>
    <properties>
      <property name="class" scope="prototype" type="String"/>
      <property name="urls" scope="prototype" type="Array">
        <summary>An array of JSON object specifying URLs to display in the
	PortletFeedSettings object. Each object contains a 'url' and 'label'
	attribute, e.g.
	[{url:'http:google.com', label:'Google'}, {url:'http://dojotoolkit.org', label: 'Dojo'}]</summary>
      </property>
      <property name="selectedIndex" scope="prototype" type="Number">
        <summary>The selected URL. Defaults to zero.</summary>
      </property>
      <property name="srcNodeRef" scope="prototype" type=""/>
      <property name="text" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype">
        <summary>Sets the portlet associated with this PortletSettings object.</summary>
      </method>
      <method name="_getFeedPortletUrlAttr" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.widget._FileInfoPane" type="Function" classlike="true" superclass="dojox.widget._RollingListPane">
    <summary>a pane to display the information for the currently-selected
	file</summary>
    <mixins>
      <mixin scope="instance" location="dojox.widget._RollingListPane"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template to be used to construct the widget.</summary>
      </property>
      <property name="_messages" scope="prototype" type="Object"/>
      <property name="store" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="onItems" scope="prototype">
        <summary>called after a fetch or load - at this point, this.items should be
	set and loaded.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._FileInfoPane.items" type="">
    <properties>
      <property name="0" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget._FileInfoPane.nameNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget._FileInfoPane.pathNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget._FileInfoPane.sizeNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.FilePicker" type="Function" classlike="true" superclass="dojox.widget.RollingList">
    <summary>a specialized version of RollingList that handles file information
	in a store</summary>
    <mixins>
      <mixin scope="instance" location="dojox.widget.RollingList"/>
    </mixins>
    <properties>
      <property name="className" scope="prototype" type="String"/>
      <property name="pathSeparator" scope="prototype" type="string">
        <summary>Our file separator - it will be guessed if not set</summary>
      </property>
      <property name="topDir" scope="prototype" type="string">
        <summary>The top directory string - it will be guessed if not set</summary>
      </property>
      <property name="parentAttr" scope="prototype" type="string">
        <summary>the attribute to read for finding our parent directory</summary>
      </property>
      <property name="pathAttr" scope="prototype" type="string">
        <summary>the attribute to read for getting the full path of our file</summary>
      </property>
      <property name="preloadItems" scope="prototype" type="boolean">
        <summary>or int
	Set this to a sane number - since we expect to mostly be using the
	dojox.data.FileStore - which doesn't like loading lots of items
	all at once.</summary>
      </property>
      <property name="selectDirectories" scope="prototype" type="boolean">
        <summary>whether or not we allow selection of directories - that is, whether or
	our value can be set to a directory.</summary>
      </property>
      <property name="selectFiles" scope="prototype" type="boolean">
        <summary>whether or not we allow selection of files - that is, we will disable
	the file entries.</summary>
      </property>
      <property name="value" scope="prototype" type=""/>
      <property name="store" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_itemsMatch" scope="prototype">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="getChildItems" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="getPaneForItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="_setPathValueAttr" scope="prototype">
        <parameters>
          <parameter name="path" type="string" usage="required"/>
          <parameter name="resetLastExec" type="boolean" usage="optional"/>
          <parameter name="onSet" type="function" usage="optional"/>
        </parameters>
      </method>
      <method name="_getPathValueAttr" scope="prototype">
        <summary>returns the path value of the given value (or current value
	if not passed a value)</summary>
        <parameters>
          <parameter name="val" type="item" usage="optional"/>
        </parameters>
      </method>
      <method name="_setValue" scope="prototype">
        <summary>internally sets the value and fires onchange</summary>
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.FisheyeList" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Menu similar to the fish eye menu on the Mac OS</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <examples>
      <example>	&lt;div dojoType="FisheyeList"
			itemWidth="40" itemHeight="40"
			itemMaxWidth="150" itemMaxHeight="150"
			orientation="horizontal"
			effectUnits="2"
			itemPadding="10"
			attachEdge="center"
			labelEdge="bottom"&gt;
			&lt;div dojoType="FisheyeListItem"
				id="item1"
				onclick="alert('click on' + this.label + '(from widget id ' + this.widgetId + ')!');"
				label="Item 1"
				iconSrc="images/fisheye_1.png"&gt;
			&lt;/div&gt;
			...
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="snarfChildDomOutput" scope="prototype" type="Object"/>
      <property name="itemWidth" scope="prototype" type="Integer">
        <summary>width of menu item (in pixels) in it's dormant state (when the mouse is far away)</summary>
      </property>
      <property name="itemHeight" scope="prototype" type="Integer">
        <summary>height of menu item (in pixels) in it's dormant state (when the mouse is far away)</summary>
      </property>
      <property name="itemMaxWidth" scope="prototype" type="Integer">
        <summary>width of menu item (in pixels) in it's fully enlarged state (when the mouse is directly over it)</summary>
      </property>
      <property name="itemMaxHeight" scope="prototype" type="Integer">
        <summary>height of menu item (in pixels) in it's fully enlarged state (when the mouse is directly over it)</summary>
      </property>
      <property name="imgNode" scope="prototype" type="Object"/>
      <property name="orientation" scope="prototype" type="String">
        <summary>orientation of the menu, either &amp;quot;horizontal&amp;quot; or &amp;quot;vertical&amp;quot;</summary>
      </property>
      <property name="isFixed" scope="prototype" type="Boolean">
        <summary>toggle to enable additional listener (window scroll) if FisheyeList is in a fixed postion</summary>
      </property>
      <property name="conservativeTrigger" scope="prototype" type="Boolean">
        <summary>if true, don't start enlarging menu items until mouse is over an image;
	if false, start enlarging menu items as the mouse moves near them.</summary>
      </property>
      <property name="effectUnits" scope="prototype" type="Number">
        <summary>controls how much reaction the menu makes, relative to the distance of the mouse from the menu</summary>
      </property>
      <property name="itemPadding" scope="prototype" type="Integer">
        <summary>padding (in pixels) betweeen each menu item</summary>
      </property>
      <property name="attachEdge" scope="prototype" type="String">
        <summary>controls the border that the menu items don't expand past;
	for example, if set to &amp;quot;top&amp;quot;, then the menu items will drop downwards as they expand.
	values
	&amp;quot;center&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;.</summary>
      </property>
      <property name="labelEdge" scope="prototype" type="String">
        <summary>controls were the labels show up in relation to the menu item icons
	values
	&amp;quot;center&amp;quot;, &amp;quot;left&amp;quot;, &amp;quot;right&amp;quot;, &amp;quot;top&amp;quot;, &amp;quot;bottom&amp;quot;.</summary>
      </property>
      <property name="isHorizontal" scope="prototype" type="bool"/>
      <property name="selectedNode" scope="prototype" type="Number"/>
      <property name="isOver" scope="prototype" type="Object"/>
      <property name="hitX1" scope="prototype" type="Number"/>
      <property name="hitY1" scope="prototype" type="Number"/>
      <property name="hitX2" scope="prototype" type="String"/>
      <property name="hitY2" scope="prototype" type="String"/>
      <property name="anchorEdge" scope="prototype" type="Object"/>
      <property name="proximityLeft" scope="prototype" type="Number"/>
      <property name="proximityRight" scope="prototype" type="Number"/>
      <property name="proximityTop" scope="prototype" type="Number"/>
      <property name="proximityBottom" scope="prototype" type="Number"/>
      <property name="children" scope="prototype" type="Object"/>
      <property name="_onMouseMoveHandle" scope="prototype" type="Object"/>
      <property name="_onScrollHandle" scope="prototype" type="Object"/>
      <property name="_onMouseOutHandle" scope="prototype" type="Object"/>
      <property name="_addChildHandle" scope="prototype" type="Object"/>
      <property name="_onResizeHandle" scope="prototype" type="Object"/>
      <property name="itemCount" scope="prototype" type=""/>
      <property name="barWidth" scope="prototype" type="Number"/>
      <property name="barHeight" scope="prototype" type="Number"/>
      <property name="totalWidth" scope="prototype" type="String"/>
      <property name="totalHeight" scope="prototype" type="String"/>
      <property name="timerScale" scope="instance-prototype" type="Number"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype">
        <summary>create our connections and setup our FisheyeList</summary>
      </method>
      <method name="_initializePositioning" scope="prototype"/>
      <method name="_overElement" scope="prototype">
        <summary>Returns whether the mouse is over the passed element.
	Node: Must must be display:block (ie, not a &amp;lt;span&amp;gt;)</summary>
        <parameters>
          <parameter name="node" type="DomNode|String" usage="required"/>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onBodyOut" scope="prototype">
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_setDormant" scope="prototype">
        <summary>called when mouse moves out of menu's range</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already dormant?"/>
        </return-types>
      </method>
      <method name="_setActive" scope="prototype">
        <summary>called when mouse is moved into menu's range</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="already activated?"/>
        </return-types>
      </method>
      <method name="_onMouseMove" scope="prototype">
        <summary>called when mouse is moved</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_onScroll" scope="prototype"/>
      <method name="onResized" scope="prototype"/>
      <method name="_onGridMouseMove" scope="prototype">
        <summary>called when mouse is moved in the vicinity of the menu</summary>
        <parameters>
          <parameter name="x" type="" usage="required"/>
          <parameter name="y" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_paint" scope="prototype"/>
      <method name="_weighAt" scope="prototype">
        <parameters>
          <parameter name="cen" type="Integer" usage="required"/>
          <parameter name="i" type="Integer" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Integer"/>
        </return-types>
      </method>
      <method name="_setItemSize" scope="prototype">
        <parameters>
          <parameter name="p" type="" usage="required"/>
          <parameter name="scale" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_positionElementsFrom" scope="prototype">
        <parameters>
          <parameter name="p" type="" usage="required"/>
          <parameter name="offset" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_positionLabel" scope="prototype">
        <parameters>
          <parameter name="itm" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_calcHitGrid" scope="prototype"/>
      <method name="_toEdge" scope="prototype">
        <parameters>
          <parameter name="inp" type="" usage="required"/>
          <parameter name="def" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_expandSlowly" scope="prototype">
        <summary>slowly expand the image to user specified max size</summary>
      </method>
      <method name="destroyRecursive" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.widget.FisheyeList.EDGE">
    <properties>
      <property name="CENTER" scope="normal" type="Number"/>
      <property name="LEFT" scope="normal" type="Number"/>
      <property name="RIGHT" scope="normal" type="Number"/>
      <property name="TOP" scope="normal" type="Number"/>
      <property name="BOTTOM" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.widget.FisheyeList.domNode.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.FisheyeList.pos">
    <properties>
      <property name="x" scope="prototype" type=""/>
      <property name="y" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.FisheyeListItem" type="Function" classlike="true" superclass="dijit._Widget">
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="iconSrc" scope="prototype" type="String">
        <summary>pathname to image file (jpg, gif, png, etc.) of icon for this menu item</summary>
      </property>
      <property name="label" scope="prototype" type="String">
        <summary>label to print next to the icon, when it is moused-over</summary>
      </property>
      <property name="id" scope="prototype" type="String">
        <summary>will be set to the id of the orginal div element</summary>
      </property>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="parent" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_isNode" scope="prototype">
        <summary>checks to see if wh is actually a node.</summary>
        <parameters>
          <parameter name="wh" type="object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="_hasParent" scope="prototype">
        <summary>returns whether or not node is a child of another node.</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="onMouseOver" scope="prototype">
        <summary>callback when user moves mouse over this menu item
	in conservative mode, don't activate the menu until user mouses over an icon</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onMouseOut" scope="prototype">
        <summary>callback when user moves mouse off of this menu item</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onClick" scope="prototype">
        <summary>user overridable callback when user clicks this menu item</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.FisheyeListItem.imgNode" type="">
    <properties>
      <property name="parentNode" scope="prototype" type=""/>
      <property name="src" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.FisheyeListItem.imgNode.style" type="">
    <properties>
      <property name="filter" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.FisheyeLite" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A Light-weight Fisheye Component, or an exhanced version
	of dojo.fx.Toggler ...</summary>
    <description>A Simple FisheyeList-like widget which (in the interest of
	performance) relies on well-styled content for positioning,
	and natural page layout for rendering.
	use position:absolute/relative nodes to prevent layout
	changes, and use caution when seleting properties to
	scale. Negative scaling works, but some properties
	react poorly to being set to negative values, IE being
	particularly annoying in that regard.
	quirk: uses the domNode as the target of the animation
	unless it finds a node class="fisheyeTarget" in the container
	being turned into a FisheyeLite instance</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <examples>
      <example>	// make all the LI's in a node Fisheye's:
		 dojo.query("#node li").forEach(function(n){
			new dojox.widget.FisheyeLite({},n);
		});</example>
      <example>	new dojox.widget.FisheyeLite({
			properties:{
				// height is literal, width is multiplied
				height:{ end: 200 }, width:2.3
			}
		}, "someNode");
	duationIn: Integer
	The time (in ms) the run the show animation</example>
    </examples>
    <properties>
      <property name="durationIn" scope="prototype" type="Number"/>
      <property name="durationOut" scope="prototype" type="Integer">
        <summary>The Time (in ms) to run the hide animation</summary>
      </property>
      <property name="properties" scope="instance-prototype" type="Object">
        <summary>An object of &amp;quot;property&amp;quot;:scale pairs, or &amp;quot;property&amp;quot;:{} pairs.
	defaults to font-size with a scale of 2.75
	If a named property is an integer or float, the &amp;quot;scale multiplier&amp;quot;
	is used. If the named property is an object, that object is mixed
	into the animation directly. eg: height:{ end:20, units:&amp;quot;em&amp;quot; }</summary>
      </property>
      <property name="units" scope="prototype" type="String">
        <summary>Sometimes, you need to specify a unit. Should be part of
	properties attrib, but was trying to shorthand the logic there</summary>
      </property>
      <property name="_target" scope="prototype" type="Object"/>
      <property name="_runningIn" scope="prototype" type="Object"/>
      <property name="_runningOut" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="easeIn" scope="normal">
        <summary>An easing function to use for the show animation</summary>
      </method>
      <method name="easeOut" scope="normal">
        <summary>An easing function to use for the hide animation</summary>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="show" scope="prototype">
        <summary>Show this Fisheye item.</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Hide this fisheye item on mouse leave</summary>
      </method>
      <method name="_makeAnims" scope="prototype">
        <summary>Pre-generate the animations</summary>
      </method>
      <method name="onClick" scope="prototype">
        <summary>stub function fired when target is clicked
	connect or override to use.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="onSelected" scope="prototype">
        <summary>stub function fired when Fisheye Item is fully visible and
	hovered. connect or override use.</summary>
        <parameters>
          <parameter name="e" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Iterator" type="Function" classlike="true" superclass="dijit.Declaration">
    <mixins>
      <mixin scope="instance" location="dijit.Declaration"/>
    </mixins>
    <properties>
      <property name="constructor" scope="prototype" type="Object"/>
      <property name="start" scope="prototype" type="Number"/>
      <property name="fetchMax" scope="prototype" type="Number"/>
      <property name="attrs" scope="instance-prototype" type="Object"/>
      <property name="defaultValue" scope="prototype" type="String"/>
      <property name="widgetCtor" scope="instance-prototype" type="Object"/>
      <property name="dataValues" scope="prototype" type="Array"/>
      <property name="data" scope="prototype" type="Object"/>
      <property name="store" scope="prototype" type="Object"/>
      <property name="_srcIndex" scope="prototype" type="Number"/>
      <property name="_srcParent" scope="prototype" type="Object"/>
      <property name="children" scope="prototype" type="Array"/>
      <property name="_classes" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="p" type="" usage="required"/>
          <parameter name="s" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setSrcIndex" scope="prototype">
        <parameters>
          <parameter name="s" type="" usage="required"/>
        </parameters>
      </method>
      <method constructor="postscript" name="postscript" scope="prototype">
        <parameters>
          <parameter name="p" type="" usage="required"/>
          <parameter name="s" type="" usage="required"/>
        </parameters>
      </method>
      <method name="clear" scope="prototype"/>
      <method name="update" scope="prototype"/>
      <method name="_addItem" scope="prototype">
        <parameters>
          <parameter name="config" type="Object" usage="required"/>
          <parameter name="idx" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAttrValuesObj" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onDataAvailable" scope="prototype">
        <parameters>
          <parameter name="data" type="" usage="required"/>
        </parameters>
      </method>
      <method name="fetch" scope="prototype">
        <parameters>
          <parameter name="query" type="" usage="required"/>
          <parameter name="start" type="" usage="required"/>
          <parameter name="end" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Iterator.query">
    <properties>
      <property name="name" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.Loader" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>a configurable global xhr-listener to display
	a loading message during running xhr's or to simply provide
	base-level topic to subscribe to for custom loading messages</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="loadIcon" scope="prototype" type="String">
        <summary>location to the icon used.</summary>
      </property>
      <property name="loadMessage" scope="prototype" type="String">
        <summary>string to use for progress loading</summary>
      </property>
      <property name="hasVisuals" scope="prototype" type="Boolean">
        <summary>true to display a fixed loading message in TR cornder, false to unly provide
	&amp;quot;Loader&amp;quot; topic to subscribe to for your own custom loading message.</summary>
      </property>
      <property name="attachToPointer" scope="prototype" type="Object"/>
      <property name="duration" scope="prototype" type="Integer">
        <summary>time in ms to toggle in/out the visual load indicator</summary>
      </property>
      <property name="_offset" scope="prototype" type="Integer">
        <summary>distance in px from the mouse pointer to show attachToPointer avatar</summary>
      </property>
      <property name="_pointerConnect" scope="prototype" type="Object"/>
      <property name="_xhrStart" scope="prototype" type="Object"/>
      <property name="_xhrEnd" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>setup the loader</summary>
      </method>
      <method name="_setMessage" scope="prototype">
        <summary>set's the message in the loader</summary>
        <parameters>
          <parameter name="message" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_putLoader" scope="prototype">
        <summary>place the floating loading element based on mousemove connection position</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_show" scope="prototype">
        <summary>publish and show progress indicator</summary>
      </method>
      <method name="_hide" scope="prototype">
        <summary>publish &amp;quot;xhr ended&amp;quot; and hide progress indicator</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Loader.loadNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.Loader.loadMessageNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.Pager" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A Pager, displaying a list of sized nodes</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="iconPrevious" scope="prototype" type="String">
        <summary>The url of the previous page icon</summary>
      </property>
      <property name="iconNext" scope="prototype" type="String">
        <summary>The url of the next page icon</summary>
      </property>
      <property name="iconPage" scope="prototype" type="Object"/>
      <property name="iconPageActive" scope="prototype" type="Object"/>
      <property name="store" scope="prototype" type="Object">
        <summary>A dojo.data Data store
	data store for items</summary>
      </property>
      <property name="orientation" scope="prototype" type="String">
        <summary>Either &amp;quot;horizontal or &amp;quot;vertical&amp;quot; to define the direction the pages will slide
	or vertical</summary>
      </property>
      <property name="statusPos" scope="prototype" type="String">
        <summary>A string describing where to put the Pager &amp;quot;current page&amp;quot; indicator. Options are
	&amp;quot;leading&amp;quot; or &amp;quot;trailing&amp;quot;. In the case of horiztonal orientation, &amp;quot;leading&amp;quot; indicates
	positioned above the PageItems. In the case of vertical, &amp;quot;leading&amp;quot; indicates &amp;quot;before&amp;quot;.</summary>
      </property>
      <property name="pagerPos" scope="prototype" type="String">
        <summary>TODOC</summary>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <summary>Time in milliseconds to transition the pages</summary>
      </property>
      <property name="itemSpace" scope="prototype" type="Integer">
        <summary>Spacing between items? TODOC</summary>
      </property>
      <property name="resizeChildren" scope="prototype" type="Boolean">
        <summary>TODOC</summary>
      </property>
      <property name="itemClass" scope="prototype" type="String">
        <summary>The full dotted named of a Class to use for the internal Pager Items.</summary>
      </property>
      <property name="itemsPage" scope="prototype" type="Integer">
        <summary>The numbers of items to display in each &amp;quot;Page&amp;quot;</summary>
      </property>
      <property name="items" scope="prototype" type=""/>
      <property name="pagerContainerView" scope="prototype" type=""/>
      <property name="pagerContainerPager" scope="prototype" type=""/>
      <property name="_totalPages" scope="prototype" type="Object"/>
      <property name="iconWidth" scope="prototype" type="Number"/>
      <property name="iconHeight" scope="prototype" type="Number"/>
      <property name="iconsLoaded" scope="prototype" type="Number"/>
      <property name="_iconConnects" scope="prototype" type="Array"/>
      <property name="_toScroll" scope="prototype" type=""/>
      <property name="_currentPage" scope="prototype" type="Number"/>
      <property name="_anim" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_a11yStyle" scope="prototype">
        <summary>top level onfocus/onblur listen to set a class &amp;quot;pagerFocus&amp;quot; on some node
	and remove it onblur</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_handleKey" scope="prototype">
        <summary>Handle keyboard navigation internally</summary>
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_init" scope="prototype">
        <parameters>
          <parameter name="items" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_renderPages" scope="prototype"/>
      <method name="_renderPager" scope="prototype"/>
      <method name="_renderStatus" scope="prototype"/>
      <method name="_pagerSkip" scope="prototype">
        <parameters>
          <parameter name="page" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_pagerNext" scope="prototype"/>
      <method name="_pagerPrevious" scope="prototype"/>
      <method name="onScrollEnd" scope="prototype">
        <summary>Stub Function. Fired after the slide is complete. Override or connect.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Pager.pagerIconNext" type="">
    <properties>
      <property name="width" scope="prototype" type=""/>
      <property name="height" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget._PagerItem" type="Function" classlike="true" superclass="dijit._Widget">
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="resizeChildren" scope="prototype"/>
      <method name="parseChildren" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.widget.PlaceholderMenuItem" type="Function" classlike="true" superclass="dijit.MenuItem">
    <summary>A menu item that can be used as a placeholder.  Set the label
	of this item to a unique key and you can then use it to add new
	items at that location.  This item is not displayed.</summary>
    <mixins>
      <mixin scope="instance" location="dijit.MenuItem"/>
    </mixins>
    <properties>
      <property name="_replaced" scope="prototype" type="bool"/>
      <property name="_replacedWith" scope="prototype" type="Array"/>
      <property name="_isPlaceholder" scope="prototype" type="Object"/>
      <property name="label" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="replace" scope="prototype">
        <summary>replaces this menu item with the given menuItems.  The original
	menu item is not actually removed from the menu - so if you want
	it removed, you must do that explicitly.</summary>
        <return-description>true if the replace happened, false if not</return-description>
        <parameters>
          <parameter name="menuItems" type="dijit.MenuItem[]" usage="required"/>
        </parameters>
      </method>
      <method name="unReplace" scope="prototype">
        <summary>Removes menu items added by calling replace().  It returns the
	array of items that were actually removed (in case you want to
	clean them up later)</summary>
        <return-description>The array of items that were actually removed</return-description>
        <parameters>
          <parameter name="destroy" type="Boolean" usage="optional">
            <summary>Also call destroy on any removed items.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="dijit.MenuItem[]"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.PlaceholderMenuItem.domNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.Portlet" type="Function" classlike="true" superclass="dijit.TitlePane">
    <summary>A container widget that is designed to be contained
	in a dojox.layout.GridContainer. Child widgets can insert
	an icon into the title bar of the Portlet, which when
	clicked, executes the &amp;quot;toggle&amp;quot; method of the child widget.
	A child widget must specify the attribute
	&amp;quot;portletIconClass&amp;quot;, and the optional class
	&amp;quot;portletIconHoverClass&amp;quot;, as well as the
	&amp;quot;toggle&amp;quot; function.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit.TitlePane"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="resizeChildren" scope="prototype" type="Boolean">
        <summary>If true, when the Portlet is resized, any child widgets
	with a 'resize' method have that method called.</summary>
      </property>
      <property name="closable" scope="prototype" type="Boolean">
        <summary>If true, a close button is placed in the title bar,
	and the Portlet can be hidden. If false, the Portlet
	cannot be closed.</summary>
      </property>
      <property name="_parents" scope="prototype" type="Array">
        <summary>An array of all the StackContainer widgets that this Portlet
	is contained in.	These are used to determine if the portlet
	is visible or not.</summary>
      </property>
      <property name="_size" scope="prototype" type="Object">
        <summary>Cache of the previous size of the portlet, used to determine
	if the size has changed and if the child widgets should be
	resized.</summary>
      </property>
      <property name="dragRestriction" scope="prototype" type="Boolean">
        <summary>To remove the drag capability.</summary>
      </property>
      <property name="closeIcon" scope="prototype" type="Object"/>
      <property name="_timer" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="buildRendering" scope="prototype"/>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_placeSettingsWidgets" scope="prototype">
        <summary>Checks all the children to see if they are instances
	of dojox.widget.PortletSettings.	If they are,
	create an icon for them in the title bar which when clicked,
	calls their toggle() method.</summary>
      </method>
      <method name="_createIcon" scope="prototype">
        <summary>creates an icon in the title bar.</summary>
        <parameters>
          <parameter name="clazz" type="" usage="required"/>
          <parameter name="hoverClazz" type="" usage="required"/>
          <parameter name="fn" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onClose" scope="prototype">
        <summary>Hides the portlet. Note that it does not
	persist this, so it is up to the client to
	listen to this method and persist the closed state
	in their own way.</summary>
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSizeChange" scope="prototype">
        <summary>Updates the Portlet size if any other Portlet
	changes its size.</summary>
        <parameters>
          <parameter name="widget" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateSize" scope="prototype">
        <summary>Updates the size of all child widgets.</summary>
      </method>
      <method name="onUpdateSize" scope="prototype">
        <summary>Stub function called when the size is changed.</summary>
      </method>
      <method name="_publish" scope="prototype">
        <summary>Publishes an event that all other portlets listen to.
	This causes them to update their child widgets if their
	size has changed.</summary>
      </method>
      <method name="_onTitleClick" scope="prototype">
        <parameters>
          <parameter name="evt" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addChild" scope="prototype">
        <summary>Adds a child widget to the portlet.</summary>
        <parameters>
          <parameter name="child" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setCss" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.widget.PortletSettings" type="Function" classlike="true" superclass="dijit._Container">
    <summary>A settings widget to be used with a dojox.widget.Portlet.</summary>
    <description>This widget should be placed inside a dojox.widget.Portlet widget.
	It is used to set some preferences for that Portlet.	It is essentially
	a ContentPane, and should contain other widgets and DOM nodes that
	do the real work of setting preferences for the portlet.</description>
    <mixins>
      <mixin scope="prototype" location="dijit.layout.ContentPane.prototype"/>
      <mixin scope="instance" location="dijit._Container"/>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
    </mixins>
    <properties>
      <property name="portletIconClass" scope="prototype" type="String">
        <summary>The CSS class to apply to the icon in the Portlet title bar that is used
	to toggle the visibility of this widget.</summary>
      </property>
      <property name="portletIconHoverClass" scope="prototype" type="String">
        <summary>The CSS class to apply to the icon in the Portlet title bar that is used
	to toggle the visibility of this widget when the mouse hovers over it.</summary>
      </property>
      <property name="portlet" scope="prototype" type=""/>
      <property name="domNode" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Sets the require CSS classes on the widget.</summary>
      </method>
      <method name="_setPortletAttr" scope="prototype">
        <summary>Sets the portlet that encloses this widget.</summary>
        <parameters>
          <parameter name="portlet" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="prototype">
        <summary>Toggles the visibility of this widget.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.PortletDialogSettings" type="Function" classlike="true" superclass="dojox.widget.PortletSettings">
    <summary>A settings widget to be used with a dojox.widget.Portlet, which displays
	the contents of this widget in a dijit.Dialog box.</summary>
    <mixins>
      <mixin scope="instance" location="dojox.widget.PortletSettings"/>
    </mixins>
    <properties>
      <property name="dimensions" scope="instance-prototype" type="Array">
        <summary>The size of the dialog to display.	This defaults to [300, 300]</summary>
      </property>
      <property name="dialog" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toggle" scope="prototype">
        <summary>Shows and hides the Dialog box.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Roller" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A simple widget to take an unordered-list of Text and roll through them</summary>
    <description>The Roller widget takes an unordered-list of items, and converts
	them to a single-area (the size of one list-item, however you so choose
	to style it) and loops continually, fading between items.
	In it's current state, it requires it be created from an unordered (or ordered)
	list, though can contain complex markup.
	You can manipulate the `items` array at any point during the cycle with
	standard array manipulation techniques.
	The class "dojoxRoller" is added to the UL element for styling purposes.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <examples>
      <example>	// create a scroller from a unordered list with id="lister"
		var thinger = new dojox.widget.Roller.Roller({},"lister");</example>
      <example>	// create a scroller from a fixed array, and place in the DOM:
		new dojox.widget.Roller({ items:["one","two","three"] }).placeAt(dojo.body());</example>
      <example>	// add an item:
		dijit.byId("roller").items.push("I am a new Label");</example>
      <example>	// stop a roller from rolling:
		dijit.byId("roller").stop();</example>
    </examples>
    <properties>
      <property name="delay" scope="prototype" type="Integer">
        <summary>Interval between rolls</summary>
      </property>
      <property name="autoStart" scope="prototype" type="Boolean">
        <summary>Toggle to control starup behavior. Call .start() manually
	if set to &lt;code&gt;false&lt;/code&gt;</summary>
      </property>
      <property name="itemSelector" scope="prototype" type="String">
        <summary>A CSS selector to be used by &lt;code&gt;dojo.query&lt;/code&gt; to find the children
	items in this widget. Defaults to &amp;quot;&amp;gt; li&amp;quot;, finding only first-children
	list-items in the list, allowing for embedded lists to occur.</summary>
      </property>
      <property name="durationIn" scope="prototype" type="Integer">
        <summary>Speed (in ms) to apply to the &amp;quot;in&amp;quot; animation (show the node)</summary>
      </property>
      <property name="durationOut" scope="prototype" type="Integer">
        <summary>Speed (in ms) to apply to the &amp;quot;out&amp;quot; animation (hide the showing node)</summary>
      </property>
      <property name="items" scope="prototype" type="Array">
        <summary>If populated prior to instantiation, is used as the Items over the children</summary>
      </property>
      <property name="_idx" scope="prototype" type="Integer">
        <summary>Index of the the currently visible item in the list of items[]</summary>
      </property>
      <property name="domNode" scope="prototype" type=""/>
      <property name="_anim" scope="prototype" type=""/>
      <property name="rolling" scope="prototype" type="bool"/>
      <property name="_timeout" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="makeAnims" scope="prototype">
        <summary>Animation creator function. Need to create an 'in' and 'out'
	Animation stored in _anim Object, which the rest of the widget
	will reuse.</summary>
      </method>
      <method name="_setupConnects" scope="prototype">
        <summary>setup the loop connection logic</summary>
      </method>
      <method name="start" scope="prototype">
        <summary>Starts to Roller looping</summary>
      </method>
      <method name="_run" scope="prototype"/>
      <method name="stop" scope="prototype">
        <summary>Stops the Roller from looping anymore.</summary>
      </method>
      <method name="_set" scope="prototype">
        <summary>Set the Roller to some passed index. If beyond range, go to first.</summary>
        <parameters>
          <parameter name="i" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Roller._roller" private="true">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.RollerSlide" type="Function" classlike="true" superclass="dojox.widget.Roller">
    <summary>An add-on to the Roller to modify animations. This produces
	a slide-from-bottom like effect. See &lt;code&gt;dojox.widget.Roller&lt;/code&gt; for
	full API information.</summary>
    <mixins>
      <mixin scope="instance" location="dojox.widget.Roller"/>
    </mixins>
    <properties>
      <property name="durationOut" scope="prototype" type="Number"/>
      <property name="domNode" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="makeAnims" scope="prototype">
        <summary>Animation creator function. Need to create an 'in' and 'out'
	Animation stored in _anim Object, which the rest of the widget
	will reuse.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._RollerHover" type="Function" classlike="true">
    <summary>A mixin class to provide a way to automate the &amp;quot;stop on hover&amp;quot; functionality.</summary>
    <description>A mixin class used to provide a way to automate a "stop on hover" behavior,
	while still allowing for ambigious subclassing for custom animations.
	Simply mix this class into a `dojox.widget.Roller` variant, and instantiate
	as you would. The hover connection is done automatically.
	The "hover" functionality is as such: Stop rotation while the mouse is over the
	instance, and resume again once leaving. Even if autoStart is disabled, the widget
	will start if a mouse enters and leaves the node in this case.</description>
    <examples>
      <example> dojo.declare("my.Roller", [dojox.widget.RollerSlide, dojox.widget._RollerHover], {});
	 new my.Roller({}, "myList");</example>
    </examples>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.widget._RollingListPane" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <summary>a core pane that can be attached to a RollingList.  All panes
	should extend this one</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="string">
        <summary>our template</summary>
      </property>
      <property name="parentPane" scope="prototype" type="dojox.widget._RollingListPane">
        <summary>The pane that immediately precedes ours</summary>
      </property>
      <property name="store" scope="prototype" type="store">
        <summary>the store we must use</summary>
      </property>
      <property name="items" scope="prototype" type="item[]">
        <summary>an array of (possibly not-yet-loaded) items to display in this.
	If this array is null, then the query and query options are used to
	get the top-level items to use.  This array is also used to watch and
	see if the pane needs to be reloaded (store notifications are handled)
	by the pane</summary>
      </property>
      <property name="query" scope="prototype" type="object">
        <summary>a query to pass to the datastore.  This is only used if items are null</summary>
      </property>
      <property name="queryOptions" scope="prototype" type="object">
        <summary>query options to be passed to the datastore</summary>
      </property>
      <property name="_focusByNode" scope="prototype" type="Object"/>
      <property name="minWidth" scope="prototype" type="integer">
        <summary>the width (in px) for this pane</summary>
      </property>
      <property name="isLoaded" scope="prototype" type="bool"/>
      <property name="onLoadDeferred" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setContentAndScroll" scope="prototype">
        <summary>sets the value of the content and scrolls it into view</summary>
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
          <parameter name="isFakeContent" type="Boolean" usage="optional"/>
        </parameters>
      </method>
      <method name="_updateNodeWidth" scope="prototype">
        <summary>updates the min width of the pane to be minPaneWidth</summary>
        <parameters>
          <parameter name="n" type="" usage="required"/>
          <parameter name="min" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onMinWidthChange" scope="prototype">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setMinWidthAttr" scope="prototype">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="_focusKey" scope="prototype">
        <summary>called when a keypress happens on the widget</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="focus" scope="prototype">
        <summary>sets the focus to this current widget</summary>
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_onShow" scope="prototype">
        <summary>checks that the store is loaded</summary>
      </method>
      <method name="_load" scope="prototype">
        <summary>sets the &amp;quot;loading&amp;quot; message and then kicks off a query asyncronously</summary>
      </method>
      <method name="_doLoadItems" scope="prototype">
        <summary>loads the given items, and then calls the callback when they
	are finished.</summary>
        <parameters>
          <parameter name="items" type="item[]" usage="required"/>
          <parameter name="callback" type="function" usage="required"/>
        </parameters>
      </method>
      <method name="_doQuery" scope="prototype">
        <summary>either runs the query or loads potentially not-yet-loaded items.</summary>
      </method>
      <method name="_hasItem" scope="prototype">
        <summary>returns whether or not the given item is handled by this
	pane</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetItem" scope="prototype">
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="attribute" type="attribute-name-string" usage="required"/>
          <parameter name="oldValue" type="object" usage="required">
            <summary>| array</summary>
          </parameter>
          <parameter name="newValue" type="object" usage="required">
            <summary>| array</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_onNewItem" scope="prototype">
        <parameters>
          <parameter name="newItem" type="item" usage="required"/>
          <parameter name="parentInfo" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_onDeleteItem" scope="prototype">
        <parameters>
          <parameter name="deletedItem" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="onFetchStart" scope="prototype">
        <summary>called before a fetch starts</summary>
      </method>
      <method name="onFetchError" scope="prototype">
        <summary>called when a fetch error occurs.</summary>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onLoadStart" scope="prototype">
        <summary>called before a load starts</summary>
      </method>
      <method name="onLoadError" scope="prototype">
        <summary>called when a load error occurs.</summary>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
        </parameters>
      </method>
      <method name="onItems" scope="prototype">
        <summary>called after a fetch or load - at this point, this.items should be
	set and loaded.  Override this function to &amp;quot;do your stuff&amp;quot;</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._RollingListPane.parentWidget" type="dojox.widget.RollingList">
    <summary>Our rolling list widget</summary>
    <properties>
      <property name="_focusedPane" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget._RollingListGroupPane" type="Function" classlike="true" superclass="dojox.widget._RollingListPane">
    <summary>a pane that will handle groups (treats them as menu items)</summary>
    <mixins>
      <mixin scope="instance" location="dojox.widget._RollingListPane"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="string">
        <summary>our template</summary>
      </property>
      <property name="_menu" scope="prototype" type="dijit.Menu">
        <summary>The menu that we will call addChild() on for adding items</summary>
      </property>
      <property name="store" scope="prototype" type=""/>
      <property name="_scrollConn" scope="prototype" type="Object"/>
      <property name="_focusByNode" scope="prototype" type="Object"/>
      <property name="_pendingFocus" scope="prototype" type="Object"/>
      <property name="_visibleLoadPending" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_setContent" scope="prototype">
        <parameters>
          <parameter name="cont" type="String|DomNode|Nodelist" usage="required"/>
        </parameters>
      </method>
      <method name="_onMinWidthChange" scope="prototype">
        <parameters>
          <parameter name="v" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onItems" scope="prototype">
        <summary>called after a fetch or load</summary>
      </method>
      <method name="_checkScrollConnection" scope="prototype">
        <summary>checks whether or not we need to connect to our onscroll
	function</summary>
        <parameters>
          <parameter name="doLoad" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="focus" scope="prototype">
        <summary>sets the focus to this current widget</summary>
        <parameters>
          <parameter name="force" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_getMenu" scope="prototype">
        <summary>returns a widget to be used for the container widget.</summary>
      </method>
      <method name="_onScrollPane" scope="prototype">
        <summary>called when the pane has been scrolled - it sets a timeout
	so that we don't try and load our visible items too often during
	a scroll</summary>
      </method>
      <method name="_loadVisibleItems" scope="prototype">
        <summary>loads the items that are currently visible in the pane</summary>
      </method>
      <method name="_getSelected" scope="prototype">
        <summary>returns the selected menu item - or null if none are selected</summary>
        <parameters>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
      <method name="_setSelected" scope="prototype">
        <summary>selectes the given item in the given menu (defaults to pane's menu)</summary>
        <parameters>
          <parameter name="item" type="dijit.MenuItem" usage="optional"/>
          <parameter name="menu" type="dijit.Menu" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget._RollingListGroupPane.containerNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.RollingList" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>a rolling list that can be tied to a data store with children</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template to be used to construct the widget.</summary>
      </property>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="className" scope="prototype" type="string">
        <summary>an additional class (or space-separated classes) to add for our widget</summary>
      </property>
      <property name="store" scope="prototype" type="store">
        <summary>the store we must use</summary>
      </property>
      <property name="query" scope="prototype" type="object">
        <summary>a query to pass to the datastore.  This is only used if items are null</summary>
      </property>
      <property name="queryOptions" scope="prototype" type="object">
        <summary>query options to be passed to the datastore</summary>
      </property>
      <property name="childrenAttrs" scope="prototype" type="String[]">
        <summary>one ore more attributes that holds children of a node</summary>
      </property>
      <property name="parentAttr" scope="prototype" type="string">
        <summary>the attribute to read for finding our parent item (if any)</summary>
      </property>
      <property name="value" scope="prototype" type="item">
        <summary>The value that has been selected</summary>
      </property>
      <property name="executeOnDblClick" scope="prototype" type="boolean">
        <summary>Set to true if you want to call onExecute when an item is
	double-clicked, false if you want to call onExecute yourself. (mainly
	used for popups to control how they want to be handled)</summary>
      </property>
      <property name="preloadItems" scope="prototype" type="boolean">
        <summary>or int
	if set to true, then onItems will be called only *after* all items have
	been loaded (ie store.isLoaded will return true for all of them).  If
	false, then no preloading will occur.  If set to an integer, preloading
	will occur if the number of items is less than or equal to the value
	of the integer.  The onItems function will need to be aware of handling
	items that may not be loaded</summary>
      </property>
      <property name="showButtons" scope="prototype" type="boolean">
        <summary>if set to true, then buttons for &amp;quot;OK&amp;quot; and &amp;quot;Cancel&amp;quot; will be provided</summary>
      </property>
      <property name="okButtonLabel" scope="prototype" type="string">
        <summary>The string to use for the OK button - will use dijit's common &amp;quot;OK&amp;quot; string
	if not set</summary>
      </property>
      <property name="cancelButtonLabel" scope="prototype" type="string">
        <summary>The string to use for the Cancel button - will use dijit's common
	&amp;quot;Cancel&amp;quot; string if not set</summary>
      </property>
      <property name="minPaneWidth" scope="prototype" type="integer">
        <summary>the minimum pane width (in px) for all child panes.  If they are narrower,
	the width will be increased to this value.</summary>
      </property>
      <property name="_declaredClasses" scope="prototype" type="Object"/>
      <property name="_scrollingTimeout" scope="prototype" type="Object"/>
      <property name="buttonsNode" scope="prototype" type=""/>
      <property name="_focusedPane" scope="prototype" type=""/>
      <property name="_setInProgress" scope="prototype" type=""/>
      <property name="_visibleItem" scope="prototype" type=""/>
      <property name="_isIdentity" scope="prototype" type=""/>
      <property name="_lastExecutedValue" scope="prototype" type="Object"/>
      <property name="_savedFocus" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype">
        <summary>Mix in our labels, if they are not set</summary>
      </method>
      <method name="_setShowButtonsAttr" scope="prototype">
        <summary>Sets the visibility of the buttons for the widget</summary>
        <parameters>
          <parameter name="doShow" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_itemsMatch" scope="prototype">
        <parameters>
          <parameter name="item1" type="item" usage="required"/>
          <parameter name="item2" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_removeAfter" scope="prototype">
        <summary>removes all widgets after the given widget (or index)</summary>
        <parameters>
          <parameter name="idx" type="Widget" usage="required">
            <summary>or int</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addChild" scope="prototype">
        <summary>adds a child to this rolling list - if passed an insertIndex,
	then all children from that index on will be removed and destroyed
	before adding the child.</summary>
        <parameters>
          <parameter name="widget" type="dijit._Widget" usage="required"/>
          <parameter name="insertIndex" type="int" usage="optional"/>
        </parameters>
      </method>
      <method name="_setMinPaneWidthAttr" scope="prototype">
        <summary>Sets the min pane width of all children</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_updateClass" scope="prototype">
        <summary>sets the state of the given node with the given type and options</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
          <parameter name="type" type="String" usage="required"/>
          <parameter name="options" type="Object" usage="optional">
            <summary>an object with key-value-pairs.  The values are boolean, if true,
	the key is added as a class, if false, it is removed.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="scrollIntoView" scope="prototype">
        <summary>scrolls the given widget into view</summary>
        <parameters>
          <parameter name="childWidget" type="dijit._Widget" usage="required"/>
        </parameters>
      </method>
      <method name="resize" scope="prototype">
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="layout" scope="prototype"/>
      <method name="_onChange" scope="prototype">
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setValue" scope="prototype">
        <summary>internally sets the value and fires onchange</summary>
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_setValueAttr" scope="prototype">
        <summary>sets the value of this widget to the given store item</summary>
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="_onItemClick" scope="prototype">
        <summary>internally called when a widget should pop up its child</summary>
        <parameters>
          <parameter name="evt" type="Event" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="_getPaneForItem" scope="prototype">
        <summary>gets the pane for the given item, and mixes in our needed parts
	Returns the pane for the given item (null if the root pane) - after mixing in
	its stuff.</summary>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="_getMenuItemForItem" scope="prototype">
        <summary>returns a widget for the given store item.  The returned
	item will be added to this widget's container widget.  null will
	be passed in for an &amp;quot;empty&amp;quot; item.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
        </parameters>
      </method>
      <method name="_setStore" scope="prototype">
        <summary>sets the store for this widget</summary>
        <parameters>
          <parameter name="store" type="dojo.data.api.Read" usage="required"/>
        </parameters>
      </method>
      <method name="_onKey" scope="prototype">
        <summary>called when a keypress event happens on this widget</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_resetValue" scope="prototype"/>
      <method name="_onCancel" scope="prototype"/>
      <method name="_onExecute" scope="prototype"/>
      <method name="focus" scope="prototype">
        <summary>sets the focus state of this widget</summary>
      </method>
      <method name="handleKey" scope="prototype">
        <summary>handle the key for the given event - called by dropdown
	widgets</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateChildClasses" scope="prototype">
        <summary>Called when a child is added or removed - so that we can
	update the classes for styling the &amp;quot;current&amp;quot; one differently than
	the others</summary>
      </method>
      <method name="startup" scope="prototype"/>
      <method name="getChildItems" scope="prototype">
        <summary>Returns the child items for the given store item</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
        </parameters>
      </method>
      <method name="getMenuItemForItem" scope="prototype">
        <summary>user overridable function to return a widget for the given item
	and its children.</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="parentPane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="getPaneForItem" scope="prototype">
        <summary>user-overridable function to return a pane that corresponds
	to the given item in the store.  It can return null to not add a new pane
	(ie, you are planning on doing something else with it in onItemClick)
	Item is undefined for the root pane, children is undefined for non-group panes</summary>
        <parameters>
          <parameter name="item" type="item" usage="optional"/>
          <parameter name="parentPane" type="dijit._Contained" usage="optional"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="onItemClick" scope="prototype">
        <summary>called when an item is clicked - it receives the store item</summary>
        <parameters>
          <parameter name="item" type="item" usage="required"/>
          <parameter name="pane" type="dijit._Contained" usage="required"/>
          <parameter name="children" type="item[]" usage="optional"/>
        </parameters>
      </method>
      <method name="onExecute" scope="prototype">
        <summary>exists so that popups don't disappear too soon</summary>
      </method>
      <method name="onCancel" scope="prototype">
        <summary>exists so that we can close ourselves if we wish</summary>
      </method>
      <method name="onChange" scope="prototype">
        <summary>called when the value of this widget has changed</summary>
        <parameters>
          <parameter name="value" type="item" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.RollingList.domNode" type="">
    <properties>
      <property name="style" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.Rotator" type="Function" classlike="true">
    <summary>A widget for rotating through child nodes using transitions.</summary>
    <description>A small, fast, extensible, awesome rotator that cycles, with transitions,
	through panes (child nodes) displaying only one at a time and ties into
	controllers used to change state.
	The Rotator does not rely on dijit.  It is designed to be as lightweight
	as possible.  Controllers and transitions have been externalized
	so builds can be as optimized with only the components you want to use.
	For best results, each rotator pane should be the same height and width as
	the Rotator container node and consider setting overflow to hidden.
	While the Rotator will accept any DOM node for a rotator pane, a block
	element or element with display:block is recommended.
	Note: When the Rotator begins, it does not transition the first pane.
	subscribed topics:
	[id]/rotator/control - Controls the Rotator
	Parameters:
	/*string*/ action        - The name of a method of the Rotator to run
	/*anything?*/ args       - One or more arguments to pass to the action
	published topics:
	[id]/rotator/update - Notifies controllers that a pane or state has changed.
	Parameters:
	/*string*/ type          - the type of notification
	/*dojox.widget.Rotator*/ rotator
	- the rotator instance
	/*object?*/ params		 - params
	declarative dojo/method events (per pane):
	onBeforeIn  - Fired before the transition in starts.
	onAfterIn   - Fired after the transition in ends.
	onBeforeOut - Fired before the transition out starts.
	onAfterOut  - Fired after the transition out ends.</description>
    <examples>
      <example>	&lt;div dojoType="dojox.widget.Rotator"&gt;
			&lt;div&gt;Pane 1!&lt;/div&gt;
			&lt;div&gt;Pane 2!&lt;/div&gt;
		&lt;/div&gt;</example>
      <example>	&lt;script type="text/javascript"&gt;
			dojo.require("dojox.widget.rotator.Fade");
		&lt;/script&gt;
		&lt;div dojoType="dojox.widget.Rotator" transition="dojox.widget.rotator.crossFade"&gt;
			&lt;div&gt;Pane 1!&lt;/div&gt;
			&lt;div&gt;Pane 2!&lt;/div&gt;
		&lt;/div&gt;</example>
    </examples>
    <properties>
      <property name="transition" scope="normal" type="string">
        <summary>The name of a function that is passed two panes nodes and a duration,
	then returns a dojo.Animation object. The default value is
	&amp;quot;dojox.widget.rotator.swap&amp;quot;.</summary>
      </property>
      <property name="transitionParams" scope="prototype" type="string">
        <summary>Parameters for the transition. The string is read in and eval'd as an
	object.  If the duration is absent, the default value will be used.</summary>
      </property>
      <property name="panes" scope="prototype" type="array">
        <summary>Array of panes to be created in the Rotator. Each array element
	will be passed as attributes to a dojo.create() call.</summary>
      </property>
      <property name="wfe" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initializes the panes and events.</summary>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Destroys the Rotator and its DOM node.</summary>
      </method>
      <method name="next" scope="prototype">
        <summary>Transitions the Rotator to the next pane.</summary>
      </method>
      <method name="prev" scope="prototype">
        <summary>Transitions the Rotator to the previous pane.</summary>
      </method>
      <method name="go" scope="prototype">
        <summary>Transitions the Rotator to the specified pane index.</summary>
        <parameters>
          <parameter name="p" type="int|string" usage="optional"/>
        </parameters>
      </method>
      <method name="onUpdate" scope="prototype">
        <summary>Send a notification to all controllers with the state of the rotator.</summary>
        <parameters>
          <parameter name="type" type="string" usage="required"/>
          <parameter name="params" type="object" usage="optional"/>
        </parameters>
      </method>
      <method name="_resetWaitForEvent" scope="prototype">
        <summary>If there is a waitForEvent pending, kill it.</summary>
      </method>
      <method name="control" scope="prototype">
        <summary>Dispatches an action, first to this engine, then to the Rotator.</summary>
        <parameters>
          <parameter name="action" type="string" usage="required"/>
        </parameters>
      </method>
      <method name="onManualChange" scope="prototype">
        <summary>Stub function that can be overriden or connected to.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.SortList" type="Function" classlike="true" superclass="dijit.layout._LayoutWidget">
    <summary>A sortable unordered-list with a fixed header for use in dijit.demos.chat
	for demonstration purposes only for now. feel free to make API suggestions
	or fixes.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit.layout._LayoutWidget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="title" scope="prototype" type="String">
        <summary>The title in the header</summary>
      </property>
      <property name="heading" scope="prototype" type="String">
        <summary>In the event a parent container is expecting a title=&amp;quot;&amp;quot; attribute, set it for the parent
	via title, and the title of this widget via heading=&amp;quot;&amp;quot; ... assuming you want different
	titles for each. eg: TabContainer, AccordionContainer, etc.</summary>
      </property>
      <property name="descending" scope="prototype" type="Boolean">
        <summary>Toggle sort order based on this value.</summary>
      </property>
      <property name="selected" scope="prototype" type="Array">
        <summary>A list of the selected &amp;lt;li&amp;gt; nodes at any given time.</summary>
      </property>
      <property name="sortable" scope="prototype" type="Boolean">
        <summary>toggle to enable/disable sorting</summary>
      </property>
      <property name="store" scope="prototype" type="Object"/>
      <property name="key" scope="prototype" type="String"/>
      <property name="baseClass" scope="prototype" type="String"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_selected" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_addItem" scope="prototype">
        <parameters>
          <parameter name="item" type="" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="resize" scope="prototype">
        <summary>do our additional calculations when resize() is called by or in a parent</summary>
      </method>
      <method name="onSort" scope="prototype">
        <summary>sort the data, and style the nodes.</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_set" scope="prototype">
        <summary>set hover state</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_unset" scope="prototype">
        <summary>remove hover state (FIXME: combine with _set?)</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_handleClick" scope="prototype">
        <summary>click listener for data portion of widget. toggle selected state
	of node, and update this.selected array accordingly</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="_updateValues" scope="prototype"/>
      <method name="_sorter" scope="prototype">
        <summary>a basic sort function, use query sort, or keep this?</summary>
        <parameters>
          <parameter name="a" type="" usage="required"/>
          <parameter name="b" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setTitle" scope="prototype">
        <summary>Sets the widget title to a String</summary>
        <parameters>
          <parameter name="title" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="onChanged" scope="prototype">
        <summary>stub function, passes the last changed item, and is fired after current state</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.SortList.bodyWrapper.style" type="">
    <properties>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.SortList.focusNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.Standby" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget designed to act as a Standby/Busy/Disable/Blocking widget to indicate a
	particular DOM node is processing and cannot be clicked on at this time.
	This widget uses absolute positioning to apply the overlay and image.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String">
        <summary>The template string defining out the basics of the widget.  No need for an external
	file.</summary>
      </property>
      <property name="_underlayNode" scope="prototype" type="DOMNode">
        <summary>The node that is the translucent underlay for the
	image that blocks access to the target.</summary>
      </property>
      <property name="_imageNode" scope="prototype" type="DOMNode">
        <summary>The image node where we attach and define the image to display.</summary>
      </property>
      <property name="_centerNode" scope="prototype" type="DOMNode">
        <summary>Which node to use as the center node, the image or the text node.</summary>
      </property>
      <property name="image" scope="prototype" type="String">
        <summary>The URL to the image to center in the overlay.</summary>
      </property>
      <property name="imageText" scope="prototype" type="String">
        <summary>Text for the ALT tag.</summary>
      </property>
      <property name="text" scope="prototype" type="String">
        <summary>Text/HTML to display in the center of the overlay
	This is used if image center is disabled.</summary>
      </property>
      <property name="centerIndicator" scope="prototype" type="String">
        <summary>Property to define if the image and its alt text should be used, or
	a simple Text/HTML node should be used.  Allowable values are 'image'
	and 'text'.
	Default is 'image'.</summary>
      </property>
      <property name="_displayed" scope="prototype" type="Boolean">
        <summary>Flag to indicate if the overlay is displayed or not.</summary>
      </property>
      <property name="_resizeCheck" scope="prototype" type="Object">
        <summary>Handle to interval function that checks the target for changes.</summary>
      </property>
      <property name="color" scope="prototype" type="String">
        <summary>The color to set the overlay.  Should be in #XXXXXX form.
	Default color for the translucent overlay is light gray.</summary>
      </property>
      <property name="duration" scope="prototype" type="integer">
        <summary>Integer defining how long the show and hide effects should take.</summary>
      </property>
      <property name="_started" scope="prototype" type="Boolean">
        <summary>Trap flag to ensure startup only processes once.</summary>
      </property>
      <property name="_parent" scope="prototype" type="DOMNode">
        <summary>Wrapping div for the widget, also used for IE 7 in dealing with the
	zoom issue.</summary>
      </property>
      <property name="zIndex" scope="prototype" type="String">
        <summary>Control that lets you specify if the zIndex for the overlay
	should be auto-computed based off parent zIndex, or should be set
	to a particular value.  This is useful when you want to overlay
	things in digit.Dialogs, you can specify a base zIndex to append from.</summary>
      </property>
      <property name="_ieFixNode" scope="prototype" type="Object"/>
      <property name="_overflowDisabled" scope="prototype" type="Object"/>
      <property name="_oldOverflow" scope="prototype" type="String"/>
      <property name="_oldBodyParentOverflow" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>Over-ride of the basic widget startup function.
	Configures the target node and sets the image to use.</summary>
        <parameters>
          <parameter name="args" type="" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <summary>Function to display the blocking overlay and busy/status icon or text.</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Function to hide the blocking overlay and status icon or text.</summary>
      </method>
      <method name="isVisible" scope="prototype">
        <summary>Helper function so you can test if the widget is already visible or not.</summary>
        <return-description>boolean indicating if the widget is in 'show' state or not.</return-description>
        <return-types>
          <return-type type="boolean"/>
        </return-types>
      </method>
      <method name="onShow" scope="prototype">
        <summary>Event that fires when the display of the Standby completes.</summary>
      </method>
      <method name="onHide" scope="prototype">
        <summary>Event that fires when the display of the Standby completes.</summary>
      </method>
      <method name="uninitialize" scope="prototype">
        <summary>Over-ride to hide the widget, which clears intervals, before cleanup.</summary>
      </method>
      <method name="_size" scope="prototype">
        <summary>Internal function that handles resizing the overlay and
	centering of the image on window resizing.</summary>
      </method>
      <method name="_cloneStyles" scope="prototype">
        <summary>Internal function to clone a set of styles from the target to
	the underlay.</summary>
        <parameters>
          <parameter name="list" type="Array" usage="required">
            <summary>An array of style names to clone.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_fadeIn" scope="prototype">
        <summary>Internal function that does the opacity style fade in animation.</summary>
      </method>
      <method name="_fadeOut" scope="prototype">
        <summary>Internal function that does the opacity style fade out animation.</summary>
      </method>
      <method name="_ignore" scope="prototype">
        <summary>Function to ignore events that occur on the overlay.</summary>
        <parameters>
          <parameter name="event" type="Event" usage="required">
            <summary>The event to halt</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_scrollerWidths" scope="prototype">
        <summary>This function will calculate the size of the vertical and
	horizontaol scrollbars.</summary>
        <return-description>Object of form: {v: Number, h: Number} where v is vertical scrollbar width
	and h is horizontal scrollbar width.</return-description>
      </method>
      <method name="_setTextAttr" scope="prototype">
        <summary>Function to allow widget.attr to set the text displayed in center
	if using text display.</summary>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <summary>The text to set.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setColorAttr" scope="prototype">
        <summary>Function to allow widget.attr to set the color used for the translucent
	div overlay.</summary>
        <parameters>
          <parameter name="c" type="String" usage="required">
            <summary>The color to set the background underlay to in #XXXXXX format..</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setImageTextAttr" scope="prototype">
        <summary>Function to allow widget.attr to set the ALT text text displayed for
	the image (if using image center display).</summary>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <summary>The text to set.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setImageAttr" scope="prototype">
        <summary>Function to allow widget.attr to set the url source for the center image
	text: String
	The url to set for the image.</summary>
        <parameters>
          <parameter name="url" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setCenterIndicatorAttr" scope="prototype">
        <summary>Function to allow widget.attr to set the node used for the center indicator,
	either the image or the text.</summary>
        <parameters>
          <parameter name="indicator" type="String" usage="required">
            <summary>The indicator to use, either 'image' or 'text'.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_disableOverflow" scope="prototype">
        <summary>Function to disable scrollbars on the body.  Only used if the overlay
	targets the body or the document.</summary>
      </method>
      <method name="_enableOverflow" scope="prototype">
        <summary>Function to restore scrollbars on the body.  Only used if the overlay
	targets the body or the document.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Standby._textNode" type="DOMNode" private="true">
    <summary>The div to attach text/HTML in the overlay center item.</summary>
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.Standby.target" type="DOMNode||DOMID(String)||WidgetID(String)">
    <summary>The target to overlay when active.  Can be a widget id, a
	dom id, or a direct node reference.</summary>
    <properties>
      <property name="parentNode" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.Toaster" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Message that slides in from the corner of the screen, used for notifications
	like &amp;quot;new email&amp;quot;.</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="String"/>
      <property name="messageTopic" scope="prototype" type="String">
        <summary>Name of topic; anything published to this topic will be displayed as a message.
	Message format is either String or an object like
	{message: &amp;quot;hello word&amp;quot;, type: &amp;quot;error&amp;quot;, duration: 500}</summary>
      </property>
      <property name="defaultType" scope="prototype" type="String">
        <summary>If message type isn't specified (see &amp;quot;messageTopic&amp;quot; parameter),
	then display message as this type.
	Possible values in messageTypes enumeration (&amp;quot;message&amp;quot;, &amp;quot;warning&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;fatal&amp;quot;)</summary>
      </property>
      <property name="positionDirection" scope="prototype" type="String">
        <summary>Position from which message slides into screen, one of
	[&amp;quot;br-up&amp;quot;, &amp;quot;br-left&amp;quot;, &amp;quot;bl-up&amp;quot;, &amp;quot;bl-right&amp;quot;, &amp;quot;tr-down&amp;quot;, &amp;quot;tr-left&amp;quot;, &amp;quot;tl-down&amp;quot;, &amp;quot;tl-right&amp;quot;]</summary>
      </property>
      <property name="positionDirectionTypes" scope="prototype" type="Array">
        <summary>Possible values for positionDirection parameter</summary>
      </property>
      <property name="duration" scope="prototype" type="Integer">
        <summary>Number of milliseconds to show message</summary>
      </property>
      <property name="slideDuration" scope="prototype" type="Integer">
        <summary>Number of milliseconds for the slide animation, increasing will cause the Toaster
	to slide in more slowly.</summary>
      </property>
      <property name="separator" scope="prototype" type="String">
        <summary>String used to separate messages if consecutive calls are made to setContent before previous messages go away</summary>
      </property>
      <property name="slideAnim" scope="prototype" type="Object"/>
      <property name="_hideTimer" scope="prototype" type="Object"/>
      <property name="_stickyMessage" scope="prototype" type="Object"/>
      <property name="_scrollConnected" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="_handleMessage" scope="prototype">
        <parameters>
          <parameter name="message" type="String|Object" usage="required"/>
        </parameters>
      </method>
      <method name="_capitalize" scope="prototype">
        <parameters>
          <parameter name="w" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="setContent" scope="prototype">
        <summary>sets and displays the given message and show duration</summary>
        <parameters>
          <parameter name="message" type="String|Function" usage="required">
            <summary>the message. If this is a function, it will be called with this toaster widget as the only argument.</summary>
          </parameter>
          <parameter name="messageType" type="String" usage="required">
            <summary>type of message; possible values in messageTypes enumeration (&amp;quot;message&amp;quot;, &amp;quot;warning&amp;quot;, &amp;quot;error&amp;quot;, &amp;quot;fatal&amp;quot;)</summary>
          </parameter>
          <parameter name="duration" type="int" usage="optional">
            <summary>duration in milliseconds to display message before removing it. Widget has default value.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_setContent" scope="prototype">
        <parameters>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_cancelHideTimer" scope="prototype"/>
      <method name="_setHideTimer" scope="prototype">
        <parameters>
          <parameter name="duration" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_placeClip" scope="prototype"/>
      <method name="onSelect" scope="prototype">
        <summary>callback for when user clicks the message</summary>
        <parameters>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <summary>show the Toaster</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>hide the Toaster</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Toaster.messageTypes" type="Enumeration">
    <summary>Possible message types.</summary>
    <properties>
      <property name="MESSAGE" scope="normal" type="String"/>
      <property name="WARNING" scope="normal" type="String"/>
      <property name="ERROR" scope="normal" type="String"/>
      <property name="FATAL" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.Toaster.containerNode" type=""/>
  <object location="dojox.widget.Toaster.containerNode.style" type="">
    <properties>
      <property name="left" scope="prototype" type="String"/>
      <property name="top" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.Toaster.contentNode" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.Toaster.clipNode" type="">
    <properties>
      <property name="id" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.widget.Toaster.clipNode.style" type="">
    <properties>
      <property name="height" scope="prototype" type="String"/>
      <property name="width" scope="prototype" type="String"/>
      <property name="top" scope="prototype" type="String"/>
      <property name="left" scope="prototype" type="String"/>
      <property name="clip" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.Toaster.bgIframe">
    <properties>
      <property name="iframe" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.Toaster.bgIframe.iframe.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.UpgradeBar" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>Shows a bar at the top of the screen when the user is to
	be notified that they should upgrade their browser or a
	plugin.</summary>
    <description>You can insert custom validations to trigger the UpgradeBar
	to display. An evaluation of 'true' shows the bar (as this
	version *is* less than it should be). Multiple validations
	may be checked, although only the first in the list will be
	displayed.
	Markup and programmatic are supported. Markup is a little
	cleaner, since a majority of the parameters are the HTML
	snippets to be displayed. In markup, the validate code should
	be an expression that will evaluate to true or false. This
	expression is wrapped in a try/catch, so if it blows up, it
	is assumed to be true and trigger the bar.
	In programmtic, a function should be used that returns true
	or false. You would need to use your own try/catch in that.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <examples>
      <example>See tests for examples.</example>
    </examples>
    <properties>
      <property name="notifications" scope="prototype" type="Array">
        <summary>An array of objects that hold the criteria for upgrades.
	message: String
	The message to display in the bar. Can be HTML.
	validate:Function
	The expression to evaluate to determine if the
	bar should show or not. Should be a simple expression
	if used in HTML:
		&amp;lt;div validate=&amp;quot;!google.gears&amp;quot;&amp;gt;
		&amp;lt;div validate=&amp;quot;dojo.isIE&amp;lt;8&amp;quot;&amp;gt;</summary>
      </property>
      <property name="buttonCancel" scope="prototype" type="String">
        <summary>The HTML tip show when hovering over the close button.</summary>
      </property>
      <property name="noRemindButton" scope="prototype" type="String">
        <summary>The text link shown that when clicked, permanently dismisses
	the message (sets a cookie). If this string is blank, this
	link is not displayed.</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_bodyMarginTop" scope="prototype" type="Object"/>
      <property name="_size" scope="prototype" type=""/>
      <property name="_showAnim" scope="prototype" type="Object"/>
      <property name="_hideAnim" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="checkNotifications" scope="prototype">
        <summary>Internal. Go through the notifications Array
	and check for any that evaluate to true.</summary>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="notify" scope="prototype">
        <summary>Triggers the bar to display. An internal function,
	but could ne called externally for fun.</summary>
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="show" scope="prototype">
        <summary>Internal. Shows the bar. Do not call directly.
	Use notify();</summary>
      </method>
      <method name="hide" scope="prototype">
        <summary>Hides the bar. May be called externally.</summary>
      </method>
      <method name="_onDontRemindClick" scope="prototype">
        <summary>Called when user clicks the &amp;quot;do not remind&amp;quot; link.</summary>
      </method>
      <method name="_onCloseEnter" scope="prototype">
        <summary>Called when user hovers over close icon</summary>
      </method>
      <method name="_onCloseLeave" scope="prototype">
        <summary>Called when user stops hovering over close icon</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.Wizard" type="Function" classlike="true" superclass="dijit.layout.StackContainer">
    <summary>A set of panels that display sequentially, typically notating a step-by-step
	procedure like an install</summary>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit.layout.StackContainer"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="nextButtonLabel" scope="prototype" type="String">
        <summary>Label override for the &amp;quot;Next&amp;quot; button.</summary>
      </property>
      <property name="previousButtonLabel" scope="prototype" type="String">
        <summary>Label override for the &amp;quot;Previous&amp;quot; button.</summary>
      </property>
      <property name="cancelButtonLabel" scope="prototype" type="String">
        <summary>Label override for the &amp;quot;Cancel&amp;quot; button.</summary>
      </property>
      <property name="doneButtonLabel" scope="prototype" type="String">
        <summary>Label override for the &amp;quot;Done&amp;quot; button.</summary>
      </property>
      <property name="cancelFunction" scope="prototype" type="Function|String">
        <summary>Name of function to call if user presses cancel button.
	Cancel button is not displayed if function is not specified.</summary>
      </property>
      <property name="hideDisabled" scope="prototype" type="Boolean">
        <summary>If true, disabled buttons are hidden; otherwise, they are assigned the
	&amp;quot;WizardButtonDisabled&amp;quot; CSS class</summary>
      </property>
      <property name="_subscription" scope="prototype" type="Object"/>
      <property name="_started" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postMixInProperties" scope="prototype"/>
      <method name="startup" scope="prototype"/>
      <method name="_checkButtons" scope="prototype"/>
      <method name="_setButtonClass" scope="prototype">
        <parameters>
          <parameter name="button" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_forward" scope="prototype">
        <summary>callback when next button is clicked</summary>
      </method>
      <method name="done" scope="prototype">
        <summary>Finish the wizard's operation</summary>
      </method>
      <method name="destroy" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.widget.Wizard.cancelButton.domNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.Wizard.selectedChildWidget" type="">
    <properties>
      <property name="isLastChild" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.Wizard.doneButton.domNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.Wizard.nextButton.domNode.style" type="">
    <properties>
      <property name="display" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.WizardPane" type="Function" classlike="true" superclass="dijit.layout.ContentPane">
    <summary>A panel in a &lt;code&gt;dojox.widget.Wizard&lt;/code&gt;</summary>
    <description>An extended ContentPane with additional hooks for passing named
	functions to prevent the pane from going either forward or
	backwards.</description>
    <mixins>
      <mixin scope="instance" location="dijit.layout.ContentPane"/>
    </mixins>
    <properties>
      <property name="canGoBack" scope="prototype" type="Boolean">
        <summary>If true, then can move back to a previous panel (by clicking the &amp;quot;Previous&amp;quot; button)</summary>
      </property>
      <property name="passFunction" scope="prototype" type="String">
        <summary>Name of function that checks if it's OK to advance to the next panel.
	If it's not OK (for example, mandatory field hasn't been entered), then
	returns an error message (String) explaining the reason.</summary>
      </property>
      <property name="doneFunction" scope="prototype" type="String">
        <summary>Name of function that is run if you press the &amp;quot;Done&amp;quot; button from this panel</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="_onShow" scope="prototype"/>
      <method name="_checkPass" scope="prototype">
        <summary>Called when the user presses the &amp;quot;next&amp;quot; button.
	Calls passFunction to see if it's OK to advance to next panel, and
	if it isn't, then display error.
	Returns true to advance, false to not advance. If passFunction
	returns a string, it is assumed to be a custom error message, and
	is alert()'ed</summary>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="done" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.widget.gauge.AnalogArcIndicator" type="Function" classlike="true" superclass="dojox.widget.gauge.AnalogLineIndicator">
    <mixins>
      <mixin scope="instance" location="dojox.widget.gauge.AnalogLineIndicator"/>
    </mixins>
    <properties>
      <property name="currentValue" scope="prototype" type=""/>
      <property name="color" scope="prototype" type=""/>
      <property name="shapes" scope="prototype" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_createArc" scope="prototype">
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <summary>Override of dojox.widget._Indicator.draw</summary>
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge.AnalogArcIndicator._gauge" type="">
    <properties>
      <property name="max" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.gauge.AnalogArrowIndicator" type="Function" classlike="true" superclass="dojox.widget.gauge.AnalogLineIndicator">
    <mixins>
      <mixin scope="instance" location="dojox.widget.gauge.AnalogLineIndicator"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="_getShapes" scope="prototype">
        <summary>Override of dojox.widget.AnalogLineIndicator._getShapes</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge.AnalogNeedleIndicator" type="Function" classlike="true" superclass="dojox.widget.gauge.AnalogLineIndicator">
    <mixins>
      <mixin scope="instance" location="dojox.widget.gauge.AnalogLineIndicator"/>
    </mixins>
    <properties>
      <property name="color" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getShapes" scope="prototype">
        <summary>Override of dojox.widget.AnalogLineIndicator._getShapes</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge.BarIndicator" type="Function" classlike="true" superclass="dojox.widget.gauge.BarLineIndicator">
    <mixins>
      <mixin scope="instance" location="dojox.widget.gauge.BarLineIndicator"/>
    </mixins>
    <properties>
      <property name="currentValue" scope="prototype" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getShapes" scope="prototype">
        <summary>Override of dojox.widget.BarLineIndicator._getShapes</summary>
      </method>
      <method name="_createShapes" scope="prototype">
        <summary>Creates a shallow copy of the current shapes while adjusting for the new value</summary>
        <parameters>
          <parameter name="val" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_move" scope="prototype">
        <summary>Override of dojox.widget.BarLineIndicator._move to resize the bar (rather than moving it)</summary>
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge.BarIndicator._gauge" type="">
    <properties>
      <property name="max" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.gauge._Gauge" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>a gauge built using the dojox.gfx package.</summary>
    <description>using dojo.gfx (and thus either SVG or VML based on what is supported), this widget
	builds a gauge component, used to display numerical data in a familiar format
	usage:
	this widget is not to be used alone. it is meant to be subclassed, such as
	dojox.widget.BarGauge or dojox.widget.AnalogGauge</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Templated"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="width" scope="prototype" type="The">
        <summary>width of the mark
	length: The length of the mark
	interval: The interval the ticks should be added on
	color: The color of the mark and text
	font: an object with any/all of the following parameters:
	{family: &amp;quot;Helvetica&amp;quot;, style: &amp;quot;italic&amp;quot;, variant: 'small-caps', weight: 'bold', size: &amp;quot;18pt&amp;quot;}</summary>
      </property>
      <property name="height" scope="prototype" type="Number">
        <summary>the height of the gauge (default is 200)</summary>
      </property>
      <property name="background" scope="prototype" type="Object">
        <summary>the color of the background.  This must be an object of one of two forms:
	{'color': 'color-name'}
	OR
	(for a gradient:)
	{'type': 'linear', 'x1': 0, 'x2': 0, 'y1': 0, 'y2': 200, 'colors': [{offset: 0, color:'#C0C0C0'}, {offset: 1, color: '#E0E0E0'}] }</summary>
      </property>
      <property name="min" scope="prototype" type="Number">
        <summary>The minimum value of the gauge.  Normally not set explicitly, as it will be determined by
	the ranges that are added.</summary>
      </property>
      <property name="max" scope="prototype" type="Number">
        <summary>The maximum value of the gauge.  Normally not set explicitly, as it will be determined by
	the ranges that are added.</summary>
      </property>
      <property name="image" scope="prototype" type="String">
        <summary>background image for gauge (default is no image)</summary>
      </property>
      <property name="useRangeStyles" scope="prototype" type="Number">
        <summary>indicates whether to use given css classes (dojoxGaugeRangeXX)
	to determine the color (and other style attributes?) of the ranges
	this value should be the number of dojoxGaugeRange classes that are
	defined, starting at dojoxGaugeRange1 (0 indicates falling to default
	hardcoded colors)</summary>
      </property>
      <property name="useTooltip" scope="prototype" type="Boolean">
        <summary>indicates whether tooltips should be displayed for ranges, indicators, etc.</summary>
      </property>
      <property name="majorTicks" scope="prototype" type="Object">
        <summary>An object representing the tick marks that should be added to the gauge. Major tick marks have a text label
	indicating the value.  The object can have the following attributes (required are marked with a *):
	offset: the distance from the 'center' of the gauge.  Used differently for Analog vs. Bar</summary>
      </property>
      <property name="minorTicks" scope="prototype" type="Object">
        <summary>An object of the same format as majorTicks, indicating where the minor (label-less) marks should be placed
	The font parameter is ignored if provided since minor tick marks have no text label.</summary>
      </property>
      <property name="_defaultIndicator" scope="prototype" type="Objection">
        <summary>Should be overridden by any extending classes and used to indicate what the 'default' indicator is.
	This object is used as the indicator when creating tick marks or when an anonmyous object is passed into
	addIndicator.</summary>
      </property>
      <property name="defaultColors" scope="prototype" type="Array">
        <summary>Set of default colors to color ranges with.</summary>
      </property>
      <property name="surface" scope="prototype" type="Object">
        <summary>The SVG/VML surface that the shapes are drawn on.  Can be accessed/used by indicators to draw themselves</summary>
      </property>
      <property name="hideValues" scope="prototype" type="Boolean">
        <summary>indicates whether the text boxes showing the value of the indicator (as text
	content) should be hidden or shown.  Default is not hidden, aka shown.</summary>
      </property>
      <property name="gaugeContent" scope="prototype" type="Object"/>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="_rangeData" scope="prototype" type="Array"/>
      <property name="_drag" scope="prototype" type="Object"/>
      <property name="_img" scope="prototype" type="Object"/>
      <property name="_overOverlay" scope="prototype" type="bool"/>
      <property name="_lastHover" scope="prototype" type="String"/>
      <property name="ranges" scope="prototype" type="Object"/>
      <property name="indicators" scope="prototype" type="Object"/>
      <property name="_background" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="_setTicks" scope="prototype">
        <summary>internal method used to clear existing tick marks, then add new ones</summary>
        <parameters>
          <parameter name="oldTicks" type="Object" usage="required"/>
          <parameter name="newTicks" type="Object" usage="required"/>
          <parameter name="label" type="Boolean" usage="required"/>
        </parameters>
      </method>
      <method name="setMinorTicks" scope="prototype">
        <summary>Creates and draws the minor tick marks based on the passed object (expecting the same format
	as the minorTicks object documented above)</summary>
        <parameters>
          <parameter name="ticks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="setMajorTicks" scope="prototype">
        <summary>Creates and draws the major tick marks based on the passed object (expecting the same format
	as the majorTicks object documented above)</summary>
        <parameters>
          <parameter name="ticks" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="createSurface" scope="prototype">
        <summary>internal method used by the gauge to create the graphics surface area</summary>
      </method>
      <method name="setBackground" scope="prototype">
        <summary>This method is used to set the background of the gauge after it is created.</summary>
        <description>Sets the background using the given object.  Must be the same 'type' of object
	as the original background argument.</description>
        <parameters>
          <parameter name="background" type="An" usage="required">
            <summary>object in one of the two forms:
	{'color': 'color-name'}
	OR
	(for a gradient:)
	{'type': 'linear', 'colors': [{offset: 0, color:'#C0C0C0'}, {offset: 1, color: '#E0E0E0'}] }
	If background is null or undefined, this will set the fill to this._backgroundDefault</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addRange" scope="prototype">
        <summary>This method is used to add a range to the gauge.</summary>
        <description>Creates a range (colored area on the background of the gauge)
	based on the given arguments.</description>
        <parameters>
          <parameter name="range" type="Object" usage="required">
            <summary>A range is either a dojox.widget.gauge.Range object, or a object
	with similar parameters (low, high, hover, etc.).</summary>
          </parameter>
        </parameters>
      </method>
      <method name="addRanges" scope="prototype">
        <summary>This method is used to add ranges to the gauge.</summary>
        <description>Creates a range (colored area on the background of the gauge)
	based on the given arguments.
	range:
	A range is either a dojox.widget.gauge.Range object, or a object
	with similar parameters (low, high, hover, etc.).</description>
        <parameters>
          <parameter name="ranges" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="addIndicator" scope="prototype">
        <summary>This method is used to add an indicator to the bar graph.</summary>
        <description>This method adds an indicator, such as a tick mark or needle,
	to the bar graph.</description>
        <parameters>
          <parameter name="indicator" type="Object" usage="required">
            <summary>A dojox.widget.gauge._Indicator or an object with similar parameters
	(value, color, offset, etc.).</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeIndicator" scope="prototype">
        <summary>Removes the given indicator from the gauge by calling it's remove function
	and removing it from the local cache.</summary>
        <parameters>
          <parameter name="indicator" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="moveIndicatorToFront" scope="prototype">
        <summary>This function is used to move an indicator the the front (top)
	of the gauge</summary>
        <parameters>
          <parameter name="indicator" type="Object" usage="required">
            <summary>A dojox.widget.gauge._Indicator or an object with similar parameters
	(value, color, offset, etc.).</summary>
          </parameter>
        </parameters>
      </method>
      <method name="drawText" scope="prototype">
        <summary>This function is used draw text onto the gauge.  The text object
	is also returned by the function so that may be removed later
	by calling removeText</summary>
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <summary>The text to be drawn</summary>
          </parameter>
          <parameter name="x" type="Number" usage="required">
            <summary>The x coordinate at which to place the text</summary>
          </parameter>
          <parameter name="y" type="Number" usage="required">
            <summary>The y coordinate at which to place the text
	align?:	String
	Indicates how to align the text
	Valid value is 'right', otherwise text is left-aligned
	vAlign?:	String
	Indicates how to align the text vertically.
	Valid value is 'top', otherwise text is bottom-aligned
	color?:	String
	Indicates the color of the text
	font?:	Object
	A font object, generally of the following format:
	{family: &amp;quot;Helvetica&amp;quot;, style: &amp;quot;italic&amp;quot;, variant: 'small-caps', weight: 'bold', size: &amp;quot;18pt&amp;quot;}</summary>
          </parameter>
          <parameter name="align" type="String" usage="optional"/>
          <parameter name="vAlign" type="String" usage="optional"/>
          <parameter name="color" type="String" usage="optional"/>
          <parameter name="font" type="Object" usage="optional"/>
        </parameters>
      </method>
      <method name="removeText" scope="prototype">
        <summary>Removes a text element from the gauge.</summary>
        <parameters>
          <parameter name="t" type="String" usage="required">
            <summary>The text to remove.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="updateTooltip" scope="prototype">
        <summary>Updates the tooltip for the gauge to display the given text.</summary>
        <parameters>
          <parameter name="txt" type="String" usage="required">
            <summary>The text to put in the tooltip.</summary>
          </parameter>
          <parameter name="e" type="Event" usage="required"/>
        </parameters>
      </method>
      <method name="handleMouseOver" scope="prototype">
        <summary>This is an internal handler used by the gauge to support
	hover text</summary>
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <summary>The event object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseOut" scope="prototype">
        <summary>This is an internal handler used by the gauge to support
	hover text</summary>
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <summary>The event object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseDown" scope="prototype">
        <summary>This is an internal handler used by the gauge to support using
	the mouse to drag an indicator to modify it's value</summary>
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <summary>The event object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseUp" scope="prototype">
        <summary>This is an internal handler used by the gauge to support using
	the mouse to drag an indicator to modify it's value</summary>
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <summary>The event object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="handleMouseMove" scope="prototype">
        <summary>This is an internal handler used by the gauge to support using
	the mouse to drag an indicator to modify it's value</summary>
        <parameters>
          <parameter name="event" type="Object" usage="required">
            <summary>The event object</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge._Gauge._backgroundDefault" private="true">
    <properties>
      <property name="color" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.gauge._Gauge.gaugeContent.style" type="">
    <properties>
      <property name="width" scope="prototype" type="String"/>
      <property name="height" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.gauge._Gauge._indicatorData" type="Array" private="true">
    <properties>
      <property name="length" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.widget.gauge.Range" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>a range to be used in a _Gauge</summary>
    <description>a range widget, which has given properties.  drawn by a _Gauge.
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.AnalogGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div	dojoType="dojox.widget.AnalogGauge"
	id="testGauge"
	width="300"
	height="200"
	cx=150
	cy=175
	radius=125
	image="gaugeOverlay.png"
	imageOverlay="false"
	imageWidth="280"
	imageHeight="155"
	imageX="12"
	imageY="38"&gt;
	&lt;div	dojoType="dojox.widget.gauge.Range"
	low=5
	high=10
	hover="5 - 10"
	&gt;&lt;/div&gt;
	&lt;div	dojoType="dojox.widget.gauge.Range"
	low=10
	high=20
	hover="10 - 20"
	&gt;&lt;/div&gt;
	&lt;/div&gt;</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Contained"/>
    </mixins>
    <properties>
      <property name="low" scope="prototype" type="Number">
        <summary>the low value of the range</summary>
      </property>
      <property name="high" scope="prototype" type="Numbe">
        <summary>the high value of the range</summary>
      </property>
      <property name="hover" scope="prototype" type="String">
        <summary>the text to put in the tooltip for the gauge</summary>
      </property>
      <property name="color" scope="prototype" type="Object">
        <summary>the color of the range.  This must be an object of one of two forms:
	{'color': 'color-name'}
	OR
	(for a gradient:)
	{'type': 'linear', 'colors': [{offset: 0, color:'#C0C0C0'}, {offset: 1, color: '#E0E0E0'}] }</summary>
      </property>
      <property name="size" scope="prototype" type="Number">
        <summary>for a circular gauge (such as an AnalogGauge), this dictates the size of the arc</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.widget.gauge._Indicator" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>a indicator to be used in a gauge</summary>
    <description>an indicator widget, which has given properties.  drawn by a gauge.
	usage:
	&lt;script type="text/javascript"&gt;
	dojo.require("dojox.widget.AnalogGauge");
	dojo.require("dijit.util.parser");
	&lt;/script&gt;
	...
	&lt;div	dojoType="dojox.widget.AnalogGauge"
	id="testGauge"
	width="300"
	height="200"
	cx=150
	cy=175
	radius=125
	image="gaugeOverlay.png"
	imageOverlay="false"
	imageWidth="280"
	imageHeight="155"
	imageX="12"
	imageY="38"&gt;
	&lt;div 	dojoType="dojox.widget.gauge.Indicator"
	value=17
	type="arrow"
	length=135
	width=3
	hover="Value: 17"
	onDragMove="handleDragMove"&gt;
	&lt;/div&gt;
	&lt;/div&gt;</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Contained.prototype"/>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Contained"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="value" scope="prototype" type="Number">
        <summary>The value (on the gauge) that this indicator should be placed at</summary>
      </property>
      <property name="type" scope="prototype" type="String">
        <summary>The type of indicator to draw.  Varies by gauge type.  Some examples include
	&amp;quot;line&amp;quot;, &amp;quot;arrow&amp;quot;, and &amp;quot;bar&amp;quot;</summary>
      </property>
      <property name="color" scope="prototype" type="String">
        <summary>The color of the indicator.</summary>
      </property>
      <property name="label" scope="prototype" type="String">
        <summary>The text label for the indicator.</summary>
      </property>
      <property name="length" scope="prototype" type="Number">
        <summary>The length of the indicator.  In the above example, the radius of the AnalogGauge
	is 125, but the length of the indicator is 135, meaning it would project beyond
	the edge of the AnalogGauge</summary>
      </property>
      <property name="width" scope="prototype" type="Number">
        <summary>The width of the indicator.</summary>
      </property>
      <property name="offset" scope="prototype" type="Number">
        <summary>The offset of the indicator</summary>
      </property>
      <property name="hover" scope="prototype" type="String">
        <summary>The string to put in the tooltip when this indicator is hovered over.</summary>
      </property>
      <property name="front" scope="prototype" type="boolean">
        <summary>Keep this indicator at the front</summary>
      </property>
      <property name="easing" scope="prototype" type="String|Object">
        <summary>indicates the easing function to be used when animating the of an indicator.</summary>
      </property>
      <property name="duration" scope="prototype" type="Number">
        <summary>indicates how long an animation of the indicator should take</summary>
      </property>
      <property name="hideValue" scope="prototype" type="bool"/>
      <property name="noChange" scope="prototype" type="Boolean">
        <summary>indicates whether the indicator's value can be changed.  Useful for
	a static target indicator.  Default is false (that the value can be changed).</summary>
      </property>
      <property name="_gauge" scope="prototype" type="Object"/>
      <property name="title" scope="prototype" type="String">
        <summary>The title of the indicator, to be displayed next to it's input box for the text-representation.</summary>
      </property>
      <property name="templateString" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype"/>
      <method name="onDragMove" scope="prototype">
        <summary>Handles updating the text box and the hover text while dragging an indicator</summary>
      </method>
      <method name="postCreate" scope="prototype"/>
      <method name="_update" scope="prototype">
        <summary>A private function, handling the updating of the gauge</summary>
        <parameters>
          <parameter name="event" type="" usage="required"/>
        </parameters>
      </method>
      <method name="update" scope="prototype">
        <summary>Updates the value of the indicator, including moving/re-drawing at it's new location and
	updating the text box</summary>
        <parameters>
          <parameter name="value" type="" usage="required"/>
        </parameters>
      </method>
      <method name="draw" scope="prototype">
        <summary>Performs the initial drawing of the indicator.</summary>
        <parameters>
          <parameter name="dontAnimate" type="Boolean" usage="optional">
            <summary>Indicates if the drawing should not be animated (rather than teh default, to animate)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="remove" scope="prototype">
        <summary>Removes the indicator's shapes from the gauge surface.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.gauge._Indicator.font">
    <summary>Generally in a format similar to:
	{family: &amp;quot;Helvetica&amp;quot;, weight: &amp;quot;bold&amp;quot;, style: &amp;quot;italic&amp;quot;, size: &amp;quot;18pt&amp;quot;, rotated: true}</summary>
    <properties>
      <property name="family" scope="normal" type="String"/>
      <property name="size" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.widget.gauge._Indicator.valueNode" type="">
    <properties>
      <property name="value" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.rotator">
    <properties>
      <property name="Fade" scope="normal" type="Object"/>
      <property name="Pan" scope="normal" type="Object"/>
      <property name="Slide" scope="normal" type="Object"/>
      <property name="Wipe" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="fade" scope="normal">
        <summary>Returns a dojo.Animation that fades out the current pane, then fades in
	the next pane.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="crossFade" scope="normal">
        <summary>Returns a dojo.Animation that cross fades two rotator panes.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="pan" scope="normal">
        <summary>Returns a dojo.Animation that either pans left or right to the next pane.
	The actual direction depends on the order of the panes.
	If panning forward from index 1 to 3, it will perform a pan left. If panning
	backwards from 5 to 1, then it will perform a pan right.
	If the parameter &amp;quot;continuous&amp;quot; is set to true, it will return an animation
	chain of several pan animations of each intermediate pane panning. For
	example, if you pan forward from 1 to 3, it will return an animation panning
	left from 1 to 2 and then 2 to 3.
	If an easing is specified, it will be applied to each pan transition.  For
	example, if you are panning from pane 1 to pane 5 and you set the easing to
	&amp;quot;dojo.fx.easing.elasticInOut&amp;quot;, then it will &amp;quot;wobble&amp;quot; 5 times, once for each
	pan transition.
	If the parameter &amp;quot;wrap&amp;quot; is set to true, it will pan to the next pane using
	the shortest distance in the array of panes. For example, if there are 6
	panes, then panning from 5 to 1 will pan forward (left) from pane 5 to 6 and
	6 to 1.  If the distance is the same either going forward or backwards, then
	it will always pan forward (left).
	A continuous pan will use the target pane's duration to pan all intermediate
	panes.  To use the target's pane duration for each intermediate pane, then
	set the &amp;quot;quick&amp;quot; parameter to &amp;quot;false&amp;quot;.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="continuous gets a linear easing by default"/>
        </return-types>
      </method>
      <method name="panDown" scope="normal">
        <summary>Returns a dojo.Animation that pans in the next rotator pane from the top.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panRight" scope="normal">
        <summary>Returns a dojo.Animation that pans in the next rotator pane from the right.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panUp" scope="normal">
        <summary>Returns a dojo.Animation that pans in the next rotator pane from the bottom.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="panLeft" scope="normal">
        <summary>Returns a dojo.Animation that pans in the next rotator pane from the left.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideDown" scope="normal">
        <summary>Returns a dojo.Animation that slides in the next rotator pane from the top.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideRight" scope="normal">
        <summary>Returns a dojo.Animation that slides in the next rotator pane from the right.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideUp" scope="normal">
        <summary>Returns a dojo.Animation that slides in the next rotator pane from the bottom.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="slideLeft" scope="normal">
        <summary>Returns a dojo.Animation that slides in the next rotator pane from the left.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeDown" scope="normal">
        <summary>Returns a dojo.Animation that wipes in the next rotator pane from the top.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeRight" scope="normal">
        <summary>Returns a dojo.Animation that wipes in the next rotator pane from the right.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeUp" scope="normal">
        <summary>Returns a dojo.Animation that wipes in the next rotator pane from the bottom.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="wipeLeft" scope="normal">
        <summary>Returns a dojo.Animation that wipes in the next rotator pane from the left.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.rotator.Controller" type="Function" classlike="true">
    <summary>A controller that manipulates a Rotator or AutoRotator.</summary>
    <description>Displays a series of controls that send actions to a Rotator or
	AutoRotator.  The Controller supports the following controls:
	* Next pane
	* Previous pane
	* Play/Pause toggler
	* Numbered tabs
	* Titled tabs
	* Information
	You may specify any of these controls in any order.  You may also
	have multiple Controllers tied to a single Rotator instance.
	The Controller's DOM node may also be styled for positioning or
	other styled preferences.</description>
    <examples>
      <example>	&lt;div dojoType="dojox.widget.rotator.Controller"
			rotator="myRotator"
		&gt;&lt;/div&gt;</example>
      <example>	&lt;div dojoType="dojox.widget.rotator.Controller"
			rotator="myRotator"
			controls="prev,#,next"
			class="myCtrl"
		&gt;&lt;/div&gt;</example>
      <example>	&lt;div dojoType="dojox.widget.rotator.Controller"
			rotator="myRotator"
			controls="titles"
			class="myCtrl"
		&gt;&lt;/div&gt;s</example>
    </examples>
    <properties>
      <property name="commands" scope="prototype" type="string">
        <summary>A comma-separated list of commands. Valid commands are:
	prev			An icon button to go to the previous pane.
	next			An icon button to go to the next pane.
	play/pause	A play and pause toggle icon button.
	info			Displays the current and total panes. (ie &amp;quot;1 / 4&amp;quot;)
	#				Displays a number button for each pane. (ie &amp;quot;1 2 3 4&amp;quot;)
	titles		Displays each pane's title as a tab. (ie &amp;quot;Home Services Contact Blog&amp;quot;)</summary>
      </property>
      <property name="_domNode" scope="instance" type="Object"/>
      <property name="_con" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initializes the pager and connect to the rotator.</summary>
        <parameters>
          <parameter name="params" type="Object" usage="required"/>
          <parameter name="node" type="DomNode|string" usage="required"/>
        </parameters>
      </method>
      <method name="destroy" scope="prototype">
        <summary>Disconnect from the rotator.</summary>
      </method>
      <method name="_togglePlay" scope="prototype">
        <summary>Toggles the play/pause button, if it exists.</summary>
        <parameters>
          <parameter name="playing" type="boolean" usage="required"/>
        </parameters>
      </method>
      <method name="_buildInfo" scope="prototype">
        <summary>Return a string containing the current pane number and the total number of panes.</summary>
        <parameters>
          <parameter name="r" type="dojox.widget.Rotator" usage="required"/>
        </parameters>
      </method>
      <method name="_onUpdate" scope="prototype">
        <summary>Updates various pager controls when the rotator updates.</summary>
        <parameters>
          <parameter name="type" type="string" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.widget.rotator.Controller.rotator" type="dojox.widget.Rotator">
    <summary>An instance of a Rotator widget.</summary>
    <properties>
      <property name="playing" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.widget.rotator.Controller._info" type="">
    <properties>
      <property name="innerHTML" scope="prototype" type="Object"/>
    </properties>
  </object>
  <object location="dojox.wire">
    <summary>Declarative data binding and action tags for simplified MVC</summary>
    <properties>
      <property name="_defaultWireClass" scope="normal" type="String"/>
      <property name="_base" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="register" scope="normal">
        <summary>Register a Wire class
	desription:
	The specified Wire class or a class name is registered with
	a key property of arguments to create a Wire</summary>
        <parameters>
          <parameter name="wireClass" type="Function||String" usage="required">
            <summary>A class or full qualified class name</summary>
          </parameter>
          <parameter name="key" type="String" usage="required">
            <summary>A key property of arguments to create a Wire</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getClass" scope="normal">
        <summary>Returns a class</summary>
        <description>The class is loaded by dojo.require() and returned
	by dojo.getObject().</description>
        <return-description>A class</return-description>
        <parameters>
          <parameter name="name" type="String" usage="required">
            <summary>A class name</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Function"/>
        </return-types>
      </method>
      <method name="create" scope="normal">
        <summary>Create a Wire from arguments</summary>
        <description>If 'args' specifies 'wireClass', it is used as a class or full
	qualified class name to create a Wire with 'args' as arguments.
	Otherwise, a Wire class is determined by other proeprties of 'args'
	checking if 'args' specifies a key property for a Wire class.
	If no key property found, the default Wire class is used.</description>
        <return-description>A Wire</return-description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to create a Wire</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="isWire" scope="normal">
        <summary>Check if an object is a Wire</summary>
        <description>If the specified object is a Wire, true is returned.
	Otherwise, false is returned.</description>
        <return-description>True if the object is a Wire, otherwise false</return-description>
        <parameters>
          <parameter name="wire" type="Object" usage="required">
            <summary>An object to check</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="transfer" scope="normal">
        <summary>Transfer a source value to a target value</summary>
        <description>If 'source' and/or 'target' are not Wires, Wires are created with
	them as arguments.
	A value is got through the source Wire and set through the target
	Wire.
	'defaultObject' is passed to Wires as a default root object.
	If 'defaultTargetObject' is specified, it is passed to the target
	Wire as a default root object, instead of 'defaultObject'.</description>
        <parameters>
          <parameter name="source" type="Wire||Object" usage="required">
            <summary>A Wire or arguments to create a Wire for a source value</summary>
          </parameter>
          <parameter name="target" type="Wire||Object" usage="required">
            <summary>A Wire or arguments to create a Wire for a target value</summary>
          </parameter>
          <parameter name="defaultObject" type="Object" usage="optional">
            <summary>defaultTargetObject; Optional default root objects passed to Wires</summary>
          </parameter>
          <parameter name="defaultTargetObject" type="Object" usage="optional"/>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="connect" scope="normal">
        <summary>Transfer a source value to a target value on a trigger event or
	topic</summary>
        <description>If 'trigger' specifies 'topic', the topic is subscribed to transer
	a value on the topic.
	Otherwise, the event specified to 'event' of 'trigger' is listened
	to transfer a value.
	On the specified event or topic, transfer() is called with
	'source', 'target' and the arguments of the event or topic (as
	default root objects).</description>
        <return-description>A connection handle for disconnect()</return-description>
        <parameters>
          <parameter name="trigger" type="Object" usage="required">
            <summary>An event or topic to trigger a transfer</summary>
          </parameter>
          <parameter name="source" type="Wire||Object" usage="required">
            <summary>A Wire or arguments to create a Wire for a source value</summary>
          </parameter>
          <parameter name="target" type="Wire||Object" usage="required">
            <summary>A Wire or arguments to create a Wire for a target value</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="disconnect" scope="normal">
        <summary>Remove a connection or subscription for transfer</summary>
        <description>If 'handle' has 'topic', the topic is unsubscribed.
	Otherwise, the listener to an event is removed.</description>
        <parameters>
          <parameter name="connection" type="Object" usage="required">
            <summary>A connection handle returned by connect()</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.CompositeWire" type="Function" classlike="true" superclass="dojox.wire.Wire">
    <summary>A Wire for composite values in object or array</summary>
    <description>This class has multiple child Wires for object properties or array
	elements.
	When an object with Wires is specified to 'children' property, they
	are used to get or set an object with property values.
	When an array of Wiares is specified to 'children' property, they
	are used to get or set an array with element values.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.Wire"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	children:
	An object or array containing child Wires</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize properties</summary>
        <description>If object properties or array elements specified in 'children'
	property are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	children:
	An object or array containing child Wires</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="prototype">
        <summary>Return an object with property values or an array with element
	values</summary>
        <description>This method calls getValue() method of the child Wires with
	'object' argument and returns an object with the values as
	properties or an arary of the values as elements.</description>
        <return-description>An object or array with values</return-description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required">
            <summary>A root object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type=""/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <summary>Set an object properties or an array elements to an object
	desription:
	This method calls setValues() method of the child Wires with
	a corresponding property or element in 'value' argument and
	'object' argument.</summary>
        <return-description>'object'</return-description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required">
            <summary>A root object</summary>
          </parameter>
          <parameter name="value" type="Object||Array" usage="required">
            <summary>An object or array with values to set</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type=""/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_initializeChildren" scope="prototype">
        <summary>Initialize child Wires</summary>
        <description>If object properties or array elements specified in 'children'
	argument are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="children" type="Object||Array" usage="required">
            <summary>An object or array containing child Wires</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.DataWire" type="Function" classlike="true" superclass="dojox.wire.Wire">
    <summary>A Wire for item attributes of data stores</summary>
    <description>This class accesses item attributes of data stores with a dotted
	notation of attribute names specified to 'attribute' property,
	using data APIs of a data store specified to 'dataStore' property.
	The root object for this class must be an item of the data store.
	Intermediate attribute names in the dotted notation specify
	attributes for child items, which are used for repeated calls to
	data APIs until reached to a descendant attribute.
	Attribute names may have an array index, such as "a[0]", to
	identify an array element of the attribute value.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.Wire"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="prototype" type="String"/>
      <property name="dataStore" scope="instance" type="A">
        <summary>data store
	attribute:
	A dotted notation to a descendant attribute</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize properties</summary>
        <description>If 'dataStore' property is not specified, but 'parent' property
	is specified, 'dataStore' property is copied from the parent.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="prototype">
        <summary>Return an attribute value of an item</summary>
        <description>This method uses a root item passed in 'object' argument and
	'attribute' property to call getValue() method of
	'dataStore'.
	If an attribute name have an array suffix ("[]"), getValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is returned, instead of the array itself.</description>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <summary>A root item</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <summary>Set an attribute value to an item</summary>
        <description>This method uses a root item passed in 'object' argument and
	'attribute' property to identify an item.
	Then, setValue() method of 'dataStore' is called with a leaf
	attribute name and 'value' argument.
	If an attribute name have an array suffix ("[]"), setValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is set to 'value', instead of the array itself.</description>
        <return-description>'object', or 'undefined' for invalid attribute</return-description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <summary>A root item</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>A value to set</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getAttributeValue" scope="prototype">
        <summary>Return an attribute value of an item</summary>
        <description>This method uses an item passed in 'item' argument and
	'attribute' argument to call getValue() method of 'dataStore'.
	If an attribute name have an array suffix ("[]"), getValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is returned, instead of the array itself.</description>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <summary>An item
	attribute
	An attribute name</summary>
          </parameter>
          <parameter name="attribute" type="String" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setAttributeValue" scope="prototype">
        <summary>Set an attribute value to an item</summary>
        <description>This method uses an item passed in 'item' argument and
	'attribute' argument to call setValue() method of 'dataStore'
	with 'value' argument.
	If an attribute name have an array suffix ("[]"), setValues()
	method is called, instead.
	If an index is specified in the array suffix, an array element
	for the index is set to 'value', instead of the array itself.</description>
        <parameters>
          <parameter name="item" type="Object" usage="required">
            <summary>An item</summary>
          </parameter>
          <parameter name="attribute" type="String" usage="required">
            <summary>An attribute name</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>A value to set</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.TableAdapter" type="Function" classlike="true" superclass="dojox.wire.CompositeWire">
    <summary>A composite Wire for table rows</summary>
    <description>This class has multiple child Wires for object properties or array
	elements of a table row.
	The root object for this class must be an array.
	When an object with Wires is specified to 'columns' property, they
	are used to get a row object with property values.
	When an array of Wires is specified to 'columns' property, they
	are used to get a row array with element values.
	The row values are returned in an array.
	This class only supports getValue(), but not setValue().</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.CompositeWire"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	columns:
	An object or array containing child Wires for column values</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize properties</summary>
        <description>If object properties or array elements specified in 'columns'
	property are not Wires, Wires are created from them as
	arguments, with 'parent' property set to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	columns:
	An object or array containing child Wires for column values</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="prototype">
        <summary>Return an array of table row value (object or array)</summary>
        <description>This method iterates over an array specified to 'object'
	argument and calls getValue() method of the child Wires with
	each element of the array to get a row object or array.
	Finally, an array with the row objects or arrays are retuned.</description>
        <return-description>An array of table row value</return-description>
        <parameters>
          <parameter name="object" type="Array" usage="required">
            <summary>A root array</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <summary>Not supported</summary>
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_getRow" scope="prototype">
        <summary>Return an array or object for a table row</summary>
        <description>This method calls getValue() method of the child Wires to
	create a row object or array.</description>
        <return-description>An array or object for a table row</return-description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Array"/>
          <return-type type=""/>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.TextAdapter" type="Function" classlike="true" superclass="dojox.wire.CompositeWire">
    <summary>A composite Wire for a concatenated text</summary>
    <description>This class has multiple child Wires for text segment values.
	Wires in 'segments' property are used to get text segments and
	values are concatenated with an optional delimiter string specified
	to 'delimiter' property.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.CompositeWire"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="prototype" type="String"/>
      <property name="delimiter" scope="instance" type="A">
        <summary>delimiter string</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	segments:
	An array containing child Wires for text segment values</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize properties</summary>
        <description>If array elements specified in 'segments' are not Wires, Wires
	are created from them as arguments, with 'parent' property set
	to this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	segments:
	An array containing child Wires for text segment values</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="prototype">
        <summary>Return a concatenated text</summary>
        <description>This method calls getValue() method of the child Wires wuth
	'object' argument and concatenate the values with 'delimiter'
	property to return.
	arg:
	A root object</description>
        <return-description>A concatinated text</return-description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Object"/>
          <return-type type=""/>
          <return-type type="Array"/>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <summary>Not supported</summary>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required"/>
          <parameter name="value" type="String" usage="required"/>
        </parameters>
      </method>
      <method name="_addSegment" scope="prototype">
        <summary>Return a concatenated text</summary>
        <description>This method add a text segment specified to 'segment' argument
	to a base text specified to 'text', with 'delimiter' property.</description>
        <return-description>A concatinated text</return-description>
        <parameters>
          <parameter name="text" type="String" usage="required">
            <summary>A base text</summary>
          </parameter>
          <parameter name="segment" type="String" usage="required">
            <summary>A text segment to add</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.TreeAdapter" type="Function" classlike="true" superclass="dojox.wire.CompositeWire">
    <summary>A composite Wire for tree nodes</summary>
    <description>This class has multiple child Wires for tree nodes, their title and
	child nodes.
	The root object for this class must be an array.
	'node' Wires in 'nodes' property is used to identify an object
	representing a node.
	'title' Wires in 'nodes' property is used to get the title string
	of a node.
	'children' Wires in 'nodes' property is used to iterate over child
	node objects.
	The node values are returned in an array as follows:
	[
	{title: title1,
	children: [
	{title: title2,
	child: ...},
	{title: title3,
	child: ...},
	...
	]},
	...
	]
	This class only supports getValue(), but not setValue().</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.CompositeWire"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	nodes:
	An array containing objects for child Wires for node values</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize properties</summary>
        <description>If object properties ('node', 'title' and 'children') of array
	elements specified in 'nodes' property are not Wires, Wires are
	created from them as arguments, with 'parent' property set to
	this Wire instance.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	nodes:
	An array containing objects for child Wires for node values</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="prototype">
        <summary>Return an array of tree node values</summary>
        <description>This method iterates over an array specified to 'object'
	argument and calls getValue() method of 'node' Wires with each
	element of the array to get object(s) that represetns nodes.
	(If 'node' Wires are omitted, the array element is used for
	further processing.)
	Then, getValue() method of 'title' Wires are called to get
	title strings for nodes.
	(If 'title' Wires are omitted, the objects representing nodes
	are used as title strings.)
	And if an array of objects with 'node' and 'title' Wires is
	specified to 'children', it is used to gather child nodes and
	their title strings in the same way recursively.
	Finally, an array of the top-level node objects are retuned.</description>
        <return-description>An array of tree node values</return-description>
        <parameters>
          <parameter name="object" type="Array" usage="required">
            <summary>A root array</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <summary>Not supported</summary>
        <parameters>
          <parameter name="object" type="Array" usage="required"/>
          <parameter name="value" type="Array" usage="required"/>
        </parameters>
      </method>
      <method name="_initializeChildren" scope="prototype">
        <summary>Initialize child Wires</summary>
        <description>If 'node' or 'title' properties of array elements specified in
	'children' argument are not Wires, Wires are created from them
	as arguments, with 'parent' property set to this Wire instance.
	If an array element has 'children' property, this method is
	called recursively with it.</description>
        <parameters>
          <parameter name="children" type="Array" usage="required">
            <summary>An array of objects containing child Wires</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getNodes" scope="prototype">
        <summary>Return an array of tree node values</summary>
        <description>This method calls getValue() method of 'node' Wires with
	'object' argument to get object(s) that represents nodes.
	(If 'node' Wires are omitted, 'object' is used for further
	processing.)
	Then, getValue() method of 'title' Wires are called to get
	title strings for nodes.
	(If 'title' Wires are omitted, the objects representing nodes
	are used as title strings.)
	And if an array of objects with 'node' and 'title' Wires is
	specified to 'children', it is used to gather child nodes and
	their title strings in the same way recursively.
	Finally, an array of node objects are returned.</description>
        <parameters>
          <parameter name="object" type="Object" usage="required">
            <summary>An object</summary>
          </parameter>
          <parameter name="child" type="Object" usage="required">
            <summary>An object with child Wires</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.Wire" type="Function" classlike="true">
    <summary>A default and base Wire to access an object property</summary>
    <description>This class accesses a property of an object with a dotted notation
	specified to 'property' property, such as "a.b.c", which identifies
	a descendant property, "object.a.b.c".
	Property names in the dotted notation may have an array index, such
	as "a[0]", to identify an array element, literally, "object.a[0]".
	When a notation start with an array index, such as "[0].a", it
	specifies an array element of the root object (array),
	"object[0].a".
	This class also serves as a base class for other Wire classes,
	preparing a root object and converting a return value, so that
	sub-classes just can implement _getValue() and _setValue() called
	from getValue() and setValue() implemented by this calss.</description>
    <properties>
      <property name="_wireClass" scope="prototype" type="String"/>
      <property name="converter" scope="instance" type="A">
        <summary>converter object (or class name) to convert the return
	value (for the source Wire)</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	object:
	A root object (or another Wire to access a root object)
	property:
	A dotted notation to a descendant property
	type:
	A type of the return value (for the source Wire)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize properties</summary>
        <description>If 'converter' property is specified and is a string for
	a converter class, an instanceof the converter class is
	created.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	object:
	A root object (or another Wire to access a root object)
	property:
	A dotted notation to a descendant property
	type:
	A type of the return value (for the source Wire)</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getValue" scope="prototype">
        <summary>Return a value of an object</summary>
        <description>This method first determins a root object as follows:
	1. If 'object' property specified,
	1.1 If 'object' is a Wire, its getValue() method is called to
	obtain a root object.
	1.2 Otherwise, use 'object' as a root object.
	2. Otherwise, use 'defaultObject' argument.
	3. If 'property' is specified, it is used to get a property
	value.
	Then, if a sub-class implements _getValue() method, it is
	called with the root object to get the return value.
	Otherwise, the root object (typically, a property valye) is
	used for the return value.
	Finally, if 'type' property is specified, the return value is
	converted to the specified primitive type ("string", "number",
	"boolean" and "array").
	If 'converter' property is specified, its convert() method is
	called to convert the value.</description>
        <return-description>A value found</return-description>
        <parameters>
          <parameter name="defaultObject" type="Object||Array" usage="required">
            <summary>A default root object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="anything (null, undefined, etc)"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="setValue" scope="prototype">
        <summary>Set a value to an object</summary>
        <description>This method first determins a root object as follows:
	1. If 'object' property specified,
	1.1 If 'object' is a Wire, its getValue() method is called to
	obtain a root object.
	1.2 Otherwise, use 'object' as a root object.
	2. Otherwise, use 'defaultObject' argument.
	3. If 'property' is specified, it is used to get a property
	value.
	Then, if a sub-class implements _setValue() method, it is
	called with the root object and 'value' argument to set
	the value.
	Otherwise, 'value' is set to a property specified with
	'property' property.
	If the root object is undefined and 'object' property is a Wire
	and a new object is created and returned by _setValue() it is
	set through 'object' (setValue() method).</description>
        <parameters>
          <parameter name="value" type="anything" usage="required">
            <summary>A value to set</summary>
          </parameter>
          <parameter name="defaultObject" type="Object||Array" usage="required">
            <summary>A default root object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getPropertyValue" scope="prototype">
        <summary>Return a property value of an object</summary>
        <description>A value for 'property' of 'object' is returned.
	If 'property' ends with an array index, it is used to indentify
	an element of an array property.
	If 'object' implements getPropertyValue(), it is called with
	'property' to obtain the property value.
	If 'object' implements a getter for the property, it is called
	to obtain the property value.</description>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required">
            <summary>A default root object</summary>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <summary>A property name</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setPropertyValue" scope="prototype">
        <summary>Set a property value to an object</summary>
        <description>'value' is set to 'property' of 'object'.
	If 'property' ends with an array index, it is used to indentify
	an element of an array property to set the value.
	If 'object' implements setPropertyValue(), it is called with
	'property' and 'value' to set the property value.
	If 'object' implements a setter for the property, it is called
	with 'value' to set the property value.</description>
        <parameters>
          <parameter name="object" type="Object||Array" usage="required">
            <summary>An object</summary>
          </parameter>
          <parameter name="property" type="String" usage="required">
            <summary>A property name</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>A value to set</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_useAttr" scope="prototype">
        <summary>Function to detect if dijit.attr support exists on the target</summary>
        <parameters>
          <parameter name="object" type="The" usage="required">
            <summary>target object to set the property of.</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.XmlWire" type="Function" classlike="true" superclass="dojox.wire.Wire">
    <summary>A Wire for XML nodes or values (element, attribute and text)</summary>
    <description>This class accesses XML nodes or value with a simplified XPath
	specified to 'path' property.
	The root object for this class must be an DOM document or element
	node.
	"@name" accesses to an attribute value of an element and "text()"
	accesses to a text value of an element.
	The hierarchy of the elements from the root node can be specified
	with slash-separated list, such as "a/b/@c", which specifies
	the value of an attribute named "c" of an element named "b" as
	a child of another element named "a" of a child of the root node.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.Wire"/>
    </mixins>
    <properties>
      <property name="_wireClass" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	path:
	A simplified XPath to an attribute, a text or elements</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize properties</summary>
        <description>'args' is just mixed in with no further processing.</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>Arguments to initialize properties
	path:
	A simplified XPath to an attribute, a text or elements</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getValue" scope="prototype">
        <summary>Return an attribute value, a text value or an array of elements</summary>
        <description>This method first uses a root node passed in 'object' argument
	and 'path' property to identify an attribute, a text or
	elements.
	If 'path' starts with a slash (absolute), the first path
	segment is ignored assuming it point to the root node.
	(That is, "/a/b/@c" and "b/@c" against a root node access
	the same attribute value, assuming the root node is an element
	with a tag name, "a".)</description>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <parameters>
          <parameter name="object" type="Node" usage="required">
            <summary>A root node</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type=""/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setValue" scope="prototype">
        <summary>Set an attribute value or a child text value to an element</summary>
        <description>This method first uses a root node passed in 'object' argument
	and 'path' property to identify an attribute, a text or
	elements.
	If an intermediate element does not exist, it creates
	an element of the tag name in the 'path' segment as a child
	node of the current node.
	Finally, 'value' argument is set to an attribute or a text
	(a child node) of the leaf element.</description>
        <parameters>
          <parameter name="object" type="Node" usage="required">
            <summary>A root node</summary>
          </parameter>
          <parameter name="value" type="String" usage="required">
            <summary>A value to set</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="_getNodeValue" scope="prototype">
        <summary>Return an attribute value, a text value or an array of elements</summary>
        <description>If 'exp' starts with '@', an attribute value of the specified
	attribute is returned.
	If 'exp' is "text()", a child text value is returned.
	Otherwise, an array of child elements, the tag name of which
	match 'exp', is returned.</description>
        <return-description>A value found, otherwise 'undefined'</return-description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>A node</summary>
          </parameter>
          <parameter name="exp" type="String" usage="required">
            <summary>An expression for attribute, text or elements</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
          <return-type type=""/>
          <return-type type="Array"/>
        </return-types>
      </method>
      <method name="_setNodeValue" scope="prototype">
        <summary>Set an attribute value or a child text value to an element</summary>
        <description>If 'exp' starts with '@', 'value' is set to the specified
	attribute.
	If 'exp' is "text()", 'value' is set to a child text.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>A node</summary>
          </parameter>
          <parameter name="exp" type="String" usage="required">
            <summary>An expression for attribute or text</summary>
          </parameter>
          <parameter name="value" type="String" usage="required">
            <summary>A value to set</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getChildNode" scope="prototype">
        <summary>Return a child node</summary>
        <description>A child element of the tag name specified with 'name' is
	returned.
	If 'name' ends with an array index, it is used to pick up
	the corresponding element from multiple child elements.</description>
        <return-description>A child node</return-description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>A parent node</summary>
          </parameter>
          <parameter name="name" type="String" usage="required">
            <summary>A tag name</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Node"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getDocument" scope="prototype">
        <summary>Return a DOM document</summary>
        <description>If 'node' is specified, a DOM document of the node is returned.
	Otherwise, a DOM document is created.</description>
        <return-description>A DOM document</return-description>
        <parameters>
          <parameter name="node" type="Node" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire._wireClasses" private="true">
    <properties>
      <property name="attribute" scope="normal" type="String"/>
      <property name="path" scope="normal" type="String"/>
      <property name="children" scope="normal" type="String"/>
      <property name="columns" scope="normal" type="String"/>
      <property name="nodes" scope="normal" type="String"/>
      <property name="segments" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.wire.ml">
    <properties>
      <property name="util" scope="normal" type="Object"/>
    </properties>
    <methods>
      <method name="_getValue" scope="normal">
        <summary>Return a value</summary>
        <description>This method obtains an object by an ID of a widget or an DOM
	element.
	If 'source' specifies a dotted notation to its property, a Wire is
	used to get the object property.
	If 'source' starts with "arguments", 'args' is used as a root
	object for the Wire.</description>
        <return-description>A value</return-description>
        <parameters>
          <parameter name="source" type="String" usage="required">
            <summary>A string to specify an object and its property</summary>
          </parameter>
          <parameter name="args" type="Array" usage="required">
            <summary>An optional arguments array</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="Object"/>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="_setValue" scope="normal">
        <summary>Store a value</summary>
        <description>This method stores a value by an ID of a widget or an DOM
	element with a dotted notation to its property, using a Wire.</description>
        <parameters>
          <parameter name="target" type="String" usage="required">
            <summary>A string to specify an object and its property</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>A value</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.Action" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A base widget to &amp;quot;run&amp;quot; a task on an event or a topic</summary>
    <description>This widget represents a controller task to be run when an event
	(a function) or a topic is issued.
	Sub-classes must implement _run() method to implement their tasks.
	'trigger' specifies an event scope, an ID of a widget or an DOM
	element, or its property with the optional dotted notation.
	If this widget has child ActionFilter widgets, their filter()
	methods are called with the arguments to the event or the topic.
	If one of filter() methods returns false, run() won't be invoked.
	This widget also can serve as a composite task to run child
	Actions on an event or a topic specified to this widget.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="trigger" scope="prototype" type="An">
        <summary>event scope</summary>
      </property>
      <property name="triggerEvent" scope="prototype" type="An">
        <summary>event (function) name</summary>
      </property>
      <property name="triggerTopic" scope="prototype" type="A">
        <summary>topic name</summary>
      </property>
      <property name="_triggerHandle" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Call _connect()</summary>
        <description>See _connect().</description>
      </method>
      <method name="_connect" scope="prototype">
        <summary>Connect run() method to an event or a topic</summary>
        <description>If 'triggerEvent' and 'trigger' are specified, connect() is
	used to set up run() to be called on the event.
	If 'triggerTopic' is specified, subscribe() is used to set up
	run() to be called on the topic.</description>
      </method>
      <method name="_disconnect" scope="prototype">
        <summary>Disconnect run() method from an event or a topic</summary>
        <description>If 'triggerEvent' and 'trigger' are specified, disconnect() is
	used to set up run() not to be called on the event.
	If 'triggerTopic' is specified, unsubscribe() is used to set up
	run() not to be called on the topic.</description>
      </method>
      <method name="run" scope="prototype">
        <summary>Run a task</summary>
        <description>This method calls filter() method of child ActionFilter
	widgets.
	If one of them returns false, this method returns.
	Otherwise, _run() method is called.</description>
      </method>
      <method name="_run" scope="prototype">
        <summary>Call run() methods of child Action widgets</summary>
        <description>If this widget has child Action widgets, their run() methods
	are called.</description>
      </method>
      <method name="uninitialize" scope="prototype">
        <summary>Over-ride of base widget unitialize function to do some connection cleanup.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.ActionFilter" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget to define a filter for the parent Action to run</summary>
    <description>This base class checks a required property specified with
	'required' attribute.
	If 'message' is specified, the message is set to a property
	specified with 'error'.
	Subclasses may implement their own filter() method.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="required" scope="prototype" type="A">
        <summary>property required</summary>
      </property>
      <property name="requiredValue" scope="prototype" type="Optional.">
        <summary>A specific value the property is required to have.  If this isn't provided
	than any non-false/non-null value of the required propery will cause this filter
	to pass.</summary>
      </property>
      <property name="type" scope="prototype" type="Optional.">
        <summary>A specific type to compare the values as (if requiredValue is set)
	Valid values for type are boolean, int, string.  Default is string.</summary>
      </property>
      <property name="message" scope="prototype" type="An">
        <summary>error message to emit if the filter doesn't execute due to property mismatch.</summary>
      </property>
      <property name="error" scope="prototype" type="A">
        <summary>property to store an error due to property mismatch.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="filter" scope="prototype">
        <summary>Check if a required property is specified.  Also, if provided, check to see
	if the required property contains a specific value.</summary>
        <description>If a value is undefined for a property, specified with
	'required', this method returns false.
	If the value for a property is defined, but there isn't a requiredValue for it
	then any non-false value will cause the method to return true.
	if requiredValue is set, then filter compares that value with the value from
	the required property and returns true if and only if they match.
	The type option just allows for a way to convert the required property values
	into a proper form for comparison (boolean, number, etc).
	If 'message' is specified, it is set to a proeprty specified
	with 'error' or shown with alert().
	If 'required' starts with "arguments", a property of
	the method arguments are checked.</description>
        <return-description>True if a required property is specified (and if requiredValue is specified,
	that they match), otherwise false</return-description>
        <return-types>
          <return-type type="Boolean"/>
          <return-type type="boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.Data" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget for a data object</summary>
    <description>This widget represents an object with '_properties' property.
	If child 'DataProperty' widgets exist, they are used to initialize
	propertiy values of '_properties' object.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="_properties" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="startup" scope="prototype">
        <summary>Call _initializeProperties()</summary>
        <description>See _initializeProperties().</description>
      </method>
      <method name="_initializeProperties" scope="prototype">
        <summary>Initialize a data object</summary>
        <description>If this widget has child DataProperty widgets, their getValue()
	methods are called and set the return value to a property
	specified by 'name' attribute of the child widgets.</description>
        <parameters>
          <parameter name="reset" type="Boolean" usage="required">
            <summary>A boolean to reset current properties</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getPropertyValue" scope="prototype">
        <summary>Return a property value</summary>
        <description>This method returns the value of a property, specified with
	'property' argument, in '_properties' object.</description>
        <return-description>A property value</return-description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <summary>A property name</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
      <method name="setPropertyValue" scope="prototype">
        <summary>Store a property value</summary>
        <description>This method stores 'value' as a property, specified with
	'property' argument, in '_properties' object.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <summary>A property name</summary>
          </parameter>
          <parameter name="value" type="anything" usage="required">
            <summary>A property value</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.DataProperty" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget to define a data property</summary>
    <description>Attributes of this widget are used to add a property to the parent
	Data widget.
	'type' attribute specifies one of "string", "number", "boolean",
	"array", "object" and "element" (DOM Element)
	(default to "string").
	If 'type' is "array" or "object", child DataProperty widgets are
	used to initialize the array elements or the object properties.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dijit._Widget"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="name" scope="prototype" type="A">
        <summary>property name</summary>
      </property>
      <property name="type" scope="prototype" type="A">
        <summary>property type name</summary>
      </property>
      <property name="value" scope="prototype" type="A">
        <summary>property value</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getValueAttr" scope="prototype"/>
      <method name="getValue" scope="prototype">
        <summary>Returns a property value</summary>
        <description>If 'type' is specified, 'value' attribute is converted to
	the specified type and returned.
	Otherwise, 'value' attribute is returned as is.</description>
        <return-description>A property value</return-description>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.DataStore" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget for a data store</summary>
    <description>This widget represents a data store of 'storeClass' attribute.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="storeClass" scope="prototype" type="A">
        <summary>class name of a data store</summary>
      </property>
      <property name="store" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Call _createStore()</summary>
        <description>See _createStore().</description>
      </method>
      <method name="_createStore" scope="prototype">
        <summary>Create a data store
	desription:
	A data store of 'storeClass' is created with arguments
	specified with attributes.</summary>
        <return-description>A data store</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="getFeatures" scope="prototype">
        <summary>Call getFeatures() method of a data store</summary>
        <description>See dojo.data.api.Read.getFeatures().</description>
        <return-description>A features object</return-description>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="fetch" scope="prototype">
        <summary>Call fetch() method of a data store</summary>
        <description>See dojo.data.api.Read.fetch().</description>
        <return-description>A request object</return-description>
        <parameters>
          <parameter name="request" type="Object" usage="required">
            <summary>A request object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="save" scope="prototype">
        <summary>Call save() method of a data store</summary>
        <description>See dojo.data.api.Write.save().</description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>A save arguments object</summary>
          </parameter>
        </parameters>
      </method>
      <method name="newItem" scope="prototype">
        <summary>Call newItem() method of a data store</summary>
        <description>See dojo.data.api.Write.newItem().</description>
        <return-description>A new item</return-description>
        <parameters>
          <parameter name="args" type="Object" usage="required">
            <summary>A new item arguments object</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="deleteItem" scope="prototype">
        <summary>Call deleteItem() method of a data store</summary>
        <description>See dojo.data.api.Write.deleteItem().</description>
        <return-description>A boolean</return-description>
        <parameters>
          <parameter name="item" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
      <method name="revert" scope="prototype">
        <summary>Call revert() method of a data store</summary>
        <description>See dojo.data.api.Write.revert().</description>
        <return-description>A boolean</return-description>
        <return-types>
          <return-type type="Boolean"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.DataStore.domNode" type="">
    <properties>
      <property name="attributes" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.wire.ml.Invocation" type="Function" classlike="true" superclass="dojox.wire.ml.Action">
    <summary>A widget to invoke a method or publish a topic</summary>
    <description>This widget represents a controller task to invoke a method or
	publish a topic when an event (a function) or a topic is issued.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.ml.Action"/>
    </mixins>
    <properties>
      <property name="object" scope="prototype" type="A">
        <summary>scope of a method to invoke</summary>
      </property>
      <property name="method" scope="prototype" type="A">
        <summary>name of a method to invoke</summary>
      </property>
      <property name="topic" scope="prototype" type="A">
        <summary>name of a topic to publish</summary>
      </property>
      <property name="parameters" scope="prototype" type="Arguments">
        <summary>for the method or the topic</summary>
      </property>
      <property name="result" scope="prototype" type="A">
        <summary>property to store a return value of the method call</summary>
      </property>
      <property name="error" scope="prototype" type="A">
        <summary>property to store an error on the method call</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_run" scope="prototype">
        <summary>Invoke a method or publish a topic</summary>
        <description>If 'topic' is specified, the topic is published with arguments
	specified to 'parameters'.
	If 'method' and 'object' are specified, the method is invoked
	with arguments specified to 'parameters' and set the return
	value to a property specified to 'result'.
	'object', 'parameters' and 'result' can specify properties of
	a widget or an DOM element with the dotted notation.
	If 'parameters' are omitted, the arguments to this method are
	passed as is.</description>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="onComplete" scope="prototype">
        <summary>A function called when the method or the topic publish
	completed</summary>
        <description>If 'result' attribute is specified, the result object also set
	to the specified property.</description>
        <parameters>
          <parameter name="result" type="anything" usage="required">
            <summary>The return value of a method or undefined for a topic</summary>
          </parameter>
        </parameters>
      </method>
      <method name="onError" scope="prototype">
        <summary>A function called on an error occurs</summary>
        <description>If 'error' attribute is specified, the error object also set to
	the specified property.</description>
        <parameters>
          <parameter name="error" type="anything" usage="required">
            <summary>The exception or error occurred</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getParameters" scope="prototype">
        <summary>Returns arguments to a method or topic to invoke</summary>
        <description>This method retunrs an array of arguments specified by
	'parameters' attribute, a comma-separated list of IDs and
	their properties in a dotted notation.
	If 'parameters' are omitted, the original arguments are
	used.</description>
        <parameters>
          <parameter name="args" type="Array" usage="required">
            <summary>Arguments to a trigger event or topic</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Array"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.Service" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget for a service</summary>
    <description>This widget represents a service defined by a service description
	specified with 'url' attribute.
	If 'serviceType' and 'serviceUrl' attributes are specified, 'url'
	attribute can be omitted.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="url" scope="prototype" type="A">
        <summary>URL to a service description</summary>
      </property>
      <property name="serviceUrl" scope="prototype" type="A">
        <summary>URL to a service</summary>
      </property>
      <property name="serviceType" scope="prototype" type="A">
        <summary>service type</summary>
      </property>
      <property name="handlerClass" scope="prototype" type="A">
        <summary>service handler class name</summary>
      </property>
      <property name="preventCache" scope="prototype" type="Object"/>
      <property name="handler" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype">
        <summary>Call _createHandler()</summary>
        <description>See _createHandler().</description>
      </method>
      <method name="_createHandler" scope="prototype">
        <summary>Create a service handler
	desription:
	A service handler class is determined by:
	1. 'handlerClass' attribute
	2. 'serviceType' attribute
	3. 'serviceType' property in a service description</summary>
        <return-description>A service handler</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="callMethod" scope="prototype">
        <summary>Call a service method with parameters</summary>
        <parameters>
          <parameter name="method" type="A" usage="required">
            <summary>method name</summary>
          </parameter>
          <parameter name="parameters" type="An" usage="required">
            <summary>array parameters</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.Service._handlerClasses" private="true">
    <properties>
      <property name="TEXT" scope="normal" type="String"/>
      <property name="XML" scope="normal" type="String"/>
      <property name="JSON" scope="normal" type="String"/>
      <property name="JSON-RPC" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.wire.ml.RestHandler" type="Function" classlike="true">
    <summary>A REST service handler</summary>
    <description>This class serves as a base REST service.
	Sub-classes may override _getContent() and _getResult() to handle
	specific content types.</description>
    <properties>
      <property name="contentType" scope="prototype" type="String"/>
      <property name="handleAs" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="bind" scope="prototype">
        <summary>Call a service method with parameters.</summary>
        <description>A service is called with a URL generated by _getUrl() and
	an HTTP method specified with 'method'.
	For "POST" and "PUT", a content is generated by _getContent().
	When data is loaded, _getResult() is used to pass the result to
	Deferred.callback().</description>
        <parameters>
          <parameter name="method" type="A" usage="required">
            <summary>method name</summary>
          </parameter>
          <parameter name="parameters" type="An" usage="required">
            <summary>array of parameters</summary>
          </parameter>
          <parameter name="deferred" type="'Deferred'" usage="required"/>
          <parameter name="url" type="A" usage="required">
            <summary>URL for the method</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getUrl" scope="prototype">
        <summary>Generate a URL</summary>
        <description>If 'method' is "GET" or "DELETE", a query string is generated
	from a query object specified to the first parameter in
	'parameters' and appended to 'url'.
	If 'url' contains variable seguments ("{parameter_name}"),
	they are replaced with corresponding parameter values, instead.</description>
        <return-description>A URL</return-description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <summary>A method name</summary>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <summary>An array of parameters</summary>
          </parameter>
          <parameter name="url" type="String" usage="required">
            <summary>A base URL</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="_getContent" scope="prototype">
        <summary>Generate a request content</summary>
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameters' is returned.</description>
        <return-description>A request content</return-description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <summary>A method name</summary>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <summary>An array of parameters</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="anything"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="_getResult" scope="prototype">
        <summary>Extract a result</summary>
        <description>A response data is returned as is.</description>
        <return-description>A result object</return-description>
        <parameters>
          <parameter name="data" type="anything" usage="required">
            <summary>A response data returned by a service</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="anything"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.XmlHandler" type="Function" classlike="true" superclass="dojox.wire.ml.RestHandler">
    <summary>A REST service handler for XML</summary>
    <description>This class provides XML handling for a REST service.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.ml.RestHandler"/>
    </mixins>
    <properties>
      <property name="contentType" scope="prototype" type="String"/>
      <property name="handleAs" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getContent" scope="prototype">
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameters' is used to generate an XML content.</description>
        <return-description>A request content</return-description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <summary>A method name</summary>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <summary>An array of parameters</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getResult" scope="prototype">
        <summary>Extract a result</summary>
        <description>A response data (XML Document) is returned wrapped with
	XmlElement.</description>
        <return-description>A result object</return-description>
        <parameters>
          <parameter name="data" type="Document" usage="required">
            <summary>A response data returned by a service</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.JsonHandler" type="Function" classlike="true" superclass="dojox.wire.ml.RestHandler">
    <summary>A REST service handler for JSON</summary>
    <description>This class provides JSON handling for a REST service.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.ml.RestHandler"/>
    </mixins>
    <properties>
      <property name="contentType" scope="prototype" type="String"/>
      <property name="handleAs" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_getContent" scope="prototype">
        <summary>Generate a request content</summary>
        <description>If 'method' is "POST" or "PUT", the first parameter in
	'parameter' is used to generate a JSON content.</description>
        <return-description>A request content</return-description>
        <parameters>
          <parameter name="method" type="String" usage="required">
            <summary>A method name</summary>
          </parameter>
          <parameter name="parameters" type="Array" usage="required">
            <summary>An array of parameters</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.JsonHandler.headers">
    <properties>
      <property name="Accept" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.wire.ml.Transfer" type="Function" classlike="true" superclass="dojox.wire.ml.Action">
    <summary>A widget to transfer values through source and target Wires</summary>
    <description>This widget represents a controller task to transfer a value from
	a source to a target, through a source and a target Wires, when
	an event (a function) or a topic is issued.
	If this widget has child ChildWire widgets, their _addWire()
	methods are called to add Wire arguments to a source or a target
	Wire.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.ml.Action"/>
    </mixins>
    <properties>
      <property name="source" scope="prototype" type="A">
        <summary>source object and/or property</summary>
      </property>
      <property name="sourceStore" scope="prototype" type="A">
        <summary>data store for a source data item</summary>
      </property>
      <property name="sourceAttribute" scope="prototype" type="An">
        <summary>attribute of a source data item</summary>
      </property>
      <property name="sourcePath" scope="prototype" type="A">
        <summary>simplified XPath to a source property of an XML element</summary>
      </property>
      <property name="type" scope="prototype" type="A">
        <summary>type of the value to be transferred</summary>
      </property>
      <property name="converter" scope="prototype" type="A">
        <summary>class name of a converter for the value to be transferred</summary>
      </property>
      <property name="delimiter" scope="prototype" type="String"/>
      <property name="target" scope="prototype" type="A">
        <summary>target object and/or property</summary>
      </property>
      <property name="targetStore" scope="prototype" type="A">
        <summary>data store for a target data item</summary>
      </property>
      <property name="targetAttribute" scope="prototype" type="An">
        <summary>attribute of a target data item</summary>
      </property>
      <property name="targetPath" scope="prototype" type="A">
        <summary>simplified XPath to a target property of an XML element</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_run" scope="prototype">
        <summary>Transfer a value from a source to a target</summary>
        <description>First, Wires for a source and a target are created from attributes.
	Then, a value is obtained by getValue() of the source Wire is set
	by setValue() of the target Wire.
	The arguments to this method is passed to getValue() and setValue()
	of Wires, so that they can be used to identify the root objects off
	the arguments.</description>
      </method>
      <method name="_getWire" scope="prototype">
        <summary>Build Wire arguments from attributes</summary>
        <description>Arguments object for a source or a target Wire, specified by
	'which' argument, are build from corresponding attributes,
	including '*Store' (for 'dataStore'), '*Attribute'
	(for 'attribute), '*Path' (for 'path'), 'type' and 'converter'.
	'source' or 'target' attribute is parsed as:
	"object_id.property_name[.sub_property_name...]"
	If 'source' or 'target' starts with "arguments", 'object'
	argument for a Wire is set to null, so that the root object is
	given as an event or topic arguments.
	If this widget has child ChildWire widgets with a corresponding
	'which' attribute, their _addWire() methods are called to add
	additional Wire arguments and nested Wire is created,
	specifying the Wire defined by this widget to 'object' argument.</description>
        <return-description>Wire arguments object</return-description>
        <parameters>
          <parameter name="which" type="String" usage="required">
            <summary>Which Wire arguments to build, &amp;quot;source&amp;quot; or &amp;quot;target&amp;quot;</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.ChildWire" type="Function" classlike="true" superclass="dijit._Widget">
    <summary>A widget to add a child wire</summary>
    <description>Attributes of this widget are used to add a child Wire to
	a composite Wire of the parent Transfer widget.</description>
    <mixins>
      <mixin scope="instance" location="dijit._Widget"/>
    </mixins>
    <properties>
      <property name="which" scope="prototype" type="Which">
        <summary>Wire to add a child Wire, &amp;quot;source&amp;quot; or &amp;quot;target&amp;quot;, default to
	&amp;quot;source&amp;quot;</summary>
      </property>
      <property name="object" scope="prototype" type="A">
        <summary>root object for the value</summary>
      </property>
      <property name="property" scope="prototype" type="A">
        <summary>property for the value</summary>
      </property>
      <property name="type" scope="prototype" type="A">
        <summary>type of the value</summary>
      </property>
      <property name="converter" scope="prototype" type="A">
        <summary>class name of a converter for the value</summary>
      </property>
      <property name="attribute" scope="prototype" type="A">
        <summary>data item attribute for the value</summary>
      </property>
      <property name="path" scope="prototype" type="A">
        <summary>simplified XPath for the value</summary>
      </property>
      <property name="name" scope="prototype" type="A">
        <summary>composite property name</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_addWire" scope="prototype">
        <summary>Add a child Wire to Wire arguments</summary>
        <description>If 'name' attribute is specified, a child Wire is added as
	the named property of 'children' object of 'args'.
	Otherwise, a child Wire is added to 'children' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <summary>A parent Transfer widget</summary>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <summary>Wire arguments</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getWire" scope="prototype">
        <summary>Build child Wire arguments from attributes</summary>
        <description>Arguments object for a child Wire are build from attributes,
	including 'object', 'property', 'type', 'converter',
	'attribute' and 'path'.</description>
        <return-description>Wire arguments object</return-description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <summary>A parent Transfer widget</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.ColumnWire" type="Function" classlike="true" superclass="dojox.wire.ml.ChildWire">
    <summary>A widget to add a column wire</summary>
    <description>Attributes of this widget are used to add a column Wire to
	a TableAdapter of the parent Transfer widget.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.ml.ChildWire"/>
    </mixins>
    <properties>
      <property name="column" scope="prototype" type="A">
        <summary>column name</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_addWire" scope="prototype">
        <summary>Add a column Wire to Wire arguments</summary>
        <description>If 'column' attribute is specified, a column Wire is added as
	the named property of 'columns' object of 'args'.
	Otherwise, a column Wire is added to 'columns' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <summary>A parent Transfer widget</summary>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <summary>Wire arguments</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.NodeWire" type="Function" classlike="true" superclass="dojox.wire.ml.ChildWire">
    <summary>A widget to add node wires</summary>
    <description>Attributes of this widget are used to add node Wires to
	a TreeAdapter of the parent Transfer widget.</description>
    <mixins>
      <mixin scope="prototype" location="dijit._Container.prototype"/>
      <mixin scope="instance" location="dojox.wire.ml.ChildWire"/>
      <mixin scope="instance" location="dijit._Container"/>
    </mixins>
    <properties>
      <property name="titleProperty" scope="prototype" type="A">
        <summary>property for the node title</summary>
      </property>
      <property name="titleAttribute" scope="prototype" type="A">
        <summary>data item attribute for the node title</summary>
      </property>
      <property name="titlePath" scope="prototype" type="A">
        <summary>simplified XPath for the node title</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="_addWire" scope="prototype">
        <summary>Add node Wires to Wire arguments</summary>
        <description>Node Wires are added to 'nodes' array of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <summary>A parent Transfer widget</summary>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <summary>Wire arguments</summary>
          </parameter>
        </parameters>
      </method>
      <method name="_getWires" scope="prototype">
        <summary>Build node Wires arguments from attributes</summary>
        <description>Arguments object for 'node' Wire are build from attributes,
	including 'object', 'property', 'type', 'converter',
	'attribute' and 'path'.
	Arguments object for 'title' Wire are build from another set of
	attributes, 'titleProperty', 'titleAttribute' and 'titlePath'.
	If this widget has child NodeWire widgets, their _getWires()
	methods are called recursively to build 'children' array of
	'args'.</description>
        <return-description>Wire arguments object</return-description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <summary>A parent Transfer widget</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="Object"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.SegmentWire" type="Function" classlike="true" superclass="dojox.wire.ml.ChildWire">
    <summary>A widget to add a segment wire</summary>
    <description>Attributes of this widget are used to add a segment Wire to
	a TextAdapter of the parent Transfer widget.</description>
    <mixins>
      <mixin scope="instance" location="dojox.wire.ml.ChildWire"/>
    </mixins>
    <methods>
      <method constructor="constructor"/>
      <method name="_addWire" scope="prototype">
        <summary>Add a segument Wire to Wire arguments</summary>
        <description>A segment Wire is added to 'segments' array of 'args'.
	If 'parent' has 'delimiter' attribute, it is used for
	'delimiter' property of 'args'.</description>
        <parameters>
          <parameter name="parent" type="Transfer" usage="required">
            <summary>A parent Transfer widget</summary>
          </parameter>
          <parameter name="args" type="Object" usage="required">
            <summary>Wire arguments</summary>
          </parameter>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.XmlElement" type="Function" classlike="true">
    <summary>An object wrapping an XML element</summary>
    <description>This class represents an XML element.</description>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="element" type="Element||String" usage="required">
            <summary>An XML element or a tag name</summary>
          </parameter>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <summary>Initialize with an XML element or a tag name</summary>
        <parameters>
          <parameter name="element" type="Element||String" usage="required">
            <summary>An XML element or a tag name</summary>
          </parameter>
        </parameters>
      </method>
      <method name="getPropertyValue" scope="prototype">
        <summary>Return a property value</summary>
        <description>If 'property' starts with '@', the attribute value is returned.
	If 'property' specifies "text()", the value of the first child
	text is returned.
	Otherwise, child elements of the tag name specified with
	'property' are returned.</description>
        <return-description>A property value</return-description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <summary>A property name</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
          <return-type type="String"/>
          <return-type type=""/>
          <return-type type="Array"/>
          <return-type type="XmlElement"/>
        </return-types>
      </method>
      <method name="setPropertyValue" scope="prototype">
        <summary>Store a property value</summary>
        <description>If 'property' starts with '@', 'value' is set to the attribute.
	If 'property' specifies "text()", 'value' is set as the first
	child text.
	If 'value' is a string, a child element of the tag name
	specified with 'property' is created and 'value' is set as
	the first child text of the child element.
	Otherwise, 'value' is set to as child elements.</description>
        <parameters>
          <parameter name="property" type="String" usage="required">
            <summary>A property name</summary>
          </parameter>
          <parameter name="value" type="String||Array||XmlElement" usage="required">
            <summary>A property value</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="undefined"/>
        </return-types>
      </method>
      <method name="toString" scope="prototype">
        <summary>Return a value of the first text child of the element</summary>
        <description>A value of the first text child of the element is returned.</description>
        <return-description>A value of the first text child of the element</return-description>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="toObject" scope="prototype">
        <summary>Return an object representation of the element</summary>
        <description>An object with properties for child elements, attributes and
	text is returned.</description>
        <return-description>An object representation of the element</return-description>
        <return-types>
          <return-type type="null"/>
          <return-type type="String"/>
          <return-type type="Object"/>
        </return-types>
      </method>
      <method name="_getDocument" scope="prototype">
        <summary>Return a DOM document</summary>
        <description>If 'element' is specified, a DOM document of the element is
	returned.
	Otherwise, a DOM document is created.</description>
        <return-description>A DOM document</return-description>
        <return-types>
          <return-type type="Document"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.wire.ml.XmlElement.element" type="An">
    <summary>XML element or a tag name</summary>
  </object>
  <object location="dojox.wire.ml.XmlElement.element.firstChild" type="">
    <properties>
      <property name="nodeValue" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.wire.ml.XmlElement.element.attributes" type="">
    <properties>
      <property name="length" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.xml">
    <summary>XML utilities.  Currently only includes a DomParser, which returns a psuedo-XML document in JSON-like form.</summary>
    <properties>
      <property name="DomParser" scope="normal" type="Object"/>
      <property name="widgetParser" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.xml.Script" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="props" type="" usage="required"/>
          <parameter name="node" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xml.parser">
    <methods>
      <method name="parse" scope="normal">
        <summary>cross-browser implementation of creating an XML document object from null, empty string, and XML text..</summary>
        <parameters>
          <parameter name="str" type="String" usage="optional">
            <summary>Optional text to create the document from.  If not provided, an empty XML document will be created.
	If str is empty string &amp;quot;&amp;quot;, then a new empty document will be created.</summary>
          </parameter>
          <parameter name="mimetype" type="String" usage="optional">
            <summary>Optional mimetype of the text.  Typically, this is text/xml.  Will be defaulted to text/xml if not provided.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="DOMDocument"/>
          <return-type type="null"/>
        </return-types>
      </method>
      <method name="textContent" scope="normal">
        <summary>Implementation of the DOM Level 3 attribute; scan node for text</summary>
        <description>Implementation of the DOM Level 3 attribute; scan node for text
	This function can also update the text of a node by replacing all child
	content of the node.</description>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>The node to get the text off of or set the text on.</summary>
          </parameter>
          <parameter name="text" type="String" usage="optional">
            <summary>Optional argument of the text to apply to the node.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
      <method name="replaceChildren" scope="normal">
        <summary>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</summary>
        <description>Removes all children of node and appends newChild. All the existing
	children will be destroyed.</description>
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <summary>The node to modify the children on</summary>
          </parameter>
          <parameter name="newChildren" type="Node" usage="required">
            <summary>The children to add to the node.  It can either be a single Node or an
	array of Nodes.</summary>
          </parameter>
        </parameters>
      </method>
      <method name="removeChildren" scope="normal">
        <summary>removes all children from node and returns the count of children removed.
	The children nodes are not destroyed. Be sure to call dojo.destroy on them
	after they are not used anymore.</summary>
        <parameters>
          <parameter name="node" type="Element" usage="required">
            <summary>The node to remove all the children from.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="int"/>
        </return-types>
      </method>
      <method name="innerXML" scope="normal">
        <summary>Implementation of MS's innerXML function.</summary>
        <parameters>
          <parameter name="node" type="Node" usage="required">
            <summary>The node from which to generate the XML text representation.</summary>
          </parameter>
        </parameters>
        <return-types>
          <return-type type="String"/>
        </return-types>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp">
    <summary>TODOC</summary>
  </object>
  <object location="dojox.xmpp.ChatService" type="Function" classlike="true">
    <properties>
      <property name="state" scope="instance-prototype" type="String"/>
      <property name="session" scope="prototype" type=""/>
      <property name="uid" scope="prototype" type=""/>
      <property name="_currentState" scope="prototype" type=""/>
      <property name="chatid" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype"/>
      <method name="recieveMessage" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="initial" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setSession" scope="prototype">
        <parameters>
          <parameter name="session" type="" usage="required"/>
        </parameters>
      </method>
      <method name="setState" scope="prototype">
        <parameters>
          <parameter name="state" type="" usage="required"/>
        </parameters>
      </method>
      <method name="invite" scope="prototype">
        <parameters>
          <parameter name="contact" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendMessage" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendChatState" scope="prototype">
        <parameters>
          <parameter name="state" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onNewMessage" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onInvite" scope="prototype">
        <parameters>
          <parameter name="contact" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.chat">
    <properties>
      <property name="CHAT_STATE_NS" scope="normal" type="String"/>
      <property name="ACTIVE_STATE" scope="normal" type="String"/>
      <property name="COMPOSING_STATE" scope="normal" type="String"/>
      <property name="INACTIVE_STATE" scope="normal" type="String"/>
      <property name="PAUSED_STATE" scope="normal" type="String"/>
      <property name="GONE_STATE" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.xmpp.PresenceService" type="Function" classlike="true">
    <properties>
      <property name="avatarHash" scope="instance-prototype" type="Object"/>
      <property name="isInvisible" scope="instance-prototype" type="bool"/>
      <property name="session" scope="instance" type=""/>
      <property name="restrictedContactjids" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="xmppService" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="xmppService" type="" usage="required"/>
        </parameters>
      </method>
      <method name="publish" scope="prototype">
        <parameters>
          <parameter name="presence" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendAvatarHash" scope="prototype">
        <parameters>
          <parameter name="avatarHash" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_setPresence" scope="prototype"/>
      <method name="toggleBlockContact" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="toggleContactInvisiblity" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_createRestrictedJid" scope="prototype"/>
      <method name="_updateRestricted" scope="prototype"/>
      <method name="_setVisible" scope="prototype"/>
      <method name="_setInvisible" scope="prototype"/>
      <method name="_manageSubscriptions" scope="prototype">
        <parameters>
          <parameter name="contact" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="subscribe" scope="prototype">
        <parameters>
          <parameter name="contact" type="" usage="required"/>
        </parameters>
      </method>
      <method name="approveSubscription" scope="prototype">
        <parameters>
          <parameter name="contact" type="" usage="required"/>
        </parameters>
      </method>
      <method name="unsubscribe" scope="prototype">
        <parameters>
          <parameter name="contact" type="" usage="required"/>
        </parameters>
      </method>
      <method name="declineSubscription" scope="prototype">
        <parameters>
          <parameter name="contact" type="" usage="required"/>
        </parameters>
      </method>
      <method name="cancelSubscription" scope="prototype">
        <parameters>
          <parameter name="contact" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.PresenceService.presence">
    <properties>
      <property name="priority" scope="prototype" type="Number"/>
    </properties>
  </object>
  <object location="dojox.xmpp.presence">
    <properties>
      <property name="UPDATE" scope="normal" type="Number"/>
      <property name="SUBSCRIPTION_REQUEST" scope="normal" type="Number"/>
      <property name="SUBSCRIPTION_SUBSTATUS_NONE" scope="normal" type="Number"/>
      <property name="SUBSCRIPTION_NONE" scope="normal" type="String"/>
      <property name="SUBSCRIPTION_FROM" scope="normal" type="String"/>
      <property name="SUBSCRIPTION_TO" scope="normal" type="String"/>
      <property name="SUBSCRIPTION_BOTH" scope="normal" type="String"/>
      <property name="SUBSCRIPTION_REQUEST_PENDING" scope="normal" type="203,">
        <summary>used when 'ask' attribute is absent on a roster item</summary>
      </property>
      <property name="STATUS_ONLINE" scope="normal" type="String"/>
      <property name="STATUS_AWAY" scope="normal" type="String"/>
      <property name="STATUS_CHAT" scope="normal" type="String"/>
      <property name="STATUS_DND" scope="normal" type="String"/>
      <property name="STATUS_EXTENDED_AWAY" scope="normal" type="String"/>
      <property name="STATUS_OFFLINE" scope="normal" type="String"/>
      <property name="STATUS_INVISIBLE" scope="normal" type="String"/>
    </properties>
  </object>
  <object location="dojox.xmpp.RosterService" type="Function" classlike="true">
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="xmppSession" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="xmppSession" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addRosterItem" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
          <parameter name="name" type="" usage="required"/>
          <parameter name="groups" type="" usage="required"/>
        </parameters>
      </method>
      <method name="updateRosterItem" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
          <parameter name="name" type="" usage="required"/>
          <parameter name="groups" type="" usage="required"/>
        </parameters>
      </method>
      <method name="verifyRoster" scope="prototype">
        <parameters>
          <parameter name="res" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addRosterItemToGroup" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
          <parameter name="group" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterGroup" scope="prototype">
        <parameters>
          <parameter name="group" type="" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterGroup" scope="prototype">
        <parameters>
          <parameter name="group" type="" usage="required"/>
          <parameter name="newGroup" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItemFromGroup" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
          <parameter name="group" type="" usage="required"/>
        </parameters>
      </method>
      <method name="rosterItemRenameGroup" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
          <parameter name="oldGroup" type="" usage="required"/>
          <parameter name="newGroup" type="" usage="required"/>
        </parameters>
      </method>
      <method name="renameRosterItem" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
          <parameter name="newName" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeRosterItem" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getAvatar" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="publishAvatar" scope="prototype">
        <parameters>
          <parameter name="type" type="" usage="required"/>
          <parameter name="binval" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRoster" scope="prototype">
        <parameters>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onVerifyRosterFailed" scope="prototype">
        <parameters>
          <parameter name="err" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.RosterService.session" type="">
    <properties>
      <property name="roster" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.xmpp.roster">
    <properties>
      <property name="ADDED" scope="normal" type="Number"/>
      <property name="CHANGED" scope="normal" type="Number"/>
      <property name="REMOVED" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.xmpp.TransportSession" type="Function" classlike="true">
    <properties>
      <property name="rid" scope="prototype" type="Number"/>
      <property name="hold" scope="prototype" type="Number"/>
      <property name="polling" scope="prototype" type="Number"/>
      <property name="secure" scope="prototype" type="bool"/>
      <property name="wait" scope="prototype" type="Number"/>
      <property name="lang" scope="prototype" type="String"/>
      <property name="submitContentType" scope="prototype" type="String"/>
      <property name="serviceUrl" scope="prototype" type="String"/>
      <property name="defaultResource" scope="prototype" type="String"/>
      <property name="domain" scope="prototype" type="String"/>
      <property name="sendTimeout" scope="instance-prototype" type="Number"/>
      <property name="useScriptSrcTransport" scope="prototype" type="bool"/>
      <property name="keepAliveTimer" scope="prototype" type="Object"/>
      <property name="state" scope="prototype" type="String"/>
      <property name="transmitState" scope="prototype" type="String"/>
      <property name="protocolPacketQueue" scope="prototype" type="Array"/>
      <property name="outboundQueue" scope="prototype" type="Array"/>
      <property name="outboundRequests" scope="prototype" type="Object"/>
      <property name="inboundQueue" scope="prototype" type="Array"/>
      <property name="deferredRequests" scope="prototype" type="Object"/>
      <property name="matchTypeIdAttribute" scope="prototype" type="Object"/>
      <property name="transportIframes" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_sendLogin" scope="prototype"/>
      <method name="_sendRestart" scope="prototype"/>
      <method name="processScriptSrc" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="close" scope="prototype">
        <parameters>
          <parameter name="protocolMsg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="redispatchPacket" scope="prototype">
        <parameters>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="addToOutboundQueue" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="removeFromOutboundQueue" scope="prototype">
        <parameters>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="processInboundQueue" scope="prototype"/>
      <method name="addToInboundQueue" scope="prototype">
        <parameters>
          <parameter name="doc" type="" usage="required"/>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="processProtocolResponse" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="isTerminated" scope="prototype"/>
      <method name="onTerminate" scope="prototype">
        <parameters>
          <parameter name="newState" type="" usage="required"/>
          <parameter name="oldState" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onProcessProtocolResponse" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onReady" scope="prototype">
        <parameters>
          <parameter name="newState" type="" usage="required"/>
          <parameter name="oldState" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession.open" type="Function" classlike="true">
    <properties>
      <property name="status" scope="instance" type="String"/>
      <property name="rid" scope="instance" type="Object"/>
      <property name="protocolPacketQueue" scope="instance" type="Array"/>
      <property name="outboundQueue" scope="instance" type="Array"/>
      <property name="outboundRequests" scope="instance" type="Object"/>
      <property name="inboundQueue" scope="instance" type="Array"/>
      <property name="deferredRequests" scope="instance" type="Object"/>
      <property name="matchTypeIdAttribute" scope="instance" type="Object"/>
      <property name="keepAliveTimer" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession._keepAlive" type="Function" classlike="true" private="true">
    <properties>
      <property name="keepAliveTimer" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession.dispatchPacket" type="Function" classlike="true">
    <properties>
      <property name="dispatchTimer" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="protocolMatchType" type="" usage="required"/>
          <parameter name="matchId" type="" usage="required"/>
          <parameter name="matchProperty" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession._dispatchPacket" type="Function" classlike="true" private="true">
    <properties>
      <property name="dispatchTimer" scope="instance" type="Object"/>
      <property name="lastPollTime" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession.processProtocolPacketQueue" type="Function" classlike="true">
    <properties>
      <property name="protocolPacketQueue" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession.sendXml" type="Function" classlike="true">
    <properties>
      <property name="transmitState" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="message" type="" usage="required"/>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession.processDocument" type="Function" classlike="true">
    <properties>
      <property name="transmitState" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="doc" type="" usage="required"/>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession.processDocument.outboundQueue.0" type="">
    <properties>
      <property name="rid" scope="instance" type=""/>
    </properties>
  </object>
  <object location="dojox.xmpp.TransportSession.processResponse" type="Function" classlike="true">
    <properties>
      <property name="sid" scope="instance" type=""/>
      <property name="authId" scope="instance" type="Object"/>
      <property name="wait" scope="instance" type="Object"/>
      <property name="polling" scope="instance" type="Number"/>
      <property name="inactivity" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="body" type="" usage="required"/>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession.setState" type="Function" classlike="true">
    <properties>
      <property name="state" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="state" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.TransportSession.processError" type="Function" classlike="true">
    <properties>
      <property name="transmitState" scope="instance" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="err" type="" usage="required"/>
          <parameter name="httpStatusCode" type="" usage="required"/>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.UserService" type="Function" classlike="true">
    <properties>
      <property name="session" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="xmppService" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="xmppService" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getPersonalProfile" scope="prototype"/>
      <method name="setPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="props" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onSetPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="response" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="id" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSetPersonalProfileFailure" scope="prototype">
        <parameters>
          <parameter name="err" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onGetPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="profile" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfile" scope="prototype">
        <parameters>
          <parameter name="profile" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onGetPersonalProfileFailure" scope="prototype">
        <parameters>
          <parameter name="err" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.bosh">
    <properties>
      <property name="transportIframes" scope="normal" type="Array"/>
      <property name="_deadScripts" scope="normal" type="Array"/>
    </properties>
    <methods>
      <method name="_iframeOnload" scope="normal">
        <parameters>
          <parameter name="index" type="" usage="required"/>
        </parameters>
      </method>
      <method name="findOpenIframe" scope="normal"/>
      <method name="handle" scope="normal">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="rid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="get" scope="normal">
        <summary>sends a get request using a dynamically created script tag.</summary>
        <parameters>
          <parameter name="args" type="dojox.xmpp.bosh.__ioArgs" usage="required"/>
        </parameters>
      </method>
      <method name="remove" scope="normal">
        <summary>removes the script element with the given id, from the given frameDocument.
	If no frameDocument is passed, the current document is used.</summary>
        <parameters>
          <parameter name="id" type="String" usage="required"/>
          <parameter name="frameDocument" type="Document" usage="optional"/>
        </parameters>
      </method>
      <method name="_makeScriptDeferred" scope="normal">
        <summary>sets up a Deferred object for an IO request.</summary>
        <parameters>
          <parameter name="args" type="Object" usage="required"/>
        </parameters>
        <return-types>
          <return-type type="dojo.Deferred"/>
        </return-types>
      </method>
      <method name="_deferredCancel" scope="normal">
        <summary>canceller function for dojo._ioSetArgs call.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredOk" scope="normal">
        <summary>okHandler function for dojo._ioSetArgs call.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_deferredError" scope="normal">
        <summary>errHandler function for dojo._ioSetArgs call.</summary>
        <parameters>
          <parameter name="error" type="Error" usage="required"/>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_addDeadScript" scope="normal">
        <summary>sets up an entry in the deadScripts array.</summary>
        <parameters>
          <parameter name="ioArgs" type="Object" usage="required"/>
        </parameters>
      </method>
      <method name="_validCheck" scope="normal">
        <summary>inflight check function to see if dfd is still valid.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_ioCheck" scope="normal">
        <summary>inflight check function to see if IO finished.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
      <method name="_resHandle" scope="normal">
        <summary>inflight function to handle a completed response.</summary>
        <parameters>
          <parameter name="dfd" type="Deferred" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.bosh.__initArgs" type="Function" classlike="true" private="true">
    <summary>The arguments passed to dojox.xmpp.bosh.initialize</summary>
    <properties>
      <property name="iframes" scope="instance" type="The">
        <summary>number of iframes to use for transmission</summary>
      </property>
      <property name="load" scope="instance" type="The">
        <summary>function called when the first iframe is
	loaded.  Generally used to signal when to send
	login information</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>The arguments passed to dojox.xmpp.bosh.initialize</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.bosh.__ioArgs" type="Function" classlike="true" superclass="dojo.__IoArgs" private="true">
    <summary>All the properties described in the dojo.__ioArgs type, apply to this
	type as well, EXCEPT &amp;quot;handleAs&amp;quot;. It is not applicable to
	dojox.xmpp.bosh.get() calls, since it is implied that the
	return will be a string of XML.</summary>
    <mixins>
      <mixin scope="instance" location="dojo.__IoArgs"/>
    </mixins>
    <properties>
      <property name="rid" scope="instance" type="The">
        <summary>rid of the message being sent.</summary>
      </property>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="constructor" scope="prototype">
        <summary>All the properties described in the dojo.__ioArgs type, apply to this
	type as well, EXCEPT &amp;quot;handleAs&amp;quot;. It is not applicable to
	dojox.xmpp.bosh.get() calls, since it is implied that the
	return will be a string of XML.</summary>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.bosh.initialize" type="Function" classlike="true">
    <properties>
      <property name="transportIframes" scope="instance" type="Array"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="args" type="dojox.xmpp.bosh.__initArgs" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.sasl">
    <properties>
      <property name="saslNS" scope="normal" type="String"/>
      <property name="registry" scope="normal" type="Object"/>
    </properties>
  </object>
  <object location="dojox.xmpp.sasl._Base" type="Function" classlike="true">
    <properties>
      <property name="mechanism" scope="prototype" type="Object"/>
      <property name="closeAuthTag" scope="prototype" type="Object"/>
      <property name="first_challenge" scope="prototype" type="Object"/>
      <property name="session" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="session" type="" usage="required"/>
        </parameters>
      </method>
      <method name="constructor" scope="prototype">
        <parameters>
          <parameter name="session" type="" usage="required"/>
        </parameters>
      </method>
      <method name="startAuth" scope="prototype"/>
      <method name="appendToAuth" scope="prototype">
        <parameters>
          <parameter name="auth" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onChallenge" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onFirstChallenge" scope="prototype"/>
      <method name="onSecondChallenge" scope="prototype"/>
      <method name="onSuccess" scope="prototype"/>
    </methods>
  </object>
  <object location="dojox.xmpp.sasl.SunWebClientAuth" type="Function" classlike="true" superclass="dojox.xmpp.sasl._Base">
    <mixins>
      <mixin scope="instance" location="dojox.xmpp.sasl._Base"/>
    </mixins>
    <properties>
      <property name="mechanism" scope="prototype" type="String"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.xmpp.sasl.Plain" type="Function" classlike="true" superclass="dojox.xmpp.sasl._Base">
    <mixins>
      <mixin scope="instance" location="dojox.xmpp.sasl._Base"/>
    </mixins>
    <properties>
      <property name="mechanism" scope="prototype" type="String"/>
      <property name="closeAuthTag" scope="prototype" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="appendToAuth" scope="prototype">
        <parameters>
          <parameter name="auth" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.sasl.DigestMD5" type="Function" classlike="true" superclass="dojox.xmpp.sasl._Base">
    <mixins>
      <mixin scope="instance" location="dojox.xmpp.sasl._Base"/>
    </mixins>
    <properties>
      <property name="mechanism" scope="prototype" type="String"/>
      <property name="rspauth" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="onFirstChallenge" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSecondChallenge" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.util">
    <methods>
      <method name="xmlEncode" scope="normal">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
      <method name="encodeJid" scope="normal">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="decodeJid" scope="normal">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createElement" scope="normal">
        <parameters>
          <parameter name="tag" type="" usage="required"/>
          <parameter name="attributes" type="" usage="required"/>
          <parameter name="terminal" type="" usage="required"/>
        </parameters>
      </method>
      <method name="stripHtml" scope="normal">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
      <method name="decodeHtmlEntities" scope="normal">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
      <method name="htmlToPlain" scope="normal">
        <parameters>
          <parameter name="str" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.util.Base64">
    <methods>
      <method name="encode" scope="normal">
        <parameters>
          <parameter name="input" type="" usage="required"/>
        </parameters>
      </method>
      <method name="decode" scope="normal">
        <parameters>
          <parameter name="input" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.widget"/>
  <object location="dojox.xmpp.widget.ChatSession" type="Function" classlike="true" superclass="dijit.layout.LayoutContainer">
    <mixins>
      <mixin scope="prototype" location="dijit._Templated.prototype"/>
      <mixin scope="instance" location="dijit.layout.LayoutContainer"/>
      <mixin scope="instance" location="dijit._Templated"/>
    </mixins>
    <properties>
      <property name="templateString" scope="prototype" type="Object"/>
      <property name="enableSubWidgets" scope="prototype" type="Object"/>
      <property name="widgetsInTemplate" scope="prototype" type="Object"/>
      <property name="widgetType" scope="prototype" type="String"/>
      <property name="chatWith" scope="prototype" type="Object"/>
      <property name="instance" scope="prototype" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
      <method name="postCreate" scope="prototype"/>
      <method name="displayMessage" scope="prototype">
        <parameters>
          <parameter name="message" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
        </parameters>
      </method>
      <method name="goToLastMessage" scope="prototype"/>
      <method name="onKeyPress" scope="prototype">
        <parameters>
          <parameter name="e" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.widget.ChatSession.messages.domNode" type="">
    <properties>
      <property name="scrollTop" scope="prototype" type=""/>
    </properties>
  </object>
  <object location="dojox.xmpp.widget.ChatSession.chatInput" type="">
    <properties>
      <property name="value" scope="prototype" type="String"/>
    </properties>
  </object>
  <object location="dojox.xmpp.xmppSession" type="Function" classlike="true">
    <properties>
      <property name="roster" scope="instance-prototype" type="Array"/>
      <property name="chatRegister" scope="instance-prototype" type="Array"/>
      <property name="_iqId" scope="instance-prototype" type="Object"/>
      <property name="session" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="props" type="" usage="required"/>
        </parameters>
      </method>
      <method name="processProtocolResponse" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="messageHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="iqHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="presenceHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="saslHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendRestart" scope="prototype"/>
      <method name="simpleMessageHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="registerChatInstance" scope="prototype">
        <parameters>
          <parameter name="chatInstance" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="iqSetHandler" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendIqResult" scope="prototype">
        <parameters>
          <parameter name="iqId" type="" usage="required"/>
          <parameter name="to" type="" usage="required"/>
        </parameters>
      </method>
      <method name="rosterSetHandler" scope="prototype">
        <parameters>
          <parameter name="elem" type="" usage="required"/>
        </parameters>
      </method>
      <method name="presenceUpdate" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="retrieveRoster" scope="prototype"/>
      <method name="getRosterIndex" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="createRosterEntry" scope="prototype">
        <parameters>
          <parameter name="elem" type="" usage="required"/>
        </parameters>
      </method>
      <method name="bindResource" scope="prototype">
        <parameters>
          <parameter name="hasSession" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getNextIqId" scope="prototype"/>
      <method name="presenceSubscriptionRequest" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="dispatchPacket" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="type" type="" usage="required"/>
          <parameter name="matchId" type="" usage="required"/>
        </parameters>
      </method>
      <method name="search" scope="prototype">
        <parameters>
          <parameter name="searchString" type="" usage="required"/>
          <parameter name="service" type="" usage="required"/>
          <parameter name="searchAttribute" type="" usage="required"/>
        </parameters>
      </method>
      <method name="_onSearchResults" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onLogin" scope="prototype"/>
      <method name="onLoginFailure" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onBindSession" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onSearchResults" scope="prototype">
        <parameters>
          <parameter name="results" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRetrieveRoster" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterUpdated" scope="prototype"/>
      <method name="onSubscriptionRequest" scope="prototype">
        <parameters>
          <parameter name="req" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onPresenceUpdate" scope="prototype">
        <parameters>
          <parameter name="p" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onTransportTerminate" scope="prototype">
        <parameters>
          <parameter name="newState" type="" usage="required"/>
          <parameter name="oldState" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onConnected" scope="prototype"/>
      <method name="onTerminate" scope="prototype">
        <parameters>
          <parameter name="newState" type="" usage="required"/>
          <parameter name="oldState" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onActive" scope="prototype"/>
      <method name="onRegisterChatInstance" scope="prototype">
        <parameters>
          <parameter name="chatInstance" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterAdded" scope="prototype">
        <parameters>
          <parameter name="ri" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterRemoved" scope="prototype">
        <parameters>
          <parameter name="ri" type="" usage="required"/>
        </parameters>
      </method>
      <method name="onRosterChanged" scope="prototype">
        <parameters>
          <parameter name="ri" type="" usage="required"/>
          <parameter name="previousCopy" type="" usage="required"/>
        </parameters>
      </method>
      <method name="processXmppError" scope="prototype">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
      <method name="sendStanzaError" scope="prototype">
        <parameters>
          <parameter name="stanzaType" type="" usage="required"/>
          <parameter name="to" type="" usage="required"/>
          <parameter name="id" type="" usage="required"/>
          <parameter name="errorType" type="" usage="required"/>
          <parameter name="condition" type="" usage="required"/>
          <parameter name="text" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getBareJid" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
        </parameters>
      </method>
      <method name="getResourceFromJid" scope="prototype">
        <parameters>
          <parameter name="jid" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.xmppSession.open" type="Function" classlike="true">
    <properties>
      <property name="jid" scope="instance" type="String"/>
      <property name="password" scope="instance" type=""/>
      <property name="resource" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="user" type="" usage="required"/>
          <parameter name="password" type="" usage="required"/>
          <parameter name="resource" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.xmppSession.close" type="Function" classlike="true">
    <properties>
      <property name="state" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.xmpp.xmppSession.featuresHandler" type="Function" classlike="true">
    <properties>
      <property name="auth" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.xmppSession.chatHandler" type="Function" classlike="true">
    <properties>
      <property name="useChatState" scope="instance" type="bool"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.xmppSession.setState" type="Function" classlike="true">
    <properties>
      <property name="state" scope="instance" type=""/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="state" type="" usage="required"/>
          <parameter name="message" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.xmppSession.onBindResource" type="Function" classlike="true">
    <properties>
      <property name="jid" scope="instance" type="Object"/>
      <property name="resource" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor">
        <parameters>
          <parameter name="msg" type="" usage="required"/>
          <parameter name="hasSession" type="" usage="required"/>
        </parameters>
      </method>
    </methods>
  </object>
  <object location="dojox.xmpp.xmppSession.onTransportReady" type="Function" classlike="true">
    <properties>
      <property name="rosterService" scope="instance" type="Object"/>
      <property name="presenceService" scope="instance" type="Object"/>
      <property name="userService" scope="instance" type="Object"/>
    </properties>
    <methods>
      <method constructor="constructor"/>
    </methods>
  </object>
  <object location="dojox.xmpp.xmpp">
    <properties>
      <property name="STREAM_NS" scope="normal" type="String"/>
      <property name="CLIENT_NS" scope="normal" type="String"/>
      <property name="STANZA_NS" scope="normal" type="String"/>
      <property name="SASL_NS" scope="normal" type="String"/>
      <property name="BIND_NS" scope="normal" type="String"/>
      <property name="SESSION_NS" scope="normal" type="String"/>
      <property name="BODY_NS" scope="normal" type="String"/>
      <property name="XHTML_BODY_NS" scope="normal" type="String"/>
      <property name="XHTML_IM_NS" scope="normal" type="String"/>
      <property name="INACTIVE" scope="normal" type="String"/>
      <property name="CONNECTED" scope="normal" type="String"/>
      <property name="ACTIVE" scope="normal" type="String"/>
      <property name="TERMINATE" scope="normal" type="String"/>
      <property name="LOGIN_FAILURE" scope="normal" type="String"/>
      <property name="INVALID_ID" scope="normal" type="Number"/>
      <property name="NO_ID" scope="normal" type="Number"/>
    </properties>
  </object>
  <object location="dojox.xmpp.xmpp.error">
    <properties>
      <property name="BAD_REQUEST" scope="normal" type="String"/>
      <property name="CONFLICT" scope="normal" type="String"/>
      <property name="FEATURE_NOT_IMPLEMENTED" scope="normal" type="String"/>
      <property name="FORBIDDEN" scope="normal" type="String"/>
      <property name="GONE" scope="normal" type="String"/>
      <property name="INTERNAL_SERVER_ERROR" scope="normal" type="String"/>
      <property name="ITEM_NOT_FOUND" scope="normal" type="String"/>
      <property name="ID_MALFORMED" scope="normal" type="String"/>
      <property name="NOT_ACCEPTABLE" scope="normal" type="String"/>
      <property name="NOT_ALLOWED" scope="normal" type="String"/>
      <property name="NOT_AUTHORIZED" scope="normal" type="String"/>
      <property name="SERVICE_UNAVAILABLE" scope="normal" type="String"/>
      <property name="SUBSCRIPTION_REQUIRED" scope="normal" type="String"/>
      <property name="UNEXPECTED_REQUEST" scope="normal" type="String"/>
    </properties>
  </object>
</javascript>
